id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TKey_8cxx_source.html:26967,Performance,perform,performance,26967," (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 772 if (!bufferRef.Buffer()) {; 773 Error(""ReadObj"", ""Cannot allocate buffer: fObjlen = %d"", fObjlen);; 774 return 0;; 775 }; 776 if (GetFile()==0) return 0;; 777 bufferRef.SetParent(GetFile());; 778 bufferR",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60858,Performance,load,load,60858,"TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void Streamer(TBuffer &)Stream a object of type TDatime.Definition TDatime.cxx:416; TDatime::Setvoid Set()Set Date/Time to current time as reported by the system.Definition TDatime.cxx:289; TDatime::ReadBuffervoid ReadBuffer(char *&buffer)Decode Date/Time from output buffer, used by I/O system.Definition TDatime.cxx:278; TDirectoryFileA ROOT file is structured in Directories (like a file s",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:1491,Safety,redund,redundant,1491,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:6487,Safety,avoid,avoid,6487,"uffer += bufferDecOffset; // Reset the buffer to be appropriate for this key.; 164 Int_t nout = fNbytes - fKeylen;; 165 Create(nout);; 166 fBufferRef->SetBufferOffset(bufferDecOffset);; 167 Streamer(*fBufferRef); //write key itself again; 168}; 169 ; 170////////////////////////////////////////////////////////////////////////////////; 171/// Create a TKey object to read keys.; 172/// Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; 173/// A TKey object is created to read the keys structure itself.; 174 ; 175TKey::TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir) : TNamed(); 176{; 177 Build(motherDir, """", pointer);; 178 ; 179 fSeekKey = pointer;; 180 fNbytes = nbytes;; 181 fBuffer = new char[nbytes];; 182 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 183}; 184 ; 185////////////////////////////////////////////////////////////////////////////////; 186/// Create a TKey object with the specified name, title for the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217//////////////////////",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:7072,Safety,avoid,avoid,7072,"* motherDir) : TNamed(); 176{; 177 Build(motherDir, """", pointer);; 178 ; 179 fSeekKey = pointer;; 180 fNbytes = nbytes;; 181 fBuffer = new char[nbytes];; 182 keyAbsNumber++; SetUniqueID(keyAbsNumber);; 183}; 184 ; 185////////////////////////////////////////////////////////////////////////////////; 186/// Create a TKey object with the specified name, title for the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without ar",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:7649,Safety,avoid,avoid,7649," the given class.; 187///; 188/// WARNING: in name avoid special characters like '^','$','.' that are used; 189/// by the regular expression parser (see TRegexp).; 190 ; 191TKey::TKey(const char *name, const char *title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 192 : TNamed(name,title); 193{; 194 Build(motherDir, cl->GetName(), -1);; 195 ; 196 fKeylen = Sizeof();; 197 fObjlen = nbytes;; 198 Create(nbytes);; 199}; 200 ; 201////////////////////////////////////////////////////////////////////////////////; 202/// Create a TKey object with the specified name, title for the given class.; 203///; 204/// WARNING: in name avoid special characters like '^','$','.' that are used; 205/// by the regular expression parser (see TRegexp).; 206 ; 207TKey::TKey(const TString &name, const TString &title, const TClass *cl, Int_t nbytes, TDirectory* motherDir); 208 : TNamed(name,title); 209{; 210 Build(motherDir, cl->GetName(), -1);; 211 ; 212 fKeylen = Sizeof();; 213 fObjlen = nbytes;; 214 Create(nbytes);; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Create a TKey object for a TObject* and fill output buffer; 219///; 220/// WARNING: in name avoid special characters like '^','$','.' that are used; 221/// by the regular expression parser (see TRegexp).; 222 ; 223TKey::TKey(const TObject *obj, const char *name, Int_t bufsize, TDirectory* motherDir); 224 : TNamed(name, obj->GetTitle()); 225{; 226 R__ASSERT(obj);; 227 ; 228 if (!obj->IsA()->HasDefaultConstructor()) {; 229 Warning(""TKey"", ""since %s has no public constructor\n""; 230 ""\twhich can be called without argument, objects of this class\n""; 231 ""\tcan not be read with the current library. You will need to\n""; 232 ""\tadd a default constructor before attempting to read it."",; 233 obj->ClassName());; 234 }; 235 ; 236 Build(motherDir, obj->ClassName(), -1);; 237 ; 238 Int_t lbuf, nout, noutot, bufmax, nzip;; 239 fBufferRef = new TBufferFile(TBuffer::kWrite, bufsize)",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:10679,Safety,avoid,avoid,10679,"(nout == 0 || nout >= fObjlen) { //this happens when the buffer cannot be compressed; 265 delete[] fBuffer;; 266 bufcur = nullptr;; 267 fBuffer = fBufferRef->Buffer();; 268 Create(fObjlen);; 269 fBufferRef->SetBufferOffset(0);; 270 Streamer(*fBufferRef); //write key itself again; 271 return;; 272 }; 273 bufcur += nout;; 274 noutot += nout;; 275 objbuf += kMAXZIPBUF;; 276 nzip += kMAXZIPBUF;; 277 }; 278 Create(noutot);; 279 fBufferRef->SetBufferOffset(0);; 280 Streamer(*fBufferRef); //write key itself again; 281 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 282 delete fBufferRef; fBufferRef = 0;; 283 } else {; 284 fBuffer = fBufferRef->Buffer();; 285 Create(fObjlen);; 286 fBufferRef->SetBufferOffset(0);; 287 Streamer(*fBufferRef); //write key itself again; 288 }; 289}; 290 ; 291////////////////////////////////////////////////////////////////////////////////; 292/// Create a TKey object for any object obj of class cl d and fill; 293/// output buffer.; 294///; 295/// WARNING: in name avoid special characters like '^','$','.' that are used; 296/// by the regular expression parser (see TRegexp).; 297 ; 298TKey::TKey(const void *obj, const TClass *cl, const char *name, Int_t bufsize, TDirectory* motherDir); 299 : TNamed(name, ""object title""); 300{; 301 R__ASSERT(obj && cl);; 302 ; 303 if (!cl->HasDefaultConstructor()) {; 304 Warning(""TKey"", ""since %s has no public constructor\n""; 305 ""\twhich can be called without argument, objects of this class\n""; 306 ""\tcan not be read with the current library. You will need to\n""; 307 ""\tadd a default constructor before attempting to read it."",; 308 cl->GetName());; 309 }; 310 ; 311 TClass *clActual = cl->GetActualClass(obj);; 312 const void* actualStart;; 313 if (clActual) {; 314 const char *temp = (const char*) obj;; 315 // clActual->GetStreamerInfo();; 316 Int_t offset = (cl != clActual) ?; 317 clActual->GetBaseClassOffset(cl) : 0;; 318 temp -= offset;; 319 actualStart = temp;; 320 } else {; 321 // We could not determine the real ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:29218,Safety,detect,detection,29218,"87 fBuffer = 0;; 788 return 0;; 789 }; 790 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 791 } else {; 792 fBuffer = bufferRef.Buffer();; 793 if( !ReadFile() ) { //Read object structure from file; 794 ; 795 fBuffer = 0;; 796 return 0;; 797 }; 798 }; 799 fBuffer = storeBuffer;; 800 ; 801 // get version of key; 802 bufferRef.SetBufferOffset(sizeof(fNbytes));; 803 Version_t kvers = bufferRef.ReadVersion();; 804 ; 805 bufferRef.SetBufferOffset(fKeylen);; 806 TObject *tobj = 0;; 807 // Create an instance of this class; 808 ; 809 char *pobj = (char*)cl->New();; 810 if (!pobj) {; 811 Error(""ReadObj"", ""Cannot create new object of class %s"", fClassName.Data());; 812 return 0;; 813 }; 814 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 815 if (baseOffset==-1) {; 816 // cl does not inherit from TObject.; 817 // Since this is not possible yet, the only reason we could reach this code; 818 // is because something is screw up in the ROOT code.; 819 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 820 fClassName.Data());; 821 }; 822 tobj = (TObject*)(pobj+baseOffset);; 823 if (kvers > 1); 824 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 825 ; 826 if (fObjlen > fNbytes-fKeylen) {; 827 char *objbuf = bufferRef.Buffer() + fKeylen;; 828 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 829 Int_t nin, nout = 0, nbuf;; 830 Int_t noutot = 0;; 831 while (1) {; 832 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 833 if (hc!=0) break;; 834 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 835 if (!nout) break;; 836 noutot += nout;; 837 if (noutot >= fObjlen) break;; 838 bufcur += nin;; 839 objbuf += nout;; 840 }; 841 compressedBuffer.reset(nullptr);; 842 if (nout) {; 843 tobj->Streamer(bufferRef); //does not work with example 2 above; 844 } else {; 845 // Even-though we have a TObject, if the class is emulated the virtual; 846 // table may not be 'right', so let's go via the TClass.;",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:33571,Safety,detect,detection,33571," = fBuffer;; 916 if (fObjlen > fNbytes-fKeylen) {; 917 fBuffer = bufferRead;; 918 memcpy(bufferRef.Buffer(),fBuffer,fKeylen);; 919 } else {; 920 fBuffer = bufferRef.Buffer();; 921 ReadFile(); //Read object structure from file; 922 }; 923 fBuffer = storeBuffer;; 924 ; 925 // get version of key; 926 bufferRef.SetBufferOffset(sizeof(fNbytes));; 927 Version_t kvers = bufferRef.ReadVersion();; 928 ; 929 bufferRef.SetBufferOffset(fKeylen);; 930 TObject *tobj = 0;; 931 // Create an instance of this class; 932 ; 933 char *pobj = (char*)cl->New();; 934 if (!pobj) {; 935 Error(""ReadObjWithBuffer"", ""Cannot create new object of class %s"", fClassName.Data());; 936 return 0;; 937 }; 938 Int_t baseOffset = cl->GetBaseClassOffset(TObject::Class());; 939 if (baseOffset==-1) {; 940 // cl does not inherit from TObject.; 941 // Since this is not possible yet, the only reason we could reach this code; 942 // is because something is screw up in the ROOT code.; 943 Fatal(""ReadObjWithBuffer"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 944 fClassName.Data());; 945 }; 946 tobj = (TObject*)(pobj+baseOffset);; 947 ; 948 if (kvers > 1); 949 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 950 ; 951 if (fObjlen > fNbytes-fKeylen) {; 952 char *objbuf = bufferRef.Buffer() + fKeylen;; 953 UChar_t *bufcur = (UChar_t *)&bufferRead[fKeylen];; 954 Int_t nin, nout = 0, nbuf;; 955 Int_t noutot = 0;; 956 while (1) {; 957 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 958 if (hc!=0) break;; 959 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 960 if (!nout) break;; 961 noutot += nout;; 962 if (noutot >= fObjlen) break;; 963 bufcur += nin;; 964 objbuf += nout;; 965 }; 966 if (nout) {; 967 tobj->Streamer(bufferRef); //does not work with example 2 above; 968 } else {; 969 // Even-though we have a TObject, if the class is emulated the virtual; 970 // table may not be 'right', so let's go via the TClass.; 971 cl->Destructor(pobj);; 972 r",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:35859,Safety,safe,safely,35859,"ast<TDirectoryFile*>(tobj);; 982 dir->SetName(GetName());; 983 dir->SetTitle(GetTitle());; 984 dir->SetMother(fMotherDir);; 985 fMotherDir->Append(dir);; 986 }; 987 ; 988 // Append the object to the directory if requested:; 989 {; 990 ROOT::DirAutoAdd_t addfunc = cl->GetDirectoryAutoAdd();; 991 if (addfunc) {; 992 addfunc(pobj, fMotherDir);; 993 }; 994 }; 995 ; 996 return tobj;; 997}; 998 ; 999////////////////////////////////////////////////////////////////////////////////; 1000/// To read an object (non deriving from TObject) from the file.; 1001///; 1002/// If expectedClass is not null, we checked that that actual class of the; 1003/// object stored is suitable to be stored in a pointer pointing to an object; 1004/// of class 'expectedClass'. We also adjust the value of the returned address; 1005/// so that it is suitable to be cast (C-Style); 1006/// a pointer pointing to an object of class 'expectedClass'.; 1007///; 1008/// So for example if the class Bottom inherits from Top and the object; 1009/// stored is of type Bottom you can safely do:; 1010/// ~~~{.cpp}; 1011/// auto TopClass = TClass::GetClass(""Top"");; 1012/// auto ptr = (Top*) key->ReadObjectAny( TopClass );; 1013/// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; 1014/// ~~~; 1015/// The object associated to this key is read from the file into memory.; 1016/// Once the key structure is read (via Streamer) the class identifier; 1017/// of the object is known.; 1018/// Using the class identifier we find the TClass object for this class.; 1019/// A TClass object contains a full description (i.e. dictionary) of the; 1020/// associated class. In particular the TClass object can create a new; 1021/// object of the class type it describes. This new object now calls its; 1022/// Streamer function to rebuilt itself.; 1023 ; 1024void *TKey::ReadObjectAny(const TClass* expectedClass); 1025{; 1026 TBufferFile bufferRef(TBuffer::kRead, fObjlen+fKeylen);; 1027 if (!bufferRef.B",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:40323,Safety,detect,detection,40323,"80 ""Trying to read an emulated class (%s) to store in a compiled pointer (%s)"",; 1081 cl->GetName(),expectedClass->GetName());; 1082 }; 1083 }; 1084 // Create an instance of this class; 1085 ; 1086 void *pobj = cl->New();; 1087 if (!pobj) {; 1088 Error(""ReadObjectAny"", ""Cannot create new object of class %s"", fClassName.Data());; 1089 return 0;; 1090 }; 1091 ; 1092 if (kvers > 1); 1093 bufferRef.MapObject(pobj,cl); //register obj in map to handle self reference; 1094 ; 1095 if (fObjlen > fNbytes-fKeylen) {; 1096 char *objbuf = bufferRef.Buffer() + fKeylen;; 1097 UChar_t *bufcur = (UChar_t *)&compressedBuffer[fKeylen];; 1098 Int_t nin, nout = 0, nbuf;; 1099 Int_t noutot = 0;; 1100 while (1) {; 1101 Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);; 1102 if (hc!=0) break;; 1103 R__unzip(&nin, bufcur, &nbuf, (unsigned char*) objbuf, &nout);; 1104 if (!nout) break;; 1105 noutot += nout;; 1106 if (noutot >= fObjlen) break;; 1107 bufcur += nin;; 1108 objbuf += nout;; 1109 }; 1110 if (nout) {; 1111 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1112 } else {; 1113 cl->Destructor(pobj);; 1114 return nullptr;; 1115 }; 1116 } else {; 1117 cl->Streamer((void*)pobj, bufferRef, clOnfile); //read object; 1118 }; 1119 ; 1120 if (cl->IsTObject()) {; 1121 auto tobjBaseOffset = cl->GetBaseClassOffset(TObject::Class());; 1122 if (tobjBaseOffset == -1) {; 1123 Fatal(""ReadObj"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 1124 fClassName.Data());; 1125 }; 1126 TObject *tobj = (TObject*)( ((char*)pobj) + tobjBaseOffset);; 1127 ; 1128 // See similar adjustments in ReadObj; 1129 if (gROOT->GetForceStyle()) tobj->UseCurrentStyle();; 1130 ; 1131 if (cl->InheritsFrom(TDirectoryFile::Class())) {; 1132 TDirectory *dir = static_cast<TDirectoryFile*>(tobj);; 1133 dir->SetName(GetName());; 1134 dir->SetTitle(GetTitle());; 1135 dir->SetMother(fMotherDir);; 1136 fMotherDir->Append(dir);; 1137 }; 1138 }; 1139 ; 1140 {; 1141 // Append the object to the directory ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49449,Safety,recover,recover,49449,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49637,Safety,recover,recover,49637,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49825,Safety,recover,recover,49825,"Offset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b << fKeylen;; 1423 b << fCycle;; 1424 if (fVersion > 1000) {; 1425 b << fSeekKey;; 1426 ; 1427 // We currently store in the 16 highest bit of fSeekPdir the value of; 1428 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1429 // file to the other. In this case the TRef and TObject might have stored a; 1430 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1431 // file, the fPidOffset is to be added to those values to corr",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:1547,Security,integrity,integrity,1547,"; 10 *************************************************************************/; 11 ; 12/**; 13\class TKey; 14\ingroup IO; 15 ; 16 Book space in a file, create I/O buffers, to fill them, (un)compress them.; 17 ; 18 The TKey class includes functions to book space in a file, to create I/O; 19 buffers, to fill these buffers, to compress/uncompress data buffers.; 20 Before saving (making persistent) an object in a file, a key must; 21 be created. The key structure contains all the information to; 22 uniquely identify a persistent object in a file.; 23 | Data Member | Explanation |; 24 |-------------|-------------|; 25 | fNbytes | Number of bytes for the compressed object and key. |; 26 | fObjlen | Length of uncompressed object. |; 27 | fDatime | Date/Time when the object was written. |; 28 | fKeylen | Number of bytes for the key structure. |; 29 | fCycle | Cycle number of the object. |; 30 | fSeekKey | Address of the object on file (points to fNbytes). This is a redundant information used to cross-check the data base integrity. |; 31 | fSeekPdir | Pointer to the directory supporting this object.|; 32 | fClassName | Object class name. |; 33 | fName | Name of the object. |; 34 | fTitle | Title of the object. |; 35 ; 36 In the 16 highest bits of fSeekPdir is encoded a pid offset. This; 37 offset is to be added to the pid index stored in the TRef object; 38 and the referenced TObject.; 39 ; 40 The TKey class is used by ROOT to:; 41 - Write an object in the current directory; 42 - Write a new ntuple buffer; 43 ; 44 The structure of a file is shown in TFile::TFile.; 45 The structure of a directory is shown in TDirectoryFile::TDirectoryFile.; 46 The TKey class is used by the TBasket class.; 47 See also TTree.; 48*/; 49 ; 50#include <atomic>; 51#include <iostream>; 52 ; 53#include ""TROOT.h""; 54#include ""TClass.h""; 55#include ""TDirectoryFile.h""; 56#include ""TFile.h""; 57#include ""TKey.h""; 58#include ""TBufferFile.h""; 59#include ""TFree.h""; 60#include ""TBrowser.h""; 61#include ""Bytes.",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60524,Security,access,access,60524,"st TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:14744,Testability,test,test,14744,"rRef->SetBufferOffset(0);; 373 Streamer(*fBufferRef); //write key itself again; 374 memcpy(fBuffer,fBufferRef->Buffer(),fKeylen);; 375 delete fBufferRef; fBufferRef = 0;; 376 } else {; 377 fBuffer = fBufferRef->Buffer();; 378 Create(fObjlen);; 379 fBufferRef->SetBufferOffset(0);; 380 Streamer(*fBufferRef); //write key itself again; 381 }; 382}; 383 ; 384////////////////////////////////////////////////////////////////////////////////; 385/// Method used in all TKey constructor to initialize basic data fields.; 386///; 387/// The member filepos is used to calculate correct version number of key; 388/// if filepos==-1, end of file position is used.; 389 ; 390void TKey::Build(TDirectory* motherDir, const char* classname, Long64_t filepos); 391{; 392 fMotherDir = motherDir;; 393 ; 394 fPidOffset = 0;; 395 fNbytes = 0;; 396 fBuffer = 0;; 397 fKeylen = 0;; 398 fObjlen = 0;; 399 fBufferRef = 0;; 400 fCycle = 0;; 401 fSeekPdir = 0;; 402 fSeekKey = 0;; 403 fLeft = 0;; 404 ; 405 fClassName = classname;; 406 //the following test required for forward and backward compatibility; 407 if (fClassName == ""TDirectoryFile"") SetBit(kIsDirectoryFile);; 408 ; 409 fVersion = TKey::Class_Version();; 410 ; 411 if ((filepos==-1) && GetFile()) filepos = GetFile()->GetEND();; 412 if (filepos > TFile::kStartBigFile) fVersion += 1000;; 413 ; 414 if (fTitle.Length() > kTitleMax) fTitle.Resize(kTitleMax);; 415 ; 416 if (GetFile() && GetFile()->TestBit(TFile::kReproducible)); 417 SetBit(TKey::kReproducible);; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Read object from disk and call its Browse() method.; 422///; 423/// If object with same name already exist in memory delete it (like; 424/// TDirectoryFile::Get() is doing), except when the key references a; 425/// folder in which case we don't want to re-read the folder object; 426/// since it might contain new objects not yet saved.; 427 ; 428void TKey::Browse(TBrowser *b); 429{; 430 if (fMo",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:45020,Testability,test,test,45020,"1244 // We currently store in the 16 highest bit of fSeekPdir the value of; 1245 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1246 // file to the other. In this case the TRef and TObject might have stored a; 1247 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1248 // file, the fPidOffset is to be added to those values to correctly find the; 1249 // TProcessID. This fPidOffset needs to be increment if the key/basket is copied; 1250 // and need to be zero for new key/basket.; 1251 Long64_t pdir;; 1252 frombuf(buffer, &pdir);; 1253 fPidOffset = pdir >> kPidOffsetShift;; 1254 fSeekPdir = pdir & kPidOffsetMask;; 1255 } else {; 1256 UInt_t seekkey,seekdir;; 1257 frombuf(buffer, &seekkey); fSeekKey = (Long64_t)seekkey;; 1258 frombuf(buffer, &seekdir); fSeekPdir= (Long64_t)seekdir;; 1259 }; 1260 fClassName.ReadBuffer(buffer);; 1261 //the following test required for forward and backward compatibility; 1262 if (fClassName == ""TDirectory"") {; 1263 fClassName = ""TDirectoryFile"";; 1264 SetBit(kIsDirectoryFile);; 1265 }; 1266 ; 1267 fName.ReadBuffer(buffer);; 1268 fTitle.ReadBuffer(buffer);; 1269}; 1270 ; 1271////////////////////////////////////////////////////////////////////////////////; 1272/// Read the key structure from the file; 1273 ; 1274Bool_t TKey::ReadFile(); 1275{; 1276 TFile* f = GetFile();; 1277 if (f==0) return kFALSE;; 1278 ; 1279 Int_t nsize = fNbytes;; 1280 f->Seek(fSeekKey);; 1281 if( f->ReadBuffer(fBuffer,nsize) ); 1282 {; 1283 Error(""ReadFile"", ""Failed to read data."");; 1284 return kFALSE;; 1285 }; 1286 if (gDebug) {; 1287 std::cout << ""TKey Reading ""<<nsize<< "" bytes at address ""<<fSeekKey<<std::endl;; 1288 }; 1289 return kTRUE;; 1290}; 1291 ; 1292////////////////////////////////////////////////////////////////////////////////; 1293/// Set parent in key buffer.; 1294 ; 1295void TKey::SetParent(const TObject *parent); 1296{; 1297 if (fBufferRef) fBufferRef->SetParent((TObject*)parent);;",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:49128,Testability,test,test,49128,"rsion > 1000) {; 1370 b >> fSeekKey;; 1371 ; 1372 // We currently store in the 16 highest bit of fSeekPdir the value of; 1373 // fPidOffset. This offset is used when a key (or basket) is transfered from one; 1374 // file to the other. In this case the TRef and TObject might have stored a; 1375 // pid index (to retrieve TProcessIDs) which refered to their order on the original; 1376 // file, the fPidOffset is to be added to those values to correctly find the; 1377 // TProcessID. This fPidOffset needs to be increment if the key/basket is copied; 1378 // and need to be zero for new key/basket.; 1379 Long64_t pdir;; 1380 b >> pdir;; 1381 fPidOffset = pdir >> kPidOffsetShift;; 1382 fSeekPdir = pdir & kPidOffsetMask;; 1383 } else {; 1384 UInt_t seekkey, seekdir;; 1385 b >> seekkey; fSeekKey = (Long64_t)seekkey;; 1386 b >> seekdir; fSeekPdir= (Long64_t)seekdir;; 1387 }; 1388 fClassName.Streamer(b);; 1389 //the following test required for forward and backward compatibility; 1390 if (fClassName == ""TDirectory"") {; 1391 fClassName = ""TDirectoryFile"";; 1392 SetBit(kIsDirectoryFile);; 1393 }; 1394 fName.Streamer(b);; 1395 fTitle.Streamer(b);; 1396 if (fKeylen < 0) {; 1397 Error(""Streamer"",""The value of fKeylen is incorrect (%d) ; trying to recover by setting it to zero"",fKeylen);; 1398 MakeZombie();; 1399 fKeylen = 0;; 1400 }; 1401 if (fObjlen < 0) {; 1402 Error(""Streamer"",""The value of fObjlen is incorrect (%d) ; trying to recover by setting it to zero"",fObjlen);; 1403 MakeZombie();; 1404 fObjlen = 0;; 1405 }; 1406 if (fNbytes < 0) {; 1407 Error(""Streamer"",""The value of fNbytes is incorrect (%d) ; trying to recover by setting it to zero"",fNbytes);; 1408 MakeZombie();; 1409 fNbytes = 0;; 1410 }; 1411 ; 1412 } else {; 1413 b << fNbytes;; 1414 version = (Version_t)fVersion;; 1415 b << version;; 1416 b << fObjlen;; 1417 if (fDatime.Get() == 0) fDatime.Set();; 1418 if (TestBit(TKey::kReproducible)); 1419 TDatime((UInt_t) 1).Streamer(b);; 1420 else; 1421 fDatime.Streamer(b);; 1422 b ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60481,Testability,test,testio,60481,"st TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:26671,Usability,simpl,simplified,26671,"19 ; 720////////////////////////////////////////////////////////////////////////////////; 721/// To read a TObject* from the file.; 722///; 723/// The object associated to this key is read from the file into memory; 724/// Once the key structure is read (via Streamer) the class identifier; 725/// of the object is known.; 726/// Using the class identifier we find the TClass object for this class.; 727/// A TClass object contains a full description (i.e. dictionary) of the; 728/// associated class. In particular the TClass object can create a new; 729/// object of the class type it describes. This new object now calls its; 730/// Streamer function to rebuilt itself.; 731///; 732/// Use TKey::ReadObjectAny to read any object non-derived from TObject; 733///; 734/// ### Note; 735/// A C style cast can only be used in the case where the final class; 736/// of this object derives from TObject as a first inheritance, otherwise; 737/// one must use a dynamic_cast.; 738///; 739/// #### Example1: simplified case; 740/// ~~~{.cpp}; 741/// class MyClass : public TObject, public AnotherClass; 742/// ~~~; 743/// then on return, one get away with using:; 744/// ~~~{.cpp}; 745/// MyClass *obj = (MyClass*)key->ReadObj();; 746/// ~~~; 747///; 748/// #### Example2: Usual case (recommended unless performance is critical); 749/// ~~~{.cpp}; 750/// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; 751/// ~~~; 752/// which support also the more complex inheritance like:; 753/// ~~~{.cpp}; 754/// class MyClass : public AnotherClass, public TObject; 755/// ~~~; 756///; 757/// Of course, `dynamic_cast<>` can also be used in the example 1.; 758 ; 759TObject *TKey::ReadObj(); 760{; 761 TClass *cl = TClass::GetClass(fClassName.Data());; 762 if (!cl) {; 763 Error(""ReadObj"", ""Unknown class %s"", fClassName.Data());; 764 return 0;; 765 }; 766 if (!cl->IsTObject()) {; 767 // in principle user should call TKey::ReadObjectAny!; 768 return (TObject*)ReadObjectAny(0);; 769 }; 770 ; 771 TBufferFile ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8cxx_source.html:60548,Usability,usab,usable,60548,"st TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetBaseClassOffsetInt_t GetBaseClassOffset(const TClass *toBase, void *address=nullptr, bool isDerivedObject=true)Definition TClass.cxx:2858; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::Classstatic TClass * Class(); TDatimeThis class stores the date and time with a precision of one second in an unsigned 32 bit word (950130...Definition TDatime.h:37; TDatime::GetUInt_t Get() constReturn raw date/time as encoded by TDatime.Definition TDatime.cxx:240; TDatime::FillBuffervoid FillBuffer(char *&buffer)Encode Date/Time into buffer, used by I/O system.Definition TDatime.cxx:229; TDatime::SizeofInt_t Sizeof() constDefinition TDatime.h:81; TDatime::Streamervirtual void ",MatchSource.WIKI,doc/master/TKey_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8cxx_source.html
https://root.cern/doc/master/TKey_8h_source.html:5184,Testability,log,logical,5184,"{return fSeekKey;}; 90 virtual Long64_t GetSeekPdir() const {return fSeekPdir;}; 91 virtual void IncrementPidOffset(UShort_t offset);; 92 Bool_t IsFolder() const override;; 93 virtual void Keep();; 94 virtual void ls(Bool_t current) const;; 95 void ls(Option_t *option="""") const override;; 96 void Print(Option_t *option="""") const override;; 97 virtual Int_t Read(TObject *obj);; 98 virtual TObject *ReadObj();; 99 virtual TObject *ReadObjWithBuffer(char *bufferRead);; 100 /// To read an object (non deriving from TObject) from the file.; 101 /// This is more user friendly version of TKey::ReadObjectAny.; 102 /// See TKey::ReadObjectAny for more details.; 103 template <typename T> T *ReadObject() {; 104 return reinterpret_cast<T*>(ReadObjectAny(TClass::GetClass<T>()));; 105 }; 106 virtual void *ReadObjectAny(const TClass *expectedClass);; 107 virtual void ReadBuffer(char *&buffer);; 108 void ReadKeyBuffer(char *&buffer);; 109 virtual Bool_t ReadFile();; 110 virtual void SetBuffer() { DeleteBuffer(); fBuffer = new char[fNbytes];}; 111 virtual void SetParent(const TObject *parent);; 112 void SetMotherDir(TDirectory* dir) { fMotherDir = dir; }; 113 Int_t Sizeof() const override;; 114 virtual Int_t WriteFile(Int_t cycle = 1, TFile* f = nullptr);; 115 ; 116 ClassDefOverride(TKey,4); //Header description of a logical record on file.; 117};; 118 ; 119#endif; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; Bool_tbool Bool_tDefinition RtypesCore.h:63; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; Short_tshort Short_tDefinition RtypesCore.h:39; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; BIT#define BIT(n)Definition Rtypes.h:90; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TBuffer.h; TClass.h; TDatime.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; offsetOption_t Option_t TPoi",MatchSource.WIKI,doc/master/TKey_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TKey_8h_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:6868,Availability,avail,available,6868,"ed with the commands in the following; 164table:; 165 ; 166Begin_Macro; 167mathsymbols.C; 168End_Macro; 169 ; 170 ; 171\anchor L6; 172## Delimiters; 173TLatex provides 4 kinds of proportional delimiters:; 174 ; 175 #[]{....} or ""a la"" Latex #left[.....#right] : big square brackets; 176 #{}{....} or #left{.....#right} : big curly brackets; 177 #||{....} or #left|.....#right| : big absolute value symbols; 178 #(){....} or #left(.....#right) : big parentheses; 179 ; 180\anchor L7; 181## Greek Letters; 182The command to produce a lowercase Greek letter is obtained by adding a; 183`#` to the name of the letter. For an uppercase Greek letter, just; 184capitalize the first letter of the command name. Some letters have two; 185representations. The name of the second one (the ""variation"") starts with ""var"".; 186The following table gives the complete list:; 187 ; 188Begin_Macro; 189greekletters.C; 190End_Macro; 191 ; 192 ; 193\anchor L8; 194## Accents; 195Several kind of accents are available:; 196 ; 197Begin_Macro; 198{; 199 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,700,300);; 200 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 201 Tl.DrawText(.1, .10, ""#hat : ""); Tl.DrawLatex(.3, .10, "" #hat{a} "");; 202 Tl.DrawText(.1, .23, ""#check : ""); Tl.DrawLatex(.3, .23, "" #check{a} "");; 203 Tl.DrawText(.1, .36, ""#acute : ""); Tl.DrawLatex(.3, .36, "" #acute{a} "");; 204 Tl.DrawText(.1, .50, ""#grave : ""); Tl.DrawLatex(.3, .50, "" #grave{a} "");; 205 Tl.DrawText(.1, .63, ""#dot : ""); Tl.DrawLatex(.3, .63, "" #dot{a} "");; 206 Tl.DrawText(.1, .76, ""#ddot : ""); Tl.DrawLatex(.3, .76, "" #ddot{a} "");; 207 Tl.DrawText(.1, .90, ""#tilde : ""); Tl.DrawLatex(.3, .90, "" #tilde{a} "");; 208}; 209End_Macro; 210 ; 211 ; 212The special sign: `#slash` draws a slash on top of the text between brackets:; 213 ; 214Begin_Macro; 215{; 216 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,700,100);; 217 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 218 Tl.DrawText(.1, .5, ""#slash{E}_{T} :""); Tl.DrawLatex(.5, .5, ""#sl",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:11170,Availability,down,down,11170,"278 latex.DrawLatex(.3,.6,""K^{*0}"");; 279 latex.DrawLatex(.2,.5,longstring);; 280 ; 281 latex.SetTextAlign(11); //default bottom alignment; 282 latex.DrawLatex(.2,.4,""K_{S}"");; 283 latex.DrawLatex(.3,.4,""K^{*0}"");; 284 latex.DrawLatex(.2,.3,longstring);; 285 ; 286 latex.SetTextAlign(10); //special bottom alignment; 287 latex.DrawLatex(.2,.2,""K_{S}"");; 288 latex.DrawLatex(.3,.2,""K^{*0}"");; 289 latex.DrawLatex(.2,.1,longstring);; 290 ; 291 latex.SetTextAlign(12);; 292 latex.SetTextFont(72);; 293 latex.DrawLatex(.1,.80,""13"");; 294 latex.DrawLatex(.1,.55,""12"");; 295 latex.DrawLatex(.1,.35,""11"");; 296 latex.DrawLatex(.1,.18,""10"");; 297 return Tlva;; 298}; 299End_Macro; 300 ; 301 ; 302\anchor L11; 303## Character Adjustment; 304 ; 305The two commands `#kern` and `#lower` enable a better control; 306over character placement. The command `#kern[(Float_t)dx]{text}` moves; 307the output string horizontally by the fraction `dx` of its length.; 308Similarly, `#lower[(Float_t)dy]{text}` shifts the text up or down by; 309the fraction `dy` of its height.; 310 ; 311Examples:; 312 ; 313Begin_Macro; 314{; 315 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,900,300);; 316 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 317 TLatex Tt; Tt.SetTextFont(43); Tt.SetTextSize(16);; 318 Double_t dy = 1./7.;; 319 Tl.DrawLatex(.5, dy, ""Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g}"");; 320 Tt.DrawText(.01, 2*dy, ""Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g} :"");; 321 Tl.DrawLatex(.5, 3*dy, ""Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g}"");; 322 Tt.DrawText(.01, 4*dy, ""Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g} :"");; 323 Tl.DrawLatex(.5, 5*dy, ""Vertical a#lower[0.2]{d}#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t"");; 324 Tt.DrawText(.01, 6*dy, ""Vertical a#low",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:18624,Availability,down,down,18624,"&)obj).fOriginSize = fOriginSize;; 486 ((TLatex&)obj).fItalic = fItalic;; 487}; 488 ; 489////////////////////////////////////////////////////////////////////////////////; 490/// Analyse function.; 491 ; 492TLatex::TLatexFormSize TLatex::Anal1(const TextSpec_t &spec, const Char_t *t, Int_t length); 493{; 494 return Analyse(0, 0, spec, t, length);; 495}; 496 ; 497////////////////////////////////////////////////////////////////////////////////; 498/// Analyse and paint the TLatex formula; 499///; 500/// It is called twice : first for calculating the size of; 501/// each portion of the formula, then to paint the formula.; 502/// When analyse finds an operator or separator, it calls; 503/// itself recursively to analyse the arguments of the operator.; 504/// when the argument is an atom (normal text), it calculates; 505/// the size of it and return it as the result.; 506/// for example : if the operator #%frac{arg1}{arg2} is found :; 507/// Analyse(arg1) return the size of arg1 (width, up, down); 508/// Analyse(arg2) return the size of arg2; 509/// now, we know the size of #%frac{arg1}{arg2}:; 510///; 511/// ~~~ {.cpp}; 512/// width = max(width_arg1, width_arg2); 513/// up = up_arg1 + down_arg1; 514/// down = up_arg2 + down_arg2; 515/// ~~~; 516///; 517/// so, when the user wants to paint a fraction at position (x,y),; 518/// the rect used for the formula is : (x,y-up,x+width,y+down); 519///; 520/// return size of zone occupied by the text/formula; 521/// - `t` : chain to be analyzed; 522/// - `length` : number of chars in t.; 523 ; 524TLatex::TLatexFormSize TLatex::Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t, Int_t length); 525{; 526 const char *tab[] = { ""alpha"",""beta"",""chi"",""delta"",""varepsilon"",""phi"",""gamma"",""eta"",""iota"",""varphi"",""kappa"",""lambda"",; 527 ""mu"",""nu"",""omicron"",""pi"",""theta"",""rho"",""sigma"",""tau"",""upsilon"",""varomega"",""omega"",""xi"",""psi"",""zeta"",; 528 ""Alpha"",""Beta"",""Chi"",""Delta"",""Epsilon"",""Phi"",""Gamma"",""Eta"",""Iota"",""vartheta"",; 529 ""K",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:18841,Availability,down,down,18841,"t, length);; 495}; 496 ; 497////////////////////////////////////////////////////////////////////////////////; 498/// Analyse and paint the TLatex formula; 499///; 500/// It is called twice : first for calculating the size of; 501/// each portion of the formula, then to paint the formula.; 502/// When analyse finds an operator or separator, it calls; 503/// itself recursively to analyse the arguments of the operator.; 504/// when the argument is an atom (normal text), it calculates; 505/// the size of it and return it as the result.; 506/// for example : if the operator #%frac{arg1}{arg2} is found :; 507/// Analyse(arg1) return the size of arg1 (width, up, down); 508/// Analyse(arg2) return the size of arg2; 509/// now, we know the size of #%frac{arg1}{arg2}:; 510///; 511/// ~~~ {.cpp}; 512/// width = max(width_arg1, width_arg2); 513/// up = up_arg1 + down_arg1; 514/// down = up_arg2 + down_arg2; 515/// ~~~; 516///; 517/// so, when the user wants to paint a fraction at position (x,y),; 518/// the rect used for the formula is : (x,y-up,x+width,y+down); 519///; 520/// return size of zone occupied by the text/formula; 521/// - `t` : chain to be analyzed; 522/// - `length` : number of chars in t.; 523 ; 524TLatex::TLatexFormSize TLatex::Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t, Int_t length); 525{; 526 const char *tab[] = { ""alpha"",""beta"",""chi"",""delta"",""varepsilon"",""phi"",""gamma"",""eta"",""iota"",""varphi"",""kappa"",""lambda"",; 527 ""mu"",""nu"",""omicron"",""pi"",""theta"",""rho"",""sigma"",""tau"",""upsilon"",""varomega"",""omega"",""xi"",""psi"",""zeta"",; 528 ""Alpha"",""Beta"",""Chi"",""Delta"",""Epsilon"",""Phi"",""Gamma"",""Eta"",""Iota"",""vartheta"",; 529 ""Kappa"",""Lambda"",""Mu"",""Nu"",""Omicron"",""Pi"",""Theta"",""Rho"",""Sigma"",""Tau"",; 530 ""Upsilon"",""varsigma"",""Omega"",""Xi"",""Psi"",""Zeta"",""varUpsilon"",""epsilon""};; 531 ; 532 const char *tab2[] = { ""leq"",""/"",""infty"",""voidb"",""club"",""diamond"",""heart"",; 533 ""spade"",""leftrightarrow"",""leftarrow"",""uparrow"",""rightarrow"",; 534 ""downarrow"",""circ"",""pm"",""doublequo",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:19020,Availability,down,down,19020,"t, length);; 495}; 496 ; 497////////////////////////////////////////////////////////////////////////////////; 498/// Analyse and paint the TLatex formula; 499///; 500/// It is called twice : first for calculating the size of; 501/// each portion of the formula, then to paint the formula.; 502/// When analyse finds an operator or separator, it calls; 503/// itself recursively to analyse the arguments of the operator.; 504/// when the argument is an atom (normal text), it calculates; 505/// the size of it and return it as the result.; 506/// for example : if the operator #%frac{arg1}{arg2} is found :; 507/// Analyse(arg1) return the size of arg1 (width, up, down); 508/// Analyse(arg2) return the size of arg2; 509/// now, we know the size of #%frac{arg1}{arg2}:; 510///; 511/// ~~~ {.cpp}; 512/// width = max(width_arg1, width_arg2); 513/// up = up_arg1 + down_arg1; 514/// down = up_arg2 + down_arg2; 515/// ~~~; 516///; 517/// so, when the user wants to paint a fraction at position (x,y),; 518/// the rect used for the formula is : (x,y-up,x+width,y+down); 519///; 520/// return size of zone occupied by the text/formula; 521/// - `t` : chain to be analyzed; 522/// - `length` : number of chars in t.; 523 ; 524TLatex::TLatexFormSize TLatex::Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t, Int_t length); 525{; 526 const char *tab[] = { ""alpha"",""beta"",""chi"",""delta"",""varepsilon"",""phi"",""gamma"",""eta"",""iota"",""varphi"",""kappa"",""lambda"",; 527 ""mu"",""nu"",""omicron"",""pi"",""theta"",""rho"",""sigma"",""tau"",""upsilon"",""varomega"",""omega"",""xi"",""psi"",""zeta"",; 528 ""Alpha"",""Beta"",""Chi"",""Delta"",""Epsilon"",""Phi"",""Gamma"",""Eta"",""Iota"",""vartheta"",; 529 ""Kappa"",""Lambda"",""Mu"",""Nu"",""Omicron"",""Pi"",""Theta"",""Rho"",""Sigma"",""Tau"",; 530 ""Upsilon"",""varsigma"",""Omega"",""Xi"",""Psi"",""Zeta"",""varUpsilon"",""epsilon""};; 531 ; 532 const char *tab2[] = { ""leq"",""/"",""infty"",""voidb"",""club"",""diamond"",""heart"",; 533 ""spade"",""leftrightarrow"",""leftarrow"",""uparrow"",""rightarrow"",; 534 ""downarrow"",""circ"",""pm"",""doublequo",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:19928,Availability,down,downarrow,19928,,MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:20076,Availability,down,downleftarrow,20076,,MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:22300,Availability,error,error,22300,",""void06"",""GT"",""int"",""forall"",""exists"" };; 544 ; 545 const char *tab3[] = { ""bar"",""vec"",""dot"",""hat"",""ddot"",""acute"",""grave"",""check"",""tilde"",""slash""};; 546 ; 547 if (fError) return TLatexFormSize(0,0,0);; 548 ; 549 Int_t nBlancDeb = 0, nBlancFin = 0, l_nBlancDeb = 0, l_nBlancFin = 0;; 550 Int_t i, k;; 551 Int_t min = 0, max = 0;; 552 Bool_t cont = kTRUE;; 553 while(cont) {; 554 // count leading blanks; 555 //while(nBlancDeb+nBlancFin<length && t[nBlancDeb]==' ') nBlancDeb++;; 556 ; 557 if (nBlancDeb==length) return TLatexFormSize(0,0,0); // empty string; 558 ; 559 // count trailing blanks; 560 //while(nBlancDeb+nBlancFin<length && t[length-nBlancFin-1]==' ') nBlancFin++;; 561 ; 562 if (nBlancDeb==l_nBlancDeb && nBlancFin==l_nBlancFin) cont = kFALSE;; 563 ; 564 // remove characters { }; 565 if (t[nBlancDeb]=='{' && t[length-nBlancFin-1]=='}') {; 566 Int_t nBrackets = 0;; 567 Bool_t sameBrackets = kTRUE;; 568 for(i=nBlancDeb;i<length-nBlancFin;i++) {; 569 if (t[i] == '{' && !(i>0 && t[i-1] == '@')) nBrackets++;; 570 if (t[i] == '}' && t[i-1]!= '@') nBrackets--;; 571 if (nBrackets==0 && i<length-nBlancFin-2) {; 572 sameBrackets=kFALSE;; 573 break;; 574 }; 575 }; 576 ; 577 if (sameBrackets) {; 578 // begin and end brackets match; 579 nBlancDeb++;; 580 nBlancFin++;; 581 if (nBlancDeb+nBlancFin==length) return TLatexFormSize(0,0,0); // empty string; 582 cont = kTRUE;; 583 }; 584 ; 585 }; 586 ; 587 l_nBlancDeb = nBlancDeb;; 588 l_nBlancFin = nBlancFin;; 589 }; 590 ; 591 // make a copy of the current processed chain of characters; 592 // removing leading and trailing blanks; 593 length -= nBlancFin+nBlancDeb; // length of string without blanks; 594 if (length <=0) {; 595 Error(""Analyse"", ""It seems there is a syntax error in the TLatex string"");; 596 return TLatexFormSize(0,0,0);; 597 }; 598 Char_t* text = new Char_t[length+1];; 599 strncpy(text,t+nBlancDeb,length);; 600 text[length] = 0;; 601 ; 602 // compute size of subscripts and superscripts; 603 Double_t indiceSize = spec.",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:22750,Availability,error,errors,22750," {; 578 // begin and end brackets match; 579 nBlancDeb++;; 580 nBlancFin++;; 581 if (nBlancDeb+nBlancFin==length) return TLatexFormSize(0,0,0); // empty string; 582 cont = kTRUE;; 583 }; 584 ; 585 }; 586 ; 587 l_nBlancDeb = nBlancDeb;; 588 l_nBlancFin = nBlancFin;; 589 }; 590 ; 591 // make a copy of the current processed chain of characters; 592 // removing leading and trailing blanks; 593 length -= nBlancFin+nBlancDeb; // length of string without blanks; 594 if (length <=0) {; 595 Error(""Analyse"", ""It seems there is a syntax error in the TLatex string"");; 596 return TLatexFormSize(0,0,0);; 597 }; 598 Char_t* text = new Char_t[length+1];; 599 strncpy(text,t+nBlancDeb,length);; 600 text[length] = 0;; 601 ; 602 // compute size of subscripts and superscripts; 603 Double_t indiceSize = spec.fSize/fFactorSize;; 604 if(indiceSize<fOriginSize/TMath::Exp(fLimitFactorSize*TMath::Log(fFactorSize))-0.001f); 605 indiceSize = spec.fSize;; 606 // subtract 0.001 because of rounding errors; 607 TextSpec_t specNewSize = spec;; 608 specNewSize.fSize = indiceSize;; 609 ; 610 // recherche des operateurs; 611 Int_t opPower = -1; // Position of first ^ (power); 612 Int_t opUnder = -1; // Position of first _ (indice); 613 Int_t opFrac = -1; // Position of first \frac; 614 Int_t opSqrt = -1; // Position of first \sqrt; 615 Int_t nBrackets = 0; // Nesting level in { }; 616 Int_t nCroch = 0; // Nesting level in [ ]; 617 Int_t opCurlyCurly = -1; // Position of first }{; 618 Int_t opSquareCurly = -1; // Position of first ]{; 619 Int_t opCloseCurly = -2; // Position of first }; 620 Int_t opColor = -1; // Position of first #color; 621 Int_t opFont = -1; // Position of first #font; 622 Int_t opScale = -1; // Position of first #scale; 623 Int_t opGreek = -1; // Position of a Greek letter; 624 Int_t opSpec = -1; // position of a special character; 625 Int_t opAbove = -1; // position of a vector/overline; 626 Int_t opSquareBracket = 0 ; // position of a ""[]{"" operator (#[]{arg}); 627 Int_t opBigCurl",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:79566,Availability,down,downleftarrow,79566,"."");; 2154 t.ReplaceAll(""#aa"",""\\mbox{\\aa}"");; 2155 t.ReplaceAll(""#AA"",""\\mbox{\\AA}"");; 2156 ; 2157 t.ReplaceAll(""#omicron"",""o"");; 2158 t.ReplaceAll(""#Alpha"",""A"");; 2159 t.ReplaceAll(""#Beta"",""B"");; 2160 t.ReplaceAll(""#Epsilon"",""E"");; 2161 t.ReplaceAll(""#Zeta"",""Z"");; 2162 t.ReplaceAll(""#Eta"",""H"");; 2163 t.ReplaceAll(""#Iota"",""I"");; 2164 t.ReplaceAll(""#Kappa"",""K"");; 2165 t.ReplaceAll(""#Mu"",""M"");; 2166 t.ReplaceAll(""#Nu"",""N"");; 2167 t.ReplaceAll(""#Omicron"",""O"");; 2168 t.ReplaceAll(""#Rho"",""P"");; 2169 t.ReplaceAll(""#Tau"",""T"");; 2170 t.ReplaceAll(""#Chi"",""X"");; 2171 t.ReplaceAll(""#varomega"",""\\varpi"");; 2172 ; 2173 t.ReplaceAll(""#varUpsilon"",""?"");; 2174 t.ReplaceAll(""#corner"",""?"");; 2175 t.ReplaceAll(""#ltbar"",""?"");; 2176 t.ReplaceAll(""#bottombar"",""?"");; 2177 t.ReplaceAll(""#notsubset"",""?"");; 2178 t.ReplaceAll(""#arcbottom"",""?"");; 2179 t.ReplaceAll(""#cbar"",""?"");; 2180 t.ReplaceAll(""#arctop"",""?"");; 2181 t.ReplaceAll(""#topbar"",""?"");; 2182 t.ReplaceAll(""#arcbar"",""?"");; 2183 t.ReplaceAll(""#downleftarrow"",""?"");; 2184 t.ReplaceAll(""#splitline"",""\\genfrac{}{}{0pt}{}"");; 2185 ; 2186 t.ReplaceAll(""#"",""\\"");; 2187 t.ReplaceAll(""%"",""\\%"");; 2188 }; 2189 gVirtualPS->Text(x,y,t.Data());; 2190 } else {; 2191 Bool_t saveb = gPad->IsBatch();; 2192 gPad->SetBatch(kTRUE);; 2193 if (!PaintLatex1( x, y, angle, size, text1)) {; 2194 if (saveps) gVirtualPS = saveps;; 2195 return;; 2196 }; 2197 gPad->SetBatch(saveb);; 2198 }; 2199 gVirtualPS = nullptr;; 2200 }; 2201 ; 2202 if (!gPad->IsBatch()) PaintLatex1( x, y, angle, size, text1);; 2203 if (saveps) gVirtualPS = saveps;; 2204}; 2205 ; 2206////////////////////////////////////////////////////////////////////////////////; 2207/// Drawing function; 2208 ; 2209Int_t TLatex::PaintLatex1(Double_t x, Double_t y, Double_t angle, Double_t size, const Char_t *text1); 2210{; 2211 if (!gPad) return 0;; 2212 TString newText = text1;; 2213 if( newText.Length() == 0) return 0;; 2214 newText.ReplaceAll(""#hbox"",""#mbox"");; 2215 ; 2216 fError = nullptr;; 2217 if (C",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:85430,Availability,error,error,85430,";; 2333 const Char_t *kLeft2[] = {""#[]{"",""#[]{"",""#{}{"",""#{}{"",""#||{"",""#||{"",""#(){"",""#(){""};; 2334 const Char_t *kRight[] = {""#right]"",""\\right]"",""#right}"",""\\right}"",""#right|"",""\\right|"",""#right)"",""\\right)""};; 2335 const Int_t lkWord1[] = {4,4,2,2,7,7,6,6,4,4,4,5,5,5,5,6,7,7,7,7,7,4,4,6,7,7,6,6,4,4,4,4,4,5,5,5,5,6,7,7,7,4,4,6};; 2336 const Int_t lkWord2[] = {7,7,6,6,6,7,7,7,6,6,6,7} ;; 2337 const Int_t lkWord3[] = {6,6,11,11} ;; 2338 Int_t nkWord1 = 44, nkWord2 = 12, nkWord3 = 4;; 2339 Int_t i,k ;; 2340 Int_t nLeft1 , nRight , nOfLeft, nOfRight;; 2341 Int_t lLeft1 = 6 ;; 2342 Int_t lLeft2 = 4 ;; 2343 Int_t lRight = 7 ;; 2344 nLeft1 = nRight = 8 ;; 2345 nOfLeft = nOfRight = 0 ;; 2346 ; 2347 Char_t buf[11] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 2352 Int_t nOfCurlyBracket, nOfKW1, nOfKW2, nOfKW3, nOfSquareCurly, nOfCurlyCurly ;; 2353 Int_t nOfSquareBracket = 0 ;; 2354 Int_t error = 0 ;; 2355 Bool_t quote1 = kFALSE , quote2 = kFALSE;; 2356 ; 2357 // first find and replace all occurrences of ""kLeft1"" keyword by ""kLeft2"" keyword,; 2358 // and all occurrences of ""kRight"" keyword by ""}"".; 2359 i = 0 ;; 2360 while (i < length) {; 2361 // The string in 'buf' does not need to be null terminated,; 2362 // we will only check with strncmp.; 2363 strncpy(buf,&text[i],TMath::Min(7,length-i));; 2364 opFound = kFALSE ;; 2365 for (k = 0 ; k < nLeft1 ; k++) {; 2366 if (strncmp(buf,kLeft1[k],lLeft1)==0) {; 2367 nOfLeft++ ;; 2368 i+=lLeft1 ;; 2369 opFound = kTRUE ;; 2370 break ;; 2371 }; 2372 }; 2373 if (opFound) continue ;; 2374 ; 2375 for(k=0;k<nRight;k++) {; 2376 if (strncmp(buf,kRight[k],lRight)==0) {; 2377 nOfRight++ ;; 2378 i+=lRight ;; 2379 opFound = kTRUE ;; 2380 break ;; 2381 }; 2382 }; 2383 if (!opFound) i++ ;; 2384 }; 2385 if (nOfLeft != nOfRight) {; 2386 printf("" nOfLeft = %d, nOfRight = %d\n"",nOfLeft,nOfRight) ;; 2387 error = 1 ;; 2388 fError = ""Operators \""#left\"" and \""#right\"" don't match",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:86387,Availability,error,error,86387,"1] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 2352 Int_t nOfCurlyBracket, nOfKW1, nOfKW2, nOfKW3, nOfSquareCurly, nOfCurlyCurly ;; 2353 Int_t nOfSquareBracket = 0 ;; 2354 Int_t error = 0 ;; 2355 Bool_t quote1 = kFALSE , quote2 = kFALSE;; 2356 ; 2357 // first find and replace all occurrences of ""kLeft1"" keyword by ""kLeft2"" keyword,; 2358 // and all occurrences of ""kRight"" keyword by ""}"".; 2359 i = 0 ;; 2360 while (i < length) {; 2361 // The string in 'buf' does not need to be null terminated,; 2362 // we will only check with strncmp.; 2363 strncpy(buf,&text[i],TMath::Min(7,length-i));; 2364 opFound = kFALSE ;; 2365 for (k = 0 ; k < nLeft1 ; k++) {; 2366 if (strncmp(buf,kLeft1[k],lLeft1)==0) {; 2367 nOfLeft++ ;; 2368 i+=lLeft1 ;; 2369 opFound = kTRUE ;; 2370 break ;; 2371 }; 2372 }; 2373 if (opFound) continue ;; 2374 ; 2375 for(k=0;k<nRight;k++) {; 2376 if (strncmp(buf,kRight[k],lRight)==0) {; 2377 nOfRight++ ;; 2378 i+=lRight ;; 2379 opFound = kTRUE ;; 2380 break ;; 2381 }; 2382 }; 2383 if (!opFound) i++ ;; 2384 }; 2385 if (nOfLeft != nOfRight) {; 2386 printf("" nOfLeft = %d, nOfRight = %d\n"",nOfLeft,nOfRight) ;; 2387 error = 1 ;; 2388 fError = ""Operators \""#left\"" and \""#right\"" don't match !"" ;; 2389 goto ERROR_END ;; 2390 }; 2391 ; 2392 for (k = 0 ; k < nLeft1 ; k++) {; 2393 text.ReplaceAll(kLeft1[k],lLeft1,kLeft2[k],lLeft2) ;; 2394 }; 2395 for (k = 0 ; k < nRight ; k++) {; 2396 text.ReplaceAll(kRight[k],lRight,""}"",1) ;; 2397 }; 2398 length = text.Length() ;; 2399 ; 2400 i = nOfCurlyBracket = nOfKW1 = nOfKW2 = nOfKW3 = nOfSquareCurly = nOfCurlyCurly =0 ;; 2401 while (i< length){; 2402 switch (text[i]) {; 2403 case '""' : quote1 = !quote1 ; break ;; 2404 case '\'': quote2 = !quote2 ; break ;; 2405 }; 2406 // The string in 'buf' does not need to be null terminated,; 2407 // we will only check with strncmp; 2408 strncpy(buf,&text[i],TMath::Min(11,length-i));; 2409 opFound = kFALSE ;; 2410 ;",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89113,Availability,error,error,89113,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89225,Availability,error,error,89225,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89337,Availability,error,error,89337,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89434,Availability,error,error,89434,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89532,Availability,error,error,89532,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89630,Availability,error,error,89630,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:89720,Availability,error,error,89720,"+ ;; 2464 i+=2 ;; 2465 }; 2466 else if (text[i] == '[' ) { // not belonging to a key word, add @ in front; 2467 text.Insert(i,""@"") ;; 2468 length++ ;; 2469 i+=2 ;; 2470 }; 2471 else if (text[i] == '{' ) { // not belonging to a key word, add @ in front; 2472 text.Insert(i,""@"") ;; 2473 length++ ;; 2474 i+=2 ;; 2475 }; 2476 else if (text[i] == '}' ) {; 2477 if ( nOfCurlyBracket) {; 2478 nOfCurlyBracket-- ;; 2479 i++ ;; 2480 } else { // extra }, add @ in front; 2481 text.Insert(i,""@"") ;; 2482 length++ ;; 2483 i+=2 ;; 2484 }; 2485 } else {; 2486 i++ ;; 2487 buf[1] = 0 ;; 2488 }; 2489 }; 2490 ; 2491 if (nOfKW2 != nOfSquareCurly) {; 2492 error = 1 ;; 2493 fError = ""Invalid number of \""]{\"""" ;; 2494 }; 2495 else if (nOfKW3 != nOfCurlyCurly) {; 2496 error = 1 ;; 2497 fError = ""Error in syntax of \""#frac\"""" ;; 2498 }; 2499 else if (nOfCurlyBracket < 0) {; 2500 error = 1 ;; 2501 fError = ""Missing \""{\"""" ;; 2502 }; 2503 else if (nOfCurlyBracket > 0) {; 2504 error = 1 ;; 2505 fError = ""Missing \""}\"""" ;; 2506 }; 2507 else if (nOfSquareBracket < 0) {; 2508 error = 1 ;; 2509 fError = ""Missing \""[\"""" ;; 2510 }; 2511 else if (nOfSquareBracket > 0) {; 2512 error = 1 ;; 2513 fError = ""Missing \""]\"""" ;; 2514 }; 2515 ; 2516 ERROR_END:; 2517 return error ;; 2518}; 2519 ; 2520////////////////////////////////////////////////////////////////////////////////; 2521/// First parsing of the analyse sequence; 2522 ; 2523TLatex::TLatexFormSize TLatex::FirstParse(Double_t angle, Double_t size, const Char_t *text); 2524{; 2525 fTabSize.reserve(100); // ensure 100 entries before memory reallocation required; 2526 fShow = kFALSE;; 2527 fOriginSize = size;; 2528 ; 2529 //get current line attributes; 2530 Short_t lineW = GetLineWidth();; 2531 Int_t lineC = GetLineColor();; 2532 ; 2533 TextSpec_t spec;; 2534 spec.fAngle = angle;; 2535 spec.fSize = GetTextSizePercent(size);; 2536 spec.fColor = GetTextColor();; 2537 spec.fFont = GetTextFont();; 2538 Short_t halign = fTextAlign/10;; 2539 Short_t valign = fT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:110502,Availability,error,error,110502,"l_t fShow! is true during the second pass (Painting)Definition TLatex.h:66; TLatex::~TLatex~TLatex() overrideDestructor.Definition TLatex.cxx:431; TLatex::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TLatex.cxx:2711; TLatex::operator=TLatex & operator=(const TLatex &)assignment operatorDefinition TLatex.cxx:453; TLatex::DrawPolyLinevoid DrawPolyLine(Int_t npoints, Double_t *xx, Double_t *yy, const TextSpec_t &spec, Double_t scale_width=0.)Draw a poly line in a Latex formula Is scale_width parameter >=1, fill area will be drawn Otherwise l...Definition TLatex.cxx:1970; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLatex::fFactorSizeDouble_t fFactorSize! Relative size of subscripts and superscriptsDefinition TLatex.h:62; TLatex::fErrorconst Char_t * fError! error codeDefinition TLatex.h:65; TLatex::fItalicBool_t fItalic! Currently inside italic operatorDefinition TLatex.h:69; TLatex::Paintvoid Paint(Option_t *option="""") overridePaint.Definition TLatex.cxx:2092; TLatex::AnalyseTLatexFormSize Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t, Int_t length)Analyse and paint the TLatex formula.Definition TLatex.cxx:522; TLatex::CheckLatexSyntaxInt_t CheckLatexSyntax(TString &text)Check if the Latex syntax is correct.Definition TLatex.cxx:2322; TLatex::Savefsvoid Savefs(TLatexFormSize *fs)Save fs values in array fTabSize.Definition TLatex.cxx:2703; TMathTextTo draw TeX Mathematical Formula.Definition TMathText.h:19; TMathText::GetYsizeDouble_t GetYsize()Get Y size.Definition TMathText.cxx:519; TMathText::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideGet the text width and height.Definition TMathText.cxx:477; TMathText::GetXsizeDouble_t GetXsize()Get X size.Definition TMathText",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:112441,Availability,error,error,112441,"sizeDouble_t GetXsize()Get X size.Definition TMathText.cxx:498; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceSpecialCppCharsTString & ReplaceSpecialCppChars()Find special characters which are typically used in printf() calls and replace them by appropriate es...Definition TString.cxx:1114; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TTextBase class for several text objects.Definition TText.h:22; TText::fYDouble_t fYY position of text (left,center,etc..)Definition TText.h:26; TText::Copyvoid Copy(TObjec",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:22918,Energy Efficiency,power,power,22918,,MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:60154,Energy Efficiency,power,power,60154,"ne found; 1632 if (opCurlyCurly==-1) { // }{ not found; 1633 // arguments missing for \splitline; 1634 fError = ""Missing second line for #splitline"";; 1635 delete[] text;; 1636 return TLatexFormSize(0,0,0);; 1637 }; 1638 Double_t height = GetHeight()*spec.fSize/8;; 1639 if (!fShow) {; 1640 fs1 = Anal1(spec,text+opSplitLine+11,opCurlyCurly-opSplitLine-11);; 1641 fs2 = Anal1(spec,text+opCurlyCurly+2,length-opCurlyCurly-3);; 1642 Savefs(&fs1);; 1643 Savefs(&fs2);; 1644 } else {; 1645 fs2 = Readfs();; 1646 fs1 = Readfs();; 1647 Analyse(x,y+fs2.Over()-height,spec,text+opCurlyCurly+2,length-opCurlyCurly-3); // second line; 1648 Analyse(x,y-fs1.Under()-3*height,spec,text+opSplitLine+11,opCurlyCurly-opSplitLine-11); //first line; 1649 }; 1650 ; 1651 result.Set(TMath::Max(fs1.Width(),fs2.Width()),fs1.Height()+3*height,fs2.Height()-height);; 1652 ; 1653 }; 1654 else if (opSqrt>-1) { // \sqrt found; 1655 if (!fShow) {; 1656 if (opSquareCurly>-1) {; 1657 // power nth #sqrt[n]{arg}; 1658 fs1 = Anal1(specNewSize,text+opSqrt+6,opSquareCurly-opSqrt-6);; 1659 fs2 = Anal1(spec,text+opSquareCurly+1,length-opSquareCurly-1);; 1660 Savefs(&fs1);; 1661 Savefs(&fs2);; 1662 result.Set(fs2.Width()+ GetHeight()*spec.fSize/10+TMath::Max(GetHeight()*spec.fSize/2,(Double_t)fs1.Width()),; 1663 fs2.Over()+fs1.Height()+GetHeight()*spec.fSize/4,fs2.Under());; 1664 } else {; 1665 fs1 = Anal1(spec,text+opSqrt+5,length-opSqrt-5);; 1666 Savefs(&fs1);; 1667 result.Set(fs1.Width()+GetHeight()*spec.fSize/2,fs1.Over()+GetHeight()*spec.fSize/4,fs1.Under());; 1668 }; 1669 } else {; 1670 if (opSquareCurly>-1) { // ]{; 1671 fs2 = Readfs();; 1672 fs1 = Readfs();; 1673 Double_t pas = TMath::Max(GetHeight()*spec.fSize/2,(Double_t)fs1.Width());; 1674 Double_t pas2 = pas + GetHeight()*spec.fSize/10;; 1675 Double_t y1 = y-fs2.Over() ;; 1676 Double_t y2 = y+fs2.Under() ;; 1677 Double_t y3 = y1-GetHeight()*spec.fSize/4;; 1678 Analyse(x+pas2,y,spec,text+opSquareCurly+1,length-opSquareCurly-1);; 1679 Analyse(x,y-fs2.Over",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:115118,Energy Efficiency,power,power,115118,"d, const char *text) constReturn text ascent and descent for string text.Definition TText.cxx:525; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TText::GetControlBoxvirtual void GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])Return the text control box.Definition TText.cxx:424; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TLatex::TextSpec_tTLatex helper struct holding the attributes of a piece of text.Definition TLatex.h:24; TLatex::TextSpec_t::fFontInt_t fFontDefinition TLatex.h:26; TLatex::TextSpec_t::fSizeDouble_t fSizeDefinition TLatex.h:25; TLatex::TextSpec_t::fAngleDouble_t fAngleDefinition TLatex.h:25; TLatex::TextSpec_t::fColorInt_t fColorDefinition TLatex.h:26; mT",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:112447,Integrability,message,message,112447,"sizeDouble_t GetXsize()Get X size.Definition TMathText.cxx:498; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceSpecialCppCharsTString & ReplaceSpecialCppChars()Find special characters which are typically used in printf() calls and replace them by appropriate es...Definition TString.cxx:1114; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TTextBase class for several text objects.Definition TText.h:22; TText::fYDouble_t fYY position of text (left,center,etc..)Definition TText.h:26; TText::Copyvoid Copy(TObjec",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:114493,Integrability,interface,interface,114493,".Definition TText.cxx:107; TText::operator=TText & operator=(const TText &src)Assignment operator.Definition TText.cxx:98; TText::fXDouble_t fXX position of text (left,center,etc..)Definition TText.h:25; TText::PaintTextvirtual void PaintText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:752; TText::GetTextExtentvirtual void GetTextExtent(UInt_t &w, UInt_t &h, const char *text) constReturn text extent for string text.Definition TText.cxx:591; TText::GetTextAscentDescentvirtual void GetTextAscentDescent(UInt_t &a, UInt_t &d, const char *text) constReturn text ascent and descent for string text.Definition TText.cxx:525; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TText::GetControlBoxvirtual void GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])Return the text control box.Definition TText.cxx:424; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:112293,Modifiability,inherit,inherits,112293,"thText.cxx:519; TMathText::GetBoundingBoxvoid GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle=kFALSE) overrideGet the text width and height.Definition TMathText.cxx:477; TMathText::GetXsizeDouble_t GetXsize()Get X size.Definition TMathText.cxx:498; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceSpecialCppCharsTString & ReplaceSpecialCppChars()Find special characters which are typically used in printf() calls and replace them by appropriate es...Definition TString.cxx:1114; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:27120,Safety,detect,detect,27120,"_t buf[3];; 697 strncpy(buf,&text[i],2);; 698 if (strncmp(buf,""^{"",2)==0) {; 699 if (opPower==-1 && nBrackets==0 && nCroch==0) opPower=i;; 700 if (i>3) {; 701 Char_t buf1[5];; 702 strncpy(buf1,&text[i-4],4);; 703 if (strncmp(buf1,""#int"",4)==0) {; 704 abovePlace = 1;; 705 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 706 }; 707 if (strncmp(buf1,""#sum"",4)==0) {; 708 abovePlace = 2;; 709 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 710 }; 711 }; 712 }; 713 if (strncmp(buf,""_{"",2)==0) {; 714 if (opUnder==-1 && nBrackets==0 && nCroch==0) opUnder=i;; 715 if (i>3) {; 716 Char_t buf2[5];; 717 strncpy(buf2,&text[i-4],4);; 718 if (strncmp(buf2,""#int"",4)==0) {; 719 abovePlace = 1;; 720 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 721 }; 722 if (strncmp(buf2,""#sum"",4)==0) {; 723 abovePlace = 2;; 724 if (i>4 && opCloseCurly==-2) opCloseCurly=i-5;; 725 }; 726 }; 727 }; 728 if (strncmp(buf,""]{"",2)==0); 729 if (opSquareCurly==-1 && nBrackets==0 && nCroch==0) opSquareCurly=i;; 730 }; 731 // detect other operators; 732 if (text[i]=='\\' || (text[i]=='#' && !opFound && nBrackets==0 && nCroch==0)) {; 733 ; 734 if (length>i+10) {; 735 Char_t buf[11];; 736 strncpy(buf,&text[i+1],10);; 737 if (strncmp(buf,""splitline{"",10)==0) {; 738 opSplitLine=i; opFound = kTRUE;; 739 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 740 continue;; 741 }; 742 }; 743 if (length>i+9) {; 744 Char_t buf[10];; 745 strncpy(buf,&text[i+1],9);; 746 if (!opBackslash && strncmp(buf,""backslash"",9)==0) {; 747 opBackslash=1; opFound = kTRUE;; 748 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 749 continue;; 750 }; 751 }; 752 if (length>i+8) {; 753 Char_t buf[9];; 754 strncpy(buf,&text[i+1],8);; 755 if (!opParallel && strncmp(buf,""parallel"",8)==0) {; 756 opParallel=1; opFound = kTRUE;; 757 if (i>0 && opCloseCurly==-2) opCloseCurly=i-1;; 758 continue;; 759 }; 760 }; 761 if (length>i+6) {; 762 Char_t buf[7];; 763 strncpy(buf,&text[i+1],6);; 764 if (strncmp(buf,""lower["",6)==0 || strncmp(buf,""lower{"",6)==0) {; 765 o",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:115204,Testability,log,logarithm,115204,"tual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; TText::GetControlBoxvirtual void GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t cBoxX[4], Int_t cBoxY[4])Return the text control box.Definition TText.cxx:424; TVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG.Definition TVirtualPS.h:30; TVirtualPS::Textvirtual void Text(Double_t x, Double_t y, const char *string)=0; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TLatex::TextSpec_tTLatex helper struct holding the attributes of a piece of text.Definition TLatex.h:24; TLatex::TextSpec_t::fFontInt_t fFontDefinition TLatex.h:26; TLatex::TextSpec_t::fSizeDouble_t fSizeDefinition TLatex.h:25; TLatex::TextSpec_t::fAngleDouble_t fAngleDefinition TLatex.h:25; TLatex::TextSpec_t::fColorInt_t fColorDefinition TLatex.h:26; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. graf2dgrafsrcTLatex.cxx. ROOT master - Referenc",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:83321,Usability,clear,clear,83321,"neC);; 2314 fTabSize.clear();; 2315 fX = xsave;; 2316 fY = ysave;; 2317 if (fError) return 0;; 2318 return 1;; 2319}; 2320 ; 2321////////////////////////////////////////////////////////////////////////////////; 2322/// Check if the Latex syntax is correct; 2323 ; 2324Int_t TLatex::CheckLatexSyntax(TString &text); 2325{; 2326 const Char_t *kWord1[] = {""{}^{"",""{}_{"",""^{"",""_{"",""#scale{"",""#color{"",""#font{"",""#sqrt{"",""#[]{"",""#{}{"",""#||{"",; 2327 ""#bar{"",""#vec{"",""#dot{"",""#hat{"",""#ddot{"",""#acute{"",""#grave{"",""#check{"",""#tilde{"",""#slash{"",""#bf{"",""#it{"",""#mbox{"",; 2328 ""\\scale{"",""\\color{"",""\\font{"",""\\sqrt{"",""\\[]{"",""\\{}{"",""\\||{"",""#(){"",""\\(){"",; 2329 ""\\bar{"",""\\vec{"",""\\dot{"",""\\hat{"",""\\ddot{"",""\\acute{"",""\\grave{"",""\\check{"",""\\bf{"",""\\it{"",""\\mbox{""}; // check for }; 2330 const Char_t *kWord2[] = {""#scale["",""#color["",""#font["",""#sqrt["",""#kern["",""#lower["",""\\scale["",""\\color["",""\\font["",""\\sqrt["",""\\kern["",""\\lower[""}; // check for ]{ + }; 2331 const Char_t *kWord3[] = {""#frac{"",""\\frac{"",""#splitline{"",""\\splitline{""}; // check for }{ then }; 2332 const Char_t *kLeft1[] = {""#left["",""\\left["",""#left{"",""\\left{"",""#left|"",""\\left|"",""#left("",""\\left(""};; 2333 const Char_t *kLeft2[] = {""#[]{"",""#[]{"",""#{}{"",""#{}{"",""#||{"",""#||{"",""#(){"",""#(){""};; 2334 const Char_t *kRight[] = {""#right]"",""\\right]"",""#right}"",""\\right}"",""#right|"",""\\right|"",""#right)"",""\\right)""};; 2335 const Int_t lkWord1[] = {4,4,2,2,7,7,6,6,4,4,4,5,5,5,5,6,7,7,7,7,7,4,4,6,7,7,6,6,4,4,4,4,4,5,5,5,5,6,7,7,7,4,4,6};; 2336 const Int_t lkWord2[] = {7,7,6,6,6,7,7,7,6,6,6,7} ;; 2337 const Int_t lkWord3[] = {6,6,11,11} ;; 2338 Int_t nkWord1 = 44, nkWord2 = 12, nkWord3 = 4;; 2339 Int_t i,k ;; 2340 Int_t nLeft1 , nRight , nOfLeft, nOfRight;; 2341 Int_t lLeft1 = 6 ;; 2342 Int_t lLeft2 = 4 ;; 2343 Int_t lRight = 7 ;; 2344 nLeft1 = nRight = 8 ;; 2345 nOfLeft = nOfRight = 0 ;; 2346 ; 2347 Char_t buf[11] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 23",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:92160,Usability,clear,clear,92160,"e; 2564 return h;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Return size of the formula along X in pad coordinates when the text precision; 2569/// is smaller than 3.; 2570 ; 2571Double_t TLatex::GetXsize(); 2572{; 2573 if (!gPad) return 0.;; 2574 TString newText = GetTitle();; 2575 if( newText.Length() == 0) return 0;; 2576 ; 2577 // The text is a TMathText.; 2578 if ( newText.Contains(""\\"") ) {; 2579 TMathText tm(0., 0., newText.Data());; 2580 return tm.GetXsize();; 2581 }; 2582 ; 2583 fError = nullptr;; 2584 if (CheckLatexSyntax(newText)) {; 2585 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2586 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2587 return 0;; 2588 }; 2589 fError = nullptr;; 2590 ; 2591 const Char_t *text = newText.Data() ;; 2592 Double_t angle_old = GetTextAngle();; 2593 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2594 SetTextAngle(angle_old);; 2595 fTabSize.clear();; 2596 return TMath::Abs(gPad->AbsPixeltoX(Int_t(fs.Width())) - gPad->AbsPixeltoX(0));; 2597}; 2598 ; 2599////////////////////////////////////////////////////////////////////////////////; 2600/// Return text size in pixels; 2601 ; 2602void TLatex::GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle); 2603{; 2604 if (!gPad) return;; 2605 TString newText = GetTitle();; 2606 if( newText.Length() == 0) return;; 2607 ; 2608 // The text is a TMathText.; 2609 if ( newText.Contains(""\\"") ) {; 2610 TMathText tm(0., 0., newText.Data());; 2611 tm.GetBoundingBox(w, h);; 2612 return;; 2613 }; 2614 ; 2615 fError = nullptr;; 2616 if (CheckLatexSyntax(newText)) {; 2617 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2618 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2619 return;; 2620 }; 2621 fError = nullptr;; 2622 ; 2623 if (angle) {; 2624 Int_t cBoxX[4], cBoxY[4];; 2625 Int_t ptx, pty;; 2626 if (TestBit(kTextNDC)) {; 2627 ptx = gPad->UtoPixel(fX);; 2628 pty = gPad->VtoPixel(fY);; 2629 } else {; 2630 ptx = gPad->XtoAbsPi",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:93818,Usability,clear,clear,93818,"cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2618 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2619 return;; 2620 }; 2621 fError = nullptr;; 2622 ; 2623 if (angle) {; 2624 Int_t cBoxX[4], cBoxY[4];; 2625 Int_t ptx, pty;; 2626 if (TestBit(kTextNDC)) {; 2627 ptx = gPad->UtoPixel(fX);; 2628 pty = gPad->VtoPixel(fY);; 2629 } else {; 2630 ptx = gPad->XtoAbsPixel(gPad->XtoPad(fX));; 2631 pty = gPad->YtoAbsPixel(gPad->YtoPad(fY));; 2632 }; 2633 GetControlBox(ptx, pty, fTextAngle, cBoxX, cBoxY);; 2634 Int_t x1 = cBoxX[0];; 2635 Int_t x2 = cBoxX[0];; 2636 Int_t y1 = cBoxY[0];; 2637 Int_t y2 = cBoxY[0];; 2638 for (Int_t i=1; i<4; i++) {; 2639 if (cBoxX[i] < x1) x1 = cBoxX[i];; 2640 if (cBoxX[i] > x2) x2 = cBoxX[i];; 2641 if (cBoxY[i] < y1) y1 = cBoxY[i];; 2642 if (cBoxY[i] > y2) y2 = cBoxY[i];; 2643 }; 2644 w = x2-x1;; 2645 h = y2-y1;; 2646 } else {; 2647 const Char_t *text = newText.Data() ;; 2648 TLatexFormSize fs = FirstParse(GetTextAngle(),GetTextSize(),text);; 2649 fTabSize.clear();; 2650 w = (UInt_t)fs.Width();; 2651 h = (UInt_t)fs.Height();; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Return size of the formula along Y in pad coordinates when the text precision; 2657/// is smaller than 3.; 2658 ; 2659Double_t TLatex::GetYsize(); 2660{; 2661 if (!gPad) return 0.;; 2662 TString newText = GetTitle();; 2663 if( newText.Length() == 0) return 0;; 2664 ; 2665 // The text is a TMathText.; 2666 if ( newText.Contains(""\\"") ) {; 2667 TMathText tm(0., 0., newText.Data());; 2668 return tm.GetYsize();; 2669 }; 2670 ; 2671 fError = nullptr;; 2672 if (CheckLatexSyntax(newText)) {; 2673 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2674 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2675 return 0;; 2676 }; 2677 fError = nullptr;; 2678 ; 2679 const Char_t *text = newText.Data();; 2680 Double_t angsav = fTextAngle;; 2681 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2682 fTextAngle = angsav;; 2683 fTabSi",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8cxx_source.html:94836,Usability,clear,clear,94836," (UInt_t)fs.Height();; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Return size of the formula along Y in pad coordinates when the text precision; 2657/// is smaller than 3.; 2658 ; 2659Double_t TLatex::GetYsize(); 2660{; 2661 if (!gPad) return 0.;; 2662 TString newText = GetTitle();; 2663 if( newText.Length() == 0) return 0;; 2664 ; 2665 // The text is a TMathText.; 2666 if ( newText.Contains(""\\"") ) {; 2667 TMathText tm(0., 0., newText.Data());; 2668 return tm.GetYsize();; 2669 }; 2670 ; 2671 fError = nullptr;; 2672 if (CheckLatexSyntax(newText)) {; 2673 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2674 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2675 return 0;; 2676 }; 2677 fError = nullptr;; 2678 ; 2679 const Char_t *text = newText.Data();; 2680 Double_t angsav = fTextAngle;; 2681 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2682 fTextAngle = angsav;; 2683 fTabSize.clear();; 2684 return TMath::Abs(gPad->AbsPixeltoY(Int_t(fs.Height())) - gPad->AbsPixeltoY(0));; 2685}; 2686 ; 2687////////////////////////////////////////////////////////////////////////////////; 2688/// Read fs in fTabSize; 2689 ; 2690TLatex::TLatexFormSize TLatex::Readfs(); 2691{; 2692 if (fTabSize.empty()) {; 2693 Error(""Readfs"", ""No data in fTabSize stack"");; 2694 return TLatexFormSize(0,0,0);; 2695 }; 2696 ; 2697 TLatexFormSize result = fTabSize.back();; 2698 fTabSize.pop_back();; 2699 return result;; 2700}; 2701 ; 2702////////////////////////////////////////////////////////////////////////////////; 2703/// Save fs values in array fTabSize; 2704 ; 2705void TLatex::Savefs(TLatex::TLatexFormSize *fs); 2706{; 2707 fTabSize.emplace_back(*fs);; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// Save primitive as a C++ statement(s) on output stream out; 2712 ; 2713void TLatex::SavePrimitive(std::ostream &out, Option_t * /*= """"*/); 2714{; 2715 char quote = '""'",MatchSource.WIKI,doc/master/TLatex_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html
https://root.cern/doc/master/TLatex_8h.html:235,Integrability,depend,dependency,235,". ROOT: graf2d/graf/inc/TLatex.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLatex.h File Reference. #include ""TText.h""; #include ""TAttLine.h""; #include <vector>. Include dependency graph for TLatex.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TLatex::TextSpec_t;  TLatex helper struct holding the attributes of a piece of text. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLatex::TLatexFormSize;  TLatex helper class used to compute the size of a portion of a formula. More...;  . graf2dgrafincTLatex.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLatex_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8h.html
https://root.cern/doc/master/TLatex_8h_source.html:2901,Availability,error,error,2901,"LatexFormSize AddOver(TLatexFormSize f); 49 { return TLatexFormSize(f.Width()+fWidth,f.Height()+fOver,fUnder); }; 50 TLatexFormSize AddUnder(TLatexFormSize f); 51 { return TLatexFormSize(f.Width()+fWidth,fOver,f.Height()+fUnder); }; 52 TLatexFormSize AddOver(TLatexFormSize f1, TLatexFormSize f2); 53 { return TLatexFormSize(fWidth+TMath::Max(f1.Width(),f2.Width()),fOver+f1.Over(),fUnder+f2.Under()); }; 54 ; 55 // return members; 56 inline Double_t Width() const { return fWidth; }; 57 inline Double_t Over() const { return fOver; }; 58 inline Double_t Under() const { return fUnder; }; 59 inline Double_t Height() const { return fOver+fUnder; }; 60 };; 61 ; 62 Double_t fFactorSize; ///<! Relative size of subscripts and superscripts; 63 Double_t fFactorPos; ///<! Relative position of subscripts and superscripts; 64 Int_t fLimitFactorSize; ///< lower bound for subscripts/superscripts size; 65 const Char_t *fError{nullptr}; ///<! error code; 66 Bool_t fShow; ///<! is true during the second pass (Painting); 67 std::vector<TLatexFormSize> fTabSize; ///<! array of values for the different zones; 68 Double_t fOriginSize; ///< Font size of the starting font; 69 Bool_t fItalic; ///<! Currently inside italic operator; 70 ; 71 TLatex& operator=(const TLatex&);; 72 ; 73 //Text analysis and painting; 74 TLatexFormSize Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t,Int_t length);; 75 TLatexFormSize Anal1(const TextSpec_t &spec, const Char_t *t,Int_t length);; 76 ; 77 void DrawPolyLine(Int_t npoints, Double_t *xx, Double_t *yy, const TextSpec_t &spec, Double_t scale_width = 0.);; 78 void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const TextSpec_t &spec);; 79 void DrawCircle(Double_t x1, Double_t y1, Double_t r, const TextSpec_t &spec);; 80 void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, const TextSpec_t &spec);; 81 ; 82 TLatexFormSize FirstParse(Double_t angle, Double_t size, const Cha",MatchSource.WIKI,doc/master/TLatex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8h_source.html
https://root.cern/doc/master/TLatex_8h_source.html:13361,Availability,error,error,13361,"l_t fShow! is true during the second pass (Painting)Definition TLatex.h:66; TLatex::~TLatex~TLatex() overrideDestructor.Definition TLatex.cxx:431; TLatex::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TLatex.cxx:2711; TLatex::operator=TLatex & operator=(const TLatex &)assignment operatorDefinition TLatex.cxx:453; TLatex::DrawPolyLinevoid DrawPolyLine(Int_t npoints, Double_t *xx, Double_t *yy, const TextSpec_t &spec, Double_t scale_width=0.)Draw a poly line in a Latex formula Is scale_width parameter >=1, fill area will be drawn Otherwise l...Definition TLatex.cxx:1970; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLatex::fFactorSizeDouble_t fFactorSize! Relative size of subscripts and superscriptsDefinition TLatex.h:62; TLatex::fErrorconst Char_t * fError! error codeDefinition TLatex.h:65; TLatex::fItalicBool_t fItalic! Currently inside italic operatorDefinition TLatex.h:69; TLatex::Paintvoid Paint(Option_t *option="""") overridePaint.Definition TLatex.cxx:2092; TLatex::AnalyseTLatexFormSize Analyse(Double_t x, Double_t y, const TextSpec_t &spec, const Char_t *t, Int_t length)Analyse and paint the TLatex formula.Definition TLatex.cxx:522; TLatex::CheckLatexSyntaxInt_t CheckLatexSyntax(TString &text)Check if the Latex syntax is correct.Definition TLatex.cxx:2322; TLatex::Savefsvoid Savefs(TLatexFormSize *fs)Save fs values in array fTabSize.Definition TLatex.cxx:2703; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TTextBase class for several text objects.Definition TText.h:22; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of ",MatchSource.WIKI,doc/master/TLatex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLatex_8h_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:5526,Availability,error,error,5526,".; 156 ; 157void TLeaf::Browse(TBrowser* b); 158{; 159 if (strchr(GetName(), '.')) {; 160 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; ",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:24095,Availability,error,error,24095,"f TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::kZombie@ kZombieobject ctor failedDefinition TObject.h:83; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find leaf..Definition TTree.cxx:4916; int; unsigned int; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:13601,Integrability,rout,routine,13601,"adEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 }; 413 return len * fLen;; 414 } else {; 415 // -- We are a fixed size thing.; 416 return fLen;; 417 }; 418}; 419 ; 420////////////////////////////////////////////////////////////////////////////////; 421/// Helper routine for TLeafX::SetAddress.; 422///; 423/// The return value is non-zero if we owned the old; 424/// value buffer and must delete it now. The size; 425/// of the value buffer is recalculated and stored,; 426/// and a decision is made whether or not we own the; 427/// new value buffer.; 428 ; 429Int_t TLeaf::ResetAddress(void* addr, bool calledFromDestructor); 430{; 431 // The kNewValue bit records whether or not we own; 432 // the current value buffer or not. If we own it,; 433 // then we are responsible for deleting it.; 434 bool deleteValue = false;; 435 if (TestBit(kNewValue)) {; 436 deleteValue = true;; 437 }; 438 // If we are not being called from a destructor,; 439 // recalculate the value buffer size and decide; 440 // whether or not we own the new value buffer.; 441 if (!calledFromDestructor) {; 442 // -- Recalculate value buffer size and decide ownership of value.; 443 if (fLeafCount) {; 444 // -- Varying length array da",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:20188,Integrability,rout,routine,20188,"ion TLeaf.h:183; TLeaf::fLenTypeInt_t fLenTypeNumber of bytes for this data type.Definition TLeaf.h:73; TLeaf::fIsRangebool fIsRange(=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'....Definition TLeaf.h:75; TLeaf::GetLeafCountValuesvirtual const Counts_t * GetLeafCountValues(Long64_t start, Long64_t len)If this branch is a branch count, return the set of collection size for the entry range requested sta...Definition TLeaf.cxx:364; TLeaf::GetMaximumvirtual Int_t GetMaximum() constDefinition TLeaf.h:134; TLeaf::~TLeaf~TLeaf() overrideDestructor.Definition TLeaf.cxx:140; TLeaf::fLenInt_t fLenNumber of fixed length elements in the leaf's data.Definition TLeaf.h:72; TLeaf::fNdataInt_t fNdata! Number of elements in fAddress data buffer.Definition TLeaf.h:71; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::ResetAddressInt_t ResetAddress(void *add, bool calledFromDestructor=false)Helper routine for TLeafX::SetAddress.Definition TLeaf.cxx:429; TLeaf::IsATClass * IsA() const overrideDefinition TLeaf.h:168; TLeaf::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TLeaf.cxx:480; TLeaf::operator=TLeaf & operator=(const TLeaf &)Assignment operator.Definition TLeaf.cxx:117; TLeaf::GetLeafCountervirtual TLeaf * GetLeafCounter(Int_t &countval) constReturn a pointer to the counter of this leaf (if any) or store the number of elements that the leaf c...Definition TLeaf.cxx:249; TLeaf::GenerateOffsetArrayBaseInt_t * GenerateOffsetArrayBase(Int_t base, Int_t events) constIf the class supports it, generate an offset array base.Definition TLeaf.cxx:188; TLeaf::SetAddressvirtual void SetAddress(void *add=nullptr)Definition TLeaf.h:185; TLeaf::Browsevoid Browse(TBrowser *b) overrideBrowse the content of this leaf.Definition TLeaf.cxx:157; TLeaf::FillBasketvirtual void FillBasket(TBuffer &b)Pack leaf elements in Basket output buf",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:24101,Integrability,message,message,24101,"f TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesInt_t GetEntries() const overrideReturn the number of objects in array (i.e.Definition TObjArray.cxx:523; TObjArray::RemoveTObject * Remove(TObject *obj) overrideRemove object from array.Definition TObjArray.cxx:719; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::GetLastInt_t GetLast() const overrideReturn index of last object in array.Definition TObjArray.cxx:577; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::kZombie@ kZombieobject ctor failedDefinition TObject.h:83; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find leaf..Definition TTree.cxx:4916; int; unsigned int; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:21737,Modifiability,variab,variable,21737,"t_t * GenerateOffsetArrayBase(Int_t base, Int_t events) constIf the class supports it, generate an offset array base.Definition TLeaf.cxx:188; TLeaf::SetAddressvirtual void SetAddress(void *add=nullptr)Definition TLeaf.h:185; TLeaf::Browsevoid Browse(TBrowser *b) overrideBrowse the content of this leaf.Definition TLeaf.cxx:157; TLeaf::FillBasketvirtual void FillBasket(TBuffer &b)Pack leaf elements in Basket output buffer.Definition TLeaf.cxx:180; TLeaf::TLeafTLeaf()Definition TLeaf.cxx:55; TLeaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::fOffsetInt_t fOffsetOffset in ClonesArray object (if one)Definition TLeaf.h:74; TLeaf::GetOffsetHeaderSizevirtual Int_t GetOffsetHeaderSize() constDefinition TLeaf.h:61; TLeaf::fBranchTBranch * fBranch! Pointer to supporting branch (we do not own the branch)Definition TLeaf.h:78; TLeaf::fIsUnsignedbool fIsUnsigned(=true if unsigned, false otherwise)Definition TLeaf.h:76; TLeaf::fLeafCountTLeaf * fLeafCountPointer to Leaf count if variable length (we do not own the counter)Definition TLeaf.h:77; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::SetLeafCountvirtual void SetLeafCount(TLeaf *leaf)Set the leaf count of this leaf.Definition TLeaf.cxx:465; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Classstatic TClass * Class(); TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TN",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:5633,Safety,avoid,avoid,5633," """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; 209 Int_t header = GetOffsetHeaderSize();; 210 Int_t len = 0;; 211 for (Int_t idx = 0, offset = base; idx < events; idx++) {; 212 retval[idx] = offset;; 2",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8cxx_source.html:12366,Usability,clear,clear,12366,"360/// If this branch is a branch count, return the set of collection size for; 361/// the entry range requested; 362/// start: first entry to read and return information about; 363/// len: number of entries to read.; 364const TLeaf::Counts_t *TLeaf::GetLeafCountValues(Long64_t start, Long64_t len); 365{; 366 if (len <= 0 || !IsRange()); 367 return nullptr;; 368 ; 369 if (fLeafCountValues) {; 370 if (fLeafCountValues->fStartEntry == start && len < (Long64_t)fLeafCountValues->fValues.size()); 371 {; 372 return &fLeafCountValues->fValues;; 373 }; 374 if (start >= fLeafCountValues->fStartEntry &&; 375 (start+len) <= (Long64_t)(fLeafCountValues->fStartEntry + fLeafCountValues->fValues.size())); 376 {; 377 auto &values(fLeafCountValues->fValues);; 378 values.erase(values.begin(), values.begin() + start-fLeafCountValues->fStartEntry);; 379 return &values;; 380 }; 381 } else {; 382 fLeafCountValues = new LeafCountValues();; 383 }; 384 ; 385 ; 386 fLeafCountValues->fValues.clear();; 387 fLeafCountValues->fValues.reserve(len);; 388 fLeafCountValues->fStartEntry = start;; 389 ; 390 auto branch = GetBranch();; 391 Long64_t orig_leaf_entry = branch->GetReadEntry();; 392 for (Long64_t idx = 0; idx < len; ++idx) {; 393 branch->GetEntry(start + idx);; 394 auto size = static_cast<Int_t>(GetValue());; 395 fLeafCountValues->fValues.push_back( size );; 396 }; 397 branch->GetEntry(orig_leaf_entry);; 398 return &(fLeafCountValues->fValues);; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// Return the number of effective elements of this leaf, for the current entry.; 403 ; 404Int_t TLeaf::GetLen() const; 405{; 406 if (fLeafCount) {; 407 // -- We are a varying length array.; 408 Int_t len = Int_t(fLeafCount->GetValue());; 409 if (len > fLeafCount->GetMaximum()) {; 410 Error(""GetLen"", ""Leaf counter is greater than maximum! leaf: '%s' len: %d max: %d"", GetName(), len, fLeafCount->GetMaximum());; 411 len = fLeafCount->GetMaximum();; 412 ",MatchSource.WIKI,doc/master/TLeaf_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:18805,Availability,error,error,18805,"af::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDouble_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:179; TLeaf::GetValueHelper< ULong64_t >::Execstatic ULong64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:176; TLeaf::GetValueHelperDefinition TLeaf.h:84; TLeaf::GetValueHelper::Execstatic T Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:85; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:68. treetreeincTLeaf.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:1720,Integrability,depend,depending,1720," //; 18// TLeaf //; 19// //; 20// A TTree object is a list of TBranch. //; 21// A TBranch object is a list of TLeaf. In most cases, the TBranch //; 22// will have one TLeaf. //; 23// A TLeaf describes the branch data types and holds the data. //; 24// //; 25// A few notes about the data held by the leaf. It can contain: //; 26// 1 a single object or primitive (e.g., one float), //; 27// 2 a fixed-number of objects (e.g., each entry has two floats). //; 28// The number of elements per entry is saved in `fLen`. //; 29// 3 a dynamic number of primitives. The number of objects in each //; 30// entry is saved in the `fLeafCount` branch. //; 31// //; 32// Note options (2) and (3) can combined - if fLeafCount says an entry //; 33// has 3 elements and fLen is 2, then there will be 6 objects in that //; 34// entry. //; 35// //; 36// Additionally, `fNdata` is transient and generated on read to //; 37// determine the necessary size of a buffer to hold event data; //; 38// depending on the call-site, it may be sized larger than the number //; 39// of elements //; 40// //; 41//////////////////////////////////////////////////////////////////////////; 42 ; 43 ; 44#include ""TNamed.h""; 45 ; 46#include <vector>; 47 ; 48#ifdef R__LESS_INCLUDES; 49class TBranch;; 50#else; 51#include ""TBranch.h""; 52#endif; 53 ; 54class TClonesArray;; 55class TBrowser;; 56 ; 57class TLeaf : public TNamed {; 58 ; 59private:; 60 ; 61 virtual Int_t GetOffsetHeaderSize() const {return 0;}; 62 ; 63protected:; 64 ; 65 using Counts_t = std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:14198,Integrability,rout,routine,14198," Int_t GetLenType() constDefinition TLeaf.h:133; TLeaf::GetTypedValueT GetTypedValue(Int_t i=0) constDefinition TLeaf.h:144; TLeaf::ReadValuevirtual void ReadValue(std::istream &, Char_t=' ')Definition TLeaf.h:156; TLeaf::GetMaximumvirtual Int_t GetMaximum() constDefinition TLeaf.h:134; TLeaf::IsUnsignedvirtual bool IsUnsigned() constDefinition TLeaf.h:150; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition TLeaf.h:139; TLeaf::~TLeaf~TLeaf() overrideDestructor.Definition TLeaf.cxx:140; TLeaf::GetValueLongDoublevirtual LongDouble_t GetValueLongDouble(Int_t i=0) constDefinition TLeaf.h:143; TLeaf::fLenInt_t fLenNumber of fixed length elements in the leaf's data.Definition TLeaf.h:72; TLeaf::fNdataInt_t fNdata! Number of elements in fAddress data buffer.Definition TLeaf.h:71; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::ResetAddressInt_t ResetAddress(void *add, bool calledFromDestructor=false)Helper routine for TLeafX::SetAddress.Definition TLeaf.cxx:429; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::Exportvirtual void Export(TClonesArray *, Int_t)Definition TLeaf.h:113; TLeaf::GetDeserializeTypevirtual DeserializeType GetDeserializeType() constDefinition TLeaf.h:117; TLeaf::ReadBasketExportvirtual void ReadBasketExport(TBuffer &, TClonesArray *, Int_t)Definition TLeaf.h:153; TLeaf::IncludeRangevirtual bool IncludeRange(TLeaf *)Definition TLeaf.h:146; TLeaf::operator=TLeaf & operator=(const TLeaf &)Assignment operator.Definition TLeaf.cxx:117; TLeaf::GetLeafCountervirtual TLeaf * GetLeafCounter(Int_t &countval) constReturn a pointer to the counter of this leaf (if any) or store the number of elements that the leaf c...Definition TLeaf.cxx:249; TLeaf::DeserializeTypeDeserializeTypeDefinition TLeaf.h:99; TLea",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:18811,Integrability,message,message,18811,"af::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDouble_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:179; TLeaf::GetValueHelper< ULong64_t >::Execstatic ULong64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:176; TLeaf::GetValueHelperDefinition TLeaf.h:84; TLeaf::GetValueHelper::Execstatic T Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:85; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:68. treetreeincTLeaf.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:3012,Modifiability,variab,variable,3012,"= std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement.; 76 bool fIsUnsigned; ///< (=true if unsigned, false otherwise); 77 TLeaf *fLeafCount; ///< Pointer to Leaf count if variable length (we do not own the counter); 78 TBranch *fBranch; ///<! Pointer to supporting branch (we do not own the branch); 79 LeafCountValues *fLeafCountValues; ///<! Cache of collection/array sizes; 80 ; 81 TLeaf(const TLeaf&);; 82 TLeaf& operator=(const TLeaf&);; 83 ; 84 template <typename T> struct GetValueHelper {; 85 static T Exec(const TLeaf *leaf, Int_t i = 0) { return leaf->GetValue(i); }; 86 };; 87 ; 88 Int_t *GenerateOffsetArrayBase(Int_t base, Int_t events) const; // For leaves containing fixed-size objects (no; 89 // polymorphism!), this will generate an appropriate; 90 // offset array.; 91 ; 92 ; 93public:; 94 enum EStatusBits {; 95 kIndirectAddress = BIT(11), ///< Data member is a pointer to an array of basic types.; 96 kNewValue = BIT(12) ///< Set if we own the value buffer and so must delete it ourselves.; 97 };; 98 ; 99 enum class DeserializeType {; 100 kInvalid = 0, // Invalid deserialization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:3553,Modifiability,polymorphi,polymorphism,3553,"= std::vector<Int_t>;; 66 struct LeafCountValues {; 67 Counts_t fValues;; 68 Long64_t fStartEntry{-1}; ///<! entry number of corresponding to element 0 of the vector.; 69 };; 70 ; 71 Int_t fNdata; ///<! Number of elements in fAddress data buffer.; 72 Int_t fLen; ///< Number of fixed length elements in the leaf's data.; 73 Int_t fLenType; ///< Number of bytes for this data type; 74 Int_t fOffset; ///< Offset in ClonesArray object (if one); 75 bool fIsRange; ///< (=true if leaf has a range, false otherwise). This is equivalent to being a 'leafcount'. For a TLeafElement the range information is actually store in the TBranchElement.; 76 bool fIsUnsigned; ///< (=true if unsigned, false otherwise); 77 TLeaf *fLeafCount; ///< Pointer to Leaf count if variable length (we do not own the counter); 78 TBranch *fBranch; ///<! Pointer to supporting branch (we do not own the branch); 79 LeafCountValues *fLeafCountValues; ///<! Cache of collection/array sizes; 80 ; 81 TLeaf(const TLeaf&);; 82 TLeaf& operator=(const TLeaf&);; 83 ; 84 template <typename T> struct GetValueHelper {; 85 static T Exec(const TLeaf *leaf, Int_t i = 0) { return leaf->GetValue(i); }; 86 };; 87 ; 88 Int_t *GenerateOffsetArrayBase(Int_t base, Int_t events) const; // For leaves containing fixed-size objects (no; 89 // polymorphism!), this will generate an appropriate; 90 // offset array.; 91 ; 92 ; 93public:; 94 enum EStatusBits {; 95 kIndirectAddress = BIT(11), ///< Data member is a pointer to an array of basic types.; 96 kNewValue = BIT(12) ///< Set if we own the value buffer and so must delete it ourselves.; 97 };; 98 ; 99 enum class DeserializeType {; 100 kInvalid = 0, // Invalid deserialization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:5073,Modifiability,variab,variable-sized,5073,"lization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104 kZeroCopy, // In-memory and on-disk representation of this object are identical.; 105 };; 106 ; 107 TLeaf();; 108 TLeaf(TBranch *parent, const char *name, const char *type);; 109 ~TLeaf() override;; 110 ; 111 void Browse(TBrowser *b) override;; 112 virtual bool CanGenerateOffsetArray() {return fLeafCount;} // overload and return true if this leaf can generate its own offset array.; 113 virtual void Export(TClonesArray *, Int_t) {}; 114 virtual void FillBasket(TBuffer &b);; 115 virtual Int_t *GenerateOffsetArray(Int_t base, Int_t events) { return GenerateOffsetArrayBase(base, events); }; 116 TBranch *GetBranch() const { return fBranch; }; 117 virtual DeserializeType GetDeserializeType() const { return DeserializeType::kExternal; }; 118 virtual TString GetFullName() const;; 119 /// If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size,; 120 /// return a pointer to the TLeaf that stores such size. Return a nullptr otherwise.; 121 virtual TLeaf *GetLeafCount() const { return fLeafCount; }; 122 virtual TLeaf *GetLeafCounter(Int_t &countval) const;; 123 ; 124 virtual const Counts_t *GetLeafCountValues(Long64_t start, Long64_t len);; 125 ; 126 virtual Int_t GetLen() const;; 127 /// Return the fixed length of this leaf.; 128 /// If the leaf stores a fixed-length array, this is the size of the array.; 129 /// If the leaf stores a non-array or a variable-sized array, this method returns 1.; 130 /// If the leaf stores an array with 2 or more dimensions, this method returns the total number of elements in the; 131 /// dimensions with static length: for example for float[3][2][] it would return 6.; 132 ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:5148,Modifiability,variab,variable,5148,"lization information.; 101 kExternal, // Deserialization of this Leaf requires a separate output buffer, i.e. the on-disk and in-memory representation are likely to be different sizes.; 102 kDestructive = kExternal, // For backward compatibility; 103 kInPlace, // Deserialization can be done directly in the input buffer.; 104 kZeroCopy, // In-memory and on-disk representation of this object are identical.; 105 };; 106 ; 107 TLeaf();; 108 TLeaf(TBranch *parent, const char *name, const char *type);; 109 ~TLeaf() override;; 110 ; 111 void Browse(TBrowser *b) override;; 112 virtual bool CanGenerateOffsetArray() {return fLeafCount;} // overload and return true if this leaf can generate its own offset array.; 113 virtual void Export(TClonesArray *, Int_t) {}; 114 virtual void FillBasket(TBuffer &b);; 115 virtual Int_t *GenerateOffsetArray(Int_t base, Int_t events) { return GenerateOffsetArrayBase(base, events); }; 116 TBranch *GetBranch() const { return fBranch; }; 117 virtual DeserializeType GetDeserializeType() const { return DeserializeType::kExternal; }; 118 virtual TString GetFullName() const;; 119 /// If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size,; 120 /// return a pointer to the TLeaf that stores such size. Return a nullptr otherwise.; 121 virtual TLeaf *GetLeafCount() const { return fLeafCount; }; 122 virtual TLeaf *GetLeafCounter(Int_t &countval) const;; 123 ; 124 virtual const Counts_t *GetLeafCountValues(Long64_t start, Long64_t len);; 125 ; 126 virtual Int_t GetLen() const;; 127 /// Return the fixed length of this leaf.; 128 /// If the leaf stores a fixed-length array, this is the size of the array.; 129 /// If the leaf stores a non-array or a variable-sized array, this method returns 1.; 130 /// If the leaf stores an array with 2 or more dimensions, this method returns the total number of elements in the; 131 /// dimensions with static length: for example for float[3][2][] it would return 6.; 132 ",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:5675,Modifiability,variab,variable-sized,5675,"esArray *, Int_t) {}; 114 virtual void FillBasket(TBuffer &b);; 115 virtual Int_t *GenerateOffsetArray(Int_t base, Int_t events) { return GenerateOffsetArrayBase(base, events); }; 116 TBranch *GetBranch() const { return fBranch; }; 117 virtual DeserializeType GetDeserializeType() const { return DeserializeType::kExternal; }; 118 virtual TString GetFullName() const;; 119 /// If this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has variable size,; 120 /// return a pointer to the TLeaf that stores such size. Return a nullptr otherwise.; 121 virtual TLeaf *GetLeafCount() const { return fLeafCount; }; 122 virtual TLeaf *GetLeafCounter(Int_t &countval) const;; 123 ; 124 virtual const Counts_t *GetLeafCountValues(Long64_t start, Long64_t len);; 125 ; 126 virtual Int_t GetLen() const;; 127 /// Return the fixed length of this leaf.; 128 /// If the leaf stores a fixed-length array, this is the size of the array.; 129 /// If the leaf stores a non-array or a variable-sized array, this method returns 1.; 130 /// If the leaf stores an array with 2 or more dimensions, this method returns the total number of elements in the; 131 /// dimensions with static length: for example for float[3][2][] it would return 6.; 132 virtual Int_t GetLenStatic() const { return fLen; }; 133 virtual Int_t GetLenType() const { return fLenType; }; 134 virtual Int_t GetMaximum() const { return 0; }; 135 virtual Int_t GetMinimum() const { return 0; }; 136 virtual Int_t GetNdata() const { return fNdata; }; 137 virtual Int_t GetOffset() const { return fOffset; }; 138 virtual void *GetValuePointer() const { return nullptr; }; 139 virtual const char *GetTypeName() const { return """"; }; 140 ; 141 virtual Double_t GetValue(Int_t i = 0) const;; 142 virtual Long64_t GetValueLong64(Int_t i = 0) const { return GetValue(i); } // overload only when it matters.; 143 virtual LongDouble_t GetValueLongDouble(Int_t i = 0) const { return GetValue(i); } // overload only when it matter",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:14332,Modifiability,variab,variable-sized,14332,"std::istream &, Char_t=' ')Definition TLeaf.h:156; TLeaf::GetMaximumvirtual Int_t GetMaximum() constDefinition TLeaf.h:134; TLeaf::IsUnsignedvirtual bool IsUnsigned() constDefinition TLeaf.h:150; TLeaf::GetTypeNamevirtual const char * GetTypeName() constDefinition TLeaf.h:139; TLeaf::~TLeaf~TLeaf() overrideDestructor.Definition TLeaf.cxx:140; TLeaf::GetValueLongDoublevirtual LongDouble_t GetValueLongDouble(Int_t i=0) constDefinition TLeaf.h:143; TLeaf::fLenInt_t fLenNumber of fixed length elements in the leaf's data.Definition TLeaf.h:72; TLeaf::fNdataInt_t fNdata! Number of elements in fAddress data buffer.Definition TLeaf.h:71; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; TLeaf::ResetAddressInt_t ResetAddress(void *add, bool calledFromDestructor=false)Helper routine for TLeafX::SetAddress.Definition TLeaf.cxx:429; TLeaf::GetLeafCountvirtual TLeaf * GetLeafCount() constIf this leaf stores a variable-sized array or a multi-dimensional array whose last dimension has vari...Definition TLeaf.h:121; TLeaf::Exportvirtual void Export(TClonesArray *, Int_t)Definition TLeaf.h:113; TLeaf::GetDeserializeTypevirtual DeserializeType GetDeserializeType() constDefinition TLeaf.h:117; TLeaf::ReadBasketExportvirtual void ReadBasketExport(TBuffer &, TClonesArray *, Int_t)Definition TLeaf.h:153; TLeaf::IncludeRangevirtual bool IncludeRange(TLeaf *)Definition TLeaf.h:146; TLeaf::operator=TLeaf & operator=(const TLeaf &)Assignment operator.Definition TLeaf.cxx:117; TLeaf::GetLeafCountervirtual TLeaf * GetLeafCounter(Int_t &countval) constReturn a pointer to the counter of this leaf (if any) or store the number of elements that the leaf c...Definition TLeaf.cxx:249; TLeaf::DeserializeTypeDeserializeTypeDefinition TLeaf.h:99; TLeaf::DeserializeType::kInPlace@ kInPlace; TLeaf::DeserializeType::kZeroCopy@ kZeroCopy; TLeaf::DeserializeType::kExternal@ kExternal; TLeaf::DeserializeType::kDestruc",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLeaf_8h_source.html:16922,Modifiability,variab,variable,16922,"eaf::FillBasketvirtual void FillBasket(TBuffer &b)Pack leaf elements in Basket output buffer.Definition TLeaf.cxx:180; TLeaf::IsOnTerminalBranchvirtual bool IsOnTerminalBranch() constDefinition TLeaf.h:148; TLeaf::TLeafTLeaf()Definition TLeaf.cxx:55; TLeaf::GetBranchTBranch * GetBranch() constDefinition TLeaf.h:116; TLeaf::SetOffsetvirtual void SetOffset(Int_t offset=0)Definition TLeaf.h:164; TLeaf::fOffsetInt_t fOffsetOffset in ClonesArray object (if one)Definition TLeaf.h:74; TLeaf::ReadBasketFastvirtual bool ReadBasketFast(TBuffer &, Long64_t)Definition TLeaf.h:154; TLeaf::GetOffsetHeaderSizevirtual Int_t GetOffsetHeaderSize() constDefinition TLeaf.h:61; TLeaf::GetMinimumvirtual Int_t GetMinimum() constDefinition TLeaf.h:135; TLeaf::fBranchTBranch * fBranch! Pointer to supporting branch (we do not own the branch)Definition TLeaf.h:78; TLeaf::fIsUnsignedbool fIsUnsigned(=true if unsigned, false otherwise)Definition TLeaf.h:76; TLeaf::fLeafCountTLeaf * fLeafCountPointer to Leaf count if variable length (we do not own the counter)Definition TLeaf.h:77; TLeaf::SetBranchvirtual void SetBranch(TBranch *branch)Definition TLeaf.h:161; TLeaf::EStatusBitsEStatusBitsDefinition TLeaf.h:94; TLeaf::kNewValue@ kNewValueSet if we own the value buffer and so must delete it ourselves.Definition TLeaf.h:96; TLeaf::kIndirectAddress@ kIndirectAddressData member is a pointer to an array of basic types.Definition TLeaf.h:95; TLeaf::SetLeafCountvirtual void SetLeafCount(TLeaf *leaf)Set the leaf count of this leaf.Definition TLeaf.cxx:465; TLeaf::SetUnsignedvirtual void SetUnsigned()Definition TLeaf.h:166; TLeaf::GetFullNamevirtual TString GetFullName() constReturn the full name (including the parent's branch names) of the leaf.Definition TLeaf.cxx:224; TLeaf::CanGenerateOffsetArrayvirtual bool CanGenerateOffsetArray()Definition TLeaf.h:112; TLeaf::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetO",MatchSource.WIKI,doc/master/TLeaf_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html
https://root.cern/doc/master/TLegendEntry_8cxx_source.html:1709,Modifiability,inherit,inherits,1709,"15#include ""TVirtualPad.h""; 16#include ""TROOT.h""; 17#include <iostream>; 18 ; 19ClassImp(TLegendEntry);; 20 ; 21/** \class TLegendEntry; 22\ingroup BasicGraphics; 23 ; 24Storage class for one entry of a TLegend.; 25*/; 26 ; 27////////////////////////////////////////////////////////////////////////////////; 28/// TLegendEntry do-nothing default constructor; 29 ; 30TLegendEntry::TLegendEntry(): TAttText(), TAttLine(), TAttFill(), TAttMarker(); 31{; 32 fObject = nullptr;; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// TLegendEntry normal constructor for one entry in a TLegend.; 37///; 38/// obj is the object this entry will represent. If obj has; 39/// line/fill/marker attributes, then the TLegendEntry will display; 40/// these attributes.; 41///; 42/// label is the text that will describe the entry, it is displayed using; 43/// TLatex, so may have a complex format.; 44///; 45/// option may have values; 46/// - L draw line associated w/ TAttLine if obj inherits from TAttLine; 47/// - P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; 48/// - F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; 49/// default is object = ""LPF""; 50 ; 51TLegendEntry::TLegendEntry(const TObject* obj, const char* label, Option_t* option ); 52 :TAttText(0,0,0,0,0), TAttLine(1,1,1), TAttFill(0,0), TAttMarker(1,21,1); 53{; 54 fObject = nullptr;; 55 if ( !label && obj ) fLabel = obj->GetTitle();; 56 else fLabel = label;; 57 fOption = option;; 58 if (obj) SetObject((TObject*)obj);; 59}; 60 ; 61////////////////////////////////////////////////////////////////////////////////; 62/// TLegendEntry copy constructor; 63 ; 64TLegendEntry::TLegendEntry(const TLegendEntry &entry) : TObject(entry), TAttText(entry), TAttLine(entry), TAttFill(entry), TAttMarker(entry); 65{; 66 entry.TLegendEntry::Copy(*this);; 67}; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// TLegendEnt",MatchSource.WIKI,doc/master/TLegendEntry_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegendEntry_8cxx_source.html
https://root.cern/doc/master/TLegendEntry_8cxx_source.html:1787,Modifiability,inherit,inherits,1787,"ptr;; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// TLegendEntry normal constructor for one entry in a TLegend.; 37///; 38/// obj is the object this entry will represent. If obj has; 39/// line/fill/marker attributes, then the TLegendEntry will display; 40/// these attributes.; 41///; 42/// label is the text that will describe the entry, it is displayed using; 43/// TLatex, so may have a complex format.; 44///; 45/// option may have values; 46/// - L draw line associated w/ TAttLine if obj inherits from TAttLine; 47/// - P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; 48/// - F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; 49/// default is object = ""LPF""; 50 ; 51TLegendEntry::TLegendEntry(const TObject* obj, const char* label, Option_t* option ); 52 :TAttText(0,0,0,0,0), TAttLine(1,1,1), TAttFill(0,0), TAttMarker(1,21,1); 53{; 54 fObject = nullptr;; 55 if ( !label && obj ) fLabel = obj->GetTitle();; 56 else fLabel = label;; 57 fOption = option;; 58 if (obj) SetObject((TObject*)obj);; 59}; 60 ; 61////////////////////////////////////////////////////////////////////////////////; 62/// TLegendEntry copy constructor; 63 ; 64TLegendEntry::TLegendEntry(const TLegendEntry &entry) : TObject(entry), TAttText(entry), TAttLine(entry), TAttFill(entry), TAttMarker(entry); 65{; 66 entry.TLegendEntry::Copy(*this);; 67}; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// TLegendEntry default destructor; 71 ; 72TLegendEntry::~TLegendEntry(); 73{; 74 fObject = nullptr;; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// copy this TLegendEntry into obj; 79 ; 80void TLegendEntry::Copy( TObject &obj ) const; 81{; 82 TObject::Copy(obj);; 83 TAttText::Copy((TLegendEntry&)obj);; 84 TAttLine::Copy((TLegendEntry&)obj);; 85 TAttFill::Copy((TLegendEntry&)obj);; 86 TAttMarker::Copy((TLegendEntry&)obj);; ",MatchSource.WIKI,doc/master/TLegendEntry_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegendEntry_8cxx_source.html
https://root.cern/doc/master/TLegendEntry_8cxx_source.html:1874,Modifiability,inherit,inherits,1874,"ptr;; 33}; 34 ; 35////////////////////////////////////////////////////////////////////////////////; 36/// TLegendEntry normal constructor for one entry in a TLegend.; 37///; 38/// obj is the object this entry will represent. If obj has; 39/// line/fill/marker attributes, then the TLegendEntry will display; 40/// these attributes.; 41///; 42/// label is the text that will describe the entry, it is displayed using; 43/// TLatex, so may have a complex format.; 44///; 45/// option may have values; 46/// - L draw line associated w/ TAttLine if obj inherits from TAttLine; 47/// - P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; 48/// - F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; 49/// default is object = ""LPF""; 50 ; 51TLegendEntry::TLegendEntry(const TObject* obj, const char* label, Option_t* option ); 52 :TAttText(0,0,0,0,0), TAttLine(1,1,1), TAttFill(0,0), TAttMarker(1,21,1); 53{; 54 fObject = nullptr;; 55 if ( !label && obj ) fLabel = obj->GetTitle();; 56 else fLabel = label;; 57 fOption = option;; 58 if (obj) SetObject((TObject*)obj);; 59}; 60 ; 61////////////////////////////////////////////////////////////////////////////////; 62/// TLegendEntry copy constructor; 63 ; 64TLegendEntry::TLegendEntry(const TLegendEntry &entry) : TObject(entry), TAttText(entry), TAttLine(entry), TAttFill(entry), TAttMarker(entry); 65{; 66 entry.TLegendEntry::Copy(*this);; 67}; 68 ; 69////////////////////////////////////////////////////////////////////////////////; 70/// TLegendEntry default destructor; 71 ; 72TLegendEntry::~TLegendEntry(); 73{; 74 fObject = nullptr;; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// copy this TLegendEntry into obj; 79 ; 80void TLegendEntry::Copy( TObject &obj ) const; 81{; 82 TObject::Copy(obj);; 83 TAttText::Copy((TLegendEntry&)obj);; 84 TAttLine::Copy((TLegendEntry&)obj);; 85 TAttFill::Copy((TLegendEntry&)obj);; 86 TAttMarker::Copy((TLegendEntry&)obj);; ",MatchSource.WIKI,doc/master/TLegendEntry_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegendEntry_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:3278,Availability,error,error,3278,"H1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp};",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:4999,Availability,error,error,4999,"ttributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the label; 132associated to this object and an option which a combination of:; 133 ; 134 - L: draw line associated with TAttLine if obj inherits from TAttLine; 135 - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 136 - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 137 - E: draw vertical error bar; 138 ; 139As shown in the following example, passing a NULL pointer as first parameter in; 140`AddEntry` is also valid. This allows to add text or blank lines in a; 141legend.; 142 ; 143Begin_Macro(source); 144{; 145 auto c2 = new TCanvas(""c2"",""c2"",500,300);; 146 ; 147 auto* legend = new TLegend(0.2, 0.2, .8, .8);; 148 auto h = new TH1F("""", """", 1, 0, 1);; 149 ; 150 legend->AddEntry(h, ""Histogram \""h\"""", ""l"");; 151 legend->AddEntry((TObject*)0, """", """");; 152 legend->AddEntry((TObject*)0, ""Some text"", """");; 153 legend->AddEntry((TObject*)0, """", """");; 154 legend->AddEntry(h, ""Histogram \""h\"" again"", ""l"");; 155 ; 156 legend->Draw();; 157}; 158End_Macro; 159 ; 160It is possible to draw the legend entries over several columns using; 161the method `SetNColumns()` like in the following example.; 162 ; 163Begin_Macro(source); 164{; 165 auto c",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:11431,Availability,error,error,11431,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:12511,Availability,error,error,12511,"const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 342 ; 343TLegendEntry *TLegend::AddEntry(const char *name, const char *label, Option_t *option); 344{; 345 if (!gPad) {; 346 Error(""AddEntry"", ""need to create a canvas first"");; 347 return nullptr;; 348 }; 349 ; 350 TObject *obj = gPad->FindObject(name);; 351 ; 352 // If the object ""name"" has not been found, the following code tries to; 353 // find it in TMultiGraph or THStack possibly present in the current pad.; 354 if (!obj) {; 355 TList *lop = gPad->GetListOfPrimitives();; 356 if (lop) {; 357 TIter next(lop);; 358 while(auto o = next()) {; 359 if ( o->InheritsFrom(TMultiGraph::Class() ) ) {; 360 TList * grlist = ((TMultiGraph *)o)->GetListOfGraphs();; 361 obj = grlist->FindObject(name);; 362 if (obj) break;; 363 }; 364 if ( o->InheritsFrom(THStack::Class() ) ) {; 365 TList * hlist = ((THStack *)o)->GetHists();; 366 obj = hlist->FindObject(name);; 367 if (obj) break;; 368 }; 369 }; 370 }; 371 }; 372 ; 373 return AddEntry( obj, label, option );; 374}; 375 ; 376/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:28500,Availability,error,error,28500," ""centered"" is treated in a special way; 778 // to ensure a better spacing between lines.; 779 if (valign == 2) {; 780 Float_t tsizepad = textsize;; 781 if (tfont%10 == 3) tsizepad = (gPad->AbsPixeltoY(0) - gPad->AbsPixeltoY(textsize))/(gPad->GetY2() - gPad->GetY1());; 782 if (yspace2 < tsizepad) {; 783 entry->SetTextAlign(10*halign+1);; 784 y = ytext - (1. - fEntrySeparation)* yspace2/2.;; 785 } else {; 786 y = ytext;; 787 }; 788 }; 789 ; 790 TLatex entrytex( x, y, entry->GetLabel() );; 791 entrytex.SetNDC();; 792 entry->TAttText::Copy(entrytex);; 793 entrytex.Paint();; 794 ; 795 // reset attributes back to their original values; 796 entry->SetTextAlign(talign);; 797 entry->SetTextAngle(tangle);; 798 entry->SetTextColor(tcolor);; 799 entry->SetTextFont(tfont);; 800 entry->SetTextSize(tsize);; 801 ; 802 // define x,y as the center of the symbol for this entry; 803 Double_t xsym = x1 + margin/2.;; 804 Double_t ysym = ytext;; 805 ; 806 TObject *eobj = entry->GetObject();; 807 ; 808 // depending on the object drawing option, the endcaps for error; 809 // bar are drawn differently.; 810 Int_t endcaps = 0; // no endcaps.; 811 if (eobj) { // eobj == nullptr for the legend header; 812 TString eobjopt = eobj->GetDrawOption();; 813 eobjopt.ToLower();; 814 if (eobjopt.Contains(""e1"") && eobj->InheritsFrom(TH1::Class())) endcaps = 1; // a bar; 815 if (eobj->InheritsFrom(TGraph::Class())) {; 816 endcaps = 1; // a bar, default for TGraph; 817 if (eobjopt.Contains(""z"")) endcaps = 0; // no endcaps.; 818 if (eobjopt.Contains("">"")) endcaps = 2; // empty arrow.; 819 if (eobjopt.Contains(""|>"")) endcaps = 3; // filled arrow.; 820 }; 821 }; 822 float arrow_shift = 0.3;; 823 if (endcaps == 3) arrow_shift = 0.2;; 824 // Draw fill pattern (in a box); 825 ; 826 if ( opt.Contains(""f"")) {; 827 if (eobj && eobj->InheritsFrom(TAttFill::Class())) {; 828 dynamic_cast<TAttFill*>(eobj)->Copy(*entry);; 829 }; 830 ; 831 // Case of exclusion graphs; 832 Float_t wl = 1., wu = 1.;; 833 if (eobj && eobj->I",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:34610,Availability,error,error,34610," - boxw, ysym - yspace*0.35,; 951 xsym + boxw, ysym - yspace*0.35);; 952 entryline.PaintLineNDC( xsym + boxw, ysym - yspace*0.35,; 953 xsym + boxw, ysym + yspace*0.35);; 954 entryline.PaintLineNDC( xsym - boxw, ysym - yspace*0.35,; 955 xsym - boxw, ysym + yspace*0.35);; 956 } else {; 957 entryline.Paint();; 958 if (opt.Contains(""e"")) {; 959 if ( !opt.Contains(""p"")) {; 960 entryline.PaintLineNDC( xsym, ysym - yspace*arrow_shift,; 961 xsym, ysym + yspace*arrow_shift);; 962 } else {; 963 Double_t sy = (fY2NDC-fY1NDC)*((0.5*(gPad->PixeltoY(0) - gPad->PixeltoY(Int_t(symbolsize*8.))))/(fY2-fY1));; 964 TLine entryline1(xsym, ysym + sy, xsym, ysym + yspace*arrow_shift);; 965 entryline1.SetBit(TLine::kLineNDC);; 966 entry->TAttLine::Copy(entryline1);; 967 entryline1.Paint();; 968 TLine entryline2(xsym, ysym - sy, xsym, ysym - yspace*arrow_shift);; 969 entryline2.SetBit(TLine::kLineNDC);; 970 entry->TAttLine::Copy(entryline2);; 971 entryline2.Paint();; 972 }; 973 DrawEndCaps();; 974 }; 975 }; 976 }; 977 ; 978 // Draw error only; 979 ; 980 if (opt.Contains(""e"") && !(opt.Contains(""l"") || opt.Contains(""f""))) {; 981 if (eobj && eobj->InheritsFrom(TAttLine::Class())) {; 982 dynamic_cast<TAttLine*>(eobj)->Copy(*entry);; 983 }; 984 if ( !opt.Contains(""p"")) {; 985 TLine entryline(xsym, ysym - yspace*arrow_shift,; 986 xsym, ysym + yspace*arrow_shift);; 987 entryline.SetBit(TLine::kLineNDC);; 988 entry->TAttLine::Copy(entryline);; 989 entryline.Paint();; 990 } else {; 991 Double_t sy = (fY2NDC-fY1NDC)*((0.5*(gPad->PixeltoY(0) - gPad->PixeltoY(Int_t(symbolsize*8.))))/(fY2-fY1));; 992 TLine entryline1(xsym, ysym + sy, xsym, ysym + yspace*arrow_shift);; 993 entryline1.SetBit(TLine::kLineNDC);; 994 entry->TAttLine::Copy(entryline1);; 995 entryline1.Paint();; 996 TLine entryline2(xsym, ysym - sy, xsym, ysym - yspace*arrow_shift);; 997 entryline2.SetBit(TLine::kLineNDC);; 998 entry->TAttLine::Copy(entryline2);; 999 entryline2.Paint();; 1000 }; 1001 DrawEndCaps();; 1002 }; 1003 ; 1004 // Draw",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:54089,Availability,error,error,54089,"lass * Class(); TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPave::Printvoid Print(Option_t *option="""") const overrideDump this pave with its attributes.Definition TPave.cxx:616; TPave::GetY2NDCDouble_t GetY2NDC() constDefinition TPave.h:62; TPave::GetBorderSizeInt_t GetBorderSize() constDefinition TPave.h:54; TPave::ConvertNDCtoPadvirtual void ConvertNDCtoPad()Convert pave coordinates from NDC to Pad coordinates.Definition TPave.cxx:139; TPave::GetX2NDCDouble_t GetX2NDC() constDefinition TPave.h:60; TPave::Copyvoid Copy(TObject &pave) const overrideCopy this pave to pave.Definition TPave.cxx:186; TPave::fBorderSizeInt_t fBorderSizewindow box bordersize in pixelsDefinition TPave.h:26; TPave::fX2NDCDouble_t fX2NDCX2 point in NDC coordinates.Definition TPave.h:24; TPave::GetY1NDCDouble_t GetY1NDC() constDefinition TPave.h:61; TPav",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:48484,Energy Efficiency,allocate,allocated,48484,"ryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::SetNColumnsvoid SetNColumns(Int_t nColumns)Set the number of columns for the legend.Definition TLegend.cxx:606; TLegend::Drawvoid Draw(Option_t *option="""") overrideDraw this legend with its current attributes.Definition TLegend.cxx:425; TLegend::SetHeadervirtual void SetHeader(const char *header="""", Option_t *option="""")Sets the header, which is the ""title"" that appears at the top of the legend.Definition TLegend.cxx:1085; TLegend::DeleteEntryvirtual void DeleteEntry()Delete entry at the mouse position.Definition TLegend.cxx:413; TLegend::GetEntryTLegendEntry * GetEntry() constGet entry pointed to by the mouse.Definition TLegend.cxx:478; TLegend::Clearvoid Clear(Option_t *option="""") overrideClear all entries in this legend, including the header.Definition TLegend.cxx:379; TLegend::fEntrySeparationFloat_t fEntrySeparationSeparation between entries, as a fraction of The space allocated to one entry.Definition TLegend.h:74; TLegend::EditEntryAttMarkervirtual void EditEntryAttMarker()Edit the marker attributes for the entry pointed by the mouse.Definition TLegend.cxx:455; TLegend::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave this legend as C++ statements on output stream out to be used with the SaveAs ....Definition TLegend.cxx:1035; TLegend::EditEntryAttTextvirtual void EditEntryAttText()Edit the text attributes for the entry pointed by the mouse.Definition TLegend.cxx:466; TLegend::Paintvoid Paint(Option_t *option="""") overridePaint this legend with its current attributes.Definition TLegend.cxx:561; TLegend::GetNColumnsInt_t GetNColumns() constDefinition TLegend.h:52; TLegend::SetDefaultsvoid SetDefaults()Definition TLegend.h:61; TLegend::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideReset the legend entries pointing to ""obj"".Definition TLegend.cxx:1022; TLegend:",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:28444,Integrability,depend,depending,28444," ""centered"" is treated in a special way; 778 // to ensure a better spacing between lines.; 779 if (valign == 2) {; 780 Float_t tsizepad = textsize;; 781 if (tfont%10 == 3) tsizepad = (gPad->AbsPixeltoY(0) - gPad->AbsPixeltoY(textsize))/(gPad->GetY2() - gPad->GetY1());; 782 if (yspace2 < tsizepad) {; 783 entry->SetTextAlign(10*halign+1);; 784 y = ytext - (1. - fEntrySeparation)* yspace2/2.;; 785 } else {; 786 y = ytext;; 787 }; 788 }; 789 ; 790 TLatex entrytex( x, y, entry->GetLabel() );; 791 entrytex.SetNDC();; 792 entry->TAttText::Copy(entrytex);; 793 entrytex.Paint();; 794 ; 795 // reset attributes back to their original values; 796 entry->SetTextAlign(talign);; 797 entry->SetTextAngle(tangle);; 798 entry->SetTextColor(tcolor);; 799 entry->SetTextFont(tfont);; 800 entry->SetTextSize(tsize);; 801 ; 802 // define x,y as the center of the symbol for this entry; 803 Double_t xsym = x1 + margin/2.;; 804 Double_t ysym = ytext;; 805 ; 806 TObject *eobj = entry->GetObject();; 807 ; 808 // depending on the object drawing option, the endcaps for error; 809 // bar are drawn differently.; 810 Int_t endcaps = 0; // no endcaps.; 811 if (eobj) { // eobj == nullptr for the legend header; 812 TString eobjopt = eobj->GetDrawOption();; 813 eobjopt.ToLower();; 814 if (eobjopt.Contains(""e1"") && eobj->InheritsFrom(TH1::Class())) endcaps = 1; // a bar; 815 if (eobj->InheritsFrom(TGraph::Class())) {; 816 endcaps = 1; // a bar, default for TGraph; 817 if (eobjopt.Contains(""z"")) endcaps = 0; // no endcaps.; 818 if (eobjopt.Contains("">"")) endcaps = 2; // empty arrow.; 819 if (eobjopt.Contains(""|>"")) endcaps = 3; // filled arrow.; 820 }; 821 }; 822 float arrow_shift = 0.3;; 823 if (endcaps == 3) arrow_shift = 0.2;; 824 // Draw fill pattern (in a box); 825 ; 826 if ( opt.Contains(""f"")) {; 827 if (eobj && eobj->InheritsFrom(TAttFill::Class())) {; 828 dynamic_cast<TAttFill*>(eobj)->Copy(*entry);; 829 }; 830 ; 831 // Case of exclusion graphs; 832 Float_t wl = 1., wu = 1.;; 833 if (eobj && eobj->I",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:53413,Integrability,message,message,53413,"oid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TList::AddFirstvoid AddFirst(TObject *obj) overrideAdd object at the beginning of the list.Definition TList.cxx:98; TMarkerManages Markers.Definition TMarker.h:22; TMarker::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TMarker.cxx:368; TMarker::Paintvoid Paint(Option_t *option="""") overridePaint this marker with its current attributes.Definition TMarker.cxx:308; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TMultiGraph::Classstatic TClass * Class(); TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPave::Printvoid Print(Option_t *option="""") const overrideDump this pave with its attributes.Defi",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:54095,Integrability,message,message,54095,"lass * Class(); TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPave::Printvoid Print(Option_t *option="""") const overrideDump this pave with its attributes.Definition TPave.cxx:616; TPave::GetY2NDCDouble_t GetY2NDC() constDefinition TPave.h:62; TPave::GetBorderSizeInt_t GetBorderSize() constDefinition TPave.h:54; TPave::ConvertNDCtoPadvirtual void ConvertNDCtoPad()Convert pave coordinates from NDC to Pad coordinates.Definition TPave.cxx:139; TPave::GetX2NDCDouble_t GetX2NDC() constDefinition TPave.h:60; TPave::Copyvoid Copy(TObject &pave) const overrideCopy this pave to pave.Definition TPave.cxx:186; TPave::fBorderSizeInt_t fBorderSizewindow box bordersize in pixelsDefinition TPave.h:26; TPave::fX2NDCDouble_t fX2NDCX2 point in NDC coordinates.Definition TPave.h:24; TPave::GetY1NDCDouble_t GetY1NDC() constDefinition TPave.h:61; TPav",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:3359,Modifiability,inherit,inherits,3359,"H1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp};",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:4787,Modifiability,inherit,inherits,4787,"ttributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the label; 132associated to this object and an option which a combination of:; 133 ; 134 - L: draw line associated with TAttLine if obj inherits from TAttLine; 135 - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 136 - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 137 - E: draw vertical error bar; 138 ; 139As shown in the following example, passing a NULL pointer as first parameter in; 140`AddEntry` is also valid. This allows to add text or blank lines in a; 141legend.; 142 ; 143Begin_Macro(source); 144{; 145 auto c2 = new TCanvas(""c2"",""c2"",500,300);; 146 ; 147 auto* legend = new TLegend(0.2, 0.2, .8, .8);; 148 auto h = new TH1F("""", """", 1, 0, 1);; 149 ; 150 legend->AddEntry(h, ""Histogram \""h\"""", ""l"");; 151 legend->AddEntry((TObject*)0, """", """");; 152 legend->AddEntry((TObject*)0, ""Some text"", """");; 153 legend->AddEntry((TObject*)0, """", """");; 154 legend->AddEntry(h, ""Histogram \""h\"" again"", ""l"");; 155 ; 156 legend->Draw();; 157}; 158End_Macro; 159 ; 160It is possible to draw the legend entries over several columns using; 161the method `SetNColumns()` like in the following example.; 162 ; 163Begin_Macro(source); 164{; 165 auto c",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:4870,Modifiability,inherit,inherits,4870,"ttributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the label; 132associated to this object and an option which a combination of:; 133 ; 134 - L: draw line associated with TAttLine if obj inherits from TAttLine; 135 - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 136 - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 137 - E: draw vertical error bar; 138 ; 139As shown in the following example, passing a NULL pointer as first parameter in; 140`AddEntry` is also valid. This allows to add text or blank lines in a; 141legend.; 142 ; 143Begin_Macro(source); 144{; 145 auto c2 = new TCanvas(""c2"",""c2"",500,300);; 146 ; 147 auto* legend = new TLegend(0.2, 0.2, .8, .8);; 148 auto h = new TH1F("""", """", 1, 0, 1);; 149 ; 150 legend->AddEntry(h, ""Histogram \""h\"""", ""l"");; 151 legend->AddEntry((TObject*)0, """", """");; 152 legend->AddEntry((TObject*)0, ""Some text"", """");; 153 legend->AddEntry((TObject*)0, """", """");; 154 legend->AddEntry(h, ""Histogram \""h\"" again"", ""l"");; 155 ; 156 legend->Draw();; 157}; 158End_Macro; 159 ; 160It is possible to draw the legend entries over several columns using; 161the method `SetNColumns()` like in the following example.; 162 ; 163Begin_Macro(source); 164{; 165 auto c",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:4957,Modifiability,inherit,inherits,4957,"ttributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the label; 132associated to this object and an option which a combination of:; 133 ; 134 - L: draw line associated with TAttLine if obj inherits from TAttLine; 135 - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 136 - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 137 - E: draw vertical error bar; 138 ; 139As shown in the following example, passing a NULL pointer as first parameter in; 140`AddEntry` is also valid. This allows to add text or blank lines in a; 141legend.; 142 ; 143Begin_Macro(source); 144{; 145 auto c2 = new TCanvas(""c2"",""c2"",500,300);; 146 ; 147 auto* legend = new TLegend(0.2, 0.2, .8, .8);; 148 auto h = new TH1F("""", """", 1, 0, 1);; 149 ; 150 legend->AddEntry(h, ""Histogram \""h\"""", ""l"");; 151 legend->AddEntry((TObject*)0, """", """");; 152 legend->AddEntry((TObject*)0, ""Some text"", """");; 153 legend->AddEntry((TObject*)0, """", """");; 154 legend->AddEntry(h, ""Histogram \""h\"" again"", ""l"");; 155 ; 156 legend->Draw();; 157}; 158End_Macro; 159 ; 160It is possible to draw the legend entries over several columns using; 161the method `SetNColumns()` like in the following example.; 162 ; 163Begin_Macro(source); 164{; 165 auto c",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:11210,Modifiability,inherit,inherits,11210,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:11296,Modifiability,inherit,inherits,11296,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:11386,Modifiability,inherit,inherits,11386,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:12290,Modifiability,inherit,inherits,12290,"const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 342 ; 343TLegendEntry *TLegend::AddEntry(const char *name, const char *label, Option_t *option); 344{; 345 if (!gPad) {; 346 Error(""AddEntry"", ""need to create a canvas first"");; 347 return nullptr;; 348 }; 349 ; 350 TObject *obj = gPad->FindObject(name);; 351 ; 352 // If the object ""name"" has not been found, the following code tries to; 353 // find it in TMultiGraph or THStack possibly present in the current pad.; 354 if (!obj) {; 355 TList *lop = gPad->GetListOfPrimitives();; 356 if (lop) {; 357 TIter next(lop);; 358 while(auto o = next()) {; 359 if ( o->InheritsFrom(TMultiGraph::Class() ) ) {; 360 TList * grlist = ((TMultiGraph *)o)->GetListOfGraphs();; 361 obj = grlist->FindObject(name);; 362 if (obj) break;; 363 }; 364 if ( o->InheritsFrom(THStack::Class() ) ) {; 365 TList * hlist = ((THStack *)o)->GetHists();; 366 obj = hlist->FindObject(name);; 367 if (obj) break;; 368 }; 369 }; 370 }; 371 }; 372 ; 373 return AddEntry( obj, label, option );; 374}; 375 ; 376/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:12376,Modifiability,inherit,inherits,12376,"const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 342 ; 343TLegendEntry *TLegend::AddEntry(const char *name, const char *label, Option_t *option); 344{; 345 if (!gPad) {; 346 Error(""AddEntry"", ""need to create a canvas first"");; 347 return nullptr;; 348 }; 349 ; 350 TObject *obj = gPad->FindObject(name);; 351 ; 352 // If the object ""name"" has not been found, the following code tries to; 353 // find it in TMultiGraph or THStack possibly present in the current pad.; 354 if (!obj) {; 355 TList *lop = gPad->GetListOfPrimitives();; 356 if (lop) {; 357 TIter next(lop);; 358 while(auto o = next()) {; 359 if ( o->InheritsFrom(TMultiGraph::Class() ) ) {; 360 TList * grlist = ((TMultiGraph *)o)->GetListOfGraphs();; 361 obj = grlist->FindObject(name);; 362 if (obj) break;; 363 }; 364 if ( o->InheritsFrom(THStack::Class() ) ) {; 365 TList * hlist = ((THStack *)o)->GetHists();; 366 obj = hlist->FindObject(name);; 367 if (obj) break;; 368 }; 369 }; 370 }; 371 }; 372 ; 373 return AddEntry( obj, label, option );; 374}; 375 ; 376/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:12466,Modifiability,inherit,inherits,12466,"const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 342 ; 343TLegendEntry *TLegend::AddEntry(const char *name, const char *label, Option_t *option); 344{; 345 if (!gPad) {; 346 Error(""AddEntry"", ""need to create a canvas first"");; 347 return nullptr;; 348 }; 349 ; 350 TObject *obj = gPad->FindObject(name);; 351 ; 352 // If the object ""name"" has not been found, the following code tries to; 353 // find it in TMultiGraph or THStack possibly present in the current pad.; 354 if (!obj) {; 355 TList *lop = gPad->GetListOfPrimitives();; 356 if (lop) {; 357 TIter next(lop);; 358 while(auto o = next()) {; 359 if ( o->InheritsFrom(TMultiGraph::Class() ) ) {; 360 TList * grlist = ((TMultiGraph *)o)->GetListOfGraphs();; 361 obj = grlist->FindObject(name);; 362 if (obj) break;; 363 }; 364 if ( o->InheritsFrom(THStack::Class() ) ) {; 365 TList * hlist = ((THStack *)o)->GetHists();; 366 obj = hlist->FindObject(name);; 367 if (obj) break;; 368 }; 369 }; 370 }; 371 }; 372 ; 373 return AddEntry( obj, label, option );; 374}; 375 ; 376/////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:24310,Modifiability,variab,variables,24310," {; 669 if ( entrytex.GetXsize() > maxentrywidth ) {; 670 maxentrywidth = entrytex.GetXsize();; 671 }; 672 } else {; 673 if ( entrytex.GetXsize() > columnWidths[iColumn] ) {; 674 columnWidths[iColumn] = entrytex.GetXsize();; 675 }; 676 iColumn++;; 677 iColumn %= fNColumns;; 678 }; 679 Double_t tmpMaxWidth = 0.0;; 680 for(int i=0; i<fNColumns; i++) tmpMaxWidth += columnWidths[i];; 681 if ( tmpMaxWidth > maxentrywidth) maxentrywidth = tmpMaxWidth;; 682 }; 683 // make sure all labels fit in the allotted space; 684 Double_t tmpsize_h = maxentryheight /(gPad->GetY2() - gPad->GetY1());; 685 textsize = TMath::Min( textsize, tmpsize_h );; 686 Double_t tmpsize_w = textsize*(fX2-fX1)*(1.0-fMargin)/maxentrywidth;; 687 if(fNColumns > 1) tmpsize_w = textsize*(fX2-fX1)*(1.0-fMargin-fColumnSeparation)/maxentrywidth;; 688 textsize = TMath::Min( textsize, tmpsize_w );; 689 SetTextSize( textsize );; 690 }; 691 ; 692 // Update column widths, put into NDC units; 693 // block off this section of code to make sure all variables are local:; 694 // don't want to ruin initialisation of these variables later on; 695 {; 696 TIter next(fPrimitives);; 697 Int_t iColumn = 0;; 698 for (Int_t k = 0; k < fNColumns; ++k); 699 columnWidths[k] = 0.;; 700 while (auto entry = (TLegendEntry *)next()) {; 701 TLatex entrytex( 0, 0, entry->GetLabel() );; 702 entrytex.SetNDC();; 703 Style_t tfont = entry->GetTextFont();; 704 if (tfont == 0) tfont = GetTextFont();; 705 if (autosize && tfont%10 == 3) --tfont;; 706 entrytex.SetTextFont(tfont);; 707 if(entry->GetTextSize() == 0) entrytex.SetTextSize(textsize);; 708 TString opt = entry->GetOption();; 709 opt.ToLower();; 710 if (!opt.Contains(""h"")) {; 711 if ( entrytex.GetXsize() > columnWidths[iColumn] ) {; 712 columnWidths[iColumn] = entrytex.GetXsize();; 713 }; 714 iColumn++;; 715 iColumn %= fNColumns;; 716 }; 717 }; 718 double totalWidth = 0.0;; 719 for(int i=0; i<fNColumns; i++) totalWidth += columnWidths[i];; 720 if(fNColumns > 1) totalWidth /= (1.0-fMargin-f",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:24382,Modifiability,variab,variables,24382," {; 669 if ( entrytex.GetXsize() > maxentrywidth ) {; 670 maxentrywidth = entrytex.GetXsize();; 671 }; 672 } else {; 673 if ( entrytex.GetXsize() > columnWidths[iColumn] ) {; 674 columnWidths[iColumn] = entrytex.GetXsize();; 675 }; 676 iColumn++;; 677 iColumn %= fNColumns;; 678 }; 679 Double_t tmpMaxWidth = 0.0;; 680 for(int i=0; i<fNColumns; i++) tmpMaxWidth += columnWidths[i];; 681 if ( tmpMaxWidth > maxentrywidth) maxentrywidth = tmpMaxWidth;; 682 }; 683 // make sure all labels fit in the allotted space; 684 Double_t tmpsize_h = maxentryheight /(gPad->GetY2() - gPad->GetY1());; 685 textsize = TMath::Min( textsize, tmpsize_h );; 686 Double_t tmpsize_w = textsize*(fX2-fX1)*(1.0-fMargin)/maxentrywidth;; 687 if(fNColumns > 1) tmpsize_w = textsize*(fX2-fX1)*(1.0-fMargin-fColumnSeparation)/maxentrywidth;; 688 textsize = TMath::Min( textsize, tmpsize_w );; 689 SetTextSize( textsize );; 690 }; 691 ; 692 // Update column widths, put into NDC units; 693 // block off this section of code to make sure all variables are local:; 694 // don't want to ruin initialisation of these variables later on; 695 {; 696 TIter next(fPrimitives);; 697 Int_t iColumn = 0;; 698 for (Int_t k = 0; k < fNColumns; ++k); 699 columnWidths[k] = 0.;; 700 while (auto entry = (TLegendEntry *)next()) {; 701 TLatex entrytex( 0, 0, entry->GetLabel() );; 702 entrytex.SetNDC();; 703 Style_t tfont = entry->GetTextFont();; 704 if (tfont == 0) tfont = GetTextFont();; 705 if (autosize && tfont%10 == 3) --tfont;; 706 entrytex.SetTextFont(tfont);; 707 if(entry->GetTextSize() == 0) entrytex.SetTextSize(textsize);; 708 TString opt = entry->GetOption();; 709 opt.ToLower();; 710 if (!opt.Contains(""h"")) {; 711 if ( entrytex.GetXsize() > columnWidths[iColumn] ) {; 712 columnWidths[iColumn] = entrytex.GetXsize();; 713 }; 714 iColumn++;; 715 iColumn %= fNColumns;; 716 }; 717 }; 718 double totalWidth = 0.0;; 719 for(int i=0; i<fNColumns; i++) totalWidth += columnWidths[i];; 720 if(fNColumns > 1) totalWidth /= (1.0-fMargin-f",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:53941,Modifiability,inherit,inherits,53941,"er with its current attributes.Definition TMarker.cxx:308; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TMultiGraph::Classstatic TClass * Class(); TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetDrawOptionvirtual Option_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPave::Printvoid Print(Option_t *option="""") const overrideDump this pave with its attributes.Definition TPave.cxx:616; TPave::GetY2NDCDouble_t GetY2NDC() constDefinition TPave.h:62; TPave::GetBorderSizeInt_t GetBorderSize() constDefinition TPave.h:54; TPave::ConvertNDCtoPadvirtual void ConvertNDCtoPad()Convert pave coordinates from NDC to Pad coordinates.Definition TPave.cxx:139; TPave::GetX2NDCDouble_t GetX2NDC() constDefinition TPave.h:60; TPave::Copyvoid Copy(TObject &pave) const overrideCopy this pave to pave.Definition TPave.cxx:186; TPave::fBorderSizeInt_t fBorderSizewindow box b",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:1855,Performance,perform,performed,1855,"ROOT.h""; 25#include ""TLegendEntry.h""; 26#include ""TMultiGraph.h""; 27#include ""TGraph.h""; 28#include ""TH1.h""; 29#include ""THStack.h""; 30 ; 31ClassImp(TLegend);; 32 ; 33/** \class TLegend; 34\ingroup BasicGraphics; 35 ; 36This class displays a legend box (TPaveText) containing several legend entries.; 37 ; 38Each legend entry is made of a reference to a ROOT object, a text label and an; 39option specifying which graphical attributes (marker/line/fill) should be; 40displayed.; 41 ; 42The following example shows how to create a legend. In this example the legend; 43contains a histogram, a function and a graph. The histogram is put in the legend; 44using its reference pointer whereas the graph and the function are added; 45using their names. Note that, because `TGraph` constructors do not have the; 46`TGraph` name as parameter, the graph name should be specified using the; 47`SetName` method.; 48 ; 49When an object is added by name, a scan is performed on the list of objects; 50contained in the current pad (`gPad`) and also in the possible; 51`TMultiGraph` and `THStack` present in the pad. If a matching; 52name is found, the corresponding object is added in the legend using its pointer.; 53 ; 54Begin_Macro(source); 55{; 56 auto c1 = new TCanvas(""c1"",""c1"",600,500);; 57 gStyle->SetOptStat(0);; 58 ; 59 auto h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; 60 h1->FillRandom(""gaus"",30000);; 61 h1->SetFillColor(kGreen);; 62 h1->SetFillStyle(3003);; 63 h1->Draw();; 64 ; 65 auto f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; 66 f1->SetLineColor(kBlue);; 67 f1->SetLineWidth(4);; 68 f1->Draw(""same"");; 69 ; 70 const Int_t n = 20;; 71 Double_t x[n], y[n], ex[n], ey[n];; 72 for (Int_t i=0;i<n;i++) {; 73 x[i] = i*0.1;; 74 y[i] = 1000*sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMark",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:3686,Usability,simpl,simply,3686,"sin(x[i]+0.2);; 75 x[i] = 17.8*x[i]-8.9;; 76 ex[i] = 1.0;; 77 ey[i] = 10.*i;; 78 }; 79 auto gr = new TGraphErrors(n,x,y,ex,ey);; 80 gr->SetName(""gr"");; 81 gr->SetLineColor(kRed);; 82 gr->SetLineWidth(2);; 83 gr->SetMarkerStyle(21);; 84 gr->SetMarkerSize(1.3);; 85 gr->SetMarkerColor(7);; 86 gr->Draw(""P"");; 87 ; 88 auto legend = new TLegend(0.1,0.7,0.48,0.9);; 89 legend->SetHeader(""The Legend Title"",""C""); // option ""C"" allows to center the header; 90 legend->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 91 legend->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; 92 legend->AddEntry(""gr"",""Graph with error bars"",""lep"");; 93 legend->Draw();; 94}; 95End_Macro; 96 ; 97 ; 98`TLegend` inherits from `TAttText` therefore changing any; 99text attributes (text alignment, font, color...) on a legend will changed the; 100text attributes on each line.; 101 ; 102In particular it can be interesting to change the text alignement that way. In; 103order to have a base-line vertical alignment instead of a centered one simply do:; 104~~~ {.cpp}; 105 legend->SetTextAlign(13);; 106~~~; 107or; 108~~~ {.cpp}; 109 legend->SetTextAlign(11);; 110~~~; 111The default value of some `TLegend` attributes can be changed using; 112`gStyle`. The default settings are:; 113~~~ {.cpp}; 114 SetLegendBorderSize(1);; 115 SetLegendFillColor(0);; 116 SetLegendFont(42);; 117 SetLegendTextSize(0.);; 118~~~; 119The global attributes change the default values for the next created legends.; 120 ; 121Text attributes can be also changed individually on each legend entry:; 122~~~ {.cpp}; 123 TLegendEntry *le = leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; 124 le->SetTextColor(kBlue);; 125~~~; 126 ; 127Note that the `TPad` class has a method to build automatically a legend; 128for all objects in the pad. It is called `TPad::BuildLegend()`.; 129 ; 130Each item in the legend is added using the `AddEntry` method. This; 131method defines the object to be added (by reference or name), the la",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8cxx_source.html:51495,Usability,simpl,simple,51495,"onst TLegend &)Assignment operator.Definition TLegend.cxx:290; TLegend::SetEntryLabelvirtual void SetEntryLabel(const char *label)Edit the label of the entry pointed to by the mouse.Definition TLegend.cxx:1066; TLegend::Printvoid Print(Option_t *option="""") const overrideDump this TLegend and its contents.Definition TLegend.cxx:1013; TLegend::PaintPrimitivesvirtual void PaintPrimitives()Paint the entries (list of primitives) for this legend.Definition TLegend.cxx:618; TLegend::EditEntryAttFillvirtual void EditEntryAttFill()Edit the fill attributes for the entry pointed by the mouse.Definition TLegend.cxx:433; TLegend::GetHeadervirtual const char * GetHeader() constReturns the header, which is the title that appears at the top of the legend.Definition TLegend.cxx:521; TLegend::InsertEntryvirtual void InsertEntry(const char *objectName="""", const char *label="""", Option_t *option=""lpf"")Add a new entry before the entry at the mouse position.Definition TLegend.cxx:536; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::Paintvoid Paint(Option_t *option="""") overridePaint this line with its current attributes.Definition TLine.cxx:389; TLine::PaintLineNDCvirtual void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2)Draw this line with new coordinates in NDC.Definition TLine.cxx:409; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::AddBeforevoid AddBefore(const TObject *before, TObject *obj) overrideInsert object before object before in the list.Definition TList.cxx:194; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the l",MatchSource.WIKI,doc/master/TLegend_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html
https://root.cern/doc/master/TLegend_8h.html:218,Integrability,depend,dependency,218,". ROOT: graf2d/graf/inc/TLegend.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLegend.h File Reference. #include ""TPave.h""; #include ""TAttText.h"". Include dependency graph for TLegend.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  . graf2dgrafincTLegend.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLegend_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8h.html
https://root.cern/doc/master/TLegend_8h_source.html:3474,Energy Efficiency,allocate,allocated,3474,"loat_t GetMargin() const { return fMargin; }; 52 Int_t GetNColumns() const { return fNColumns; }; 53 Int_t GetNRows() const;; 54 virtual void InsertEntry( const char* objectName = """",const char* label = """",; 55 Option_t* option = ""lpf"" ); // *MENU*; 56 void Paint( Option_t* option = """" ) override;; 57 virtual void PaintPrimitives();; 58 void Print( Option_t* option = """" ) const override;; 59 void RecursiveRemove(TObject *obj) override;; 60 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 61 void SetDefaults() { fEntrySeparation = 0.1f; fMargin = 0.25f; fNColumns = 1; fColumnSeparation = 0.0f; }; 62 void SetColumnSeparation( Float_t columnSeparation ); 63 { fColumnSeparation = columnSeparation; } // *MENU*; 64 virtual void SetEntryLabel( const char* label ); // *MENU*; 65 virtual void SetEntryOption( Option_t* option ); // *MENU*; 66 void SetEntrySeparation( Float_t entryseparation ); 67 { fEntrySeparation = entryseparation; } // *MENU*; 68 virtual void SetHeader( const char *header = """", Option_t *option = """" ); // *MENU*; 69 void SetMargin( Float_t margin ) { fMargin = margin; } // *MENU*; 70 void SetNColumns( Int_t nColumns ); // *MENU*; 71 ; 72protected:; 73 TList *fPrimitives{nullptr}; ///< List of TLegendEntries; 74 Float_t fEntrySeparation; ///< Separation between entries, as a fraction of; 75 ///< The space allocated to one entry.; 76 ///< Typical value is 0.1.; 77 Float_t fMargin; ///< Fraction of total width used for symbol; 78 Int_t fNColumns; ///< Number of columns in the legend; 79 Float_t fColumnSeparation; ///< Separation between columns, as a fraction of; 80 ///< The space allowed to one column; 81 ; 82 ClassDefOverride(TLegend,3) // Legend of markers/lines/boxes to represent obj's; 83};; 84 ; 85#endif; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(nam",MatchSource.WIKI,doc/master/TLegend_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8h_source.html
https://root.cern/doc/master/TLegend_8h_source.html:6058,Energy Efficiency,allocate,allocated,6058,"tion TLegend.cxx:388; TLegend::AddEntryTLegendEntry * AddEntry(const TObject *obj, const char *label="""", Option_t *option=""lpf"")Add a new entry to this legend.Definition TLegend.cxx:320; TLegend::SetNColumnsvoid SetNColumns(Int_t nColumns)Set the number of columns for the legend.Definition TLegend.cxx:606; TLegend::SetHeadervirtual void SetHeader(const char *header="""", Option_t *option="""")Sets the header, which is the ""title"" that appears at the top of the legend.Definition TLegend.cxx:1085; TLegend::DeleteEntryvirtual void DeleteEntry()Delete entry at the mouse position.Definition TLegend.cxx:413; TLegend::GetEntryTLegendEntry * GetEntry() constGet entry pointed to by the mouse.Definition TLegend.cxx:478; TLegend::GetColumnSeparationFloat_t GetColumnSeparation() constDefinition TLegend.h:46; TLegend::Clearvoid Clear(Option_t *option="""") overrideClear all entries in this legend, including the header.Definition TLegend.cxx:379; TLegend::fEntrySeparationFloat_t fEntrySeparationSeparation between entries, as a fraction of The space allocated to one entry.Definition TLegend.h:74; TLegend::SetEntrySeparationvoid SetEntrySeparation(Float_t entryseparation)Definition TLegend.h:66; TLegend::EditEntryAttMarkervirtual void EditEntryAttMarker()Edit the marker attributes for the entry pointed by the mouse.Definition TLegend.cxx:455; TLegend::GetListOfPrimitivesTList * GetListOfPrimitives() constDefinition TLegend.h:50; TLegend::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave this legend as C++ statements on output stream out to be used with the SaveAs ....Definition TLegend.cxx:1035; TLegend::EditEntryAttTextvirtual void EditEntryAttText()Edit the text attributes for the entry pointed by the mouse.Definition TLegend.cxx:466; TLegend::Paintvoid Paint(Option_t *option="""") overridePaint this legend with its current attributes.Definition TLegend.cxx:561; TLegend::GetNColumnsInt_t GetNColumns() constDefinition TLegend.h:52; TLegend::SetDefaultsvo",MatchSource.WIKI,doc/master/TLegend_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLegend_8h_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:4149,Deployability,release,released,4149,"1,x2,y2);; 98}; 99 ; 100////////////////////////////////////////////////////////////////////////////////; 101/// Draw this line with new coordinates.; 102 ; 103TLine *TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 104{; 105 TLine *newline = new TLine(x1, y1, x2, y2);; 106 TAttLine::Copy(*newline);; 107 newline->SetBit(kCanDelete);; 108 newline->AppendPad();; 109 return newline;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Draw this line with new coordinates in NDC.; 114 ; 115TLine *TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 116{; 117 TLine *newline = DrawLine(x1, y1, x2, y2);; 118 newline->SetBit(kLineNDC);; 119 return newline;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Execute action corresponding to one event.; 124/// This member function is called when a line is clicked with the locator; 125///; 126/// If Left button clicked on one of the line end points, this point; 127/// follows the cursor until button is released.; 128///; 129/// if Middle button clicked, the line is moved parallel to itself; 130/// until the button is released.; 131 ; 132void TLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 133{; 134 if (!gPad) return;; 135 ; 136 Int_t kMaxDiff = 20;; 137 static Int_t d1,d2,px1,px2,py1,py2;; 138 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 139 static Double_t oldX1, oldY1, oldX2, oldY2;; 140 static Bool_t p1, p2, pL, ndcsav;; 141 Double_t dpx,dpy,xp1,yp1;; 142 Int_t dx, dy;; 143 ; 144 Bool_t opaque = gPad->OpaqueMoving();; 145 ; 146 if (!gPad->IsEditable()) return;; 147 ; 148 switch (event) {; 149 ; 150 case kArrowKeyPress:; 151 case kButton1Down:; 152 oldX1 = GetX1();; 153 oldY1 = GetY1();; 154 oldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes o",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:4266,Deployability,release,released,4266," *TLine::DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 104{; 105 TLine *newline = new TLine(x1, y1, x2, y2);; 106 TAttLine::Copy(*newline);; 107 newline->SetBit(kCanDelete);; 108 newline->AppendPad();; 109 return newline;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Draw this line with new coordinates in NDC.; 114 ; 115TLine *TLine::DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 116{; 117 TLine *newline = DrawLine(x1, y1, x2, y2);; 118 newline->SetBit(kLineNDC);; 119 return newline;; 120}; 121 ; 122////////////////////////////////////////////////////////////////////////////////; 123/// Execute action corresponding to one event.; 124/// This member function is called when a line is clicked with the locator; 125///; 126/// If Left button clicked on one of the line end points, this point; 127/// follows the cursor until button is released.; 128///; 129/// if Middle button clicked, the line is moved parallel to itself; 130/// until the button is released.; 131 ; 132void TLine::ExecuteEvent(Int_t event, Int_t px, Int_t py); 133{; 134 if (!gPad) return;; 135 ; 136 Int_t kMaxDiff = 20;; 137 static Int_t d1,d2,px1,px2,py1,py2;; 138 static Int_t pxold, pyold, px1old, py1old, px2old, py2old;; 139 static Double_t oldX1, oldY1, oldX2, oldY2;; 140 static Bool_t p1, p2, pL, ndcsav;; 141 Double_t dpx,dpy,xp1,yp1;; 142 Int_t dx, dy;; 143 ; 144 Bool_t opaque = gPad->OpaqueMoving();; 145 ; 146 if (!gPad->IsEditable()) return;; 147 ; 148 switch (event) {; 149 ; 150 case kArrowKeyPress:; 151 case kButton1Down:; 152 oldX1 = GetX1();; 153 oldY1 = GetY1();; 154 oldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes only if necessary; 160 }; 161 ; 162 // No break !!!; 163 ; 164 case kMouseMotion:; 165 ; 166 if (TestBit(kLineNDC)) {; 167 px1 = gPad->UtoPixel(GetX1());; 168 py1 = g",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:10882,Deployability,release,released,10882,"tY2() - gPad->GetY1())/(gPad->GetY2()-gPad->GetY1()));; 307 SetNDC();; 308 }; 309 gPad->ShowGuidelines(this, event);; 310 } else {; 311 if (TestBit(kLineNDC)) {; 312 dpx = gPad->GetX2() - gPad->GetX1();; 313 dpy = gPad->GetY2() - gPad->GetY1();; 314 xp1 = gPad->GetX1();; 315 yp1 = gPad->GetY1();; 316 if (p1) {; 317 SetX1((gPad->AbsPixeltoX(px)-xp1)/dpx);; 318 SetY1((gPad->AbsPixeltoY(py)-yp1)/dpy);; 319 }; 320 if (p2) {; 321 SetX2((gPad->AbsPixeltoX(px)-xp1)/dpx);; 322 SetY2((gPad->AbsPixeltoY(py)-yp1)/dpy);; 323 }; 324 if (pL) {; 325 SetX1((gPad->AbsPixeltoX(px1)-xp1)/dpx);; 326 SetY1((gPad->AbsPixeltoY(py1)-yp1)/dpy);; 327 SetX2((gPad->AbsPixeltoX(px2)-xp1)/dpx);; 328 SetY2((gPad->AbsPixeltoY(py2)-yp1)/dpy);; 329 }; 330 } else {; 331 if (p1) {; 332 SetX1(gPad->PadtoX(gPad->AbsPixeltoX(px)));; 333 SetY1(gPad->PadtoY(gPad->AbsPixeltoY(py)));; 334 }; 335 if (p2) {; 336 SetX2(gPad->PadtoX(gPad->AbsPixeltoX(px)));; 337 SetY2(gPad->PadtoY(gPad->AbsPixeltoY(py)));; 338 }; 339 if (pL) {; 340 SetX1(gPad->PadtoX(gPad->AbsPixeltoX(px1)));; 341 SetY1(gPad->PadtoY(gPad->AbsPixeltoY(py1)));; 342 SetX2(gPad->PadtoX(gPad->AbsPixeltoX(px2)));; 343 SetY2(gPad->PadtoY(gPad->AbsPixeltoY(py2)));; 344 }; 345 }; 346 if (TestBit(kVertical)) {; 347 if (p1) SetX2(GetX1());; 348 if (p2) SetX1(GetX2());; 349 }; 350 if (TestBit(kHorizontal)) {; 351 if (p1) SetY2(GetY1());; 352 if (p2) SetY1(GetY2());; 353 }; 354 gPad->Modified(kTRUE);; 355 gPad->Update();; 356 if (!opaque) gVirtualX->SetLineColor(-1);; 357 }; 358 break;; 359 ; 360 case kButton1Locate:; 361 ; 362 ExecuteEvent(kButton1Down, px, py);; 363 while (true) {; 364 px = py = 0;; 365 event = gVirtualX->RequestLocator(1,1,px,py);; 366 ; 367 ExecuteEvent(kButton1Motion, px, py);; 368 ; 369 if (event != -1) { // button is released; 370 ExecuteEvent(kButton1Up, px, py);; 371 return;; 372 }; 373 }; 374 }; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// List this line with its attributes.",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:14434,Modifiability,inherit,inheritance,14434,"45 out<<"" line->Draw();""<<std::endl;; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Check whether this line is to be drawn horizontally.; 450 ; 451Bool_t TLine::IsHorizontal(); 452{; 453 return TestBit(kHorizontal);; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Check whether this line is to be drawn vertically.; 458 ; 459Bool_t TLine::IsVertical(); 460{; 461 return TestBit(kVertical);; 462}; 463 ; 464////////////////////////////////////////////////////////////////////////////////; 465/// Set NDC mode on if isNDC = kTRUE, off otherwise; 466 ; 467void TLine::SetNDC(Bool_t isNDC); 468{; 469 ResetBit(kLineNDC);; 470 if (isNDC) SetBit(kLineNDC);; 471}; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Force the line to be drawn horizontally.; 475/// Makes fY2 equal to fY1. The line length is kept.; 476/// TArrow and TGaxis also get this function by inheritance.; 477 ; 478void TLine::SetHorizontal(Bool_t set /*= kTRUE*/); 479{; 480 SetBit(kHorizontal, set);; 481 if (set && gPad) {; 482 SetVertical(kFALSE);; 483 Int_t px1 = gPad->XtoAbsPixel(fX1);; 484 Int_t px2 = gPad->XtoAbsPixel(fX2);; 485 Int_t py1 = gPad->YtoAbsPixel(fY1);; 486 Int_t py2 = gPad->YtoAbsPixel(fY2);; 487 Int_t l = Int_t(TMath::Sqrt((px2-px1)*(px2-px1)+(py2-py1)*(py2-py1)));; 488 if (fX2 >= fX1) fX2 = gPad->AbsPixeltoX(px1+l);; 489 else fX2 = gPad->AbsPixeltoX(px1-l);; 490 fY2 = fY1;; 491 }; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Force the line to be drawn vertically.; 496/// Makes fX2 equal to fX1. The line length is kept.; 497/// TArrow and TGaxis also get this function by inheritance.; 498 ; 499void TLine::SetVertical(Bool_t set /*= kTRUE*/); 500{; 501 SetBit(kVertical, set);; 502 if (set && gPad) {; 503 SetHorizontal(kFALSE);; 504 Int_t px1 = gPad->XtoAbsPixel(fX1);; 505 Int_t",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:15205,Modifiability,inherit,inheritance,15205,"; 472 ; 473////////////////////////////////////////////////////////////////////////////////; 474/// Force the line to be drawn horizontally.; 475/// Makes fY2 equal to fY1. The line length is kept.; 476/// TArrow and TGaxis also get this function by inheritance.; 477 ; 478void TLine::SetHorizontal(Bool_t set /*= kTRUE*/); 479{; 480 SetBit(kHorizontal, set);; 481 if (set && gPad) {; 482 SetVertical(kFALSE);; 483 Int_t px1 = gPad->XtoAbsPixel(fX1);; 484 Int_t px2 = gPad->XtoAbsPixel(fX2);; 485 Int_t py1 = gPad->YtoAbsPixel(fY1);; 486 Int_t py2 = gPad->YtoAbsPixel(fY2);; 487 Int_t l = Int_t(TMath::Sqrt((px2-px1)*(px2-px1)+(py2-py1)*(py2-py1)));; 488 if (fX2 >= fX1) fX2 = gPad->AbsPixeltoX(px1+l);; 489 else fX2 = gPad->AbsPixeltoX(px1-l);; 490 fY2 = fY1;; 491 }; 492}; 493 ; 494////////////////////////////////////////////////////////////////////////////////; 495/// Force the line to be drawn vertically.; 496/// Makes fX2 equal to fX1. The line length is kept.; 497/// TArrow and TGaxis also get this function by inheritance.; 498 ; 499void TLine::SetVertical(Bool_t set /*= kTRUE*/); 500{; 501 SetBit(kVertical, set);; 502 if (set && gPad) {; 503 SetHorizontal(kFALSE);; 504 Int_t px1 = gPad->XtoAbsPixel(fX1);; 505 Int_t px2 = gPad->XtoAbsPixel(fX2);; 506 Int_t py1 = gPad->YtoAbsPixel(fY1);; 507 Int_t py2 = gPad->YtoAbsPixel(fY2);; 508 Int_t l = Int_t(TMath::Sqrt((px2-px1)*(px2-px1)+(py2-py1)*(py2-py1)));; 509 if (fY2 >= fY1) fY2 = gPad->AbsPixeltoY(py1-l);; 510 else fY2 = gPad->AbsPixeltoY(py1+l);; 511 fX2 = fX1;; 512 }; 513}; 514 ; 515////////////////////////////////////////////////////////////////////////////////; 516/// Stream an object of class TLine.; 517 ; 518void TLine::Streamer(TBuffer &R__b); 519{; 520 if (R__b.IsReading()) {; 521 UInt_t R__s, R__c;; 522 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 523 if (R__v > 1) {; 524 R__b.ReadClassBuffer(TLine::Class(), this, R__v, R__s, R__c);; 525 return;; 526 }; 527 //====process old versions before automatic schema evo",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:975,Usability,simpl,simple,975,". ROOT: graf2d/graf/src/TLine.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TLine.cxx. Go to the documentation of this file. 1// @(#)root/graf:$Id$; 2// Author: Rene Brun 12/12/94; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <cstdlib>; 13 ; 14#include <iostream>; 15#include ""TROOT.h""; 16#include ""TBuffer.h""; 17#include ""TLine.h""; 18#include ""TVirtualPad.h""; 19#include ""TClass.h""; 20#include ""TVirtualX.h""; 21#include ""TMath.h""; 22#include ""TPoint.h""; 23 ; 24ClassImp(TLine);; 25 ; 26/** \class TLine; 27\ingroup BasicGraphics; 28 ; 29Use the TLine constructor to create a simple line.; 30 ; 31~~~ {.cpp}; 32 TLine(Double_t x1,Double_t y1,Double_t x2,Double_t y2); 33~~~; 34 ; 35`x1`, `y1`, `x2`, `y2` are the coordinates of the first and the second point.; 36 ; 37_**Example**_:; 38 ; 39~~~ {.cpp}; 40 root[] l = new TLine(0.2,0.2,0.8,0.3); 41 root[] l->Draw(); 42~~~; 43*/; 44 ; 45 ; 46////////////////////////////////////////////////////////////////////////////////; 47/// Line normal constructor.; 48 ; 49TLine::TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); 50 :TObject(), TAttLine(); 51{; 52 fX1=x1; fY1=y1; fX2=x2; fY2=y2;; 53}; 54 ; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Line copy constructor.; 58 ; 59TLine::TLine(const TLine &line) : TObject(line), TAttLine(line), TAttBBox2D(line); 60{; 61 line.TLine::Copy(*this);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Assignment operator; 66 ; 67TLine &TLine::operator=(const TLine &src); 68{; 69 src.TLine::Copy(*this);;",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:5621,Usability,simpl,simply,5621,",yp1;; 142 Int_t dx, dy;; 143 ; 144 Bool_t opaque = gPad->OpaqueMoving();; 145 ; 146 if (!gPad->IsEditable()) return;; 147 ; 148 switch (event) {; 149 ; 150 case kArrowKeyPress:; 151 case kButton1Down:; 152 oldX1 = GetX1();; 153 oldY1 = GetY1();; 154 oldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes only if necessary; 160 }; 161 ; 162 // No break !!!; 163 ; 164 case kMouseMotion:; 165 ; 166 if (TestBit(kLineNDC)) {; 167 px1 = gPad->UtoPixel(GetX1());; 168 py1 = gPad->VtoPixel(GetY1());; 169 px2 = gPad->UtoPixel(GetX2());; 170 py2 = gPad->VtoPixel(GetY2());; 171 } else {; 172 px1 = gPad->XtoAbsPixel(gPad->XtoPad(GetX1()));; 173 py1 = gPad->YtoAbsPixel(gPad->YtoPad(GetY1()));; 174 px2 = gPad->XtoAbsPixel(gPad->XtoPad(GetX2()));; 175 py2 = gPad->YtoAbsPixel(gPad->YtoPad(GetY2()));; 176 }; 177 p1 = p2 = pL = kFALSE;; 178 ; 179 d1 = abs(px1 - px) + abs(py1-py); //simply take sum of pixels differences; 180 if (d1 < kMaxDiff) { //*-*================>OK take point number 1; 181 px1old = px1; py1old = py1;; 182 p1 = kTRUE;; 183 gPad->SetCursor(kPointer);; 184 return;; 185 }; 186 d2 = abs(px2 - px) + abs(py2-py); //simply take sum of pixels differences; 187 if (d2 < kMaxDiff) { //*-*================>OK take point number 2; 188 px2old = px2; py2old = py2;; 189 p2 = kTRUE;; 190 gPad->SetCursor(kPointer);; 191 return;; 192 }; 193 ; 194 pL = kTRUE;; 195 pxold = px; pyold = py;; 196 gPad->SetCursor(kMove);; 197 ; 198 break;; 199 ; 200 case kArrowKeyRelease:; 201 case kButton1Motion:; 202 ; 203 if (p1) {; 204 if (!opaque) {; 205 gVirtualX->DrawLine(px1old, py1old, px2, py2);; 206 gVirtualX->DrawLine(px, py, px2, py2);; 207 } else {; 208 if (ndcsav) {; 209 SetNDC(kFALSE);; 210 SetX2(gPad->GetX1() + oldX2*(gPad->GetX2()-gPad->GetX1()));; 211 SetY2(gPad->GetY1() + oldY2*(gPad->GetY2()-gPad->GetY1()));; 212 }; 213 SetX1(gPad->AbsPixeltoX(px));; 214 SetY1(gPad->Ab",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:5873,Usability,simpl,simply,5873,"ldX2 = GetX2();; 155 oldY2 = GetY2();; 156 ndcsav = TestBit(kLineNDC);; 157 if (!opaque) {; 158 gVirtualX->SetLineColor(-1);; 159 TAttLine::Modify(); //Change line attributes only if necessary; 160 }; 161 ; 162 // No break !!!; 163 ; 164 case kMouseMotion:; 165 ; 166 if (TestBit(kLineNDC)) {; 167 px1 = gPad->UtoPixel(GetX1());; 168 py1 = gPad->VtoPixel(GetY1());; 169 px2 = gPad->UtoPixel(GetX2());; 170 py2 = gPad->VtoPixel(GetY2());; 171 } else {; 172 px1 = gPad->XtoAbsPixel(gPad->XtoPad(GetX1()));; 173 py1 = gPad->YtoAbsPixel(gPad->YtoPad(GetY1()));; 174 px2 = gPad->XtoAbsPixel(gPad->XtoPad(GetX2()));; 175 py2 = gPad->YtoAbsPixel(gPad->YtoPad(GetY2()));; 176 }; 177 p1 = p2 = pL = kFALSE;; 178 ; 179 d1 = abs(px1 - px) + abs(py1-py); //simply take sum of pixels differences; 180 if (d1 < kMaxDiff) { //*-*================>OK take point number 1; 181 px1old = px1; py1old = py1;; 182 p1 = kTRUE;; 183 gPad->SetCursor(kPointer);; 184 return;; 185 }; 186 d2 = abs(px2 - px) + abs(py2-py); //simply take sum of pixels differences; 187 if (d2 < kMaxDiff) { //*-*================>OK take point number 2; 188 px2old = px2; py2old = py2;; 189 p2 = kTRUE;; 190 gPad->SetCursor(kPointer);; 191 return;; 192 }; 193 ; 194 pL = kTRUE;; 195 pxold = px; pyold = py;; 196 gPad->SetCursor(kMove);; 197 ; 198 break;; 199 ; 200 case kArrowKeyRelease:; 201 case kButton1Motion:; 202 ; 203 if (p1) {; 204 if (!opaque) {; 205 gVirtualX->DrawLine(px1old, py1old, px2, py2);; 206 gVirtualX->DrawLine(px, py, px2, py2);; 207 } else {; 208 if (ndcsav) {; 209 SetNDC(kFALSE);; 210 SetX2(gPad->GetX1() + oldX2*(gPad->GetX2()-gPad->GetX1()));; 211 SetY2(gPad->GetY1() + oldY2*(gPad->GetY2()-gPad->GetY1()));; 212 }; 213 SetX1(gPad->AbsPixeltoX(px));; 214 SetY1(gPad->AbsPixeltoY(py));; 215 }; 216 px1old = px;; 217 py1old = py;; 218 }; 219 if (p2) {; 220 if (!opaque) {; 221 gVirtualX->DrawLine(px1, py1, px2old, py2old);; 222 gVirtualX->DrawLine(px1, py1, px, py);; 223 } else {; 224 if (ndcsav) {; 225 SetNDC(kFALSE);; ",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8cxx_source.html:24776,Usability,simpl,simple,24776,"oid Copy(TAttLine &attline) constCopy this line attributes to a new TAttLine.Definition TAttLine.cxx:177; TAttLine::DistancetoLineInt_t DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2)Compute distance from point px,py to a line.Definition TAttLine.cxx:211; TAttLine::SaveLineAttributesvirtual void SaveLineAttributes(std::ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1)Save line attributes as C++ statement(s) on output stream out.Definition TAttLine.cxx:275; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TBuffer::ReadVersionvirtual Version_t ReadVersion(UInt_t *start=nullptr, UInt_t *bcnt=nullptr, const TClass *cl=nullptr)=0; TBuffer::ReadClassBuffervirtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class=nullptr)=0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::WriteClassBuffervirtual Int_t WriteClassBuffer(const TClass *cl, void *pointer)=0; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::lsvoid ls(Option_t *option="""") const overrideList this line with its attributes.Definition TLine.cxx:380; TLine::SetY2virtual void SetY2(Double_t y2)Definition TLine.h:68; TLine::Classstatic TClass * Class(); TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::SetX2virtual void SetX2(Double_t x2)Definition TLine.h:66; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::kHorizontal@ kHorizontalLine is horizontal.Definition TLine.h:35; TLine::kVertical@ kVerticalLine is vertical.Definition TLine.h:34; TLine::IsVerticalBool_t IsVertical()Check whether this line is to be drawn vertically.Definition TLine.cxx:459; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TLine::SetBBoxY1void SetBB",MatchSource.WIKI,doc/master/TLine_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8cxx_source.html
https://root.cern/doc/master/TLine_8h.html:241,Integrability,depend,dependency,241,". ROOT: graf2d/graf/inc/TLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLine.h File Reference. #include ""TObject.h""; #include ""TAttLine.h""; #include ""TAttBBox2D.h"". Include dependency graph for TLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLine;  Use the TLine constructor to create a simple line. More...;  . graf2dgrafincTLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h.html
https://root.cern/doc/master/TLine_8h.html:576,Usability,simpl,simple,576,". ROOT: graf2d/graf/inc/TLine.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TLine.h File Reference. #include ""TObject.h""; #include ""TAttLine.h""; #include ""TAttBBox2D.h"". Include dependency graph for TLine.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TLine;  Use the TLine constructor to create a simple line. More...;  . graf2dgrafincTLine.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TLine_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h.html
https://root.cern/doc/master/TLine_8h_source.html:4625,Usability,simpl,simple,4625,"ualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; DrawLineOption_t Option_t TPoint TPoint const char DrawLineDefinition TGWin32VirtualXProxy.cxx:70; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TObject.h; TAttBBox2DAbstract base class for elements drawn in the editor.Definition TAttBBox2D.h:19; TAttLineLine Attributes class.Definition TAttLine.h:18; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::lsvoid ls(Option_t *option="""") const overrideList this line with its attributes.Definition TLine.cxx:380; TLine::SetY2virtual void SetY2(Double_t y2)Definition TLine.h:68; TLine::fY1Double_t fY1Y of 1st point.Definition TLine.h:26; TLine::fX1Double_t fX1X of 1st point.Definition TLine.h:25; TLine::SetX2virtual void SetX2(Double_t x2)Definition TLine.h:66; TLine::kLineNDC@ kLineNDCUse NDC coordinates.Definition TLine.h:33; TLine::kHorizontal@ kHorizontalLine is horizontal.Definition TLine.h:35; TLine::kVertical@ kVerticalLine is vertical.Definition TLine.h:34; TLine::IsVerticalBool_t IsVertical()Check whether this line is to be drawn vertically.Definition TLine.cxx:459; TLine::SetBBoxY1void SetBBoxY1(const Int_t y) overrideSet top of BoundingBox to a value (resize in y direction on top)Definition TLine.cxx:667; TLine::SetVerticalvoid SetVertical(Bool_t set=kTRUE)Force the line to be drawn vertically.Definition TLine.cxx:499; TL",MatchSource.WIKI,doc/master/TLine_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TLine_8h_source.html
https://root.cern/doc/master/TList_8cxx_source.html:13230,Availability,avail,available,13230," case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operati",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:15470,Availability,avail,available,15470,"CKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 474 ; 475 TList removeDirectory; // need to deregister these from their directory; 476 ; 477 if (slow) {; 478 ; 479 // In some case, for example TParallelCoord, a list (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform RecursiveRemove of the node currently; 489 // being cleared/deleted.; 490 while (fFirst) {; 491 auto tlk = fFirst;; 492 fFirst = fFirst->fNext;; 493 fSize--;; 494 ; 495 // Make node available to RecursiveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 525 while (first) {; 526 auto tlk = first;; 527 first = first->fNext;; 528 // delete only heap objects; 529 auto obj = tlk->GetObject();; 530 tlk->SetObject(nullptr);; 531 if (ob",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:25564,Availability,alive,alive,25564,".reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 R__COLLECTION_WRITE_GUARD();; 823 ; 824 if (!obj) return nullptr;; 825 ; 826 Int_t idx;; 827 TObjLink *lnk = FindLink(obj, idx);; 828 ; 829 if (!lnk) return nullptr;; 830 ; 831 // return object found, which may be (pointer wise) different than the; 832 // input object (depending on what IsEqual() is doing); 833 ; 834 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 835 ; 836 TObject *ob = lnk->GetObject();; 837 lnk->SetObject(nullptr);; 838 if (lnk == fFirst.get()) {; 839 fFirst = lnk->fNext;; 840 // lnk is still alive as we have either fLast; 841 // or the 'new' fFirst->fPrev pointing to it.; 842 if (lnk == fLast.get()) {; 843 fLast.reset();; 844 fFirst.reset();; 845 } else; 846 fFirst->fPrev.reset();; 847 //DeleteLink(lnk);; 848 } else if (lnk == fLast.get()) {; 849 fLast = lnk->fPrev.lock();; 850 fLast->fNext.reset();; 851 //DeleteLink(lnk);; 852 } else {; 853 lnk->Next()->fPrev = lnk->fPrev;; 854 lnk->Prev()->fNext = lnk->fNext;; 855 //DeleteLink(lnk);; 856 }; 857 fSize--;; 858 fCache.reset();; 859 Changed();; 860 ; 861 return ob;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Remove object link (and therefore the object it contains); 866/// from the list.; 867 ; 868TObject *TList::Remove(TObjLink *lnk); 869{; 870 R__COLLECTION_WRITE_GUARD();; 871 ; 872 if (!lnk) return nullptr;; 873 ; 874 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 875 ; 876 TObject *obj = lnk->GetObject();; 877 lnk->SetObject(nullptr);; 878 if (lnk == fFirst.get()) {; 87",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:26620,Availability,alive,alive,26620,nting to it.; 842 if (lnk == fLast.get()) {; 843 fLast.reset();; 844 fFirst.reset();; 845 } else; 846 fFirst->fPrev.reset();; 847 //DeleteLink(lnk);; 848 } else if (lnk == fLast.get()) {; 849 fLast = lnk->fPrev.lock();; 850 fLast->fNext.reset();; 851 //DeleteLink(lnk);; 852 } else {; 853 lnk->Next()->fPrev = lnk->fPrev;; 854 lnk->Prev()->fNext = lnk->fNext;; 855 //DeleteLink(lnk);; 856 }; 857 fSize--;; 858 fCache.reset();; 859 Changed();; 860 ; 861 return ob;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Remove object link (and therefore the object it contains); 866/// from the list.; 867 ; 868TObject *TList::Remove(TObjLink *lnk); 869{; 870 R__COLLECTION_WRITE_GUARD();; 871 ; 872 if (!lnk) return nullptr;; 873 ; 874 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 875 ; 876 TObject *obj = lnk->GetObject();; 877 lnk->SetObject(nullptr);; 878 if (lnk == fFirst.get()) {; 879 fFirst = lnk->fNext;; 880 // lnk is still alive as we have either fLast; 881 // or the 'new' fFirst->fPrev pointing to it.; 882 if (lnk == fLast.get()) {; 883 fLast.reset();; 884 fFirst.reset();; 885 } else; 886 fFirst->fPrev.reset();; 887 // DeleteLink(lnk);; 888 } else if (lnk == fLast.get()) {; 889 fLast = lnk->fPrev.lock();; 890 fLast->fNext.reset();; 891 // DeleteLink(lnk);; 892 } else {; 893 lnk->Next()->fPrev = lnk->fPrev;; 894 lnk->Prev()->fNext = lnk->fNext;; 895 // DeleteLink(lnk);; 896 }; 897 fSize--;; 898 fCache.reset();; 899 Changed();; 900 ; 901 return obj;; 902}; 903 ; 904////////////////////////////////////////////////////////////////////////////////; 905/// Remove the last object of the list.; 906 ; 907void TList::RemoveLast(); 908{; 909 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 910 R__COLLECTION_WRITE_GUARD();; 911 ; 912 TObjLink *lnk = fLast.get();; 913 if (!lnk) return;; 914 ; 915 lnk->SetObject(nullptr);; 916 if (lnk == fFirst.get()) {; 917 fFirst.reset();; 918 fLast.reset();; 919 } else {; 920 fLast = lnk->fP,MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:46908,Availability,error,error,46908,"evTObjLink * Prev()Definition TList.h:152; TObjLink::GetAddOptionvirtual Option_t * GetAddOption() constDefinition TList.h:148; TObjLink::fObjectTObject * fObjectDefinition TList.h:134; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::fPrevTObjLinkWeakPtr_t fPrevDefinition TList.h:132; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjLink::fNextTObjLinkPtr_t fNextDefinition TList.h:131; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; bool; int; object; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; v@ vDefinition rootcling_impl.cxx:3699; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. corecontsrcTList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:821,Integrability,wrap,wrapped,821,". ROOT: core/cont/src/TList.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:1389,Integrability,wrap,wrapper,1389," * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; 56 TObjLink *lnk = GetListOfPrimitives()->FirstLink();; 57 while (lnk) {; 58 lnk->GetObject()->Draw(lnk->GetOption());; 59 lnk = lnk->Next();; 60 }; 61~~~; 62 6. Using the TList's After() and Before() member functions:; 63~~~ {.cpp}; 64 TFree *idcur = this;; 65 while (idcur) {; 66 ...; 67 ...; 68 idcur = (TFree*)GetListOfFree()->After(idcur);; 69 }; 70~~~; 71Methods 3, 4 and 5 c",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:1966,Integrability,wrap,wrap,1966,"to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; 56 TObjLink *lnk = GetListOfPrimitives()->FirstLink();; 57 while (lnk) {; 58 lnk->GetObject()->Draw(lnk->GetOption());; 59 lnk = lnk->Next();; 60 }; 61~~~; 62 6. Using the TList's After() and Before() member functions:; 63~~~ {.cpp}; 64 TFree *idcur = this;; 65 while (idcur) {; 66 ...; 67 ...; 68 idcur = (TFree*)GetListOfFree()->After(idcur);; 69 }; 70~~~; 71Methods 3, 4 and 5 can also easily iterate backwards using either; 72a backward TIter (using argument kIterBackward) or by using; 73LastLink() and lnk->Prev() or by using the Before() member.; 74*/; 75 ; 76#include ""TList.h""; 77#include ""TClass.h""; 78#include ""TROOT.h""; 79#include ""TVirtualMutex.h""; 80#include ""TBuffer.h""; 81 ; 82#include <string>; 83 ; 84ClassImp(TList);; 85 ; 86////////////////////////////////////////////////////////////////////////////////; 87/// Delete the list. Objects are not deleted unless the TList is the; 88/// owner (set via SetOwner()).; 89 ; 90TList::~TList(); 91{",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:25314,Integrability,depend,depending,25314,"!ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 R__COLLECTION_WRITE_GUARD();; 823 ; 824 if (!obj) return nullptr;; 825 ; 826 Int_t idx;; 827 TObjLink *lnk = FindLink(obj, idx);; 828 ; 829 if (!lnk) return nullptr;; 830 ; 831 // return object found, which may be (pointer wise) different than the; 832 // input object (depending on what IsEqual() is doing); 833 ; 834 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 835 ; 836 TObject *ob = lnk->GetObject();; 837 lnk->SetObject(nullptr);; 838 if (lnk == fFirst.get()) {; 839 fFirst = lnk->fNext;; 840 // lnk is still alive as we have either fLast; 841 // or the 'new' fFirst->fPrev pointing to it.; 842 if (lnk == fLast.get()) {; 843 fLast.reset();; 844 fFirst.reset();; 845 } else; 846 fFirst->fPrev.reset();; 847 //DeleteLink(lnk);; 848 } else if (lnk == fLast.get()) {; 849 fLast = lnk->fPrev.lock();; 850 fLast->fNext.reset();; 851 //DeleteLink(lnk);; 852 } else {; 853 lnk->Next()->fPrev = lnk->fPrev;; 854 lnk->Prev()->fNext = lnk->fNext;; 855 //DeleteLink(lnk);; 856 }; 857 fSize--;; 858 fCache.reset();; 859 Changed();; 860 ; 861 return ob;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Remove object link (and therefore the object i",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:38910,Integrability,wrap,wrapper,38910," kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; R__COLLECTION_READ_LOCKGUARD#define R__COLLECTION_READ_LOCKGUARD(mutex)Definition TCollection.h:362; R__COLLECTION_WRITE_GUARD#define R__COLLECTION_WRITE_GUARD()Definition TCollection.h:127; R__COLLECTION_READ_GUARD#define R__COLLECTION_READ_GUARD()Definition TCollection.h:128; kIterForwardconst Bool_t kIterForwardDefinition TCollection.h:42; R__COLLECTION_ITER_GUARD#define R__COLLECTION_ITER_GUARD(collection)Definition TCollection.h:129; R__COLLECTION_WRITE_LOCKGUARD#define R__COLLECTION_WRITE_LOCKGUARD(mutex)Definition TCollection.h:365; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TList.h; TROOT.h; TVirtualMutex.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClass::GetDirectoryAutoAddROOT::DirAutoAdd_t GetDirectoryAutoAdd() constReturn the wrapper around the directory auto add function.Definition TClass.cxx:7554; TCollection::IsArgNullBool_t IsArgNull(const char *where, const TObject *obj) constReturns true if object is a null pointer.Definition TCollection.cxx:372; TCollection::GetNameconst char * GetName() const overrideReturn name of this collection.Definition TCollection.cxx:351; TCollection::fSizeInt_t fSizeDefinition TCollection.h:150; TCollection::fNameTString fNameDefinition TCollection.h:149; TCollection::IsOwnerBool_t IsOwner() constDefinition TCollection.h:190; TCollection::GarbageCollectstatic void GarbageCollect(TObject *obj)Add to the list of things to be cleaned up.Definition TCollection.cxx:725; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TIterDefinition TCollection.h:235; TIteratorIterator abstract base class.Definition TIterator.h:30; TIterator::IsAvirtual TClass * IsA() constDefinition TIterator.h:48; TLi",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:46914,Integrability,message,message,46914,"evTObjLink * Prev()Definition TList.h:152; TObjLink::GetAddOptionvirtual Option_t * GetAddOption() constDefinition TList.h:148; TObjLink::fObjectTObject * fObjectDefinition TList.h:134; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjLink::fPrevTObjLinkWeakPtr_t fPrevDefinition TList.h:132; TObjLink::NextTObjLink * Next()Definition TList.h:151; TObjLink::fNextTObjLinkPtr_t fNextDefinition TList.h:131; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::IsEqualvirtual Bool_t IsEqual(const TObject *obj) constDefault equal comparison (objects are equal if they have the same address in memory).Definition TObject.cxx:570; TObject::RecursiveRemovevirtual void RecursiveRemove(TObject *obj)Recursively remove this object from a list.Definition TObject.cxx:665; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TSeqCollection::Changedvirtual void Changed()Definition TSeqCollection.h:34; TSeqCollection::fSortedBool_t fSortedDefinition TSeqCollection.h:31; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; bool; int; object; unsigned int; nconst Int_t nDefinition legend1.C:16; ROOT::Detail::HasBeenDeletedR__ALWAYS_INLINE bool HasBeenDeleted(const TObject *obj)Check if the TObject's memory has been deleted.Definition TObject.h:402; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; v@ vDefinition rootcling_impl.cxx:3699; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. corecontsrcTList.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:09 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:705,Modifiability,inherit,inheriting,705,". ROOT: core/cont/src/TList.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.cxx. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TList; 13\ingroup Containers; 14A doubly linked list.; 15 ; 16All classes inheriting from TObject can be; 17inserted in a TList. Before being inserted into the list the object; 18pointer is wrapped in a TObjLink object which contains, besides; 19the object pointer also a previous and next pointer.; 20 ; 21There are several ways to iterate over a TList; in order of preference, if; 22not forced by other constraints:; 23 ; 24 1. (Preferred way) Using the C++ range-based `for` or `begin()` / `end()`:; 25~~~ {.cpp}; 26 for(TObject *obj: *GetListOfPrimitives()); 27 obj->Write();; 28~~~; 29 2. Using the R__FOR_EACH macro:; 30~~~ {.cpp}; 31 GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);; 32~~~; 33 3. Using the TList iterator TListIter (via the wrapper class TIter):; 34~~~ {.cpp}; 35 TIter next(GetListOfPrimitives());; 36 while (TObject *obj = next()); 37 obj->Draw(next.GetOption());; 38~~~; 39 4. Using the TList iterator TListIter and std::for_each algorithm:; 40~~~ {.cpp}; 41 // A function object, which will be applied to each element; 42 // of the given range.; 43 struct STestFunctor {; 44 bool operator()(TObject *aObj) {; 45 ...; 46 return true;; 47 }; 48 }; 49 ...; 50 ...; 51 TIter iter(mylist);; 52 for_each( iter.Begin(), TIter::End(), STestFunctor() );; 53~~~; 54 5. Using the TObjLink list entries (that wrap the TObject*):; 55~~~ {.cpp}; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:34969,Modifiability,inherit,inheriting,34969,"etOption() const; 1141{; 1142 if (fCurCursor) return fCurCursor->GetOption();; 1143 return """";; 1144}; 1145 ; 1146////////////////////////////////////////////////////////////////////////////////; 1147/// Sets the object option stored in the list.; 1148 ; 1149void TListIter::SetOption(Option_t *option); 1150{; 1151 if (fCurCursor) fCurCursor->SetOption(option);; 1152}; 1153 ; 1154////////////////////////////////////////////////////////////////////////////////; 1155/// Reset list iterator.; 1156 ; 1157void TListIter::Reset(); 1158{; 1159 R__COLLECTION_ITER_GUARD(fList);; 1160 fStarted = kFALSE;; 1161}; 1162 ; 1163////////////////////////////////////////////////////////////////////////////////; 1164/// This operator compares two TIterator objects.; 1165 ; 1166Bool_t TListIter::operator!=(const TIterator &aIter) const; 1167{; 1168 if (IsA() == aIter.IsA()) {; 1169 // We compared equal only two iterator of the same type.; 1170 // Since this is a function of TListIter, we consequently know that; 1171 // both this and aIter are of type inheriting from TListIter.; 1172 const TListIter &iter(dynamic_cast<const TListIter &>(aIter));; 1173 return (fCurCursor != iter.fCurCursor);; 1174 }; 1175 return false; // for base class we don't implement a comparison; 1176}; 1177 ; 1178////////////////////////////////////////////////////////////////////////////////; 1179/// This operator compares two TListIter objects.; 1180 ; 1181Bool_t TListIter::operator!=(const TListIter &aIter) const; 1182{; 1183 return (fCurCursor != aIter.fCurCursor);; 1184}; 1185 ; 1186////////////////////////////////////////////////////////////////////////////////; 1187/// Stream all objects in the collection to or from the I/O buffer.; 1188 ; 1189void TList::Streamer(TBuffer &b); 1190{; 1191 R__COLLECTION_WRITE_GUARD();; 1192 ; 1193 Int_t nobjects;; 1194 UChar_t nch;; 1195 Int_t nbig;; 1196 TObject *obj;; 1197 UInt_t R__s, R__c;; 1198 ; 1199 if (b.IsReading()) {; 1200 Clear(); // Get rid of old data if any.; 120",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9676,Performance,cache,cached,9676,"ink(obj, after->shared_from_this());; 295 fSize++;; 296 Changed();; 297 }; 298 }; 299}; 300 ; 301////////////////////////////////////////////////////////////////////////////////; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365//////////////////////////////////////////////",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9709,Performance,cache,cached,9709,"/////////////////////////////////////////////////////////; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object'",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9725,Performance,cache,cached,9725,"///; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.;",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9748,Performance,cache,cached,9748,"///; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.;",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9794,Performance,cache,cached,9794,"///; 302/// Insert object at position idx in the list.; 303 ; 304void TList::AddAt(TObject *obj, Int_t idx); 305{; 306 R__COLLECTION_WRITE_GUARD();; 307 ; 308 if (IsArgNull(""AddAt"", obj)) return;; 309 ; 310 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 311 ; 312 TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.;",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:9838,Performance,cache,cached,9838," TObjLink *lnk = LinkAt(idx);; 313 if (!lnk); 314 TList::AddLast(obj);; 315 else if (lnk == fFirst.get()); 316 TList::AddFirst(obj);; 317 else {; 318 NewLink(obj, lnk->fPrev.lock());; 319 fSize++;; 320 Changed();; 321 }; 322}; 323 ; 324////////////////////////////////////////////////////////////////////////////////; 325/// Returns the object after object obj. Obj is found using the; 326/// object's IsEqual() method. Returns 0 if obj is last in list.; 327 ; 328TObject *TList::After(const TObject *obj) const; 329{; 330 R__COLLECTION_WRITE_GUARD();; 331 ; 332 TObjLink *t;; 333 ; 334 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 335 ; 336 auto cached = fCache.lock();; 337 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 338 t = cached.get();; 339 ((TList*)this)->fCache = cached->fNext; //cast const away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && c",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:10952,Performance,cache,cached,10952,"st away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 39",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:10985,Performance,cache,cached,10985,"s)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLEC",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:11001,Performance,cache,cached,11001,"ext()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:11024,Performance,cache,cached,11024,"ext()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:11070,Performance,cache,cached,11070,"ext()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:11114,Performance,cache,cached,11114,"t *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLECTION_WRITE_GUARD();; 404 ; 405 Bool_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the conta",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23828,Performance,cache,cached,23828,"st::TObjLinkPtr_t TList::NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23861,Performance,cache,cached,23861,"Object *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23871,Performance,cache,cached,23871,"Object *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23905,Performance,cache,cached,23905,"LinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817//////////////////////////////////",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23965,Performance,cache,cached,23965,":make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:13523,Security,access,accessing,13523," the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operations during the delete (e.g. during the dtor; 465/// of an object in this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:14285,Security,access,access,14285,"5 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operations during the delete (e.g. during the dtor; 465/// of an object in this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 474 ; 475 TList removeDirectory; // need to deregister these from their directory; 476 ; 477 if (slow) {; 478 ; 479 // In some case, for example TParallelCoord, a list (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:15724,Security,access,accessing,15724,"t (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform RecursiveRemove of the node currently; 489 // being cleared/deleted.; 490 while (fFirst) {; 491 auto tlk = fFirst;; 492 fFirst = fFirst->fNext;; 493 fSize--;; 494 ; 495 // Make node available to RecursiveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 525 while (first) {; 526 auto tlk = first;; 527 first = first->fNext;; 528 // delete only heap objects; 529 auto obj = tlk->GetObject();; 530 tlk->SetObject(nullptr);; 531 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 532 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 533 obj, GetName());; 534 else if (obj && obj->IsOnHeap()); 535 TCollection::GarbageCollect(obj);; 536 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 537 removeDirectory.Add(ob",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:16508,Security,access,accessing,16508,"siveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 525 while (first) {; 526 auto tlk = first;; 527 first = first->fNext;; 528 // delete only heap objects; 529 auto obj = tlk->GetObject();; 530 tlk->SetObject(nullptr);; 531 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 532 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 533 obj, GetName());; 534 else if (obj && obj->IsOnHeap()); 535 TCollection::GarbageCollect(obj);; 536 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 537 removeDirectory.Add(obj);; 538 ; 539 // The formerly first token, when tlk goes out of scope has no more references; 540 // because of the fFirst.reset(); 541 }; 542 }; 543 ; 544 // These objects cannot expect to have a valid TDirectory anymore;; 545 // e.g. because *this is the TDirectory's list of objects. Even if; 546 // not, they are supposed to be deleted, so we can as well unregister; 547 // them from their directory, even if they are stack-based:; 548 TIter iRemDir(&removeDirectory);; 549 TObject* dirRem = nullptr;; 550 while ((dirRem = iRemDir())) {; 551 (*dirRem->IsA()->GetDirectoryAutoAdd())(dirRem, nullptr);; 552 }; 553 Changed();; 554}; 555 ; 556#if 0; 557////////////////////////////////////////////////////////////////////////////////; 55",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:13094,Usability,clear,cleared,13094,"ol_t nodel = option ? (!strcmp(option, ""nodelete"") ? kTRUE : kFALSE) : kFALSE;; 406 ; 407 if (!nodel && IsOwner()) {; 408 Delete(option);; 409 return;; 410 }; 411 ; 412 // In some case, for example TParallelCoord, a list (the pad's list of; 413 // primitives) will contain both the container and the containees; 414 // (the TParallelCoordVar) but if the Clear is being called from; 415 // the destructor of the container of this list, one of the first; 416 // thing done will be the remove the container (the pad) for the; 417 // list (of Primitives of the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:13380,Usability,clear,clear,13380," the canvas) that was connecting it; 418 // (indirectly) to the list of cleanups.; 419 // Note: The Code in TParallelCoordVar was changed (circa June 2017),; 420 // to no longer have this behavior and thus rely on this code (by moving; 421 // from using Draw to Paint) but the structure might still exist elsewhere; 422 // so we keep this comment here.; 423 ; 424 // To preserve this connection (without introducing one when there was none),; 425 // we re-use fCache to inform RecursiveRemove of the node currently; 426 // being cleared/deleted.; 427 while (fFirst) {; 428 auto tlk = fFirst;; 429 fFirst = fFirst->fNext;; 430 fSize--;; 431 ; 432 ; 433 // Make node available to RecursiveRemove; 434 tlk->fNext.reset();; 435 tlk->fPrev.reset();; 436 fCache = tlk;; 437 ; 438 // delete only heap objects marked OK to clear; 439 auto obj = tlk->GetObject();; 440 if (!nodel && obj) {; 441 if (ROOT::Detail::HasBeenDeleted(obj)) {; 442 Error(""Clear"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 443 obj, GetName());; 444 } else if (obj->IsOnHeap()) {; 445 if (obj->TestBit(kCanDelete)) {; 446 if (!ROOT::Detail::HasBeenDeleted(obj)) {; 447 TCollection::GarbageCollect(obj);; 448 }; 449 }; 450 }; 451 }; 452 // delete tlk;; 453 }; 454 fFirst.reset();; 455 fLast.reset();; 456 fCache.reset();; 457 fSize = 0;; 458 Changed();; 459}; 460 ; 461////////////////////////////////////////////////////////////////////////////////; 462/// Remove all objects from the list AND delete all heap based objects.; 463/// If option=""slow"" then keep list consistent during delete. This allows; 464/// recursive list operations during the delete (e.g. during the dtor; 465/// of an object in this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : ",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:15340,Usability,clear,cleared,15340,"n this list one can still access the list to search for; 466/// other not yet deleted objects).; 467 ; 468void TList::Delete(Option_t *option); 469{; 470 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 471 R__COLLECTION_WRITE_GUARD();; 472 ; 473 Bool_t slow = option ? (!strcmp(option, ""slow"") ? kTRUE : kFALSE) : kFALSE;; 474 ; 475 TList removeDirectory; // need to deregister these from their directory; 476 ; 477 if (slow) {; 478 ; 479 // In some case, for example TParallelCoord, a list (the pad's list of; 480 // primitives) will contain both the container and the containees; 481 // (the TParallelCoorVar) but if the Clear is being called from; 482 // the destructor of the container of this list, one of the first; 483 // thing done will be the remove the container (the pad) for the; 484 // list (of Primitives of the canvas) that was connecting it; 485 // (indirectly) to the list of cleanups.; 486 ; 487 // To preserve this connection (without introducing one when there was none),; 488 // we re-use fCache to inform RecursiveRemove of the node currently; 489 // being cleared/deleted.; 490 while (fFirst) {; 491 auto tlk = fFirst;; 492 fFirst = fFirst->fNext;; 493 fSize--;; 494 ; 495 // Make node available to RecursiveRemove; 496 tlk->fNext.reset();; 497 tlk->fPrev.reset();; 498 fCache = tlk;; 499 ; 500 // delete only heap objects; 501 auto obj = tlk->GetObject();; 502 if (obj && ROOT::Detail::HasBeenDeleted(obj)); 503 Error(""Delete"", ""A list is accessing an object (%p) already deleted (list name = %s)"",; 504 obj, GetName());; 505 else if (obj && obj->IsOnHeap()); 506 TCollection::GarbageCollect(obj);; 507 else if (obj && obj->IsA()->GetDirectoryAutoAdd()); 508 removeDirectory.Add(obj);; 509 ; 510 // delete tlk;; 511 }; 512 ; 513 fFirst.reset();; 514 fLast.reset();; 515 fCache.reset();; 516 fSize = 0;; 517 ; 518 } else {; 519 ; 520 auto first = fFirst; //pointer to first entry in linked list; 521 fFirst.reset();; 522 fLast.reset();; 523 fCache.reset();; 524 fSize = 0;; 52",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8cxx_source.html:23787,Usability,clear,cleared,23787,"/////////////////////////; 744/// Return a new TObjOptLink (a TObjLink that also stores the option).; 745 ; 746TList::TObjLinkPtr_t TList::NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(",MatchSource.WIKI,doc/master/TList_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html
https://root.cern/doc/master/TList_8h.html:286,Integrability,depend,dependency,286,". ROOT: core/cont/inc/TList.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Functions |; Variables ; TList.h File Reference. #include ""TSeqCollection.h""; #include ""TString.h""; #include <iterator>; #include <memory>. Include dependency graph for TList.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TList;  A doubly linked list. More...;  ; class  TListIter;  Iterator of linked list. More...;  ; class  TObjLink;  Wrapper around a TObject so it can be stored in a TList. More...;  ; class  TObjOptLink;  . Functions; bool operator== (const std::shared_ptr< TObjLink > &l, TObjOptLink *r);  ; bool operator== (TObjOptLink *l, const std::shared_ptr< TObjLink > &r);  . Variables; const Bool_t kSortAscending = kTRUE;  ; const Bool_t kSortDescending = !kSortAscending;  . Function Documentation. ◆ operator==() [1/2]. bool operator== ; (; const std::shared_ptr< TObjLink > & ; l, . TObjOptLink * ; r . ). inline . Definition at line 237 of file TList.h. ◆ operator==() [2/2]. bool operator== ; (; TObjOptLink * ; l, . const std::shared_ptr< TObjLink > & ; r . ). inline . Definition at line 233 of file TList.h. Variable Documentation. ◆ kSortAscending. const Bool_t kSortAscending = kTRUE. Definition at line 31 of file TList.h. ◆ kSortDescending. const Bool_t kSortDescending = !kSortAscending. Definition at line 32 of file TList.h. corecontincTList.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TList_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h.html
https://root.cern/doc/master/TList_8h_source.html:818,Modifiability,inherit,inheriting,818,". ROOT: core/cont/inc/TList.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TList.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Fons Rademakers 10/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TList; 13#define ROOT_TList; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TList //; 19// //; 20// A doubly linked list. All classes inheriting from TObject can be //; 21// inserted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 5",MatchSource.WIKI,doc/master/TList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h_source.html
https://root.cern/doc/master/TList_8h_source.html:1601,Performance,cache,cache,1601,"serted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 57 TObjLinkPtr_t NewLink(TObject *obj, const TObjLinkPtr_t &prev = nullptr);; 58 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev = nullptr);; 59 TObjLinkPtr_t NewLink(TObject *obj, TObjLink *prev);; 60 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, TObjLink *prev);; 61 // virtual void DeleteLink(TObjLink *lnk);; 62 ; 63 void InsertAfter(const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);; 64 ; 65private:; 66 TList(const TList&) = delete;; 67 TList& operator=(const TList&) = delete;; 68 ; 69public:; 70 typedef TListIter Iterator_t;; 71 ; 72 TList() : fAscending(kTRUE) { }; 73 ; 74 TList(TObject *) R__DEPRECATED(6, 34, ""The argument is ignored. Use the default constructor TList::TList()."") : fAscending(kTRUE) { } // for backward compatibility, don't use; 75 ; 76 virtual ~TList();; 77 void Clear(Option_t *op",MatchSource.WIKI,doc/master/TList_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TList_8h_source.html
https://root.cern/doc/master/TMarker_8cxx_source.html:6851,Deployability,release,released,6851,"t_t(4*fMarkerSize);; 191 if (dist <= markerRadius) return 0;; 192 if (dist > markerRadius+3) return 999;; 193 return dist;; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Draw this marker with its current attributes.; 198 ; 199void TMarker::Draw(Option_t *option); 200{; 201 AppendPad(option);; 202 ; 203}; 204 ; 205////////////////////////////////////////////////////////////////////////////////; 206/// Draw this marker with new coordinates.; 207 ; 208TMarker *TMarker::DrawMarker(Double_t x, Double_t y); 209{; 210 TMarker *newmarker = new TMarker(x, y, 1);; 211 TAttMarker::Copy(*newmarker);; 212 newmarker->SetBit(kCanDelete);; 213 newmarker->AppendPad();; 214 return newmarker;; 215}; 216 ; 217////////////////////////////////////////////////////////////////////////////////; 218/// Execute action corresponding to one event.; 219///; 220/// This member function is called when a marker is clicked with the locator; 221///; 222/// If Left button is clicked on a marker, the marker is moved to; 223/// a new position when the mouse button is released.; 224 ; 225void TMarker::ExecuteEvent(Int_t event, Int_t px, Int_t py); 226{; 227 if (!gPad) return;; 228 ; 229 TPoint p;; 230 static Int_t pxold, pyold;; 231 static Bool_t ndcsav;; 232 Double_t dpx, dpy, xp1,yp1;; 233 Bool_t opaque = gPad->OpaqueMoving();; 234 ; 235 if (!gPad->IsEditable()) return;; 236 ; 237 switch (event) {; 238 ; 239 case kButton1Down:; 240 ndcsav = TestBit(kMarkerNDC);; 241 if (!opaque) {; 242 gVirtualX->SetTextColor(-1); // invalidate current text color (use xor mode); 243 TAttMarker::Modify(); //Change marker attributes only if necessary; 244 }; 245 // No break !!!; 246 ; 247 case kMouseMotion:; 248 pxold = px; pyold = py;; 249 gPad->SetCursor(kMove);; 250 break;; 251 ; 252 case kButton1Motion:; 253 p.fX = pxold; p.fY = pyold;; 254 if (!opaque) gVirtualX->DrawPolyMarker(1, &p);; 255 p.fX = px; p.fY = py;; 256 if (!opaque) gVirtualX->DrawPolyMarker(1, &",MatchSource.WIKI,doc/master/TMarker_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMarker_8cxx_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:937,Availability,avail,available,937,". ROOT: core/base/inc/TMathBase.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMathBase.h. Go to the documentation of this file. 1// @(#)root/base:; 2// Authors: Rene Brun, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TMathBase; 13#define ROOT_TMathBase; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TMath Base functions //; 19// //; 20// Define the functions Min, Max, Abs, Sign, Range for all types. //; 21// NB: These functions are unfortunately not available in a portable //; 22// way in std::. //; 23// //; 24// More functions are defined in TMath.h. TMathBase.h is designed to be //; 25// a stable file and used in place of TMath.h in the ROOT miniCore. //; 26// //; 27//////////////////////////////////////////////////////////////////////////; 28 ; 29#include ""RtypesCore.h""; 30 ; 31#include <cstdlib>; 32#include <cmath>; 33#include <algorithm>; 34 ; 35namespace TMath {; 36 ; 37 // Abs; 38 inline Short_t Abs(Short_t d);; 39 inline Int_t Abs(Int_t d);; 40 inline Long_t Abs(Long_t d);; 41 inline Long64_t Abs(Long64_t d);; 42 inline Float_t Abs(Float_t d);; 43 inline Double_t Abs(Double_t d);; 44 inline LongDouble_t Abs(LongDouble_t d);; 45 ; 46 // Even/Odd; 47 inline Bool_t Even(Long_t a);; 48 inline Bool_t Odd(Long_t a);; 49 ; 50 // SignBit; 51 template<typename Integer>; 52 inline Bool_t SignBit(Integer a);; 53 inline Bool_t SignBit(Float_t a);; 54 inline Bool_t SignBit(Double_t a);; 55 inline Bool_t SignBit(LongDouble_t a);; 56 ; 57 // Sign; 58 template<typename T1, typename T2>; 59 inline T1 S",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:4033,Availability,down,down,4033,"(ULong_t a, ULong_t b);; 82 inline Long64_t Max(Long64_t a, Long64_t b);; 83 inline ULong64_t Max(ULong64_t a, ULong64_t b);; 84 inline Float_t Max(Float_t a, Float_t b);; 85 inline Double_t Max(Double_t a, Double_t b);; 86 ; 87 // Range; 88 inline Short_t Range(Short_t lb, Short_t ub, Short_t x);; 89 inline Int_t Range(Int_t lb, Int_t ub, Int_t x);; 90 inline Long_t Range(Long_t lb, Long_t ub, Long_t x);; 91 inline ULong_t Range(ULong_t lb, ULong_t ub, ULong_t x);; 92 inline Double_t Range(Double_t lb, Double_t ub, Double_t x);; 93 ; 94 //NextPrime is used by the Core classes.; 95 Long_t NextPrime(Long_t x); // Least prime number greater than x; 96 ; 97 // Binary search; 98 template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value);; 99 template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value);; 100 template <typename Iterator, typename Element> Iterator BinarySearch(Iterator first, Iterator last, Element value);; 101 ; 102 // Sorting; 103 template <typename Element, typename Index>; 104 void Sort(Index n, const Element* a, Index* index, Bool_t down=kTRUE);; 105 template <typename Iterator, typename IndexIterator>; 106 void SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE);; 107}; 108 ; 109 ; 110//---- Even/odd ----------------------------------------------------------------; 111 ; 112/// Returns `true` if `a` is even.; 113inline Bool_t TMath::Even(Long_t a); 114 { return ! (a & 1); }; 115 ; 116/// Returns `true` if `a` is odd.; 117inline Bool_t TMath::Odd(Long_t a); 118 { return (a & 1); }; 119 ; 120//---- Abs ---------------------------------------------------------------------; 121 ; 122/// Returns the absolute value of parameter `Short_t d`.; 123inline Short_t TMath::Abs(Short_t d); 124{ return (d >= 0) ? d : Short_t(-d); }; 125 ; 126/// Returns the absolute value of parameter `Int_t d`.; 127inline Int_t TMath::Abs(Int_t d); 128{ return std::abs(d); }; 129 ; 130/// Returns the absolute v",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:4181,Availability,down,down,4181,"(ULong_t a, ULong_t b);; 82 inline Long64_t Max(Long64_t a, Long64_t b);; 83 inline ULong64_t Max(ULong64_t a, ULong64_t b);; 84 inline Float_t Max(Float_t a, Float_t b);; 85 inline Double_t Max(Double_t a, Double_t b);; 86 ; 87 // Range; 88 inline Short_t Range(Short_t lb, Short_t ub, Short_t x);; 89 inline Int_t Range(Int_t lb, Int_t ub, Int_t x);; 90 inline Long_t Range(Long_t lb, Long_t ub, Long_t x);; 91 inline ULong_t Range(ULong_t lb, ULong_t ub, ULong_t x);; 92 inline Double_t Range(Double_t lb, Double_t ub, Double_t x);; 93 ; 94 //NextPrime is used by the Core classes.; 95 Long_t NextPrime(Long_t x); // Least prime number greater than x; 96 ; 97 // Binary search; 98 template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value);; 99 template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value);; 100 template <typename Iterator, typename Element> Iterator BinarySearch(Iterator first, Iterator last, Element value);; 101 ; 102 // Sorting; 103 template <typename Element, typename Index>; 104 void Sort(Index n, const Element* a, Index* index, Bool_t down=kTRUE);; 105 template <typename Iterator, typename IndexIterator>; 106 void SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE);; 107}; 108 ; 109 ; 110//---- Even/odd ----------------------------------------------------------------; 111 ; 112/// Returns `true` if `a` is even.; 113inline Bool_t TMath::Even(Long_t a); 114 { return ! (a & 1); }; 115 ; 116/// Returns `true` if `a` is odd.; 117inline Bool_t TMath::Odd(Long_t a); 118 { return (a & 1); }; 119 ; 120//---- Abs ---------------------------------------------------------------------; 121 ; 122/// Returns the absolute value of parameter `Short_t d`.; 123inline Short_t TMath::Abs(Short_t d); 124{ return (d >= 0) ? d : Short_t(-d); }; 125 ; 126/// Returns the absolute value of parameter `Int_t d`.; 127inline Int_t TMath::Abs(Int_t d); 128{ return std::abs(d); }; 129 ; 130/// Returns the absolute v",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:15369,Availability,down,down,15369,"ame T> Long64_t TMath::BinarySearch(Long64_t n, const T **array, T value); 363{; 364 const T* pind;; 365 pind = std::lower_bound(*array, *array + n, value);; 366 if ( (pind != *array + n) && (*pind == value) ); 367 return (pind - *array);; 368 else; 369 return ( pind - *array - 1);; 370}; 371 ; 372template<typename T>; 373struct CompareDesc {; 374 ; 375 CompareDesc(T d) : fData(d) {}; 376 ; 377 template<typename Index>; 378 bool operator()(Index i1, Index i2) {; 379 return *(fData + i1) > *(fData + i2);; 380 }; 381 ; 382 T fData;; 383};; 384 ; 385template<typename T>; 386struct CompareAsc {; 387 ; 388 CompareAsc(T d) : fData(d) {}; 389 ; 390 template<typename Index>; 391 bool operator()(Index i1, Index i2) {; 392 return *(fData + i1) < *(fData + i2);; 393 }; 394 ; 395 T fData;; 396};; 397 ; 398/// Sort the n1 elements of the Short_t array defined by its; 399/// iterators. In output the array index contains the indices of; 400/// the sorted array. If down is false sort in increasing order; 401/// (default is decreasing order).; 402///; 403/// NOTE that the array index must be created with a length bigger; 404/// or equal than the main array before calling this function.; 405template <typename Iterator, typename IndexIterator>; 406void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= ",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:15733,Availability,down,down,15733," return *(fData + i1) > *(fData + i2);; 380 }; 381 ; 382 T fData;; 383};; 384 ; 385template<typename T>; 386struct CompareAsc {; 387 ; 388 CompareAsc(T d) : fData(d) {}; 389 ; 390 template<typename Index>; 391 bool operator()(Index i1, Index i2) {; 392 return *(fData + i1) < *(fData + i2);; 393 }; 394 ; 395 T fData;; 396};; 397 ; 398/// Sort the n1 elements of the Short_t array defined by its; 399/// iterators. In output the array index contains the indices of; 400/// the sorted array. If down is false sort in increasing order; 401/// (default is decreasing order).; 402///; 403/// NOTE that the array index must be created with a length bigger; 404/// or equal than the main array before calling this function.; 405template <typename Iterator, typename IndexIterator>; 406void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= n; 428/// before calling this function.; 429/// NOTE also that the size type for n must be the same type used for the index array; 430/// (templated type Index); 431template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down); 432{; 433 for(Index i = 0; i < n; i++) { index[i] = i; }; 434 if ( down ); 435 std::sort(index, index + n, CompareDesc<const Element*>(a) );; 436 else; 437 std::sort(index, index + n, Compa",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:15930,Availability,down,down,15930," return *(fData + i1) > *(fData + i2);; 380 }; 381 ; 382 T fData;; 383};; 384 ; 385template<typename T>; 386struct CompareAsc {; 387 ; 388 CompareAsc(T d) : fData(d) {}; 389 ; 390 template<typename Index>; 391 bool operator()(Index i1, Index i2) {; 392 return *(fData + i1) < *(fData + i2);; 393 }; 394 ; 395 T fData;; 396};; 397 ; 398/// Sort the n1 elements of the Short_t array defined by its; 399/// iterators. In output the array index contains the indices of; 400/// the sorted array. If down is false sort in increasing order; 401/// (default is decreasing order).; 402///; 403/// NOTE that the array index must be created with a length bigger; 404/// or equal than the main array before calling this function.; 405template <typename Iterator, typename IndexIterator>; 406void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= n; 428/// before calling this function.; 429/// NOTE also that the size type for n must be the same type used for the index array; 430/// (templated type Index); 431template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down); 432{; 433 for(Index i = 0; i < n; i++) { index[i] = i; }; 434 if ( down ); 435 std::sort(index, index + n, CompareDesc<const Element*>(a) );; 436 else; 437 std::sort(index, index + n, Compa",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:16261,Availability,down,down,16261," In output the array index contains the indices of; 400/// the sorted array. If down is false sort in increasing order; 401/// (default is decreasing order).; 402///; 403/// NOTE that the array index must be created with a length bigger; 404/// or equal than the main array before calling this function.; 405template <typename Iterator, typename IndexIterator>; 406void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= n; 428/// before calling this function.; 429/// NOTE also that the size type for n must be the same type used for the index array; 430/// (templated type Index); 431template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down); 432{; 433 for(Index i = 0; i < n; i++) { index[i] = i; }; 434 if ( down ); 435 std::sort(index, index + n, CompareDesc<const Element*>(a) );; 436 else; 437 std::sort(index, index + n, CompareAsc<const Element*>(a) );; 438}; 439 ; 440#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; RtypesCore.h; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:16680,Availability,down,down,16680,"t, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= n; 428/// before calling this function.; 429/// NOTE also that the size type for n must be the same type used for the index array; 430/// (templated type Index); 431template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down); 432{; 433 for(Index i = 0; i < n; i++) { index[i] = i; }; 434 if ( down ); 435 std::sort(index, index + n, CompareDesc<const Element*>(a) );; 436 else; 437 std::sort(index, index + n, CompareAsc<const Element*>(a) );; 438}; 439 ; 440#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; RtypesCore.h; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; Double_tdouble Double_tDefinition RtypesCore.h:59; LongDouble_tlong double LongDouble_tDefinition RtypesCore.h:61; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93;",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:16754,Availability,down,down,16754,"t, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= n; 428/// before calling this function.; 429/// NOTE also that the size type for n must be the same type used for the index array; 430/// (templated type Index); 431template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down); 432{; 433 for(Index i = 0; i < n; i++) { index[i] = i; }; 434 if ( down ); 435 std::sort(index, index + n, CompareDesc<const Element*>(a) );; 436 else; 437 std::sort(index, index + n, CompareAsc<const Element*>(a) );; 438}; 439 ; 440#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; RtypesCore.h; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Short_tshort Short_tDefinition RtypesCore.h:39; Double_tdouble Double_tDefinition RtypesCore.h:59; LongDouble_tlong double LongDouble_tDefinition RtypesCore.h:61; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93;",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:18616,Availability,down,down,18616,"ong ULong64_tDefinition RtypesCore.h:70; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; cindexOption_t Option_t cindexDefinition TGWin32VirtualXProxy.cxx:50; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; bool; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T1#define T1Definition md5.inl:146; TMathTMath.Definition TMathBase.h:35; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::SortItrvoid SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE)Sort the n1 elements of the Short_t array defined by its iterators.Definition TMathBase.h:406; TMath::NextPrimeLong_t NextPrime(Long_t x); TMath::SignT1 Sign(T1 a, T2 b)Returns a value with the magnitude of a and the sign of b.Definition TMathBase.h:175; TMath::RangeShort_t Range(Short_t lb, Short_t ub, Short_t x)Returns x if lb < x < up, lb if x < lb and ub if x > ub.Definition TMathBase.h:302; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::OddBool_t Odd(Long_t a)Returns true if a is odd.Definition TMathBase.h:117; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::SignBitBool_t SignBit(Integer a)Returns whether the sign of Integer a is negative.Definition TMathBase.h:155; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array ",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:19281,Availability,down,down,19281,"st Int_t nDefinition legend1.C:16; T2#define T2Definition md5.inl:147; T1#define T1Definition md5.inl:146; TMathTMath.Definition TMathBase.h:35; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::SortItrvoid SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE)Sort the n1 elements of the Short_t array defined by its iterators.Definition TMathBase.h:406; TMath::NextPrimeLong_t NextPrime(Long_t x); TMath::SignT1 Sign(T1 a, T2 b)Returns a value with the magnitude of a and the sign of b.Definition TMathBase.h:175; TMath::RangeShort_t Range(Short_t lb, Short_t ub, Short_t x)Returns x if lb < x < up, lb if x < lb and ub if x > ub.Definition TMathBase.h:302; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::OddBool_t Odd(Long_t a)Returns true if a is odd.Definition TMathBase.h:117; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::SignBitBool_t SignBit(Integer a)Returns whether the sign of Integer a is negative.Definition TMathBase.h:155; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::EvenBool_t Even(Long_t a)Returns true if a is even.Definition TMathBase.h:113; CompareAscDefinition TMathBase.h:386; CompareAsc::fDataT fDataDefinition TMathBase.h:395; CompareAsc::operator()bool operator()(Index i1, Index i2)Definition TMathBase.h:391; CompareAsc::CompareAscCompareAsc(T d)Definition TMathBase.h:388; CompareDescDefinition TMathBase.h:373; CompareDesc::operator()bool operator()(Index i1, Index i2)Definition TMathBase.h:378; CompareDesc::CompareDescCompareDesc(T d)Definition TMathB",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathBase_8h_source.html:952,Modifiability,portab,portable,952,". ROOT: core/base/inc/TMathBase.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMathBase.h. Go to the documentation of this file. 1// @(#)root/base:; 2// Authors: Rene Brun, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TMathBase; 13#define ROOT_TMathBase; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TMath Base functions //; 19// //; 20// Define the functions Min, Max, Abs, Sign, Range for all types. //; 21// NB: These functions are unfortunately not available in a portable //; 22// way in std::. //; 23// //; 24// More functions are defined in TMath.h. TMathBase.h is designed to be //; 25// a stable file and used in place of TMath.h in the ROOT miniCore. //; 26// //; 27//////////////////////////////////////////////////////////////////////////; 28 ; 29#include ""RtypesCore.h""; 30 ; 31#include <cstdlib>; 32#include <cmath>; 33#include <algorithm>; 34 ; 35namespace TMath {; 36 ; 37 // Abs; 38 inline Short_t Abs(Short_t d);; 39 inline Int_t Abs(Int_t d);; 40 inline Long_t Abs(Long_t d);; 41 inline Long64_t Abs(Long64_t d);; 42 inline Float_t Abs(Float_t d);; 43 inline Double_t Abs(Double_t d);; 44 inline LongDouble_t Abs(LongDouble_t d);; 45 ; 46 // Even/Odd; 47 inline Bool_t Even(Long_t a);; 48 inline Bool_t Odd(Long_t a);; 49 ; 50 // SignBit; 51 template<typename Integer>; 52 inline Bool_t SignBit(Integer a);; 53 inline Bool_t SignBit(Float_t a);; 54 inline Bool_t SignBit(Double_t a);; 55 inline Bool_t SignBit(LongDouble_t a);; 56 ; 57 // Sign; 58 template<typename T1, typename T2>; 59 inline T1 S",MatchSource.WIKI,doc/master/TMathBase_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html
https://root.cern/doc/master/TMathText_8cxx_source.html:1448,Availability,avail,available,1448,"ee $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#include <iostream>; 13#include ""TROOT.h""; 14#include <ft2build.h>; 15#include FT_FREETYPE_H; 16#include FT_GLYPH_H; 17#include ""TTF.h""; 18#include ""TMathText.h""; 19#include ""TMath.h""; 20#include ""TVirtualPad.h""; 21#include ""TVirtualPS.h""; 22#include ""TVirtualX.h""; 23#include ""TText.h""; 24 ; 25#include ""../../../graf2d/mathtext/inc/mathtext.h""; 26#include ""../../../graf2d/mathtext/inc/mathrender.h""; 27 ; 28/** \class TMathText; 29\ingroup BasicGraphics; 30 ; 31To draw TeX Mathematical Formula; 32 ; 33TMathText's purpose is to write mathematical equations, exactly as TeX would; 34do it. The syntax is the same as the TeX's one.; 35 ; 36The following example demonstrate how to use TMathText:; 37 ; 38Begin_Macro(source); 39../../../tutorials/graphics/tmathtext.C; 40End_Macro; 41 ; 42The list of all available symbols is given in the following example:; 43 ; 44Begin_Macro; 45../../../tutorials/graphics/tmathtext2.C; 46End_Macro; 47 ; 48#### Limitation:; 49TMathText rendering is not implemented for the PDF output.; 50PostScript output should be used instead.; 51*/; 52 ; 53const Double_t kPI = TMath::Pi();; 54 ; 55class TMathTextRenderer : public TText, public TAttFill,; 56 public mathtext::math_text_renderer_t {; 57private:; 58 TMathText *_parent;; 59 float _font_size;; 60 float _x0;; 61 float _y0;; 62 float _angle_degree;; 63 float _pad_pixel_transform[6];; 64 float _pad_scale;; 65 float _pad_scale_x;; 66 float _pad_scale_y;; 67 float _pad_scale_x_relative;; 68 float _pad_scale_y_relative;; 69 float _current_font_size[mathtext::math_text_renderer_t::NFAMILY];; 70 inline size_t root_face_number(; 71 const unsigned int family, const bool serif = false) const; 72 {; 73 static const int precision = 2;; 74 ; 75 if (family >= mathtext::math_text_renderer_t::; 76 FAMILY_REGULAR &&; 77 family <= mathtext::ma",MatchSource.WIKI,doc/master/TMathText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathText_8cxx_source.html
https://root.cern/doc/master/TMathText_8cxx_source.html:34133,Modifiability,inherit,inherits,34133,"with the new parameters and copy object attributes.Definition TMathText.cxx:541; TMathText::TMathTextTMathText()Default constructor.Definition TMathText.cxx:345; TMathText::PaintMathTextvirtual void PaintMathText(Double_t x, Double_t y, Double_t angle, Double_t size, const char *text)Paint text (used by Paint()).Definition TMathText.cxx:577; TMathText::Copyvoid Copy(TObject &text) const overrideCopy.Definition TMathText.cxx:394; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TTF::fgFacestatic FT_Face fgFace[kTTMaxFonts]font faceDefinition TTF.h:82; TTF::SetTextFontstatic void SetTextFont(Font_t fontnumber)Set specified ",MatchSource.WIKI,doc/master/TMathText_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMathText_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:5475,Availability,error,error,5475,"0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s,a,alfa,b1,b2,b0;; 133 t=h=y=s=a=alfa=b1=b2=b0=0.;; 134 ; 135 if (x == 1) {; 136 h = pi6;; 137 } else if (x == -1) {; 138 h = -pi12;; 139 } else {; 140 t = -x;; 141 if (t <= -2) {; 142 y = -1/(1+t);; 143 s = 1;; 144 b1= TMath::Log(-t);; 145 b2= TMath::Log(1+1/t);; 146 a = -pi3+hf*(b1*b1-b2*b2);; 147 } else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208D",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:5780,Availability,error,error,5780," else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208Double_t TMath::ErfInverse(Double_t x); 209{; 210 Int_t kMaxit = 50;; 211 Double_t kEps = 1e-14;; 212 Double_t kConst = 0.8862269254527579; // sqrt(pi)/2.0; 213 ; 214 if(TMath::Abs(x) <= kEps) return kConst*x;; 215 ; 216 // Newton iterations; 217 Double_t erfi, derfi, y0,y1,dy0,dy1;; 218 if(TMath::Abs(x) < 1.0) {; 219 erfi = kConst*TMath::Abs(x);; 220 y0 = TMath::Erf(0.9*erfi);; 221 derfi = 0.1*erfi;; 222 for (Int_t iter=0; iter<kMaxit; iter++) {; 223 y1 = 1. - TMath::Erfc(erfi);; 224 dy1 = TMath::Abs(x)",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:6089,Availability,error,error,6089," TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208Double_t TMath::ErfInverse(Double_t x); 209{; 210 Int_t kMaxit = 50;; 211 Double_t kEps = 1e-14;; 212 Double_t kConst = 0.8862269254527579; // sqrt(pi)/2.0; 213 ; 214 if(TMath::Abs(x) <= kEps) return kConst*x;; 215 ; 216 // Newton iterations; 217 Double_t erfi, derfi, y0,y1,dy0,dy1;; 218 if(TMath::Abs(x) < 1.0) {; 219 erfi = kConst*TMath::Abs(x);; 220 y0 = TMath::Erf(0.9*erfi);; 221 derfi = 0.1*erfi;; 222 for (Int_t iter=0; iter<kMaxit; iter++) {; 223 y1 = 1. - TMath::Erfc(erfi);; 224 dy1 = TMath::Abs(x) - y1;; 225 if (TMath::Abs(dy1) < kEps) {if (x < 0) return -erfi; else return erfi;}; 226 dy0 = y1 - y0;; 227 derfi *= dy1/dy0;; 228 y0 = y1;; 229 erfi += derfi;; 230 if(TMath::Abs(derfi/erfi) < kEps) {if (x < 0) return -erfi; else return erfi;}; 231 }; 232 }; 233 return 0; //did not converge; 234}; 235",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:7090,Availability,error,error,7090,"dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208Double_t TMath::ErfInverse(Double_t x); 209{; 210 Int_t kMaxit = 50;; 211 Double_t kEps = 1e-14;; 212 Double_t kConst = 0.8862269254527579; // sqrt(pi)/2.0; 213 ; 214 if(TMath::Abs(x) <= kEps) return kConst*x;; 215 ; 216 // Newton iterations; 217 Double_t erfi, derfi, y0,y1,dy0,dy1;; 218 if(TMath::Abs(x) < 1.0) {; 219 erfi = kConst*TMath::Abs(x);; 220 y0 = TMath::Erf(0.9*erfi);; 221 derfi = 0.1*erfi;; 222 for (Int_t iter=0; iter<kMaxit; iter++) {; 223 y1 = 1. - TMath::Erfc(erfi);; 224 dy1 = TMath::Abs(x) - y1;; 225 if (TMath::Abs(dy1) < kEps) {if (x < 0) return -erfi; else return erfi;}; 226 dy0 = y1 - y0;; 227 derfi *= dy1/dy0;; 228 y0 = y1;; 229 erfi += derfi;; 230 if(TMath::Abs(derfi/erfi) < kEps) {if (x < 0) return -erfi; else return erfi;}; 231 }; 232 }; 233 return 0; //did not converge; 234}; 235 ; 236////////////////////////////////////////////////////////////////////////////////; 237/// Returns the inverse of the complementary error function.; 238/// x must be 0<x<2; 239/// implement using the quantile of the normal distribution; 240/// instead of ErfInverse for better numerical precision for large x; 241 ; 242Double_t TMath::ErfcInverse(Double_t x); 243{; 244 ; 245 // erfc-1(x) = - 1/sqrt(2) * normal_quantile( 0.5 * x); 246 return - 0.70710678118654752440 * TMath::NormQuantile( 0.5 * x);; 247}; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Computes factorial(n).; 251 ; 252Double_t TMath::Factorial(Int_t n); 253{; 254 if (n <= 0) return 1.;; 255 Double_t x = 1;; 256 Int_t b = 0;; 257 do {; 258 b++;; 259 x *= b;; 260 } while (b != n);; 261 return x;; 262}; 263 ; 264///////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:23872,Availability,error,error,23872,"713/// with coming from the same parent distribution, using the Kolmogorov test.; 714/// That is, it is used to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:29206,Availability,error,error,29206,"(rdmax,TMath::Abs(rdiff));; 855 }; 856 // Should never terminate this loop with ok = kFALSE!; 857 R__ASSERT(ok);; 858 ; 859 if (ok) {; 860 rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; 861 Double_t z = rdmax * TMath::Sqrt(rna*rnb/(rna+rnb));; 862 prob = TMath::KolmogorovProb(z);; 863 }; 864 // debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:29474,Availability,error,error,29474,"/ debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg == 0) { //pure gauss; 909 return 0.39894228 / sigma * TMath::Exp(-xx*xx / (2*sigma*sigma));; 910 }; 911 ; 912 Double_t x, y, k;; 913 x = xx / sigma / 1.41421356;; 914 y = lg / 2 / sigma / 1.41421356;; 915 ; 916 Double_t r0, r1;; 917 ; 918 if (r < 2) r = 2;; 919 if (r > 5) r = 5;; 920 ; 921 r",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:40674,Availability,avail,available,40674,"esulting sample quantiles are approximately unbiased, when; 1198/// the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);; 1199///; 1200/// default type = 7; 1201///; 1202/// ### References:; 1203/// 1. Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packages""; 1204/// American Statistician, 50, 361-365; 1205/// 2. R Project documentation for the function quantile of package {stats}; 1206 ; 1207void TMath::Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted, Int_t *index, Int_t type); 1208{; 1209 ; 1210 if (type<1 || type>9){; 1211 printf(""illegal value of type\n"");; 1212 return;; 1213 }; 1214 Int_t *ind = nullptr;; 1215 Bool_t isAllocated = kFALSE;; 1216 if (!isSorted){; 1217 if (index) ind = index;; 1218 else {; 1219 ind = new Int_t[n];; 1220 isAllocated = kTRUE;; 1221 }; 1222 }; 1223 ; 1224 // re-implemented by L.M (9/11/2011) to fix bug https://savannah.cern.ch/bugs/?87251; 1225 // following now exactly R implementation (available in library/stats/R/quantile.R ); 1226 // which follows precisely Hyndman-Fan paper; 1227 // (older implementation had a bug for type =3); 1228 ; 1229 for (Int_t i=0; i<nprob; i++){; 1230 ; 1231 Double_t nppm = 0;; 1232 Double_t gamma = 0;; 1233 Int_t j = 0;; 1234 ; 1235 //Discontinuous functions; 1236 // type = 1,2, or 3; 1237 if (type < 4 ){; 1238 if (type == 3); 1239 nppm = n*prob[i]-0.5; // use m = -0.5; 1240 else; 1241 nppm = n*prob[i]; // use m = 0; 1242 ; 1243 // be careful with machine precision; 1244 double eps = 4 * TMath::Limits<Double_t>::Epsilon();; 1245 j = TMath::FloorNint(nppm + eps);; 1246 ; 1247 // LM : fix for numerical problems if nppm is actually equal to j, but results different for numerical error; 1248 // g in the paper is nppm -j; 1249 if (type == 1); 1250 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0;; 1251 else if (type == 2); 1252 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0.5;; 1253 else i",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:41407,Availability,error,error,41407,"t isAllocated = kFALSE;; 1216 if (!isSorted){; 1217 if (index) ind = index;; 1218 else {; 1219 ind = new Int_t[n];; 1220 isAllocated = kTRUE;; 1221 }; 1222 }; 1223 ; 1224 // re-implemented by L.M (9/11/2011) to fix bug https://savannah.cern.ch/bugs/?87251; 1225 // following now exactly R implementation (available in library/stats/R/quantile.R ); 1226 // which follows precisely Hyndman-Fan paper; 1227 // (older implementation had a bug for type =3); 1228 ; 1229 for (Int_t i=0; i<nprob; i++){; 1230 ; 1231 Double_t nppm = 0;; 1232 Double_t gamma = 0;; 1233 Int_t j = 0;; 1234 ; 1235 //Discontinuous functions; 1236 // type = 1,2, or 3; 1237 if (type < 4 ){; 1238 if (type == 3); 1239 nppm = n*prob[i]-0.5; // use m = -0.5; 1240 else; 1241 nppm = n*prob[i]; // use m = 0; 1242 ; 1243 // be careful with machine precision; 1244 double eps = 4 * TMath::Limits<Double_t>::Epsilon();; 1245 j = TMath::FloorNint(nppm + eps);; 1246 ; 1247 // LM : fix for numerical problems if nppm is actually equal to j, but results different for numerical error; 1248 // g in the paper is nppm -j; 1249 if (type == 1); 1250 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0;; 1251 else if (type == 2); 1252 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0.5;; 1253 else if (type == 3); 1254 // gamma = 0 for g=0 and j even; 1255 gamma = ( TMath::Abs(nppm -j) <= j*TMath::Limits<Double_t>::Epsilon() && TMath::Even(j) ) ? 0 : 1;; 1256 ; 1257 }; 1258 else {; 1259 // for continuous quantiles type 4 to 9); 1260 // define alpha and beta; 1261 double a = 0;; 1262 double b = 0;; 1263 if (type == 4) { a = 0; b = 1; }; 1264 else if (type == 5) { a = 0.5; b = 0.5; }; 1265 else if (type == 6) { a = 0.; b = 0.; }; 1266 else if (type == 7) { a = 1.; b = 1.; }; 1267 else if (type == 8) { a = 1./3.; b = a; }; 1268 else if (type == 9) { a = 3./8.; b = a; }; 1269 ; 1270 // be careful with machine precision; 1271 double eps = 4 * TMath::Limits<Double_t>::Epsilon();; 1272 nppm = a + prob",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:86677,Availability,error,error,86677,"ouble_t f6 = 1.42151175831644588870e-7;; 2507 Double_t f7 = 2.04426310338993978564e-15;; 2508 ; 2509 Double_t split1 = 0.425;; 2510 Double_t split2=5.;; 2511 Double_t konst1=0.180625;; 2512 Double_t konst2=1.6;; 2513 ; 2514 Double_t q, r, quantile;; 2515 q=p-0.5;; 2516 if (TMath::Abs(q)<split1) {; 2517 r=konst1-q*q;; 2518 quantile = q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3); 2519 * r + a2) * r + a1) * r + a0) /; 2520 (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3); 2521 * r + b2) * r + b1) * r + 1.);; 2522 } else {; 2523 if(q<0) r=p;; 2524 else r=1-p;; 2525 //error case; 2526 if (r<=0); 2527 quantile=0;; 2528 else {; 2529 r=TMath::Sqrt(-TMath::Log(r));; 2530 if (r<=split2) {; 2531 r=r-konst2;; 2532 quantile=(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3); 2533 * r + c2) * r + c1) * r + c0) /; 2534 (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3); 2535 * r + d2) * r + d1) * r + 1);; 2536 } else{; 2537 r=r-split2;; 2538 quantile=(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3); 2539 * r + e2) * r + e1) * r + e0) /; 2540 (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3); 2541 * r + f2) * r + f1) * r + 1);; 2542 }; 2543 if (q<0) quantile=-quantile;; 2544 }; 2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:88413,Availability,down,downward,88413,"2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find lower right element higher than the lower; 2573 // element of the upward transition; 2574 for(i=n-1;i>i1;i--) {; 2575 if(a[i] > a[i1]) {; 2576 // swap the two; 2577 itmp=a[i1];; 2578 a[i1]=a[i];; 2579 a[i]=itmp;; 2580 break;; 2581 }; 2582 }; 2583 // order the rest, in fact just invert, as there; 2584 // are only downward transitions from here on; 2585 for(i=0;i<(n-i1-1)/2;i++) {; 2586 itmp=a[i1+i+1];; 2587 a[i1+i+1]=a[n-i-1];; 2588 a[n-i-1]=itmp;; 2589 }; 2590 }; 2591 return kTRUE;; 2592}; 2593 ; 2594////////////////////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between t",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:114217,Availability,error,error,114217,"10// template ROOT::Double_v vecCore::math::Cbrt(const ROOT::Double_v & x);; 3211#endif; PdfFuncMathCore.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; NamespaceImp#define NamespaceImp(name)Definition Rtypes.h:398; SpecFuncMathCore.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; delOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t delDefinition TGWin32VirtualXProxy.cxx:188; rOption_t Option_t TPoint TPoint co",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:114483,Availability,error,error,114483,"xx:105; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; NamespaceImp#define NamespaceImp(name)Definition Rtypes.h:398; SpecFuncMathCore.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; delOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t delDefinition TGWin32VirtualXProxy.cxx:188; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude G",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:122179,Availability,error,error,122179," over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Comp",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:125102,Availability,error,error,125102,"'s t- distribution (the probability function (integral of densit...Definition TMath.cxx:2623; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::BetaDistIDouble_t BetaDistI(Double_t x, Double_t p, Double_t q)Computes the cumulative distribution function of the Beta distribution, i.e.Definition TMath.cxx:2090; TMath::FloorNintInt_t FloorNint(Double_t x)Returns the nearest integer of TMath::Floor(x).Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:125515,Availability,error,error,125515,".Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MinShort_t Min(Short_t a, Short_t b)Retur",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:131263,Availability,error,error,131263,"_t)Returns the area hyperbolic tangent of x.Definition TMath.cxx:95; TMath::BesselI0Double_t BesselI0(Double_t x)Integer order modified Bessel function K_n(x)Definition TMath.cxx:1426; TMath::VavilovSetvoid VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt)Internal function, called by Vavilov and VavilovI.Definition TMath.cxx:2854; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::StudentIDouble_t StudentI(Double_t T, Double_t ndf)Calculates the cumulative distribution function of Student's t-distribution second parameter stands f...Definition TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath::ErfcInverseDouble_t ErfcInverse(Double_t x)Returns the inverse of the complementary error function.Definition TMath.cxx:242; TMath::EvenBool_t Even(Long_t a)Returns true if a is even.Definition TMathBase.h:113; v@ vDefinition rootcling_impl.cxx:3699; TMath::LimitsDefinition TMath.h:407; TMath::Limits::Epsilonstatic T Epsilon()Returns minimum double representation.Definition TMath.h:941; mTMarker mDefinition textangle.C:8; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoresrcTMath.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24136,Deployability,integrat,integrated,24136,"ays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; bre",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:39086,Deployability,continuous,continuous,39086," ; 1166////////////////////////////////////////////////////////////////////////////////; 1167///Computes sample quantiles, corresponding to the given probabilities; 1168///; 1169/// \param[in] x the data sample; 1170/// \param[in] n its size; 1171/// \param[out] quantiles computed quantiles are returned in there; 1172/// \param[in] prob probabilities where to compute quantiles; 1173/// \param[in] nprob size of prob array; 1174/// \param[in] isSorted is the input array x sorted ?; 1175/// \param[in] index parameter index; 1176/// \param[in] type method to compute (from 1 to 9).; 1177///; 1178/// #### NOTE:; 1179/// When the input is not sorted, an array of integers of size n needs; 1180/// to be allocated. It can be passed by the user in parameter index,; 1181/// or, if not passed, it will be allocated inside the function; 1182///; 1183/// ### Following types are provided:; 1184/// - Discontinuous:; 1185/// - type=1 - inverse of the empirical distribution function; 1186/// - type=2 - like type 1, but with averaging at discontinuities; 1187/// - type=3 - SAS definition: nearest even order statistic; 1188/// - Piecewise linear continuous:; 1189/// - In this case, sample quantiles can be obtained by linear interpolation; 1190/// between the k-th order statistic and p(k).; 1191/// -type=4 - linear interpolation of empirical cdf, p(k)=k/n;; 1192/// - type=5 - a very popular definition, p(k) = (k-0.5)/n;; 1193/// - type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; 1194/// - type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; 1195/// - type=8 - resulting sample quantiles are approximately median unbiased; 1196/// regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; 1197/// - type=9 - resulting sample quantiles are approximately unbiased, when; 1198/// the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);; 1199///; 1200/// default type = 7; 1201///; 1202/// ### References:; 1203/// 1. Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packa",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:41859,Deployability,continuous,continuous,41859,"t_t i=0; i<nprob; i++){; 1230 ; 1231 Double_t nppm = 0;; 1232 Double_t gamma = 0;; 1233 Int_t j = 0;; 1234 ; 1235 //Discontinuous functions; 1236 // type = 1,2, or 3; 1237 if (type < 4 ){; 1238 if (type == 3); 1239 nppm = n*prob[i]-0.5; // use m = -0.5; 1240 else; 1241 nppm = n*prob[i]; // use m = 0; 1242 ; 1243 // be careful with machine precision; 1244 double eps = 4 * TMath::Limits<Double_t>::Epsilon();; 1245 j = TMath::FloorNint(nppm + eps);; 1246 ; 1247 // LM : fix for numerical problems if nppm is actually equal to j, but results different for numerical error; 1248 // g in the paper is nppm -j; 1249 if (type == 1); 1250 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0;; 1251 else if (type == 2); 1252 gamma = ( (nppm -j) > j*TMath::Limits<Double_t>::Epsilon() ) ? 1 : 0.5;; 1253 else if (type == 3); 1254 // gamma = 0 for g=0 and j even; 1255 gamma = ( TMath::Abs(nppm -j) <= j*TMath::Limits<Double_t>::Epsilon() && TMath::Even(j) ) ? 0 : 1;; 1256 ; 1257 }; 1258 else {; 1259 // for continuous quantiles type 4 to 9); 1260 // define alpha and beta; 1261 double a = 0;; 1262 double b = 0;; 1263 if (type == 4) { a = 0; b = 1; }; 1264 else if (type == 5) { a = 0.5; b = 0.5; }; 1265 else if (type == 6) { a = 0.; b = 0.; }; 1266 else if (type == 7) { a = 1.; b = 1.; }; 1267 else if (type == 8) { a = 1./3.; b = a; }; 1268 else if (type == 9) { a = 3./8.; b = a; }; 1269 ; 1270 // be careful with machine precision; 1271 double eps = 4 * TMath::Limits<Double_t>::Epsilon();; 1272 nppm = a + prob[i] * ( n + 1 -a -b); // n * p + m; 1273 j = TMath::FloorNint(nppm + eps);; 1274 gamma = nppm - j;; 1275 if (gamma < eps) gamma = 0;; 1276 }; 1277 ; 1278 // since index j starts from 1 first is j-1 and second is j; 1279 // add protection to keep indices in range [0,n-1]; 1280 int first = (j > 0 && j <=n) ? j-1 : ( j <=0 ) ? 0 : n-1;; 1281 int second = (j > 0 && j < n) ? j : ( j <=0 ) ? 0 : n-1;; 1282 ; 1283 Double_t xj, xjj;; 1284 if (isSorted){; 1285 xj = x[first];; 1",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:71616,Deployability,continuous,continuous,71616,"n, j)**TMath::Power (p, j)*TMath::Power (1-p, n-j); 2131/// ~~~; 2132/// For _n_ larger than 12 BetaIncomplete is a much better way; 2133/// to evaluate the sum than would be the straightforward sum calculation; 2134/// for _n_ smaller than 12 either method is acceptable (""Numerical Recipes""); 2135///; 2136/// Note this function is not exactly implementing the cumulative or the complement of the cumulative of the; 2137/// Binomial distrinution. It is equivalent to ROOT::Math::binomial_cdf_c(k-1,p,n); 2138///; 2139/// \author Anna Kreshuk; 2140 ; 2141Double_t TMath::BinomialI(Double_t p, Int_t n, Int_t k); 2142{; 2143 if(k <= 0) return 1.0;; 2144 if(k > n) return 0.0;; 2145 if(k == n) return TMath::Power(p, n);; 2146 ; 2147 return BetaIncomplete(p, Double_t(k), Double_t(n-k+1));; 2148}; 2149 ; 2150////////////////////////////////////////////////////////////////////////////////; 2151/// Computes the density of Cauchy distribution at point x; 2152/// by default, standard Cauchy distribution is used (t=0, s=1); 2153/// - t is the location parameter; 2154/// - s is the scale parameter; 2155///; 2156/// The Cauchy distribution, also called Lorentzian distribution,; 2157/// is a continuous distribution describing resonance behavior; 2158/// The mean and standard deviation of the Cauchy distribution are undefined.; 2159/// The practical meaning of this is that collecting 1,000 data points gives; 2160/// no more accurate an estimate of the mean and standard deviation than; 2161/// does a single point.; 2162/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2163/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm; 2164///; 2165/// Example:; 2166///; 2167/// ~~~ {cpp}; 2168/// TF1* fc = new TF1(""fc"", ""TMath::CauchyDist(x, [0], [1])"", -5, 5);; 2169/// fc->SetParameters(0, 1);; 2170/// fc->Draw();; 2171/// ~~~; 2172///; 2173/// \author Anna Kreshuk; 2174 ; 2175Double_t TMath::CauchyDist(Double_t x, Double_t t, Double_t s); 2176{; 2177 Doubl",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:15659,Energy Efficiency,adapt,adapted,15659," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:20905,Energy Efficiency,power,powerful,20905,"ct model should be less than the value chi2.; 630///; 631/// The returned probability corresponds to 1-P(a,x),; 632/// which denotes the probability that an observed Chi-squared exceeds; 633/// the value chi2 by chance, even for a correct model.; 634///; 635/// \author NvE 14-nov-1998 UU-SAP Utrecht; 636 ; 637Double_t TMath::Prob(Double_t chi2,Int_t ndf); 638{; 639 if (ndf <= 0) return 0; // Set CL to zero in case ndf<=0; 640 ; 641 if (chi2 <= 0) {; 642 if (chi2 < 0) return 0;; 643 else return 1;; 644 }; 645 ; 646 return ::ROOT::Math::chisquared_cdf_c(chi2,ndf);; 647}; 648 ; 649////////////////////////////////////////////////////////////////////////////////; 650/// Calculates the Kolmogorov distribution function,; 651///; 652/// \f[; 653/// P(z) = 2 \sum_{j=1}^{\infty} (-1)^{j-1} e^{-2 j^2 z^2}; 654/// \f]; 655///; 656/// which gives the probability that Kolmogorov's test statistic will exceed; 657/// the value z assuming the null hypothesis. This gives a very powerful; 658/// test for comparing two one-dimensional distributions.; 659/// see, for example, Eadie et al, ""statistical Methods in Experimental; 660/// Physics', pp 269-270).; 661///; 662/// This function returns the confidence level for the null hypothesis, where:; 663/// - \f$ z = dn \sqrt{n} \f$, and; 664/// - \f$ dn \f$ is the maximum deviation between a hypothetical distribution; 665/// function and an experimental distribution with; 666/// - \f$ n \f$ events; 667///; 668/// NOTE: To compare two experimental distributions with m and n events,; 669/// use \f$ z = \sqrt{m n/(m+n)) dn} \f$; 670///; 671/// Accuracy: The function is far too accurate for any imaginable application.; 672/// Probabilities less than \f$ 10^{-15} \f$ are returned as zero.; 673/// However, remember that the formula is only valid for ""large"" n.; 674///; 675/// Theta function inversion formula is used for z <= 1; 676///; 677/// This function was translated by Rene Brun from PROBKL in CERNLIB.; 678 ; 679Double_t TMath::KolmogorovProb",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24265,Energy Efficiency,adapt,adapted,24265,"ing to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; break;}; 761/// } else {; 762/// rdiff += sb - sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > n",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:29386,Energy Efficiency,adapt,adapted,29386,"*rnb/(rna+rnb));; 862 prob = TMath::KolmogorovProb(z);; 863 }; 864 // debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg == 0) { //pure gauss; 909 return 0.39894228 / sigma * TMath::Exp(-xx*xx / (2*sigma*sigma));; 910 }; 911 ; 912 Double_t x, y, k;; 913 x = xx / sigma / 1.41421356;; 914 y = lg / 2 / sigma / 1.41421356;; 915 ; 916 Double_t r0, ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:38648,Energy Efficiency,allocate,allocated,38648,"hi/3;; 1150 pis3 = TMath::Pi()/3;; 1151 c1 = TMath::Cos(phis3);; 1152 c2 = TMath::Cos(pis3 + phis3);; 1153 c3 = TMath::Cos(pis3 - phis3);; 1154 tmp = TMath::Sqrt(ps3);; 1155 y1 = 2*tmp*c1;; 1156 y2 = -2*tmp*c2;; 1157 y3 = -2*tmp*c3;; 1158 tmp = r/3;; 1159 a = y1 - tmp;; 1160 b = y2 - tmp;; 1161 c = y3 - tmp;; 1162 }; 1163 return complex;; 1164}; 1165 ; 1166////////////////////////////////////////////////////////////////////////////////; 1167///Computes sample quantiles, corresponding to the given probabilities; 1168///; 1169/// \param[in] x the data sample; 1170/// \param[in] n its size; 1171/// \param[out] quantiles computed quantiles are returned in there; 1172/// \param[in] prob probabilities where to compute quantiles; 1173/// \param[in] nprob size of prob array; 1174/// \param[in] isSorted is the input array x sorted ?; 1175/// \param[in] index parameter index; 1176/// \param[in] type method to compute (from 1 to 9).; 1177///; 1178/// #### NOTE:; 1179/// When the input is not sorted, an array of integers of size n needs; 1180/// to be allocated. It can be passed by the user in parameter index,; 1181/// or, if not passed, it will be allocated inside the function; 1182///; 1183/// ### Following types are provided:; 1184/// - Discontinuous:; 1185/// - type=1 - inverse of the empirical distribution function; 1186/// - type=2 - like type 1, but with averaging at discontinuities; 1187/// - type=3 - SAS definition: nearest even order statistic; 1188/// - Piecewise linear continuous:; 1189/// - In this case, sample quantiles can be obtained by linear interpolation; 1190/// between the k-th order statistic and p(k).; 1191/// -type=4 - linear interpolation of empirical cdf, p(k)=k/n;; 1192/// - type=5 - a very popular definition, p(k) = (k-0.5)/n;; 1193/// - type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; 1194/// - type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; 1195/// - type=8 - resulting sample quantiles are approximately median unbiased; 1196/// regardless of ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:38747,Energy Efficiency,allocate,allocated,38747," ; 1166////////////////////////////////////////////////////////////////////////////////; 1167///Computes sample quantiles, corresponding to the given probabilities; 1168///; 1169/// \param[in] x the data sample; 1170/// \param[in] n its size; 1171/// \param[out] quantiles computed quantiles are returned in there; 1172/// \param[in] prob probabilities where to compute quantiles; 1173/// \param[in] nprob size of prob array; 1174/// \param[in] isSorted is the input array x sorted ?; 1175/// \param[in] index parameter index; 1176/// \param[in] type method to compute (from 1 to 9).; 1177///; 1178/// #### NOTE:; 1179/// When the input is not sorted, an array of integers of size n needs; 1180/// to be allocated. It can be passed by the user in parameter index,; 1181/// or, if not passed, it will be allocated inside the function; 1182///; 1183/// ### Following types are provided:; 1184/// - Discontinuous:; 1185/// - type=1 - inverse of the empirical distribution function; 1186/// - type=2 - like type 1, but with averaging at discontinuities; 1187/// - type=3 - SAS definition: nearest even order statistic; 1188/// - Piecewise linear continuous:; 1189/// - In this case, sample quantiles can be obtained by linear interpolation; 1190/// between the k-th order statistic and p(k).; 1191/// -type=4 - linear interpolation of empirical cdf, p(k)=k/n;; 1192/// - type=5 - a very popular definition, p(k) = (k-0.5)/n;; 1193/// - type=6 - used by Minitab and SPSS, p(k) = k/(n+1);; 1194/// - type=7 - used by S-Plus and R, p(k) = (k-1)/(n-1);; 1195/// - type=8 - resulting sample quantiles are approximately median unbiased; 1196/// regardless of the distribution of x. p(k) = (k-1/3)/(n+1/3);; 1197/// - type=9 - resulting sample quantiles are approximately unbiased, when; 1198/// the sample comes from Normal distribution. p(k)=(k-3/8)/(n+1/4);; 1199///; 1200/// default type = 7; 1201///; 1202/// ### References:; 1203/// 1. Hyndman, R.J and Fan, Y, (1996) ""Sample quantiles in statistical packa",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:87547,Energy Efficiency,adapt,adapted,87547,"ouble_t f6 = 1.42151175831644588870e-7;; 2507 Double_t f7 = 2.04426310338993978564e-15;; 2508 ; 2509 Double_t split1 = 0.425;; 2510 Double_t split2=5.;; 2511 Double_t konst1=0.180625;; 2512 Double_t konst2=1.6;; 2513 ; 2514 Double_t q, r, quantile;; 2515 q=p-0.5;; 2516 if (TMath::Abs(q)<split1) {; 2517 r=konst1-q*q;; 2518 quantile = q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3); 2519 * r + a2) * r + a1) * r + a0) /; 2520 (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3); 2521 * r + b2) * r + b1) * r + 1.);; 2522 } else {; 2523 if(q<0) r=p;; 2524 else r=1-p;; 2525 //error case; 2526 if (r<=0); 2527 quantile=0;; 2528 else {; 2529 r=TMath::Sqrt(-TMath::Log(r));; 2530 if (r<=split2) {; 2531 r=r-konst2;; 2532 quantile=(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3); 2533 * r + c2) * r + c1) * r + c0) /; 2534 (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3); 2535 * r + d2) * r + d1) * r + 1);; 2536 } else{; 2537 r=r-split2;; 2538 quantile=(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3); 2539 * r + e2) * r + e1) * r + e0) /; 2540 (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3); 2541 * r + f2) * r + f1) * r + 1);; 2542 }; 2543 if (q<0) quantile=-quantile;; 2544 }; 2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:121992,Energy Efficiency,power,power,121992,"(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:126212,Energy Efficiency,power,power,126212," LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::GamCfDouble_t GamCf(Double_t a, Double_t x)Computation of the incomplete gamma function P(a,x) via its continued fraction representation.Definition TMath.cxx:380; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:792,Integrability,rout,routines,792,". ROOT: math/mathcore/src/TMath.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMath.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: Rene Brun, Anna Kreshuk, Eddy Offermann, Fons Rademakers 29/07/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12////////////////////////////////////////////////////////////////////////////////; 13// TMath; 14//; 15// Encapsulate math routines.; 16 ; 17#include ""TMath.h""; 18#include ""TError.h""; 19#include <cmath>; 20#include <cstring>; 21#include <algorithm>; 22#include <iostream>; 23#include ""TString.h""; 24 ; 25#include <Math/SpecFuncMathCore.h>; 26#include <Math/PdfFuncMathCore.h>; 27#include <Math/ProbFuncMathCore.h>; 28 ; 29//const Double_t; 30// TMath::Pi = 3.14159265358979323846,; 31// TMath::E = 2.7182818284590452354;; 32 ; 33 ; 34// Without this macro the THtml doc for TMath can not be generated; 35#if !defined(R__SOLARIS) && !defined(R__ACC) && !defined(R__FBSD); 36NamespaceImp(TMath); 37#endif; 38 ; 39namespace TMath {; 40 ; 41 Double_t GamCf(Double_t a,Double_t x);; 42 Double_t GamSer(Double_t a,Double_t x);; 43 Double_t VavilovDenEval(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype);; 44 void VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt);; 45 ; 46}; 47 ; 48////////////////////////////////////////////////////////////////////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56///////////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:15684,Integrability,rout,routine,15684," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24136,Integrability,integrat,integrated,24136,"ays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; bre",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24299,Integrability,rout,routine,24299,"ing to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; break;}; 761/// } else {; 762/// rdiff += sb - sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > n",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:32431,Integrability,depend,dependents,32431,"z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point in Region 3; 998 rg3 = 0;; 999 z0 = 272.1014 + y * (1280.829 + y *; 1000 (2802.870 + y *; 1001 (3764.966 + y *; 1002 (3447.629 + y *; 1003 (2256.981 + y *; 1004 (1074.409 + y *; 1005 (369.1989 + y *; 1006 (88.26741 + y *; 1007 (",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:32760,Integrability,depend,dependents,32760,= 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point in Region 3; 998 rg3 = 0;; 999 z0 = 272.1014 + y * (1280.829 + y *; 1000 (2802.870 + y *; 1001 (3764.966 + y *; 1002 (3447.629 + y *; 1003 (2256.981 + y *; 1004 (1074.409 + y *; 1005 (369.1989 + y *; 1006 (88.26741 + y *; 1007 (13.39880 + y); 1008 )))))))); // Region 3 y-dependents; 1009 z2 = 211.678 + y * (902.3066 + y *; 1010 (1758.336 + y *; 1011 (2037.310 + y *; 1012 (1549.675 + y *; 1013 (793.4273 + y *; 1014 (266.2987 + y *; 1015 (53.59518 + y * 5.0); 1016 ))))));; 1017 z4 = 78.86585 + y * (308.1852 + y *; 1018 (497.3014 + y ,MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:33492,Integrability,depend,dependents,33492, 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point in Region 3; 998 rg3 = 0;; 999 z0 = 272.1014 + y * (1280.829 + y *; 1000 (2802.870 + y *; 1001 (3764.966 + y *; 1002 (3447.629 + y *; 1003 (2256.981 + y *; 1004 (1074.409 + y *; 1005 (369.1989 + y *; 1006 (88.26741 + y *; 1007 (13.39880 + y); 1008 )))))))); // Region 3 y-dependents; 1009 z2 = 211.678 + y * (902.3066 + y *; 1010 (1758.336 + y *; 1011 (2037.310 + y *; 1012 (1549.675 + y *; 1013 (793.4273 + y *; 1014 (266.2987 + y *; 1015 (53.59518 + y * 5.0); 1016 ))))));; 1017 z4 = 78.86585 + y * (308.1852 + y *; 1018 (497.3014 + y *; 1019 (479.2576 + y *; 1020 (269.2916 + y *; 1021 (80.39278 + y * 10.0); 1022 ))));; 1023 z6 = 22.03523 + y * (55.02933 + y *; 1024 (92.75679 + y *; 1025 (53.59518 + y * 10.0); 1026 ));; 1027 z8 = 1.496460 + y * (13.39880 + y * 5.0);; 1028 p0 = 153.5168 + y * (549.3954 + y *; 1029 (919.4955 + y *; 1030 (946.8970 + y *; 1031 (662.8097 + y *; 1032 (328.2151 + y *; 1033 (115.3772 + y *; 1034 (27.93941 + y *; 1035 (4.264678 + y * 0.3183291); 1036 )))))));; 1037 p2 = -34.16955 + y * (-1.322256+ y *; 1038 (124.5975 + y *; 1039 (189.7730 + y *; 1040 (139.4665 + y *; 1041 (56.81652 + y *; 1042 (12.79458 + y * 1.2733163); 1043 )))));; 1044 p4 = 2.584042 + y * (10.46332 + y *; 1045 (24.01655 + y *; 1046 (29.81482 + y *; 1047 (,MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:87568,Integrability,rout,routine,87568,"ouble_t f6 = 1.42151175831644588870e-7;; 2507 Double_t f7 = 2.04426310338993978564e-15;; 2508 ; 2509 Double_t split1 = 0.425;; 2510 Double_t split2=5.;; 2511 Double_t konst1=0.180625;; 2512 Double_t konst2=1.6;; 2513 ; 2514 Double_t q, r, quantile;; 2515 q=p-0.5;; 2516 if (TMath::Abs(q)<split1) {; 2517 r=konst1-q*q;; 2518 quantile = q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3); 2519 * r + a2) * r + a1) * r + a0) /; 2520 (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3); 2521 * r + b2) * r + b1) * r + 1.);; 2522 } else {; 2523 if(q<0) r=p;; 2524 else r=1-p;; 2525 //error case; 2526 if (r<=0); 2527 quantile=0;; 2528 else {; 2529 r=TMath::Sqrt(-TMath::Log(r));; 2530 if (r<=split2) {; 2531 r=r-konst2;; 2532 quantile=(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3); 2533 * r + c2) * r + c1) * r + c0) /; 2534 (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3); 2535 * r + d2) * r + d1) * r + 1);; 2536 } else{; 2537 r=r-split2;; 2538 quantile=(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3); 2539 * r + e2) * r + e1) * r + e0) /; 2540 (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3); 2541 * r + f2) * r + f1) * r + 1);; 2542 }; 2543 if (q<0) quantile=-quantile;; 2544 }; 2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:114357,Integrability,message,messages,114357,"RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; NamespaceImp#define NamespaceImp(name)Definition Rtypes.h:398; SpecFuncMathCore.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; delOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t delDefinition TGWin32VirtualXProxy.cxx:188; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t Win",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:15659,Modifiability,adapt,adapted,15659," kFALSE) the result is divided; 469/// by sqrt(2*Pi)*sigma.; 470 ; 471Double_t TMath::Gaus(Double_t x, Double_t mean, Double_t sigma, Bool_t norm); 472{; 473 if (sigma == 0) return 1.e30;; 474 Double_t arg = (x-mean)/sigma;; 475 // for |arg| > 39 result is zero in double precision; 476 if (arg < -39.0 || arg > 39.0) return 0.0;; 477 Double_t res = TMath::Exp(-0.5*arg*arg);; 478 if (!norm) return res;; 479 return res/(2.50662827463100024*sigma); //sqrt(2*Pi)=2.50662827463100024; 480}; 481 ; 482////////////////////////////////////////////////////////////////////////////////; 483/// The LANDAU function.; 484///; 485/// mu is a location parameter and correspond approximately to the most probable value; 486/// and sigma is a scale parameter (not the sigma of the full distribution which is not defined); 487/// Note that for mu=0 and sigma=1 (default values) the exact location of the maximum of the distribution; 488/// (most proper value) is at x = -0.22278; 489/// This function has been adapted from the CERNLIB routine G110 denlan.; 490/// If norm=kTRUE (default is kFALSE) the result is divided by sigma; 491 ; 492Double_t TMath::Landau(Double_t x, Double_t mu, Double_t sigma, Bool_t norm); 493{; 494 if (sigma <= 0) return 0;; 495 Double_t den = ::ROOT::Math::landau_pdf( (x-mu)/sigma );; 496 if (!norm) return den;; 497 return den/sigma;; 498}; 499 ; 500////////////////////////////////////////////////////////////////////////////////; 501/// Computation of ln[gamma(z)] for all z.; 502///; 503/// C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86.; 504///; 505/// The accuracy of the result is better than 2e-10.; 506///; 507/// \author NvE 14-nov-1998 UU-SAP Utrecht; 508 ; 509Double_t TMath::LnGamma(Double_t z); 510{; 511 return ::ROOT::Math::lgamma(z);; 512}; 513 ; 514////////////////////////////////////////////////////////////////////////////////; 515/// Normalize a vector v in place.; 516/// Returns the norm of the original vector.; 517 ; 518Float_t TMath::Normaliz",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24265,Modifiability,adapt,adapted,24265,"ing to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; break;}; 761/// } else {; 762/// rdiff += sb - sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > n",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:29386,Modifiability,adapt,adapted,29386,"*rnb/(rna+rnb));; 862 prob = TMath::KolmogorovProb(z);; 863 }; 864 // debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg == 0) { //pure gauss; 909 return 0.39894228 / sigma * TMath::Exp(-xx*xx / (2*sigma*sigma));; 910 }; 911 ; 912 Double_t x, y, k;; 913 x = xx / sigma / 1.41421356;; 914 y = lg / 2 / sigma / 1.41421356;; 915 ; 916 Double_t r0, ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:31061,Modifiability,variab,variables,31061,"0 * exp(0.554 * (Double_t)r);; 923 ; 924 // Constants; 925 ; 926 const Double_t rrtpi = 0.56418958; // 1/SQRT(pi); 927 ; 928 Double_t y0, y0py0, y0q; // for CPF12 algorithm; 929 y0 = 1.5;; 930 y0py0 = y0 + y0;; 931 y0q = y0 * y0;; 932 ; 933 Double_t c[6] = { 1.0117281, -0.75197147, 0.012557727, 0.010022008, -0.00024206814, 0.00000050084806};; 934 Double_t s[6] = { 1.393237, 0.23115241, -0.15535147, 0.0062183662, 0.000091908299, -0.00000062752596};; 935 Double_t t[6] = { 0.31424038, 0.94778839, 1.5976826, 2.2795071, 3.0206370, 3.8897249};; 936 ; 937 // Local variables; 938 ; 939 int j; // Loop variables; 940 int rg1, rg2, rg3; // y polynomial flags; 941 Double_t abx, xq, yq, yrrtpi; // --x--, x^2, y^2, y/SQRT(pi); 942 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:31097,Modifiability,variab,variables,31097,"0 * exp(0.554 * (Double_t)r);; 923 ; 924 // Constants; 925 ; 926 const Double_t rrtpi = 0.56418958; // 1/SQRT(pi); 927 ; 928 Double_t y0, y0py0, y0q; // for CPF12 algorithm; 929 y0 = 1.5;; 930 y0py0 = y0 + y0;; 931 y0q = y0 * y0;; 932 ; 933 Double_t c[6] = { 1.0117281, -0.75197147, 0.012557727, 0.010022008, -0.00024206814, 0.00000050084806};; 934 Double_t s[6] = { 1.393237, 0.23115241, -0.15535147, 0.0062183662, 0.000091908299, -0.00000062752596};; 935 Double_t t[6] = { 0.31424038, 0.94778839, 1.5976826, 2.2795071, 3.0206370, 3.8897249};; 936 ; 937 // Local variables; 938 ; 939 int j; // Loop variables; 940 int rg1, rg2, rg3; // y polynomial flags; 941 Double_t abx, xq, yq, yrrtpi; // --x--, x^2, y^2, y/SQRT(pi); 942 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:31387,Modifiability,variab,variables,31387,"0 * exp(0.554 * (Double_t)r);; 923 ; 924 // Constants; 925 ; 926 const Double_t rrtpi = 0.56418958; // 1/SQRT(pi); 927 ; 928 Double_t y0, y0py0, y0q; // for CPF12 algorithm; 929 y0 = 1.5;; 930 y0py0 = y0 + y0;; 931 y0q = y0 * y0;; 932 ; 933 Double_t c[6] = { 1.0117281, -0.75197147, 0.012557727, 0.010022008, -0.00024206814, 0.00000050084806};; 934 Double_t s[6] = { 1.393237, 0.23115241, -0.15535147, 0.0062183662, 0.000091908299, -0.00000062752596};; 935 Double_t t[6] = { 0.31424038, 0.94778839, 1.5976826, 2.2795071, 3.0206370, 3.8897249};; 936 ; 937 // Local variables; 938 ; 939 int j; // Loop variables; 940 int rg1, rg2, rg3; // y polynomial flags; 941 Double_t abx, xq, yq, yrrtpi; // --x--, x^2, y^2, y/SQRT(pi); 942 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:53055,Modifiability,enhance,enhance,53055,",2,... and positive real x.; 1558///; 1559/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1560 ; 1561Double_t TMath::BesselK(Int_t n,Double_t x); 1562{; 1563 if (x <= 0 || n < 0) {; 1564 Error(""TMath::BesselK"", ""*K* Invalid argument(s) (n,x) = (%d, %g)\n"",n,x);; 1565 return 0;; 1566 }; 1567 ; 1568 if (n==0) return TMath::BesselK0(x);; 1569 if (n==1) return TMath::BesselK1(x);; 1570 ; 1571 // Perform upward recurrence for all x; 1572 Double_t tox = 2/x;; 1573 Double_t bkm = TMath::BesselK0(x);; 1574 Double_t bk = TMath::BesselK1(x);; 1575 Double_t bkp = 0;; 1576 for (Int_t j=1; j<n; j++) {; 1577 bkp = bkm+Double_t(j)*tox*bk;; 1578 bkm = bk;; 1579 bk = bkp;; 1580 }; 1581 return bk;; 1582}; 1583 ; 1584////////////////////////////////////////////////////////////////////////////////; 1585/// Computes the Integer Order Modified Bessel function I_n(x); 1586/// for n=0,1,2,... and any real x.; 1587///; 1588/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1589 ; 1590Double_t TMath::BesselI(Int_t n,Double_t x); 1591{; 1592 Int_t iacc = 40; // Increase to enhance accuracy; 1593 const Double_t kBigPositive = 1.e10;; 1594 const Double_t kBigNegative = 1.e-10;; 1595 ; 1596 if (n < 0) {; 1597 Error(""TMath::BesselI"", ""*I* Invalid argument (n,x) = (%d, %g)\n"",n,x);; 1598 return 0;; 1599 }; 1600 ; 1601 if (n==0) return TMath::BesselI0(x);; 1602 if (n==1) return TMath::BesselI1(x);; 1603 ; 1604 if (x == 0) return 0;; 1605 if (TMath::Abs(x) > kBigPositive) return 0;; 1606 ; 1607 Double_t tox = 2/TMath::Abs(x);; 1608 Double_t bip = 0, bim = 0;; 1609 Double_t bi = 1;; 1610 Double_t result = 0;; 1611 Int_t m = 2*((n+Int_t(sqrt(Float_t(iacc*n)))));; 1612 for (Int_t j=m; j>=1; j--) {; 1613 bim = bip+Double_t(j)*tox*bi;; 1614 bip = bi;; 1615 bi = bim;; 1616 // Renormalise to prevent overflows; 1617 if (TMath::Abs(bi) > kBigPositive) {; 1618 result *= kBigNegative;; 1619 bi *= kBigNegative;; 1620 bip *= kBigNegative;; 1621 }; 1622 if (j==n) result=bip;; 1623 }; 1624 ; 1625 result *= TMath::BesselI0(x)",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:75968,Modifiability,variab,variable,75968,"; 2247 s1 = (c[19] + a * (c[17] + a * (c[14] + a * (c[13] + a * (c[12] +c[11] * a))))) / c[24];; 2248 s2 = (c[24] + a * (c[29] + a * (c[32] + a * (c[33] + c[35] * a)))) / c[37];; 2249 s3 = (c[19] + a * (c[25] + a * (c[28] + c[31] * a))) / c[37];; 2250 s4 = (c[20] + a * (c[27] + c[34] * a) + cp * (c[22] + a * (c[30] + c[36] * a))) / c[38];; 2251 s5 = (c[13] + c[21] * a + cp * (c[18] + c[26] * a)) / c[37];; 2252 s6 = (c[15] + cp * (c[23] + c[16] * cp)) / c[38];; 2253 ch = ch + t * (1 + 0.5 * t * s1 - b * cp * (s1 - b * (s2 - b * (s3 - b * (s4 - b * (s5 - b * s6))))));; 2254 if (TMath::Abs(q / ch - 1) > e) break;; 2255 }; 2256 return ch;; 2257}; 2258 ; 2259////////////////////////////////////////////////////////////////////////////////; 2260/// Computes the density function of F-distribution; 2261/// (probability function, integral of density, is computed in FDistI).; 2262///; 2263/// Parameters N and M stand for degrees of freedom of chi-squares; 2264/// mentioned above parameter F is the actual variable x of the; 2265/// density function p(x) and the point at which the density function; 2266/// is calculated.; 2267///; 2268/// ### About F distribution:; 2269/// F-distribution arises in testing whether two random samples; 2270/// have the same variance. It is the ratio of two chi-square; 2271/// distributions, with N and M degrees of freedom respectively,; 2272/// where each chi-square is first divided by it's number of degrees; 2273/// of freedom.; 2274///; 2275/// \author Anna Kreshuk; 2276 ; 2277Double_t TMath::FDist(Double_t F, Double_t N, Double_t M); 2278{; 2279 return ::ROOT::Math::fdistribution_pdf(F,N,M);; 2280}; 2281 ; 2282////////////////////////////////////////////////////////////////////////////////; 2283/// Calculates the cumulative distribution function of F-distribution; 2284/// (see ROOT::Math::fdistribution_cdf).; 2285/// This function occurs in the statistical test of whether two observed; 2286/// samples have the same variance. For this test a certa",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:87547,Modifiability,adapt,adapted,87547,"ouble_t f6 = 1.42151175831644588870e-7;; 2507 Double_t f7 = 2.04426310338993978564e-15;; 2508 ; 2509 Double_t split1 = 0.425;; 2510 Double_t split2=5.;; 2511 Double_t konst1=0.180625;; 2512 Double_t konst2=1.6;; 2513 ; 2514 Double_t q, r, quantile;; 2515 q=p-0.5;; 2516 if (TMath::Abs(q)<split1) {; 2517 r=konst1-q*q;; 2518 quantile = q* (((((((a7 * r + a6) * r + a5) * r + a4) * r + a3); 2519 * r + a2) * r + a1) * r + a0) /; 2520 (((((((b7 * r + b6) * r + b5) * r + b4) * r + b3); 2521 * r + b2) * r + b1) * r + 1.);; 2522 } else {; 2523 if(q<0) r=p;; 2524 else r=1-p;; 2525 //error case; 2526 if (r<=0); 2527 quantile=0;; 2528 else {; 2529 r=TMath::Sqrt(-TMath::Log(r));; 2530 if (r<=split2) {; 2531 r=r-konst2;; 2532 quantile=(((((((c7 * r + c6) * r + c5) * r + c4) * r + c3); 2533 * r + c2) * r + c1) * r + c0) /; 2534 (((((((d7 * r + d6) * r + d5) * r + d4) * r + d3); 2535 * r + d2) * r + d1) * r + 1);; 2536 } else{; 2537 r=r-split2;; 2538 quantile=(((((((e7 * r + e6) * r + e5) * r + e4) * r + e3); 2539 * r + e2) * r + e1) * r + e0) /; 2540 (((((((f7 * r + f6) * r + f5) * r + f4) * r + f3); 2541 * r + f2) * r + f1) * r + 1);; 2542 }; 2543 if (q<0) quantile=-quantile;; 2544 }; 2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:88894,Modifiability,variab,variable,88894,"1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find lower right element higher than the lower; 2573 // element of the upward transition; 2574 for(i=n-1;i>i1;i--) {; 2575 if(a[i] > a[i1]) {; 2576 // swap the two; 2577 itmp=a[i1];; 2578 a[i1]=a[i];; 2579 a[i]=itmp;; 2580 break;; 2581 }; 2582 }; 2583 // order the rest, in fact just invert, as there; 2584 // are only downward transitions from here on; 2585 for(i=0;i<(n-i1-1)/2;i++) {; 2586 itmp=a[i1+i+1];; 2587 a[i1+i+1]=a[n-i-1];; 2588 a[n-i-1]=itmp;; 2589 }; 2590 }; 2591 return kTRUE;; 2592}; 2593 ; 2594////////////////////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between two sample means and for confidence intervals for the difference; 2606/// between two population means.; 2607///; 2608/// Example: suppose we have a random sample of size n drawn from normal; 2609/// distribution with mean Mu and st.deviation Sigma. Then the variable; 2610///; 2611/// t = (sample_mean - Mu)/(sample_deviation / sqrt(n)); 2612///; 2613/// has Student's t-distribution with n-1 degrees of freedom.; 2614///; 2615/// NOTE that this function's second argument is number of degrees of freedom,; 2616/// not the sample size.; 2617///; 2618/// As the number of degrees of freedom grows, t-distribution approaches; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:89546,Modifiability,variab,variable,89546,"///////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between two sample means and for confidence intervals for the difference; 2606/// between two population means.; 2607///; 2608/// Example: suppose we have a random sample of size n drawn from normal; 2609/// distribution with mean Mu and st.deviation Sigma. Then the variable; 2610///; 2611/// t = (sample_mean - Mu)/(sample_deviation / sqrt(n)); 2612///; 2613/// has Student's t-distribution with n-1 degrees of freedom.; 2614///; 2615/// NOTE that this function's second argument is number of degrees of freedom,; 2616/// not the sample size.; 2617///; 2618/// As the number of degrees of freedom grows, t-distribution approaches; 2619/// Normal(0,1) distribution.; 2620///; 2621/// \author Anna Kreshuk; 2622 ; 2623Double_t TMath::Student(Double_t T, Double_t ndf); 2624{; 2625 if (ndf < 1) {; 2626 return 0;; 2627 }; 2628 ; 2629 Double_t r = ndf;; 2630 Double_t rh = 0.5*r;; 2631 Double_t rh1 = rh + 0.5;; 2632 Double_t denom = TMath::Sqrt(r*TMath::Pi())*TMath::Gamma(rh)*TMath::Power(1+T*T/r, rh1);; 2633 return TMath::Gamma(rh1)/denom;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// Calculates the cumulative distribution function of Student's; 2638/// t-distribution second parameter stands for number of degrees of freedom,; 2639/// not for the number of samples; 2640/",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:26229,Performance,perform,perform,26229,"sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > nb) {ok = kTRUE; break;}; 767/// }; 768/// rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; 769/// }; 770/// ~~~; 771///; 772/// For the last case, a=b, the algorithm advances each array by one index in an; 773/// attempt to move through the equality. However, this is incorrect when one or; 774/// the other of a or b (or both) have a repeated value, call it x. For the KS; 775/// statistic to be computed properly, rdiff needs to be calculated after all of; 776/// the a and b at x have been tallied (this is due to the definition of the; 777/// empirical distribution function; another way to convince yourself that the; 778/// old CERNLIB method is wrong is that it implies that the function defined as the; 779/// difference between a and b is multi-valued at x -- besides being ugly, this; 780/// would invalidate Kolmogorov's theorem).; 781///; 782/// The solution is to just add while-loops into the equality-case handling to; 783/// perform the tally:; 784///; 785/// ~~~ {.cpp}; 786/// } else {; 787/// double x = a[ia-1];; 788/// while(a[ia-1] == x && ia <= na) {; 789/// rdiff -= sa;; 790/// ia++;; 791/// }; 792/// while(b[ib-1] == x && ib <= nb) {; 793/// rdiff += sb;; 794/// ib++;; 795/// }; 796/// if (ia > na) {ok = kTRUE; break;}; 797/// if (ib > nb) {ok = kTRUE; break;}; 798/// }; 799/// ~~~; 800///; 801/// ### Note:; 802/// A good description of the Kolmogorov test can be seen at:; 803/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 804 ; 805Double_t TMath::KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option); 806{; 807// LM: Nov 2010: clean up and returns now a zero distance when vectors are the same; 808 ; 809 TString opt = option;; 810 opt.ToUpper();; 811 ; 812 Double_t prob = -1;; 813// Require at least two points in each graph; 814 if (!a || !b || na <= 2 || nb <= 2) {; 815 Error(""KolmogorovTest"",""Sets must have more ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:32072,Safety,avoid,avoid,32072,"42 Double_t xlim0, xlim1, xlim2, xlim3, xlim4; // --x-- on region boundaries; 943 Double_t a0=0, d0=0, d2=0, e0=0, e2=0, e4=0, h0=0, h2=0, h4=0, h6=0;// W4 temporary variables; 944 Double_t p0=0, p2=0, p4=0, p6=0, p8=0, z0=0, z2=0, z4=0, z6=0, z8=0;; 945 Double_t xp[6], xm[6], yp[6], ym[6]; // CPF12 temporary values; 946 Double_t mq[6], pq[6], mf[6], pf[6];; 947 Double_t d, yf, ypy0, ypy0q;; 948 ; 949 //***** Start of executable code *****************************************; 950 ; 951 rg1 = 1; // Set flags; 952 rg2 = 1;; 953 rg3 = 1;; 954 yq = y * y; // y^2; 955 yrrtpi = y * rrtpi; // y/SQRT(pi); 956 ; 957 // Region boundaries when both k and L are required or when R<>4; 958 ; 959 xlim0 = r0 - y;; 960 xlim1 = r1 - y;; 961 xlim3 = 3.097 * y - 0.45;; 962 xlim2 = 6.8 - y;; 963 xlim4 = 18.1 * y + 1.65;; 964 if ( y <= 1e-6 ) { // When y<10^-6 avoid W4 algorithm; 965 xlim1 = xlim0;; 966 xlim2 = xlim0;; 967 }; 968 ; 969 abx = fabs(x); // |x|; 970 xq = abx * abx; // x^2; 971 if ( abx > xlim0 ) { // Region 0 algorithm; 972 k = yrrtpi / (xq + yq);; 973 } else if ( abx > xlim1 ) { // Humlicek W4 Region 1; 974 if ( rg1 != 0 ) { // First point in Region 1; 975 rg1 = 0;; 976 a0 = yq + 0.5; // Region 1 y-dependents; 977 d0 = a0*a0;; 978 d2 = yq + yq - 1.0;; 979 }; 980 d = rrtpi / (d0 + xq*(d2 + xq));; 981 k = d * y * (a0 + xq);; 982 } else if ( abx > xlim2 ) { // Humlicek W4 Region 2; 983 if ( rg2 != 0 ) { // First point in Region 2; 984 rg2 = 0;; 985 h0 = 0.5625 + yq * (4.5 + yq * (10.5 + yq * (6.0 + yq)));; 986 // Region 2 y-dependents; 987 h2 = -4.5 + yq * (9.0 + yq * ( 6.0 + yq * 4.0));; 988 h4 = 10.5 - yq * (6.0 - yq * 6.0);; 989 h6 = -6.0 + yq * 4.0;; 990 e0 = 1.875 + yq * (8.25 + yq * (5.5 + yq));; 991 e2 = 5.25 + yq * (1.0 + yq * 3.0);; 992 e4 = 0.75 * h6;; 993 }; 994 d = rrtpi / (h0 + xq * (h2 + xq * (h4 + xq * (h6 + xq))));; 995 k = d * y * (e0 + xq * (e2 + xq * (e4 + xq)));; 996 } else if ( abx < xlim3 ) { // Humlicek W4 Region 3; 997 if ( rg3 != 0 ) { // First point i",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:45915,Security,hash,hash,45915,"l2-1];; 1335 localArr2[iEl2-1] = localArr2[iEl2];; 1336 localArr2[iEl2] = tmp2;; 1337 }; 1338 }; 1339 }; 1340 ; 1341 for (iEl = 0; iEl < Narr; iEl++) {; 1342 arr2[iEl] = localArr2[iEl];; 1343 }; 1344 delete [] localArr2;; 1345 delete [] localArr1;; 1346}; 1347 ; 1348////////////////////////////////////////////////////////////////////////////////; 1349/// Opposite ordering of the array arr2[] to that of BubbleHigh.; 1350///; 1351/// \author Adrian Bevan (bevan@slac.stanford.edu); 1352 ; 1353void TMath::BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2); 1354{; 1355 if (Narr <= 0) return;; 1356 double *localArr1 = new double[Narr];; 1357 int *localArr2 = new int[Narr];; 1358 int iEl;; 1359 int iEl2;; 1360 ; 1361 for (iEl = 0; iEl < Narr; iEl++) {; 1362 localArr1[iEl] = arr1[iEl];; 1363 localArr2[iEl] = iEl;; 1364 }; 1365 ; 1366 for (iEl = 0; iEl < Narr; iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same resu",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:46131,Security,hash,hash,46131,"w int[Narr];; 1358 int iEl;; 1359 int iEl2;; 1360 ; 1361 for (iEl = 0; iEl < Narr; iEl++) {; 1362 localArr1[iEl] = arr1[iEl];; 1363 localArr2[iEl] = iEl;; 1364 }; 1365 ; 1366 for (iEl = 0; iEl < Narr; iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same result; 1398/// as for libc rand().; 1399///; 1400/// - For string: i = TMath::Hash(string,nstring);; 1401/// - For int: i = TMath::Hash(&intword,sizeof(int));; 1402/// - For pointer: i = TMath::Hash(&pointer,sizeof(void*));; 1403///; 1404/// V.Perev; 1405/// This function is kept for back compatibility. The code previously in this function; 1406/// has been moved to the static function TString::Hash; 1407 ; 1408ULong_t TMath::Hash(const void *txt, Int_t ntxt); 1409{; 1410 return TString::Hash(txt,ntxt);; 1411}; 1412 ; 1413 ; 1414////////////////////////////////////////////////////////////////////////////////; 1415 ; 1416ULong_t TMath::Hash(const char *txt); ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:46171,Security,hash,hash,46171,"Arr1[iEl] = arr1[iEl];; 1363 localArr2[iEl] = iEl;; 1364 }; 1365 ; 1366 for (iEl = 0; iEl < Narr; iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same result; 1398/// as for libc rand().; 1399///; 1400/// - For string: i = TMath::Hash(string,nstring);; 1401/// - For int: i = TMath::Hash(&intword,sizeof(int));; 1402/// - For pointer: i = TMath::Hash(&pointer,sizeof(void*));; 1403///; 1404/// V.Perev; 1405/// This function is kept for back compatibility. The code previously in this function; 1406/// has been moved to the static function TString::Hash; 1407 ; 1408ULong_t TMath::Hash(const void *txt, Int_t ntxt); 1409{; 1410 return TString::Hash(txt,ntxt);; 1411}; 1412 ; 1413 ; 1414////////////////////////////////////////////////////////////////////////////////; 1415 ; 1416ULong_t TMath::Hash(const char *txt); 1417{; 1418 return Hash(txt, Int_t(strlen(txt)));; 1419}; 1420 ; 1421//////////////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:46259,Security,hash,hash,46259," iEl++) {; 1367 for (iEl2 = Narr-1; iEl2 > iEl; --iEl2) {; 1368 if (localArr1[iEl2-1] > localArr1[iEl2]) {; 1369 double tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same result; 1398/// as for libc rand().; 1399///; 1400/// - For string: i = TMath::Hash(string,nstring);; 1401/// - For int: i = TMath::Hash(&intword,sizeof(int));; 1402/// - For pointer: i = TMath::Hash(&pointer,sizeof(void*));; 1403///; 1404/// V.Perev; 1405/// This function is kept for back compatibility. The code previously in this function; 1406/// has been moved to the static function TString::Hash; 1407 ; 1408ULong_t TMath::Hash(const void *txt, Int_t ntxt); 1409{; 1410 return TString::Hash(txt,ntxt);; 1411}; 1412 ; 1413 ; 1414////////////////////////////////////////////////////////////////////////////////; 1415 ; 1416ULong_t TMath::Hash(const char *txt); 1417{; 1418 return Hash(txt, Int_t(strlen(txt)));; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// Computes the modified Bessel function I_",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:117548,Security,hash,hash,117548,"loat_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; qfloat * qDefinition THbookFile.cxx:89; TMath.h; TString.h; HashUInt_t Hash(const TString &s)Definition TString.h:494; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ROOT::Math::landau_pdfdouble landau_pdf(double x, double xi=1, double x0=0)Probability density function of the Landau distribution:Definition PdfFuncMathCore.cxx:21; ROOT::Math::fdistribution_cdfdouble fdistribution_cdf(double x, double n, double m, double x0=0)Cumulative distribution function of the F-distribution (lower tail).Definition ProbFuncMathCore.cxx:183; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; Types.h; F#define F(x, y, z); TMathTMath.Definition TMathBase.h:35; TMath::FDistIDouble_t FDistI(Double_t F, Double_t N, ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:123349,Security,hash,hash,123349," n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point ...Definition TMath.cxx:2380; TMath::HashULong_t Hash(const void *txt, Int_t ntxt)Calculates hash index from any char string.Definition TMath.cxx:1408; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::SignT1 Sign(T1 a, T2 b)Returns a value with the magnitude of a and the sign of b.Definition TMathBase.h:175; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, Double_t ndf)Computes density function for Student's t- distribution (the probability function (integral of densit...Definition TMath.cxx:2623; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::BetaDistIDouble_t BetaDistI(Double_t x, Double_t p, Double_t q)Computes the cumulative distri",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:2442,Testability,log,log,2442," a,Double_t x);; 42 Double_t GamSer(Double_t a,Double_t x);; 43 Double_t VavilovDenEval(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype);; 44 void VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt);; 45 ; 46}; 47 ; 48////////////////////////////////////////////////////////////////////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Returns `sqrt(x*x + y*y)`; 58 ; 59Double_t TMath::Hypot(Double_t x, Double_t y); 60{; 61 return hypot(x, y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112/////////////////////////",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:2802,Testability,log,log,2802,"///////////////////; 49/// Returns `sqrt(x*x + y*y)`; 50 ; 51Long_t TMath::Hypot(Long_t x, Long_t y); 52{; 53 return (Long_t) (hypot((Double_t)x, (Double_t)y) + 0.5);; 54}; 55 ; 56////////////////////////////////////////////////////////////////////////////////; 57/// Returns `sqrt(x*x + y*y)`; 58 ; 59Double_t TMath::Hypot(Double_t x, Double_t y); 60{; 61 return hypot(x, y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// The DiLogarithm function; 114/// Code translated by R.Brun from CERNLIB DILOG function C332; 115 ; 116Double_t TMath::DiLog(Double_t x); 117{; 118 const Double_t hf = 0.5;; 119 const Double_t pi = TMath::Pi();; 120 const Double_t pi2 = pi*pi;; 121 const Double_t pi3 = pi2/3;; 122 const Double_t ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:3098,Testability,log,log,3098,"y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// The DiLogarithm function; 114/// Code translated by R.Brun from CERNLIB DILOG function C332; 115 ; 116Double_t TMath::DiLog(Double_t x); 117{; 118 const Double_t hf = 0.5;; 119 const Double_t pi = TMath::Pi();; 120 const Double_t pi2 = pi*pi;; 121 const Double_t pi3 = pi2/3;; 122 const Double_t pi6 = pi2/6;; 123 const Double_t pi12 = pi2/12;; 124 const Double_t c[20] = {0.42996693560813697, 0.40975987533077106,; 125 -0.01858843665014592, 0.00145751084062268,-0.00014304184442340,; 126 0.00001588415541880,-0.00000190784959387, 0.00000024195180854,; 127 -0.00000003193341274, 0.00000000434545063,-0.00000000060578480,; 128 0.00000000008612098,-0.00000000001244332, 0.",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:3293,Testability,log,logarithm,3293,"y);; 62}; 63 ; 64////////////////////////////////////////////////////////////////////////////////; 65/// Returns the area hyperbolic sine of `x`.; 66 ; 67Double_t TMath::ASinH(Double_t x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// The DiLogarithm function; 114/// Code translated by R.Brun from CERNLIB DILOG function C332; 115 ; 116Double_t TMath::DiLog(Double_t x); 117{; 118 const Double_t hf = 0.5;; 119 const Double_t pi = TMath::Pi();; 120 const Double_t pi2 = pi*pi;; 121 const Double_t pi3 = pi2/3;; 122 const Double_t pi6 = pi2/6;; 123 const Double_t pi12 = pi2/12;; 124 const Double_t c[20] = {0.42996693560813697, 0.40975987533077106,; 125 -0.01858843665014592, 0.00145751084062268,-0.00014304184442340,; 126 0.00001588415541880,-0.00000190784959387, 0.00000024195180854,; 127 -0.00000003193341274, 0.00000000434545063,-0.00000000060578480,; 128 0.00000000008612098,-0.00000000001244332, 0.",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:3372,Testability,log,log,3372," x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// The DiLogarithm function; 114/// Code translated by R.Brun from CERNLIB DILOG function C332; 115 ; 116Double_t TMath::DiLog(Double_t x); 117{; 118 const Double_t hf = 0.5;; 119 const Double_t pi = TMath::Pi();; 120 const Double_t pi2 = pi*pi;; 121 const Double_t pi3 = pi2/3;; 122 const Double_t pi6 = pi2/6;; 123 const Double_t pi12 = pi2/12;; 124 const Double_t c[20] = {0.42996693560813697, 0.40975987533077106,; 125 -0.01858843665014592, 0.00145751084062268,-0.00014304184442340,; 126 0.00001588415541880,-0.00000190784959387, 0.00000024195180854,; 127 -0.00000003193341274, 0.00000000434545063,-0.00000000060578480,; 128 0.00000000008612098,-0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:3379,Testability,log,log,3379," x); 68{; 69#if defined(WIN32); 70 if(x==0.0) return 0.0;; 71 Double_t ax = Abs(x);; 72 return log(x+ax*sqrt(1.+1./(ax*ax)));; 73#else; 74 return asinh(x);; 75#endif; 76}; 77 ; 78////////////////////////////////////////////////////////////////////////////////; 79/// Returns the nonnegative area hyperbolic cosine of `x`.; 80 ; 81Double_t TMath::ACosH(Double_t x); 82{; 83#if defined(WIN32); 84 if(x==0.0) return 0.0;; 85 Double_t ax = Abs(x);; 86 return log(x+ax*sqrt(1.-1./(ax*ax)));; 87#else; 88 return acosh(x);; 89#endif; 90}; 91 ; 92////////////////////////////////////////////////////////////////////////////////; 93/// Returns the area hyperbolic tangent of `x`.; 94 ; 95Double_t TMath::ATanH(Double_t x); 96{; 97#if defined(WIN32); 98 return log((1+x)/(1-x))/2;; 99#else; 100 return atanh(x);; 101#endif; 102}; 103 ; 104////////////////////////////////////////////////////////////////////////////////; 105/// Returns the binary (base-2) logarithm of `x`.; 106 ; 107Double_t TMath::Log2(Double_t x); 108{; 109 return log(x)/log(2.0);; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// The DiLogarithm function; 114/// Code translated by R.Brun from CERNLIB DILOG function C332; 115 ; 116Double_t TMath::DiLog(Double_t x); 117{; 118 const Double_t hf = 0.5;; 119 const Double_t pi = TMath::Pi();; 120 const Double_t pi2 = pi*pi;; 121 const Double_t pi3 = pi2/3;; 122 const Double_t pi6 = pi2/6;; 123 const Double_t pi12 = pi2/12;; 124 const Double_t c[20] = {0.42996693560813697, 0.40975987533077106,; 125 -0.01858843665014592, 0.00145751084062268,-0.00014304184442340,; 126 0.00001588415541880,-0.00000190784959387, 0.00000024195180854,; 127 -0.00000003193341274, 0.00000000434545063,-0.00000000060578480,; 128 0.00000000008612098,-0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:18786,Testability,log,log,18786,"ar/amax;; 565 Double_t d = amax * Sqrt(1.+foofrac*foofrac+barfrac*barfrac);; 566 ; 567 v[0] /= d;; 568 v[1] /= d;; 569 v[2] /= d;; 570 return d;; 571}; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574/// Computes the Poisson distribution function for (x,par).; 575/// The Poisson PDF is implemented by means of Euler's Gamma-function; 576/// (for the factorial), so for any x integer argument it is the correct Poisson distribution.; 577/// BUT for non-integer x values, it IS NOT equal to the Poisson distribution !; 578///; 579/// Begin_Macro; 580/// {; 581/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 582/// TF1 *poisson = new TF1(""poisson"", ""TMath::Poisson(x, 5)"", 0, 15);; 583/// poisson->Draw(""L"");; 584/// }; 585/// End_Macro; 586 ; 587Double_t TMath::Poisson(Double_t x, Double_t par); 588{; 589 if (par < 0); 590 return TMath::QuietNaN();; 591 if (x < 0); 592 return 0;; 593 else if (x == 0.0 ); 594 return Exp(-par);; 595 else; 596 {; 597 return Exp( x * log(par) - LnGamma(x + 1.) - par);; 598 }; 599}; 600 ; 601////////////////////////////////////////////////////////////////////////////////; 602/// Computes the Discrete Poisson distribution function for (x,par).; 603/// This is a discrete and a non-smooth function.; 604/// This function is equivalent to ROOT::Math::poisson_pdf; 605///; 606/// Begin_Macro; 607/// {; 608/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 609/// TF1 *poissoni = new TF1(""poissoni"", ""TMath::PoissonI(x, 5)"", 0, 15);; 610/// poissoni->SetNpx(1000);; 611/// poissoni->Draw(""L"");; 612/// }; 613/// End_Macro; 614 ; 615Double_t TMath::PoissonI(Double_t x, Double_t par); 616{; 617 Int_t ix = Int_t(x);; 618 return Poisson(ix,par);; 619}; 620 ; 621////////////////////////////////////////////////////////////////////////////////; 622/// Computation of the probability for a certain Chi-squared (chi2); 623/// and number of degrees of freedom (ndf).; 624///; 625/// Calculations are based on the incom",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:20810,Testability,test,test,20810,"////////////////////////////////////////////////////////////////; 622/// Computation of the probability for a certain Chi-squared (chi2); 623/// and number of degrees of freedom (ndf).; 624///; 625/// Calculations are based on the incomplete gamma function P(a,x),; 626/// where a=ndf/2 and x=chi2/2.; 627///; 628/// P(a,x) represents the probability that the observed Chi-squared; 629/// for a correct model should be less than the value chi2.; 630///; 631/// The returned probability corresponds to 1-P(a,x),; 632/// which denotes the probability that an observed Chi-squared exceeds; 633/// the value chi2 by chance, even for a correct model.; 634///; 635/// \author NvE 14-nov-1998 UU-SAP Utrecht; 636 ; 637Double_t TMath::Prob(Double_t chi2,Int_t ndf); 638{; 639 if (ndf <= 0) return 0; // Set CL to zero in case ndf<=0; 640 ; 641 if (chi2 <= 0) {; 642 if (chi2 < 0) return 0;; 643 else return 1;; 644 }; 645 ; 646 return ::ROOT::Math::chisquared_cdf_c(chi2,ndf);; 647}; 648 ; 649////////////////////////////////////////////////////////////////////////////////; 650/// Calculates the Kolmogorov distribution function,; 651///; 652/// \f[; 653/// P(z) = 2 \sum_{j=1}^{\infty} (-1)^{j-1} e^{-2 j^2 z^2}; 654/// \f]; 655///; 656/// which gives the probability that Kolmogorov's test statistic will exceed; 657/// the value z assuming the null hypothesis. This gives a very powerful; 658/// test for comparing two one-dimensional distributions.; 659/// see, for example, Eadie et al, ""statistical Methods in Experimental; 660/// Physics', pp 269-270).; 661///; 662/// This function returns the confidence level for the null hypothesis, where:; 663/// - \f$ z = dn \sqrt{n} \f$, and; 664/// - \f$ dn \f$ is the maximum deviation between a hypothetical distribution; 665/// function and an experimental distribution with; 666/// - \f$ n \f$ events; 667///; 668/// NOTE: To compare two experimental distributions with m and n events,; 669/// use \f$ z = \sqrt{m n/(m+n)) dn} \f$; 670///; 671/// Accuracy",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:20922,Testability,test,test,20922,"ct model should be less than the value chi2.; 630///; 631/// The returned probability corresponds to 1-P(a,x),; 632/// which denotes the probability that an observed Chi-squared exceeds; 633/// the value chi2 by chance, even for a correct model.; 634///; 635/// \author NvE 14-nov-1998 UU-SAP Utrecht; 636 ; 637Double_t TMath::Prob(Double_t chi2,Int_t ndf); 638{; 639 if (ndf <= 0) return 0; // Set CL to zero in case ndf<=0; 640 ; 641 if (chi2 <= 0) {; 642 if (chi2 < 0) return 0;; 643 else return 1;; 644 }; 645 ; 646 return ::ROOT::Math::chisquared_cdf_c(chi2,ndf);; 647}; 648 ; 649////////////////////////////////////////////////////////////////////////////////; 650/// Calculates the Kolmogorov distribution function,; 651///; 652/// \f[; 653/// P(z) = 2 \sum_{j=1}^{\infty} (-1)^{j-1} e^{-2 j^2 z^2}; 654/// \f]; 655///; 656/// which gives the probability that Kolmogorov's test statistic will exceed; 657/// the value z assuming the null hypothesis. This gives a very powerful; 658/// test for comparing two one-dimensional distributions.; 659/// see, for example, Eadie et al, ""statistical Methods in Experimental; 660/// Physics', pp 269-270).; 661///; 662/// This function returns the confidence level for the null hypothesis, where:; 663/// - \f$ z = dn \sqrt{n} \f$, and; 664/// - \f$ dn \f$ is the maximum deviation between a hypothetical distribution; 665/// function and an experimental distribution with; 666/// - \f$ n \f$ events; 667///; 668/// NOTE: To compare two experimental distributions with m and n events,; 669/// use \f$ z = \sqrt{m n/(m+n)) dn} \f$; 670///; 671/// Accuracy: The function is far too accurate for any imaginable application.; 672/// Probabilities less than \f$ 10^{-15} \f$ are returned as zero.; 673/// However, remember that the formula is only valid for ""large"" n.; 674///; 675/// Theta function inversion formula is used for z <= 1; 676///; 677/// This function was translated by Rene Brun from PROBKL in CERNLIB.; 678 ; 679Double_t TMath::KolmogorovProb",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:22863,Testability,test,test,22863," used for z <= 1; 676///; 677/// This function was translated by Rene Brun from PROBKL in CERNLIB.; 678 ; 679Double_t TMath::KolmogorovProb(Double_t z); 680{; 681 Double_t fj[4] = {-2,-8,-18,-32}, r[4];; 682 const Double_t w = 2.50662827;; 683 // c1 - -pi**2/8, c2 = 9*c1, c3 = 25*c1; 684 const Double_t c1 = -1.2337005501361697;; 685 const Double_t c2 = -11.103304951225528;; 686 const Double_t c3 = -30.842513753404244;; 687 ; 688 Double_t u = TMath::Abs(z);; 689 Double_t p;; 690 if (u < 0.2) {; 691 p = 1;; 692 } else if (u < 0.755) {; 693 Double_t v = 1./(u*u);; 694 p = 1 - w*(TMath::Exp(c1*v) + TMath::Exp(c2*v) + TMath::Exp(c3*v))/u;; 695 } else if (u < 6.8116) {; 696 r[1] = 0;; 697 r[2] = 0;; 698 r[3] = 0;; 699 Double_t v = u*u;; 700 Int_t maxj = TMath::Max(1,TMath::Nint(3./u));; 701 for (Int_t j=0; j<maxj;j++) {; 702 r[j] = TMath::Exp(fj[j]*v);; 703 }; 704 p = 2*(r[0] - r[1] +r[2] - r[3]);; 705 } else {; 706 p = 0;; 707 }; 708 return p;; 709 }; 710 ; 711////////////////////////////////////////////////////////////////////////////////; 712/// Statistical test whether two one-dimensional sets of points are compatible; 713/// with coming from the same parent distribution, using the Kolmogorov test.; 714/// That is, it is used to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:23002,Testability,test,test,23002," used for z <= 1; 676///; 677/// This function was translated by Rene Brun from PROBKL in CERNLIB.; 678 ; 679Double_t TMath::KolmogorovProb(Double_t z); 680{; 681 Double_t fj[4] = {-2,-8,-18,-32}, r[4];; 682 const Double_t w = 2.50662827;; 683 // c1 - -pi**2/8, c2 = 9*c1, c3 = 25*c1; 684 const Double_t c1 = -1.2337005501361697;; 685 const Double_t c2 = -11.103304951225528;; 686 const Double_t c3 = -30.842513753404244;; 687 ; 688 Double_t u = TMath::Abs(z);; 689 Double_t p;; 690 if (u < 0.2) {; 691 p = 1;; 692 } else if (u < 0.755) {; 693 Double_t v = 1./(u*u);; 694 p = 1 - w*(TMath::Exp(c1*v) + TMath::Exp(c2*v) + TMath::Exp(c3*v))/u;; 695 } else if (u < 6.8116) {; 696 r[1] = 0;; 697 r[2] = 0;; 698 r[3] = 0;; 699 Double_t v = u*u;; 700 Int_t maxj = TMath::Max(1,TMath::Nint(3./u));; 701 for (Int_t j=0; j<maxj;j++) {; 702 r[j] = TMath::Exp(fj[j]*v);; 703 }; 704 p = 2*(r[0] - r[1] +r[2] - r[3]);; 705 } else {; 706 p = 0;; 707 }; 708 return p;; 709 }; 710 ; 711////////////////////////////////////////////////////////////////////////////////; 712/// Statistical test whether two one-dimensional sets of points are compatible; 713/// with coming from the same parent distribution, using the Kolmogorov test.; 714/// That is, it is used to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:23554,Testability,test,test,23554,"p(c3*v))/u;; 695 } else if (u < 6.8116) {; 696 r[1] = 0;; 697 r[2] = 0;; 698 r[3] = 0;; 699 Double_t v = u*u;; 700 Int_t maxj = TMath::Max(1,TMath::Nint(3./u));; 701 for (Int_t j=0; j<maxj;j++) {; 702 r[j] = TMath::Exp(fj[j]*v);; 703 }; 704 p = 2*(r[0] - r[1] +r[2] - r[3]);; 705 } else {; 706 p = 0;; 707 }; 708 return p;; 709 }; 710 ; 711////////////////////////////////////////////////////////////////////////////////; 712/// Statistical test whether two one-dimensional sets of points are compatible; 713/// with coming from the same parent distribution, using the Kolmogorov test.; 714/// That is, it is used to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Metho",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24054,Testability,test,test,24054,"d to compare two experimental distributions of unbinned data.; 715///; 716/// ### Input:; 717/// a,b: One-dimensional arrays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:24072,Testability,test,test,24072,"ays of length na, nb, respectively.; 718/// The elements of a and b must be given in ascending order.; 719/// option is a character string to specify options; 720/// ""D"" Put out a line of ""Debug"" printout; 721/// ""M"" Return the Maximum Kolmogorov distance instead of prob; 722///; 723/// ### Output:; 724/// The returned value prob is a calculated confidence level which gives a; 725/// statistical test for compatibility of a and b.; 726/// Values of prob close to zero are taken as indicating a small probability; 727/// of compatibility. For two point sets drawn randomly from the same parent; 728/// distribution, the value of prob should be uniformly distributed between; 729/// zero and one.; 730/// in case of error the function return -1; 731/// If the 2 sets have a different number of points, the minimum of; 732/// the two sets is used.; 733///; 734/// ### Method:; 735/// The Kolmogorov test is used. The test statistic is the maximum deviation; 736/// between the two integrated distribution functions, multiplied by the; 737/// normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; 738///; 739/// Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James); 740/// (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet,; 741/// Statistical Methods in Experimental Physics, (North-Holland,; 742/// Amsterdam 1971) 269-271); 743///; 744/// ### Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); 745///; 746/// The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop; 747/// over the two sorted arrays a and b representing empirical distribution; 748/// functions. The for-loop handles 3 cases: when the next points to be; 749/// evaluated satisfy a>b, a<b, or a=b:; 750///; 751/// ~~~ {.cpp}; 752/// for (Int_t i=0;i<na+nb;i++) {; 753/// if (a[ia-1] < b[ib-1]) {; 754/// rdiff -= sa;; 755/// ia++;; 756/// if (ia > na) {ok = kTRUE; break;}; 757/// } else if (a[ia-1] > b[ib-1]) {; 758/// rdiff += sb;; 759/// ib++;; 760/// if (ib > nb) {ok = kTRUE; bre",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:26671,Testability,test,test,26671,"an; 773/// attempt to move through the equality. However, this is incorrect when one or; 774/// the other of a or b (or both) have a repeated value, call it x. For the KS; 775/// statistic to be computed properly, rdiff needs to be calculated after all of; 776/// the a and b at x have been tallied (this is due to the definition of the; 777/// empirical distribution function; another way to convince yourself that the; 778/// old CERNLIB method is wrong is that it implies that the function defined as the; 779/// difference between a and b is multi-valued at x -- besides being ugly, this; 780/// would invalidate Kolmogorov's theorem).; 781///; 782/// The solution is to just add while-loops into the equality-case handling to; 783/// perform the tally:; 784///; 785/// ~~~ {.cpp}; 786/// } else {; 787/// double x = a[ia-1];; 788/// while(a[ia-1] == x && ia <= na) {; 789/// rdiff -= sa;; 790/// ia++;; 791/// }; 792/// while(b[ib-1] == x && ib <= nb) {; 793/// rdiff += sb;; 794/// ib++;; 795/// }; 796/// if (ia > na) {ok = kTRUE; break;}; 797/// if (ib > nb) {ok = kTRUE; break;}; 798/// }; 799/// ~~~; 800///; 801/// ### Note:; 802/// A good description of the Kolmogorov test can be seen at:; 803/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 804 ; 805Double_t TMath::KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option); 806{; 807// LM: Nov 2010: clean up and returns now a zero distance when vectors are the same; 808 ; 809 TString opt = option;; 810 opt.ToUpper();; 811 ; 812 Double_t prob = -1;; 813// Require at least two points in each graph; 814 if (!a || !b || na <= 2 || nb <= 2) {; 815 Error(""KolmogorovTest"",""Sets must have more than 2 points"");; 816 return prob;; 817 }; 818// Constants needed; 819 Double_t rna = na;; 820 Double_t rnb = nb;; 821 Double_t sa = 1./rna;; 822 Double_t sb = 1./rnb;; 823 Double_t rdiff = 0;; 824 Double_t rdmax = 0;; 825 Int_t ia = 0;; 826 Int_t ib = 0;; 827 ; 828// Main loop over point s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:46368,Testability,test,tested,46368,"ble tmp = localArr1[iEl2-1];; 1370 localArr1[iEl2-1] = localArr1[iEl2];; 1371 localArr1[iEl2] = tmp;; 1372 ; 1373 int tmp2 = localArr2[iEl2-1];; 1374 localArr2[iEl2-1] = localArr2[iEl2];; 1375 localArr2[iEl2] = tmp2;; 1376 }; 1377 }; 1378 }; 1379 ; 1380 for (iEl = 0; iEl < Narr; iEl++) {; 1381 arr2[iEl] = localArr2[iEl];; 1382 }; 1383 delete [] localArr2;; 1384 delete [] localArr1;; 1385}; 1386 ; 1387 ; 1388////////////////////////////////////////////////////////////////////////////////; 1389/// Calculates hash index from any char string.; 1390/// Based on pre-calculated table of 256 specially selected numbers.; 1391/// These numbers are selected in such a way, that for string; 1392/// length == 4 (integer number) the hash is unambiguous, i.e.; 1393/// from hash value we can recalculate input (no degeneration).; 1394///; 1395/// The quality of hash method is good enough, that; 1396/// ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); 1397/// tested by `<R>`, `<R*R>`, `<Ri*Ri+1>` gives the same result; 1398/// as for libc rand().; 1399///; 1400/// - For string: i = TMath::Hash(string,nstring);; 1401/// - For int: i = TMath::Hash(&intword,sizeof(int));; 1402/// - For pointer: i = TMath::Hash(&pointer,sizeof(void*));; 1403///; 1404/// V.Perev; 1405/// This function is kept for back compatibility. The code previously in this function; 1406/// has been moved to the static function TString::Hash; 1407 ; 1408ULong_t TMath::Hash(const void *txt, Int_t ntxt); 1409{; 1410 return TString::Hash(txt,ntxt);; 1411}; 1412 ; 1413 ; 1414////////////////////////////////////////////////////////////////////////////////; 1415 ; 1416ULong_t TMath::Hash(const char *txt); 1417{; 1418 return Hash(txt, Int_t(strlen(txt)));; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// Computes the modified Bessel function I_0(x) for any real x.; 1423///; 1424/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1425 ; 1426Double_t TMath::BesselI0(Do",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:49172,Testability,log,log,49172,"ult = (TMath::Exp(ax)/TMath::Sqrt(ax))*(q1+y*(q2+y*(q3+y*(q4+y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))));; 1448 }; 1449 return result;; 1450}; 1451 ; 1452////////////////////////////////////////////////////////////////////////////////; 1453/// Computes the modified Bessel function K_0(x) for positive real x.; 1454///; 1455/// M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; 1456/// Applied Mathematics Series vol. 55 (1964), Washington.; 1457///; 1458/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1459 ; 1460Double_t TMath::BesselK0(Double_t x); 1461{; 1462 // Parameters of the polynomial approximation; 1463 const Double_t p1=-0.57721566, p2=0.42278420, p3=0.23069756,; 1464 p4= 3.488590e-2, p5=2.62698e-3, p6=1.0750e-4, p7=7.4e-6;; 1465 ; 1466 const Double_t q1= 1.25331414, q2=-7.832358e-2, q3= 2.189568e-2,; 1467 q4=-1.062446e-2, q5= 5.87872e-3, q6=-2.51540e-3, q7=5.3208e-4;; 1468 ; 1469 if (x <= 0) {; 1470 Error(""TMath::BesselK0"", ""*K0* Invalid argument x = %g\n"",x);; 1471 return 0;; 1472 }; 1473 ; 1474 Double_t y=0, result=0;; 1475 ; 1476 if (x <= 2) {; 1477 y = x*x/4;; 1478 result = (-log(x/2.)*TMath::BesselI0(x))+(p1+y*(p2+y*(p3+y*(p4+y*(p5+y*(p6+y*p7))))));; 1479 } else {; 1480 y = 2/x;; 1481 result = (exp(-x)/sqrt(x))*(q1+y*(q2+y*(q3+y*(q4+y*(q5+y*(q6+y*q7))))));; 1482 }; 1483 return result;; 1484}; 1485 ; 1486////////////////////////////////////////////////////////////////////////////////; 1487/// Computes the modified Bessel function I_1(x) for any real x.; 1488///; 1489/// M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; 1490/// Applied Mathematics Series vol. 55 (1964), Washington.; 1491///; 1492/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1493 ; 1494Double_t TMath::BesselI1(Double_t x); 1495{; 1496 // Parameters of the polynomial approximation; 1497 const Double_t p1=0.5, p2=0.87890594, p3=0.51498869,; 1498 p4=0.15084934, p5=2.658733e-2, p6=3.01532e-3, p7=3.2411e-4;; 1499 ; 1500 const Double_t q1= 0.39894228, q2=-3.988024e-2, q3=-3.620",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:51596,Testability,log,log,51596,"ax))*(q1+y*(q2+y*(q3+y*(q4+y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))));; 1516 if (x < 0) result = -result;; 1517 }; 1518 return result;; 1519}; 1520 ; 1521////////////////////////////////////////////////////////////////////////////////; 1522/// Computes the modified Bessel function K_1(x) for positive real x.; 1523///; 1524/// M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; 1525/// Applied Mathematics Series vol. 55 (1964), Washington.; 1526///; 1527/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1528 ; 1529Double_t TMath::BesselK1(Double_t x); 1530{; 1531 // Parameters of the polynomial approximation; 1532 const Double_t p1= 1., p2= 0.15443144, p3=-0.67278579,; 1533 p4=-0.18156897, p5=-1.919402e-2, p6=-1.10404e-3, p7=-4.686e-5;; 1534 ; 1535 const Double_t q1= 1.25331414, q2= 0.23498619, q3=-3.655620e-2,; 1536 q4= 1.504268e-2, q5=-7.80353e-3, q6= 3.25614e-3, q7=-6.8245e-4;; 1537 ; 1538 if (x <= 0) {; 1539 Error(""TMath::BesselK1"", ""*K1* Invalid argument x = %g\n"",x);; 1540 return 0;; 1541 }; 1542 ; 1543 Double_t y=0,result=0;; 1544 ; 1545 if (x <= 2) {; 1546 y = x*x/4;; 1547 result = (log(x/2.)*TMath::BesselI1(x))+(1./x)*(p1+y*(p2+y*(p3+y*(p4+y*(p5+y*(p6+y*p7))))));; 1548 } else {; 1549 y = 2/x;; 1550 result = (exp(-x)/sqrt(x))*(q1+y*(q2+y*(q3+y*(q4+y*(q5+y*(q6+y*q7))))));; 1551 }; 1552 return result;; 1553}; 1554 ; 1555////////////////////////////////////////////////////////////////////////////////; 1556/// Computes the Integer Order Modified Bessel function K_n(x); 1557/// for n=0,1,2,... and positive real x.; 1558///; 1559/// \author NvE 12-mar-2000 UU-SAP Utrecht; 1560 ; 1561Double_t TMath::BesselK(Int_t n,Double_t x); 1562{; 1563 if (x <= 0 || n < 0) {; 1564 Error(""TMath::BesselK"", ""*K* Invalid argument(s) (n,x) = (%d, %g)\n"",n,x);; 1565 return 0;; 1566 }; 1567 ; 1568 if (n==0) return TMath::BesselK0(x);; 1569 if (n==1) return TMath::BesselK1(x);; 1570 ; 1571 // Perform upward recurrence for all x; 1572 Double_t tox = 2/x;; 1573 Double_t bkm = TMath::Bess",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:58151,Testability,log,log,58151,"708 const Double_t p1 = -2957821389., p2 = 7062834065.0, p3 = -512359803.6;; 1709 const Double_t p4 = 10879881.29, p5 = -86327.92757, p6 = 228.4622733;; 1710 const Double_t p7 = 40076544269., p8 = 745249964.8, p9 = 7189466.438;; 1711 const Double_t p10 = 47447.26470, p11 = 226.1030244, p12 = 0.636619772;; 1712 ; 1713 const Double_t q1 = 0.785398164;; 1714 const Double_t q2 = -0.1098628627e-2, q3 = 0.2734510407e-4;; 1715 const Double_t q4 = -0.2073370639e-5, q5 = 0.2093887211e-6;; 1716 const Double_t q6 = -0.1562499995e-1, q7 = 0.1430488765e-3;; 1717 const Double_t q8 = -0.6911147651e-5, q9 = 0.7621095161e-6;; 1718 const Double_t q10 = -0.934945152e-7, q11 = 0.636619772;; 1719 ; 1720 if (x < 8) {; 1721 y = x*x;; 1722 result1 = p1 + y*(p2 + y*(p3 + y*(p4 + y*(p5 + y*p6))));; 1723 result2 = p7 + y*(p8 + y*(p9 + y*(p10 + y*(p11 + y))));; 1724 result = (result1/result2) + p12*TMath::BesselJ0(x)*log(x);; 1725 } else {; 1726 z = 8/x;; 1727 y = z*z;; 1728 xx = x-q1;; 1729 result1 = 1 + y*(q2 + y*(q3 + y*(q4 + y*q5)));; 1730 result2 = q6 + y*(q7 + y*(q8 + y*(q9 + y*q10)));; 1731 result = sqrt(q11/x)*(sin(xx)*result1+z*cos(xx)*result2);; 1732 }; 1733 return result;; 1734}; 1735 ; 1736////////////////////////////////////////////////////////////////////////////////; 1737/// Returns the Bessel function Y1(x) for positive x.; 1738 ; 1739Double_t TMath::BesselY1(Double_t x); 1740{; 1741 Double_t z,xx,y,result,result1,result2;; 1742 const Double_t p1 = -0.4900604943e13, p2 = 0.1275274390e13;; 1743 const Double_t p3 = -0.5153438139e11, p4 = 0.7349264551e9;; 1744 const Double_t p5 = -0.4237922726e7, p6 = 0.8511937935e4;; 1745 const Double_t p7 = 0.2499580570e14, p8 = 0.4244419664e12;; 1746 const Double_t p9 = 0.3733650367e10, p10 = 0.2245904002e8;; 1747 const Double_t p11 = 0.1020426050e6, p12 = 0.3549632885e3;; 1748 const Double_t p13 = 0.636619772;; 1749 const Double_t q1 = 2.356194491;; 1750 const Double_t q2 = 0.183105e-2, q3 = -0.3516396496e-4;; 1751 const Double_t q4 = 0.245752",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:59704,Testability,log,log,59704,"44 const Double_t p5 = -0.4237922726e7, p6 = 0.8511937935e4;; 1745 const Double_t p7 = 0.2499580570e14, p8 = 0.4244419664e12;; 1746 const Double_t p9 = 0.3733650367e10, p10 = 0.2245904002e8;; 1747 const Double_t p11 = 0.1020426050e6, p12 = 0.3549632885e3;; 1748 const Double_t p13 = 0.636619772;; 1749 const Double_t q1 = 2.356194491;; 1750 const Double_t q2 = 0.183105e-2, q3 = -0.3516396496e-4;; 1751 const Double_t q4 = 0.2457520174e-5, q5 = -0.240337019e-6;; 1752 const Double_t q6 = 0.04687499995, q7 = -0.2002690873e-3;; 1753 const Double_t q8 = 0.8449199096e-5, q9 = -0.88228987e-6;; 1754 const Double_t q10 = 0.105787412e-6, q11 = 0.636619772;; 1755 ; 1756 if (x < 8) {; 1757 y=x*x;; 1758 result1 = x*(p1 + y*(p2 + y*(p3 + y*(p4 + y*(p5 + y*p6)))));; 1759 result2 = p7 + y*(p8 + y*(p9 + y*(p10 + y*(p11 + y*(p12+y)))));; 1760 result = (result1/result2) + p13*(TMath::BesselJ1(x)*log(x)-1/x);; 1761 } else {; 1762 z = 8/x;; 1763 y = z*z;; 1764 xx = x-q1;; 1765 result1 = 1 + y*(q2 + y*(q3 + y*(q4 + y*q5)));; 1766 result2 = q6 + y*(q7 + y*(q8 + y*(q9 + y*q10)));; 1767 result = sqrt(q11/x)*(sin(xx)*result1+z*cos(xx)*result2);; 1768 }; 1769 return result;; 1770}; 1771 ; 1772////////////////////////////////////////////////////////////////////////////////; 1773/// Struve Functions of Order 0; 1774///; 1775/// Converted from CERNLIB M342 by Rene Brun.; 1776 ; 1777Double_t TMath::StruveH0(Double_t x); 1778{; 1779 const Int_t n1 = 15;; 1780 const Int_t n2 = 25;; 1781 const Double_t c1[16] = { 1.00215845609911981, -1.63969292681309147,; 1782 1.50236939618292819, -.72485115302121872,; 1783 .18955327371093136, -.03067052022988,; 1784 .00337561447375194, -2.6965014312602e-4,; 1785 1.637461692612e-5, -7.8244408508e-7,; 1786 3.021593188e-8, -9.6326645e-10,; 1787 2.579337e-11, -5.8854e-13,; 1788 1.158e-14, -2e-16 };; 1789 const Double_t c2[26] = { .99283727576423943, -.00696891281138625,; 1790 1.8205103787037e-4, -1.063258252844e-5,; 1791 9.8198294287e-7, -1.2250645445e-7,; 1792 1.8940833",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:76163,Testability,test,testing,76163,"a * (c[25] + a * (c[28] + c[31] * a))) / c[37];; 2250 s4 = (c[20] + a * (c[27] + c[34] * a) + cp * (c[22] + a * (c[30] + c[36] * a))) / c[38];; 2251 s5 = (c[13] + c[21] * a + cp * (c[18] + c[26] * a)) / c[37];; 2252 s6 = (c[15] + cp * (c[23] + c[16] * cp)) / c[38];; 2253 ch = ch + t * (1 + 0.5 * t * s1 - b * cp * (s1 - b * (s2 - b * (s3 - b * (s4 - b * (s5 - b * s6))))));; 2254 if (TMath::Abs(q / ch - 1) > e) break;; 2255 }; 2256 return ch;; 2257}; 2258 ; 2259////////////////////////////////////////////////////////////////////////////////; 2260/// Computes the density function of F-distribution; 2261/// (probability function, integral of density, is computed in FDistI).; 2262///; 2263/// Parameters N and M stand for degrees of freedom of chi-squares; 2264/// mentioned above parameter F is the actual variable x of the; 2265/// density function p(x) and the point at which the density function; 2266/// is calculated.; 2267///; 2268/// ### About F distribution:; 2269/// F-distribution arises in testing whether two random samples; 2270/// have the same variance. It is the ratio of two chi-square; 2271/// distributions, with N and M degrees of freedom respectively,; 2272/// where each chi-square is first divided by it's number of degrees; 2273/// of freedom.; 2274///; 2275/// \author Anna Kreshuk; 2276 ; 2277Double_t TMath::FDist(Double_t F, Double_t N, Double_t M); 2278{; 2279 return ::ROOT::Math::fdistribution_pdf(F,N,M);; 2280}; 2281 ; 2282////////////////////////////////////////////////////////////////////////////////; 2283/// Calculates the cumulative distribution function of F-distribution; 2284/// (see ROOT::Math::fdistribution_cdf).; 2285/// This function occurs in the statistical test of whether two observed; 2286/// samples have the same variance. For this test a certain statistic F,; 2287/// the ratio of observed dispersion of the first sample to that of the; 2288/// second sample, is calculated. N and M stand for numbers of degrees; 2289/// of freedom in the s",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:76869,Testability,test,test,76869," for degrees of freedom of chi-squares; 2264/// mentioned above parameter F is the actual variable x of the; 2265/// density function p(x) and the point at which the density function; 2266/// is calculated.; 2267///; 2268/// ### About F distribution:; 2269/// F-distribution arises in testing whether two random samples; 2270/// have the same variance. It is the ratio of two chi-square; 2271/// distributions, with N and M degrees of freedom respectively,; 2272/// where each chi-square is first divided by it's number of degrees; 2273/// of freedom.; 2274///; 2275/// \author Anna Kreshuk; 2276 ; 2277Double_t TMath::FDist(Double_t F, Double_t N, Double_t M); 2278{; 2279 return ::ROOT::Math::fdistribution_pdf(F,N,M);; 2280}; 2281 ; 2282////////////////////////////////////////////////////////////////////////////////; 2283/// Calculates the cumulative distribution function of F-distribution; 2284/// (see ROOT::Math::fdistribution_cdf).; 2285/// This function occurs in the statistical test of whether two observed; 2286/// samples have the same variance. For this test a certain statistic F,; 2287/// the ratio of observed dispersion of the first sample to that of the; 2288/// second sample, is calculated. N and M stand for numbers of degrees; 2289/// of freedom in the samples 1-FDistI() is the significance level at; 2290/// which the hypothesis ""1 has smaller variance than 2"" can be rejected.; 2291/// A small numerical value of 1 - FDistI() implies a very significant; 2292/// rejection, in turn implying high confidence in the hypothesis; 2293/// ""1 has variance greater than 2"".; 2294///; 2295/// \author Anna Kreshuk; 2296 ; 2297Double_t TMath::FDistI(Double_t F, Double_t N, Double_t M); 2298{; 2299 Double_t fi = ::ROOT::Math::fdistribution_cdf(F,N,M);; 2300 return fi;; 2301}; 2302 ; 2303////////////////////////////////////////////////////////////////////////////////; 2304/// Computes the density function of Gamma distribution at point x.; 2305///; 2306/// \param[in] x evaluatio",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:76948,Testability,test,test,76948,"x) and the point at which the density function; 2266/// is calculated.; 2267///; 2268/// ### About F distribution:; 2269/// F-distribution arises in testing whether two random samples; 2270/// have the same variance. It is the ratio of two chi-square; 2271/// distributions, with N and M degrees of freedom respectively,; 2272/// where each chi-square is first divided by it's number of degrees; 2273/// of freedom.; 2274///; 2275/// \author Anna Kreshuk; 2276 ; 2277Double_t TMath::FDist(Double_t F, Double_t N, Double_t M); 2278{; 2279 return ::ROOT::Math::fdistribution_pdf(F,N,M);; 2280}; 2281 ; 2282////////////////////////////////////////////////////////////////////////////////; 2283/// Calculates the cumulative distribution function of F-distribution; 2284/// (see ROOT::Math::fdistribution_cdf).; 2285/// This function occurs in the statistical test of whether two observed; 2286/// samples have the same variance. For this test a certain statistic F,; 2287/// the ratio of observed dispersion of the first sample to that of the; 2288/// second sample, is calculated. N and M stand for numbers of degrees; 2289/// of freedom in the samples 1-FDistI() is the significance level at; 2290/// which the hypothesis ""1 has smaller variance than 2"" can be rejected.; 2291/// A small numerical value of 1 - FDistI() implies a very significant; 2292/// rejection, in turn implying high confidence in the hypothesis; 2293/// ""1 has variance greater than 2"".; 2294///; 2295/// \author Anna Kreshuk; 2296 ; 2297Double_t TMath::FDistI(Double_t F, Double_t N, Double_t M); 2298{; 2299 Double_t fi = ::ROOT::Math::fdistribution_cdf(F,N,M);; 2300 return fi;; 2301}; 2302 ; 2303////////////////////////////////////////////////////////////////////////////////; 2304/// Computes the density function of Gamma distribution at point x.; 2305///; 2306/// \param[in] x evaluation point; 2307/// \param[in] gamma shape parameter; 2308/// \param[in] mu location parameter; 2309/// \param[in] beta scale parameter; 23",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:81501,Testability,log,lognormal,81501,"f Laplace distribution at point x, with location parameter alpha and shape parameter beta.; 2375/// By default, alpha=0, beta=1; 2376/// This distribution is known under different names, most common is; 2377/// double exponential distribution, but it also appears as; 2378/// the two-tailed exponential or the bilateral exponential distribution; 2379 ; 2380Double_t TMath::LaplaceDistI(Double_t x, Double_t alpha, Double_t beta); 2381{; 2382 Double_t temp;; 2383 if (x<=alpha){; 2384 temp = 0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2385 } else {; 2386 temp = 1-0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2387 }; 2388 return temp;; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->Set",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82182,Testability,log,logn,82182,"t temp;; 2383 if (x<=alpha){; 2384 temp = 0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2385 } else {; 2386 temp = 1-0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2387 }; 2388 return temp;; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82198,Testability,log,logn,82198,"t temp;; 2383 if (x<=alpha){; 2384 temp = 0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2385 } else {; 2386 temp = 1-0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2387 }; 2388 return temp;; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82259,Testability,log,logn,82259,"t temp;; 2383 if (x<=alpha){; 2384 temp = 0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2385 } else {; 2386 temp = 1-0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2387 }; 2388 return temp;; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82301,Testability,log,logn,82301,"t temp;; 2383 if (x<=alpha){; 2384 temp = 0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2385 } else {; 2386 temp = 1-0.5*TMath::Exp(-TMath::Abs((x-alpha)/beta));; 2387 }; 2388 return temp;; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82344,Testability,log,logn,82344,"//////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter v",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82389,Testability,log,logn,82389,"//////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter v",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82419,Testability,log,logn,82419,"//////////////////////; 2392/// Computes the density of LogNormal distribution at point x.; 2393/// Variable X has lognormal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter v",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82462,Testability,log,logn,82462,"rmal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82507,Testability,log,logn,82507,"rmal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82541,Testability,log,logn,82541,"rmal distribution if Y=Ln(X) has normal distribution; 2394///; 2395/// \param[in] x is the evaluation point; 2396/// \param[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82584,Testability,log,logn,82584,"m[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82629,Testability,log,logn,82629,"m[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82663,Testability,log,logn,82663,"m[in] sigma is the shape parameter; 2397/// \param[in] theta is the location parameter; 2398/// \param[in] m is the scale parameter; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; ",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82706,Testability,log,logn,82706,"r; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; 2447 ; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Computes quant",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:82751,Testability,log,logn,82751,"r; 2399///; 2400/// The formula was taken from ""Engineering Statistics Handbook"" on site; 2401/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda3669.htm; 2402/// Implementation using ROOT::Math::lognormal_pdf; 2403///; 2404/// Begin_Macro; 2405/// {; 2406/// TCanvas *c1 = new TCanvas(""c1"", ""c1"", 700, 500);; 2407///; 2408/// c1->SetLogy();; 2409/// c1->SetGridx();; 2410/// c1->SetGridy();; 2411///; 2412/// TF1 *logn = new TF1(""logn"", ""TMath::LogNormal(x, [0], [1], [2])"", 0, 5);; 2413/// logn->SetMinimum(1e-3);; 2414///; 2415/// logn->SetParameters(0.5, 0., 1.);; 2416/// logn->SetLineColor(2);; 2417/// TF1 *logn1 = logn->DrawCopy(""L"");; 2418/// logn->SetParameters(1.0, 0., 1.);; 2419/// logn->SetLineColor(3);; 2420/// TF1 *logn2 = logn->DrawCopy(""LSAME"");; 2421/// logn->SetParameters(2.0, 0., 1.);; 2422/// logn->SetLineColor(4);; 2423/// TF1 *logn3 = logn->DrawCopy(""LSAME"");; 2424/// logn->SetParameters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; 2447 ; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Computes quant",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:83540,Testability,log,log,83540,"ters(5.0, 0., 1.);; 2425/// logn->SetLineColor(6);; 2426/// TF1 *logn4 = logn->DrawCopy(""LSAME"");; 2427///; 2428/// auto legend = new TLegend(0.15, 0.15, 0.5, 0.35);; 2429/// legend->AddEntry(logn1, ""sigma = 0.5, theta = 0, m = 1"", ""L"");; 2430/// legend->AddEntry(logn2, ""sigma = 1.0, theta = 0, m = 1"", ""L"");; 2431/// legend->AddEntry(logn3, ""sigma = 2.0, theta = 0, m = 1"", ""L"");; 2432/// legend->AddEntry(logn4, ""sigma = 5.0, theta = 0, m = 1"", ""L"");; 2433/// legend->Draw();; 2434/// }; 2435/// End_Macro; 2436 ; 2437Double_t TMath::LogNormal(Double_t x, Double_t sigma, Double_t theta, Double_t m); 2438{; 2439 if ((x<theta) || (sigma<=0) || (m<=0)) {; 2440 Error(""TMath::Lognormal"", ""illegal parameter values"");; 2441 return 0;; 2442 }; 2443 // lognormal_pdf uses same definition of http://en.wikipedia.org/wiki/Log-normal_distribution; 2444 // where mu = log(m); 2445 ; 2446 return ::ROOT::Math::lognormal_pdf(x, TMath::Log(m), sigma, theta);; 2447 ; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Computes quantiles for standard normal distribution N(0, 1); 2452/// at probability p; 2453///; 2454/// ALGORITHM AS241 APPL. STATIST. (1988) VOL. 37, NO. 3, 477-484.; 2455 ; 2456Double_t TMath::NormQuantile(Double_t p); 2457{; 2458 if ((p<=0)||(p>=1)) {; 2459 Error(""TMath::NormQuantile"", ""probability outside (0, 1)"");; 2460 return 0;; 2461 }; 2462 ; 2463 Double_t a0 = 3.3871328727963666080e0;; 2464 Double_t a1 = 1.3314166789178437745e+2;; 2465 Double_t a2 = 1.9715909503065514427e+3;; 2466 Double_t a3 = 1.3731693765509461125e+4;; 2467 Double_t a4 = 4.5921953931549871457e+4;; 2468 Double_t a5 = 6.7265770927008700853e+4;; 2469 Double_t a6 = 3.3430575583588128105e+4;; 2470 Double_t a7 = 2.5090809287301226727e+3;; 2471 Double_t b1 = 4.2313330701600911252e+1;; 2472 Double_t b2 = 6.8718700749205790830e+2;; 2473 Double_t b3 = 5.3941960214247511077e+3;; 2474 Double_t b4 = 2.1213794301586595867e+4;; 2475 Double_t b5 = 3.930789580",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:89168,Testability,test,tests,89168,"] > a[i1]) {; 2576 // swap the two; 2577 itmp=a[i1];; 2578 a[i1]=a[i];; 2579 a[i]=itmp;; 2580 break;; 2581 }; 2582 }; 2583 // order the rest, in fact just invert, as there; 2584 // are only downward transitions from here on; 2585 for(i=0;i<(n-i1-1)/2;i++) {; 2586 itmp=a[i1+i+1];; 2587 a[i1+i+1]=a[n-i-1];; 2588 a[n-i-1]=itmp;; 2589 }; 2590 }; 2591 return kTRUE;; 2592}; 2593 ; 2594////////////////////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between two sample means and for confidence intervals for the difference; 2606/// between two population means.; 2607///; 2608/// Example: suppose we have a random sample of size n drawn from normal; 2609/// distribution with mean Mu and st.deviation Sigma. Then the variable; 2610///; 2611/// t = (sample_mean - Mu)/(sample_deviation / sqrt(n)); 2612///; 2613/// has Student's t-distribution with n-1 degrees of freedom.; 2614///; 2615/// NOTE that this function's second argument is number of degrees of freedom,; 2616/// not the sample size.; 2617///; 2618/// As the number of degrees of freedom grows, t-distribution approaches; 2619/// Normal(0,1) distribution.; 2620///; 2621/// \author Anna Kreshuk; 2622 ; 2623Double_t TMath::Student(Double_t T, Double_t ndf); 2624{; 2625 if (ndf < 1) {; 2626 return 0;; 2627 }; 2628 ; 2629 Double_t r = ndf;; 2630 Double_t rh = 0.5*r;; 2631 Double_t rh1 = rh + 0.5;; 2632 Double_t denom = TMath::Sqrt(r",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:89217,Testability,test,tests,89217,"] > a[i1]) {; 2576 // swap the two; 2577 itmp=a[i1];; 2578 a[i1]=a[i];; 2579 a[i]=itmp;; 2580 break;; 2581 }; 2582 }; 2583 // order the rest, in fact just invert, as there; 2584 // are only downward transitions from here on; 2585 for(i=0;i<(n-i1-1)/2;i++) {; 2586 itmp=a[i1+i+1];; 2587 a[i1+i+1]=a[n-i-1];; 2588 a[n-i-1]=itmp;; 2589 }; 2590 }; 2591 return kTRUE;; 2592}; 2593 ; 2594////////////////////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between two sample means and for confidence intervals for the difference; 2606/// between two population means.; 2607///; 2608/// Example: suppose we have a random sample of size n drawn from normal; 2609/// distribution with mean Mu and st.deviation Sigma. Then the variable; 2610///; 2611/// t = (sample_mean - Mu)/(sample_deviation / sqrt(n)); 2612///; 2613/// has Student's t-distribution with n-1 degrees of freedom.; 2614///; 2615/// NOTE that this function's second argument is number of degrees of freedom,; 2616/// not the sample size.; 2617///; 2618/// As the number of degrees of freedom grows, t-distribution approaches; 2619/// Normal(0,1) distribution.; 2620///; 2621/// \author Anna Kreshuk; 2622 ; 2623Double_t TMath::Student(Double_t T, Double_t ndf); 2624{; 2625 if (ndf < 1) {; 2626 return 0;; 2627 }; 2628 ; 2629 Double_t r = ndf;; 2630 Double_t rh = 0.5*r;; 2631 Double_t rh1 = rh + 0.5;; 2632 Double_t denom = TMath::Sqrt(r",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:120368,Testability,test,test,120368,"l(Double_t rlam, Double_t *AC, Double_t *HC, Int_t itype)Internal function, called by Vavilov and VavilovSet.Definition TMath.cxx:3155; TMath::ACosDouble_t ACos(Double_t)Returns the principal value of the arc cosine of x, expressed in radians.Definition TMath.h:632; TMath::BesselIDouble_t BesselI(Int_t n, Double_t x)Computes the Integer Order Modified Bessel function I_n(x) for n=0,1,2,... and any real x.Definition TMath.cxx:1590; TMath::KOrdStatElement KOrdStat(Size n, const Element *a, Size k, Size *work=0)Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements).Definition TMath.h:1359; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::FactorialDouble_t Factorial(Int_t i)Computes factorial(n).Definition TMath.cxx:252; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::BinomialIDouble_t BinomialI(Double_t p, Int_t n, Int_t k)Suppose an event occurs with probability p per trial Then the probability P of its occurring k or mor...Definition TMath.cxx:2141; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::VavilovDouble_t Vavilov(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::ProbDouble_t Prob(Double_t chi2, Int_t n",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:121540,Testability,log,logarithm,121540,")Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::BinomialIDouble_t BinomialI(Double_t p, Int_t n, Int_t k)Suppose an event occurs with probability p per trial Then the probability P of its occurring k or mor...Definition TMath.cxx:2141; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::VavilovDouble_t Vavilov(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:125413,Testability,log,logarithm,125413,"ath.cxx:2090; TMath::FloorNintInt_t FloorNint(Double_t x)Returns the nearest integer of TMath::Floor(x).Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Compu",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8cxx_source.html:130274,Testability,log,logarithm,130274,"TMath::BetaIncompleteDouble_t BetaIncomplete(Double_t x, Double_t a, Double_t b)Calculates the incomplete Beta-function.Definition TMath.cxx:2103; TMath::StruveH1Double_t StruveH1(Double_t x)Struve functions of order 0.Definition TMath.cxx:1846; TMath::FreqDouble_t Freq(Double_t x)Computation of the normal frequency function freq(x).Definition TMath.cxx:270; TMath::LandauIDouble_t LandauI(Double_t x)Returns the cumulative (lower tail integral) of the Landau distribution function at point x.Definition TMath.cxx:2845; TMath::ATanHDouble_t ATanH(Double_t)Returns the area hyperbolic tangent of x.Definition TMath.cxx:95; TMath::BesselI0Double_t BesselI0(Double_t x)Integer order modified Bessel function K_n(x)Definition TMath.cxx:1426; TMath::VavilovSetvoid VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt)Internal function, called by Vavilov and VavilovI.Definition TMath.cxx:2854; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::StudentIDouble_t StudentI(Double_t T, Double_t ndf)Calculates the cumulative distribution function of Student's t-distribution second parameter stands f...Definition TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath::ErfcInverseDouble_t ErfcInverse(Double_t x)Returns the inverse o",MatchSource.WIKI,doc/master/TMath_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html
https://root.cern/doc/master/TMath_8h.html:5471,Availability,error,error,5471,"le_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:5562,Availability,error,error,5562,"x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (F",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:5675,Availability,error,error,5675,"ouble_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:5758,Availability,error,error,5758,"i-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral val",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:6455,Availability,mask,mask,6455,");  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t TMath::FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t TMath::Freq (Double_t x);  Computation of the normal frequency function freq(x). ;  ; constexpr Double_t TMath::G ();  Gravitational constant in: \( m^{3} kg^{-1} s^{-2} \). ;  ; Double_t TMath::Gamma (Double_t a, Double_t x);  Computation of the normalized lower incomplete gamma function P(a,x) as defined in the Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 . ;  ; Double_t TMath::Gamma (Double_t z);  Computation of gamma(z) for all z. ;  ; Double_t TMath::GammaDist (Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1);  Compu",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:6580,Availability,mask,mask,6580,"ion erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t TMath::FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t TMath::Freq (Double_t x);  Computation of the normal frequency function freq(x). ;  ; constexpr Double_t TMath::G ();  Gravitational constant in: \( m^{3} kg^{-1} s^{-2} \). ;  ; Double_t TMath::Gamma (Double_t a, Double_t x);  Computation of the normalized lower incomplete gamma function P(a,x) as defined in the Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 . ;  ; Double_t TMath::Gamma (Double_t z);  Computation of gamma(z) for all z. ;  ; Double_t TMath::GammaDist (Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1);  Computes the density function of Gamma distribution at point x. ;  ; Double_t TMath::Gaus (Double_t x, Double_t mean=0, Double_t si",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:6688,Availability,down,downward,6688,"ble_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t TMath::FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t TMath::Freq (Double_t x);  Computation of the normal frequency function freq(x). ;  ; constexpr Double_t TMath::G ();  Gravitational constant in: \( m^{3} kg^{-1} s^{-2} \). ;  ; Double_t TMath::Gamma (Double_t a, Double_t x);  Computation of the normalized lower incomplete gamma function P(a,x) as defined in the Handbook of Mathematical Functions by Abramowitz and Stegun, formula 6.5.1 on page 260 . ;  ; Double_t TMath::Gamma (Double_t z);  Computation of gamma(z) for all z. ;  ; Double_t TMath::GammaDist (Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1);  Computes the density function of Gamma distribution at point x. ;  ; Double_t TMath::Gaus (Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE);  Calculates a gaussian function with mean and sigma. ;  ; constexpr Double_t TMath::Gcgs ();  \( ",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:5959,Energy Efficiency,power,power,5959,"he hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t TMath::Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t TMath::Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t TMath::Floor (Double_t x);  Rounds x downward, returning the largest integral value that is not greater than x. ;  ; Int_t TMath::FloorNint (Double_t x);  Returns the nearest integer of TMath::Floor(x). ;  ; Double_t TMath::Freq (Double_t x);  Computation ",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:11419,Energy Efficiency,power,power,11419,"*a, Size k, Size *work=0);  Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ;  ; constexpr Double_t TMath::KUncertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t TMath::Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t TMath::LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t TMath::LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the b",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:14749,Energy Efficiency,adapt,adapted,14749,"onstexpr Double_t TMath::Na ();  Avogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t TMath::NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; template<typename T > ; Int_t TMath::Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * TMath::Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t TMath::Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15277,Energy Efficiency,power,power,15277,"ce. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a qu",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15361,Energy Efficiency,power,power,15361," template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas c",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15452,Energy Efficiency,power,power,15452,"Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15547,Energy Efficiency,power,power,15547,"uble_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath:",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15646,Energy Efficiency,power,power,15646,"ol_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Ite",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15864,Energy Efficiency,charge,charge,15864,"Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Iterator > ; Double_t TMath::RMS (Iterator first, Iterator last);  Returns the Standard Deviation of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::RMS (Iterator first, Iterator la",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:15945,Energy Efficiency,charge,charge,15945,"ath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t chi2, Int_t ndf);  Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf). ;  ; constexpr Double_t TMath::Qe ();  Elementary charge in \( C \) . ;  ; constexpr Double_t TMath::QeUncertainty ();  Elementary charge uncertainty. ;  ; void TMath::Quantiles (Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7);  Computes sample quantiles, corresponding to the given probabilities. ;  ; Double_t TMath::QuietNaN ();  Returns a quiet NaN as defined by IEEE 754. ;  ; constexpr Double_t TMath::R ();  Universal gas constant ( \( Na K \)) in \( J K^{-1} mol^{-1} \) ;  ; constexpr Double_t TMath::RadToDeg ();  Conversion from radian to degree: \( \frac{180}{\pi} \). ;  ; constexpr Double_t TMath::Rgair ();  Dry Air Gas Constant (R / MWair) in \( J kg^{-1} K^{-1} \) ;  ; template<typename Iterator > ; Double_t TMath::RMS (Iterator first, Iterator last);  Returns the Standard Deviation of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::RMS (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted Standard Deviation of an a",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:323,Integrability,depend,dependency,323,". ROOT: math/mathcore/inc/TMath.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; TMath.h File Reference. #include ""TMathBase.h""; #include ""TError.h""; #include <algorithm>; #include <limits>; #include <cmath>; #include <cfloat>. Include dependency graph for TMath.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  TMath::Limits< T >;  . Namespaces; namespace  TMath;  TMath. ;  . Functions; Double_t TMath::ACos (Double_t);  Returns the principal value of the arc cosine of x, expressed in radians. ;  ; Double_t TMath::ACosH (Double_t);  Returns the nonnegative area hyperbolic cosine of x. ;  ; Bool_t TMath::AreEqualAbs (Double_t af, Double_t bf, Double_t epsilon);  Comparing floating points. ;  ; Bool_t TMath::AreEqualRel (Double_t af, Double_t bf, Double_t relPrec);  Comparing floating points. ;  ; Double_t TMath::ASin (Double_t);  Returns the principal value of the arc sine of x, expressed in radians. ;  ; Double_t TMath::ASinH (Double_t);  Returns the area hyperbolic sine of x. ;  ; Double_t TMath::ATan (Double_t);  Returns the principal value of the arc tangent of x, expressed in radians. ;  ; Double_t TMath::ATan2 (Double_t y, Double_t x);  Returns the principal value of the arc tangent of y/x, expressed in radians. ;  ; Double_t TMath::ATanH (Double_t);  Returns the area hyperbolic tangent of x. ;  ; Double_t TMath::BesselI (Int_t n, Double_t x);  Computes the Integer Order Modified Bessel function I_n(x) for n=0,1,2,... and any real x. ;  ; Double_t TMath::BesselI0 (Double_t x);  Integer order modified Bessel function K_n(x) ;  ; Double_t TMath::BesselI1 (Double_t x);  Modified Bessel function K_0(x) ;  ; Double_t TMath::BesselJ0 (Double_t x);  Modified Bessel function K_1(x) ;  ; Double_t TMath::BesselJ1 (Double_t x);  Bessel function J0(x) for any real x. ;  ; Double_t TMath::BesselK (Int_t n, Double_t x);  Integer order m",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:14770,Integrability,rout,routine,14770,"onstexpr Double_t TMath::Na ();  Avogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t TMath::NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; template<typename T > ; Int_t TMath::Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * TMath::Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t TMath::Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:14749,Modifiability,adapt,adapted,14749,"onstexpr Double_t TMath::Na ();  Avogadro constant (Avogadro's Number) in \( mol^{-1} \). ;  ; constexpr Double_t TMath::NaUncertainty ();  Avogadro constant (Avogadro's Number) uncertainty. ;  ; template<typename T > ; Int_t TMath::Nint (T x);  Round to nearest integer. Rounds half integers to the nearest even integer. ;  ; template<typename T > ; T * TMath::Normal2Plane (const T v1[3], const T v2[3], const T v3[3], T normal[3]);  Calculates a normal vector of a plane. ;  ; Double_t TMath::Normalize (Double_t v[3]);  Normalize a vector v in place. ;  ; Float_t TMath::Normalize (Float_t v[3]);  Normalize a vector v in place. ;  ; template<typename T > ; T TMath::NormCross (const T v1[3], const T v2[3], T out[3]);  Calculates the Normalized Cross Product of two vectors. ;  ; Double_t TMath::NormQuantile (Double_t p);  Computes quantiles for standard normal distribution N(0, 1) at probability p. ;  ; Bool_t TMath::Permute (Int_t n, Int_t *a);  Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinct adapted from CERNLIB routine PERMU. ;  ; constexpr Double_t TMath::Pi ();  \( \pi\) ;  ; constexpr Double_t TMath::PiOver2 ();  \( \frac{\pi}{2} \) ;  ; constexpr Double_t TMath::PiOver4 ();  \( \frac{\pi}{4} \) ;  ; Double_t TMath::Poisson (Double_t x, Double_t par);  Computes the Poisson distribution function for (x,par). ;  ; Double_t TMath::PoissonI (Double_t x, Double_t par);  Computes the Discrete Poisson distribution function for (x,par). ;  ; Double_t TMath::Power (Double_t x, Double_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Power (Double_t x, Int_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (Long64_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, Long64_t y);  Returns x raised to the power y. ;  ; LongDouble_t TMath::Power (LongDouble_t x, LongDouble_t y);  Returns x raised to the power y. ;  ; Double_t TMath::Prob (Double_t",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:8661,Security,hash,hash,8661,"ian function with mean and sigma. ;  ; constexpr Double_t TMath::Gcgs ();  \( cm^{3} g^{-1} s^{-2} \) ;  ; template<typename Iterator > ; Double_t TMath::GeomMean (Iterator first, Iterator last);  Returns the geometric mean of an array defined by the iterators. ;  ; template<typename T > ; Double_t TMath::GeomMean (Long64_t n, const T *a);  Returns the geometric mean of an array a of size n. ;  ; constexpr Double_t TMath::GhbarC ();  \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ;  ; constexpr Double_t TMath::GhbarCUncertainty ();  \( \frac{G}{\hbar C} \) uncertainty. ;  ; constexpr Double_t TMath::Gn ();  Standard acceleration of gravity in \( m s^{-2} \). ;  ; constexpr Double_t TMath::GnUncertainty ();  Standard acceleration of gravity uncertainty. ;  ; constexpr Double_t TMath::GUncertainty ();  Gravitational constant uncertainty. ;  ; constexpr Double_t TMath::H ();  Planck's constant in \( J s \): \( h \). ;  ; ULong_t TMath::Hash (const char *str);  ; ULong_t TMath::Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; constexpr Double_t TMath::Hbar ();  \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ;  ; constexpr Double_t TMath::Hbarcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HbarUncertainty ();  \( \hbar \) uncertainty. ;  ; constexpr Double_t TMath::HC ();  \( hc \) in \( J m \) ;  ; constexpr Double_t TMath::HCcgs ();  \( erg cm \) ;  ; constexpr Double_t TMath::Hcgs ();  \( erg s \) ;  ; constexpr Double_t TMath::HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t TMath::Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t TMath::Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t TMath::Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t TMath::InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t TMath::IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the p",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:5398,Testability,log,log,5398,"r Double_t TMath::Ccgs ();  \( cm s^{-1} \) ;  ; Double_t TMath::Ceil (Double_t x);  Rounds x upward, returning the smallest integral value that is not less than x. ;  ; Int_t TMath::CeilNint (Double_t x);  Returns the nearest integer of TMath::Ceil(x). ;  ; Double_t TMath::ChisquareQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t TMath::Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t TMath::CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * TMath::Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t TMath::CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t TMath::DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t TMath::DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t TMath::E ();  Base of natural log: \( e \). ;  ; Double_t TMath::Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t TMath::Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t TMath::ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t TMath::ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t TMath::EulerGamma ();  Euler-Mascheroni Constant. ;  ; Double_t TMath::Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t TMath::Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t TMath::FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t TMath::FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistributi",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:10137,Testability,test,test,10137,"Planck's constant uncertainty. ;  ; Double_t TMath::Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t TMath::Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t TMath::Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t TMath::InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t TMath::IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ;  ; Bool_t TMath::IsNaN (Double_t x);  ; Bool_t TMath::IsNaN (Float_t x);  ; constexpr Double_t TMath::K ();  Boltzmann's constant in \( J K^{-1} \): \( k \). ;  ; constexpr Double_t TMath::Kcgs ();  \( erg K^{-1} \) ;  ; Double_t TMath::KolmogorovProb (Double_t z);  Calculates the Kolmogorov distribution function,. ;  ; Double_t TMath::KolmogorovTest (Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option);  Statistical test whether two one-dimensional sets of points are compatible with coming from the same parent distribution, using the Kolmogorov test. ;  ; template<class Element , typename Size > ; Element TMath::KOrdStat (Size n, const Element *a, Size k, Size *work=0);  Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ;  ; constexpr Double_t TMath::KUncertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t TMath::Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t TMath::LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t TMath::LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:10268,Testability,test,test,10268,"Planck's constant uncertainty. ;  ; Double_t TMath::Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t TMath::Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t TMath::Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t TMath::InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t TMath::IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ;  ; Bool_t TMath::IsNaN (Double_t x);  ; Bool_t TMath::IsNaN (Float_t x);  ; constexpr Double_t TMath::K ();  Boltzmann's constant in \( J K^{-1} \): \( k \). ;  ; constexpr Double_t TMath::Kcgs ();  \( erg K^{-1} \) ;  ; Double_t TMath::KolmogorovProb (Double_t z);  Calculates the Kolmogorov distribution function,. ;  ; Double_t TMath::KolmogorovTest (Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option);  Statistical test whether two one-dimensional sets of points are compatible with coming from the same parent distribution, using the Kolmogorov test. ;  ; template<class Element , typename Size > ; Element TMath::KOrdStat (Size n, const Element *a, Size k, Size *work=0);  Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ;  ; constexpr Double_t TMath::KUncertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t TMath::Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t TMath::LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t TMath::LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:11497,Testability,log,log,11497,"ertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t TMath::Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t TMath::LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t TMath::LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Doub",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:11519,Testability,log,log,11519,"ertainty ();  Boltzmann's constant uncertainty. ;  ; Double_t TMath::Landau (Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);  The LANDAU function. ;  ; Double_t TMath::LandauI (Double_t x);  Returns the cumulative (lower tail integral) of the Landau distribution function at point x. ;  ; Double_t TMath::LaplaceDist (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the probability density function of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::LaplaceDistI (Double_t x, Double_t alpha=0, Double_t beta=1);  Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Doub",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:12213,Testability,log,logarithm,12213," integral) of Laplace distribution at point x, with location parameter alpha and shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, co",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:12300,Testability,log,logarithm,12300,"shape parameter beta. ;  ; Double_t TMath::Ldexp (Double_t x, Int_t exp);  Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, const T *a, const Double_t *w=nullptr);  Returns the weighted mean of an array a wit",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:12385,Testability,log,logarithm,12385," result of multiplying x (the significant) by 2 raised to the power of exp (the exponent). ;  ; constexpr Double_t TMath::Ln10 ();  Natural log of 10 (to convert log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, const T *a, const Double_t *w=nullptr);  Returns the weighted mean of an array a with length n. ;  ; template<typename T > ; Double_t TMath::Median (Long64_t n, const T *",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:12450,Testability,log,log,12450,"t log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, const T *a, const Double_t *w=nullptr);  Returns the weighted mean of an array a with length n. ;  ; template<typename T > ; Double_t TMath::Median (Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr);  Same as RMS. ;  ; template<typename T > ; T TMath::MinElement (Long64_t n, const T *a);  Returns minimu",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h.html:12477,Testability,log,log,12477,"t log to ln) ;  ; Double_t TMath::LnGamma (Double_t z);  Computation of ln[gamma(z)] for all z. ;  ; template<typename Iterator > ; Iterator TMath::LocMax (Iterator first, Iterator last);  Returns index of array with the maximum element. ;  ; template<typename T > ; Long64_t TMath::LocMax (Long64_t n, const T *a);  Returns index of array with the maximum element. ;  ; template<typename Iterator > ; Iterator TMath::LocMin (Iterator first, Iterator last);  Returns index of array with the minimum element. ;  ; template<typename T > ; Long64_t TMath::LocMin (Long64_t n, const T *a);  Returns index of array with the minimum element. ;  ; Double_t TMath::Log (Double_t x);  Returns the natural logarithm of x. ;  ; Double_t TMath::Log10 (Double_t x);  Returns the common (base-10) logarithm of x. ;  ; Double_t TMath::Log2 (Double_t x);  Returns the binary (base-2) logarithm of x. ;  ; constexpr Double_t TMath::LogE ();  Base-10 log of e (to convert ln to log) ;  ; Double_t TMath::LogNormal (Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);  Computes the density of LogNormal distribution at point x. ;  ; template<typename T > ; T TMath::MaxElement (Long64_t n, const T *a);  Returns maximum of array a of length n. ;  ; template<typename Iterator > ; Double_t TMath::Mean (Iterator first, Iterator last);  Returns the weighted mean of an array defined by the iterators. ;  ; template<typename Iterator , typename WeightIterator > ; Double_t TMath::Mean (Iterator first, Iterator last, WeightIterator wfirst);  Returns the weighted mean of an array defined by the first and last iterators. ;  ; template<typename T > ; Double_t TMath::Mean (Long64_t n, const T *a, const Double_t *w=nullptr);  Returns the weighted mean of an array a with length n. ;  ; template<typename T > ; Double_t TMath::Median (Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr);  Same as RMS. ;  ; template<typename T > ; T TMath::MinElement (Long64_t n, const T *a);  Returns minimu",MatchSource.WIKI,doc/master/TMath_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h.html
https://root.cern/doc/master/TMath_8h_source.html:25514,Availability,down,downward,25514,"rn 0;; 649 if (y > 0) return Pi()/2;; 650 else return -Pi()/2;; 651 }; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Returns `x*x`.; 655 ; 656inline Double_t TMath::Sq(Double_t x); 657 { return x*x; }; 658 ; 659////////////////////////////////////////////////////////////////////////////////; 660/// Returns the square root of x.; 661 ; 662inline Double_t TMath::Sqrt(Double_t x); 663 { return sqrt(x); }; 664 ; 665////////////////////////////////////////////////////////////////////////////////; 666/// Rounds `x` upward, returning the smallest integral value that is not less than `x`.; 667 ; 668inline Double_t TMath::Ceil(Double_t x); 669 { return ceil(x); }; 670 ; 671////////////////////////////////////////////////////////////////////////////////; 672/// Returns the nearest integer of `TMath::Ceil(x)`.; 673 ; 674inline Int_t TMath::CeilNint(Double_t x); 675 { return TMath::Nint(ceil(x)); }; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Rounds `x` downward, returning the largest integral value that is not greater than `x`.; 679 ; 680inline Double_t TMath::Floor(Double_t x); 681 { return floor(x); }; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Returns the nearest integer of `TMath::Floor(x)`.; 685 ; 686inline Int_t TMath::FloorNint(Double_t x); 687 { return TMath::Nint(floor(x)); }; 688 ; 689////////////////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:28736,Availability,mask,mask,28736,"//////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:28979,Availability,mask,mask,28979,"/////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29087,Availability,mask,mask,29087,endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29094,Availability,mask,mask,29094,endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29538,Availability,mask,mask,29538,/////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ld,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29774,Availability,mask,mask,29774,"finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribu",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29865,Availability,mask,mask,29865,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29872,Availability,mask,mask,29872,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:50924,Availability,error,error,50924,"ains the k_th element; 1422 }; 1423 }; 1424}; 1425 ; 1426#endif; IsNaN#define IsNaN(a)Definition HypoTestResult.cxx:69; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; LongDouble_tlong double LongDouble_tDefinition RtypesCore.h:61; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; CrossTGLVector3 Cross(const TGLVector3 &v1, const TGLVector3 &v2)Definition TGLUtil.h:323; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionO",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:51541,Availability,mask,maskDefinition,51541,"n RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; LongDouble_tlong double LongDouble_tDefinition RtypesCore.h:61; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; CrossTGLVector3 Cross(const TGLVector3 &v1, const TGLVector3 &v2)Definition TGLUtil.h:323; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:59448,Availability,error,error,59448,"he np points in array...Definition TMath.h:1233; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:59822,Availability,down,downward,59822,"t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::Gnconstexpr Double_t Gn()Standard acceleration of gravity in .Definition TMath.h:174; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution f",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:63060,Availability,mask,mask,63060,"ty function (integral of densit...Definition TMath.cxx:2623; TMath::CUncertaintyconstexpr Double_t CUncertainty()Speed of light uncertainty.Definition TMath.h:128; TMath::Qeconstexpr Double_t Qe()Elementary charge in .Definition TMath.h:339; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::HCcgsconstexpr Double_t HCcgs()Definition TMath.h:240; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::BetaDistIDouble_t BetaDistI(Double_t x, Double_t p, Double_t q)Computes the cumulative distribution function of the Beta distribution, i.e.Definition TMath.cxx:2090; TMath::NormCrossT NormCross(const T v1[3], const T v2[3], T out[3])Calculates the Normalized Cross Product of two vectors.Definition TMath.h:951; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::TanHDouble_t TanH(Double_t)Returns the hyperbolic tangent of x.Definition TMath.h:618; TMath::FloorNintInt_t FloorNint(Double_t x)Returns the nearest integer of TMath::Floor(x).Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::RUncertaintyconstexpr Double_t RUncertainty()Universal gas constant uncertainty.Definition TMath.h:309; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:64320,Availability,error,error,64320,"nearest integer of TMath::Floor(x).Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::RUncertaintyconstexpr Double_t RUncertainty()Universal gas constant uncertainty.Definition TMath.h:309; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::LocMaxLong64_t LocMax(Long64_t n, const T *a)Returns index of array with the maximum element.Definition TMath.h:1012; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::GnUncertaintyconstexpr Double_t GnUncertainty()Standard acceleration of gravity uncertainty.Definition TMath.h:181; TMath::Hcgsconstexpr Double_t Hcgs()Definition TMath.h:195; TMath::HUncertaintyconstexpr Double_t HUncertainty()Planck's constant uncertainty.Definition TMath.h:202; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:65199,Availability,error,error,65199,"*a)Returns index of array with the maximum element.Definition TMath.h:1012; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::GnUncertaintyconstexpr Double_t GnUncertainty()Standard acceleration of gravity uncertainty.Definition TMath.h:181; TMath::Hcgsconstexpr Double_t Hcgs()Definition TMath.h:195; TMath::HUncertaintyconstexpr Double_t HUncertainty()Planck's constant uncertainty.Definition TMath.h:202; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Retu",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:70022,Availability,down,down,70022,"alculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where.Definition TMath.cxx:1107; TMath::ChisquareQuantileDouble_t ChisquareQuantile(Double_t p, Double_t ndf)Evaluate the quantiles of the chi-squared probability distribution function.Definition TMath.cxx:2193; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::FDistDouble_t FDist(Double_t F, Double_t N, Double_t M)Computes the density function of F-distribution (probability function, integral of density,...Definition TMath.cxx:2277; TMath::SignalingNaNDouble_t SignalingNaN()Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).Definition TMath.h:910; TMath::BreitWignerRelativisticDouble_t BreitWignerRelativistic(Double_t x, Double_t median=0, Double_t gamma=1)Calculates a Relativistic Breit Wigner function with median and gamma.Definition TMath.cxx:452; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::CrossT * Cross(const T v1[3], const T v2[3], T out[3])Calculates the Cross Product of two vectors: out = [v1 x v2].Definition TMath.h:1197; TMath::BubbleLowvoid BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2)Opposite ordering of the array arr2[] to that of BubbleHigh.Definition TMath.cxx:1353; TMath::BesselKDouble_t BesselK(Int_t n, Double_t x)Integer order modified Bessel function I_n(x)Definition TMath.cxx:1561; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TMath::BesselJ1Double_t BesselJ1(Double_t x)Bessel function J0(x) for any real x.Definition TMath.cxx:1669; TMath::BetaIncompleteDouble_t BetaIncomplete(Double_t x, Double_t a, Double_t b)Calculates the incomplete Beta-function.Definition TMath.cxx:21",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:73474,Availability,error,error,73474," TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::GhbarCconstexpr Double_t GhbarC()inDefinition TMath.h:158; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; TMath::HbarUncertaintyconstexpr Double_t HbarUncertainty()uncertainty.Definition TMath.h:225; TMath::InfinityDouble_t Infinity()Returns an infinity as defined by the IEEE standard.Definition TMath.h:917; TMath::ErfcInverseDouble_t ErfcInverse(Double_t x)Returns the inverse of the complementary error function.Definition TMath.cxx:242; TMath::SinHDouble_t SinH(Double_t)Returns the hyperbolic sine of `x.Definition TMath.h:606; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; TMath::LimitsDefinition TMath.h:407; TMath::Limits::Minstatic T Min()Returns maximum representation for type T.Definition TMath.h:925; TMath::Limits::Epsilonstatic T Epsilon()Returns minimum double representation.Definition TMath.h:941; TMath::Limits::Maxstatic T Max()Returns minimum double representation.Definition TMath.h:933; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincTMath.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:10752,Energy Efficiency,charge,charge,10752,11 return R() * ((KUncertainty() / K()) + (NaUncertainty() / Na()));; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// [Molecular weight of dry air 1976 US Standard Atmosphere](http://atmos.nmsu.edu/jsdap/encyclopediawork.html); 316/// in \f$ kg kmol^{-1} \f$ or \f$ gm mol^{-1} \f$; 317constexpr Double_t MWair(); 318{; 319 return 28.9644;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// [Dry Air Gas Constant (R / MWair)](http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm); 324/// in \f$ J kg^{-1} K^{-1} \f$; 325constexpr Double_t Rgair(); 326{; 327 return (1000.0 * R()) / MWair();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Euler-Mascheroni Constant.; 332constexpr Double_t EulerGamma(); 333{; 334 return 0.577215664901532860606512090082402431042;; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Elementary charge in \f$ C \f$ .; 339constexpr Double_t Qe(); 340{; 341 return 1.602176634e-19;; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Elementary charge uncertainty.; 346constexpr Double_t QeUncertainty(); 347{; 348 // constant is exact according to 2019 redefinition; 349 // (https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units); 350 return 0.0;; 351}; 352 ; 353////////////////////////////////////////////////////////////////////////////////; 354// Mathematical Functions; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357// Trigonometrical Functions; 358 ; 359inline Double_t Sin(Double_t);; 360inline Double_t Cos(Double_t);; 361inline Double_t Tan(Double_t);; 362inline Double_t SinH(Double_t);; 363inline Double_t CosH(Double_t);; 364inline Double_t TanH(Double_t);; 365inline Double_t ASin(Double_t);; 366inl,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:10953,Energy Efficiency,charge,charge,10953,"andard Atmosphere](http://atmos.nmsu.edu/jsdap/encyclopediawork.html); 316/// in \f$ kg kmol^{-1} \f$ or \f$ gm mol^{-1} \f$; 317constexpr Double_t MWair(); 318{; 319 return 28.9644;; 320}; 321 ; 322////////////////////////////////////////////////////////////////////////////////; 323/// [Dry Air Gas Constant (R / MWair)](http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm); 324/// in \f$ J kg^{-1} K^{-1} \f$; 325constexpr Double_t Rgair(); 326{; 327 return (1000.0 * R()) / MWair();; 328}; 329 ; 330////////////////////////////////////////////////////////////////////////////////; 331/// Euler-Mascheroni Constant.; 332constexpr Double_t EulerGamma(); 333{; 334 return 0.577215664901532860606512090082402431042;; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Elementary charge in \f$ C \f$ .; 339constexpr Double_t Qe(); 340{; 341 return 1.602176634e-19;; 342}; 343 ; 344////////////////////////////////////////////////////////////////////////////////; 345/// Elementary charge uncertainty.; 346constexpr Double_t QeUncertainty(); 347{; 348 // constant is exact according to 2019 redefinition; 349 // (https://en.wikipedia.org/wiki/2019_redefinition_of_the_SI_base_units); 350 return 0.0;; 351}; 352 ; 353////////////////////////////////////////////////////////////////////////////////; 354// Mathematical Functions; 355 ; 356////////////////////////////////////////////////////////////////////////////////; 357// Trigonometrical Functions; 358 ; 359inline Double_t Sin(Double_t);; 360inline Double_t Cos(Double_t);; 361inline Double_t Tan(Double_t);; 362inline Double_t SinH(Double_t);; 363inline Double_t CosH(Double_t);; 364inline Double_t TanH(Double_t);; 365inline Double_t ASin(Double_t);; 366inline Double_t ACos(Double_t);; 367inline Double_t ATan(Double_t);; 368inline Double_t ATan2(Double_t y, Double_t x);; 369Double_t ASinH(Double_t);; 370Double_t ACosH(Double_t);; 371Double_t ATanH(Double_t);; 372Dou",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:26527,Energy Efficiency,power,power,26527,"//////////////////////////////////////////////////////////////////////; 678/// Rounds `x` downward, returning the largest integral value that is not greater than `x`.; 679 ; 680inline Double_t TMath::Floor(Double_t x); 681 { return floor(x); }; 682 ; 683////////////////////////////////////////////////////////////////////////////////; 684/// Returns the nearest integer of `TMath::Floor(x)`.; 685 ; 686inline Int_t TMath::FloorNint(Double_t x); 687 { return TMath::Nint(floor(x)); }; 688 ; 689////////////////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:26785,Energy Efficiency,power,power,26785,"83////////////////////////////////////////////////////////////////////////////////; 684/// Returns the nearest integer of `TMath::Floor(x)`.; 685 ; 686inline Int_t TMath::FloorNint(Double_t x); 687 { return TMath::Nint(floor(x)); }; 688 ; 689////////////////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736/////////////////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:27034,Energy Efficiency,power,power,27034,"/////////////////////////////////////////////////////////////////////; 690/// Round to nearest integer. Rounds half integers to the nearest even integer.; 691 ; 692template<typename T>; 693inline Int_t TMath::Nint(T x); 694{; 695 int i;; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:27276,Energy Efficiency,power,power,27276,"; 696 if (x >= 0) {; 697 i = int(x + 0.5);; 698 if ( i & 1 && x + 0.5 == T(i) ) i--;; 699 } else {; 700 i = int(x - 0.5);; 701 if ( i & 1 && x - 0.5 == T(i) ) i++;; 702 }; 703 return i;; 704}; 705 ; 706////////////////////////////////////////////////////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#en",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:27528,Energy Efficiency,power,power,27528,"///////////////////////////////////; 707/// Returns the base-e exponential function of x, which is e raised to the power `x`.; 708 ; 709inline Double_t TMath::Exp(Double_t x); 710 { return exp(x); }; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759/////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:27762,Energy Efficiency,power,power,27762,"//////////////////////////////////////////////; 713/// Returns the result of multiplying `x` (the significant) by 2 raised to the power of `exp` (the exponent).; 714 ; 715inline Double_t TMath::Ldexp(Double_t x, Int_t exp); 716 { return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765/////////////////////////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:27988,Energy Efficiency,power,power,27988,"return ldexp(x, exp); }; 717 ; 718////////////////////////////////////////////////////////////////////////////////; 719/// Returns `x` raised to the power `y`.; 720 ; 721inline LongDouble_t TMath::Power(LongDouble_t x, LongDouble_t y); 722 { return std::pow(x,y); }; 723 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMat",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:59261,Energy Efficiency,power,power,59261,"ed (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all distinc...Definition TMath.cxx:2557; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::PoissonIDouble_t PoissonI(Double_t x, Double_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by defaul",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:61112,Energy Efficiency,charge,charge,61112,"tDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::Gnconstexpr Double_t Gn()Standard acceleration of gravity in .Definition TMath.h:174; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point ...Definition TMath.cxx:2380; TMath::HashULong_t Hash(const void *txt, Int_t ntxt)Calculates hash index from any char string.Definition TMath.cxx:1408; TMath::QeUncertaintyconstexpr Double_t QeUncertainty()Elementary charge uncertainty.Definition TMath.h:346; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, Double_t ndf)Computes density function for Student's t- distribution (the probability function (integral of densit..",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:62258,Energy Efficiency,charge,charge,62258,"ath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, Double_t ndf)Computes density function for Student's t- distribution (the probability function (integral of densit...Definition TMath.cxx:2623; TMath::CUncertaintyconstexpr Double_t CUncertainty()Speed of light uncertainty.Definition TMath.h:128; TMath::Qeconstexpr Double_t Qe()Elementary charge in .Definition TMath.h:339; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::HCcgsconstexpr Double_t HCcgs()Definition TMath.h:240; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::BetaDistIDouble_t BetaDistI(Double_t x, Double_t p, Double_t q)Computes the cumulative distribution function of the Beta distribution, i.e.Definition TMath.cxx:2090; TMath::NormCrossT NormCross(const T v1[3], const T v2[3], T out[3])Calculates the Normalized Cross Product of two vectors.Definition TMath.h:951; TMath::FiniteInt_t Finite(Double_t x)Check if it is finite with a mask in order to be consistent in presence of fast math.Definition TMath.h:770; TMath::TanHDouble_t TanH(Double_t)Returns the hyperbolic tangent of x.Definition TMath.h:618; TMath",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:66196,Energy Efficiency,power,power,66196,"_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:66461,Energy Efficiency,power,power,66461," of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqr",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:29983,Integrability,rout,routines,29983,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:35593,Performance,perform,performing,35593,"ement(Long64_t n, const T *a) {; 961 return *std::min_element(a,a+n);; 962}; 963 ; 964////////////////////////////////////////////////////////////////////////////////; 965/// Returns maximum of array a of length n.; 966 ; 967template <typename T>; 968T TMath::MaxElement(Long64_t n, const T *a) {; 969 return *std::max_element(a,a+n);; 970}; 971 ; 972////////////////////////////////////////////////////////////////////////////////; 973/// Returns index of array with the minimum element.; 974/// If more than one element is minimum returns first found.; 975///; 976/// Implement here since this one is found to be faster (mainly on 64 bit machines); 977/// than stl generic implementation.; 978/// When performing the comparison, the STL implementation needs to de-reference both the array iterator; 979/// and the iterator pointing to the resulting minimum location; 980 ; 981template <typename T>; 982Long64_t TMath::LocMin(Long64_t n, const T *a) {; 983 if (n <= 0 || !a) return -1;; 984 T xmin = a[0];; 985 Long64_t loc = 0;; 986 for (Long64_t i = 1; i < n; i++) {; 987 if (xmin > a[i]) {; 988 xmin = a[i];; 989 loc = i;; 990 }; 991 }; 992 return loc;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Returns index of array with the minimum element.; 997/// If more than one element is minimum returns first found.; 998 ; 999template <typename Iterator>; 1000Iterator TMath::LocMin(Iterator first, Iterator last) {; 1001 ; 1002 return std::min_element(first, last);; 1003}; 1004 ; 1005////////////////////////////////////////////////////////////////////////////////; 1006/// Returns index of array with the maximum element.; 1007/// If more than one element is maximum returns first found.; 1008///; 1009/// Implement here since it is faster (see comment in LocMin function); 1010 ; 1011template <typename T>; 1012Long64_t TMath::LocMax(Long64_t n, const T *a) {; 1013 if (n <= 0 || !a) return -1;; 1014 T xmax = a[0];; 1015 Long64_t loc =",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:33649,Safety,avoid,avoid,33649,"; 904 return std::numeric_limits<Double_t>::quiet_NaN();; 905}; 906 ; 907////////////////////////////////////////////////////////////////////////////////; 908/// Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).; 909 ; 910inline Double_t TMath::SignalingNaN() {; 911 return std::numeric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956///////////////////",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:33977,Safety,avoid,avoid,33977,"meric_limits<Double_t>::signaling_NaN();; 912}; 913 ; 914////////////////////////////////////////////////////////////////////////////////; 915/// Returns an infinity as defined by the IEEE standard.; 916 ; 917inline Double_t TMath::Infinity() {; 918 return std::numeric_limits<Double_t>::infinity();; 919}; 920 ; 921////////////////////////////////////////////////////////////////////////////////; 922/// Returns maximum representation for type T.; 923 ; 924template<typename T>; 925inline T TMath::Limits<T>::Min() {; 926 return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows; 927}; 928 ; 929////////////////////////////////////////////////////////////////////////////////; 930/// Returns minimum double representation.; 931 ; 932template<typename T>; 933inline T TMath::Limits<T>::Max() {; 934 return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows; 935}; 936 ; 937////////////////////////////////////////////////////////////////////////////////; 938/// Returns minimum double representation.; 939 ; 940template<typename T>; 941inline T TMath::Limits<T>::Epsilon() {; 942 return std::numeric_limits<T>::epsilon();; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946// Advanced.; 947 ; 948////////////////////////////////////////////////////////////////////////////////; 949/// Calculates the Normalized Cross Product of two vectors.; 950 ; 951template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3]); 952{; 953 return Normalize(Cross(v1,v2,out));; 954}; 955 ; 956////////////////////////////////////////////////////////////////////////////////; 957/// Returns minimum of array a of length n.; 958 ; 959template <typename T>; 960T TMath::MinElement(Long64_t n, const T *a) {; 961 return *std::min_element(a,a+n);; 962}; 963 ; 964////////////////////////////////////////////////////////////////////////////////; ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:60988,Security,hash,hash,60988,"uble_t par)Computes the Discrete Poisson distribution function for (x,par).Definition TMath.cxx:615; TMath::CauchyDistDouble_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1)Computes the density of Cauchy distribution at point x by default, standard Cauchy distribution is us...Definition TMath.cxx:2175; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::StruveL1Double_t StruveL1(Double_t x)Modified Struve functions of order 0.Definition TMath.cxx:1970; TMath::Gnconstexpr Double_t Gn()Standard acceleration of gravity in .Definition TMath.h:174; TMath::ASinHDouble_t ASinH(Double_t)Returns the area hyperbolic sine of x.Definition TMath.cxx:67; TMath::LaplaceDistIDouble_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the cumulative distribution function (lower tail integral) of Laplace distribution at point ...Definition TMath.cxx:2380; TMath::HashULong_t Hash(const void *txt, Int_t ntxt)Calculates hash index from any char string.Definition TMath.cxx:1408; TMath::QeUncertaintyconstexpr Double_t QeUncertainty()Elementary charge uncertainty.Definition TMath.h:346; TMath::Kconstexpr Double_t K()Boltzmann's constant in : .Definition TMath.h:247; TMath::BreitWignerDouble_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1)Calculates a Breit Wigner function with mean and gamma.Definition TMath.cxx:442; TMath::Sqrt2constexpr Double_t Sqrt2()Definition TMath.h:86; TMath::KUncertaintyconstexpr Double_t KUncertainty()Boltzmann's constant uncertainty.Definition TMath.h:261; TMath::Hbarcgsconstexpr Double_t Hbarcgs()Definition TMath.h:218; TMath::LandauDouble_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE)The LANDAU function.Definition TMath.cxx:492; TMath::VoigtDouble_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r=4)Computation of Voigt function (normalised).Definition TMath.cxx:898; TMath::StudentDouble_t Student(Double_t T, ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:2885,Testability,log,log,2885,///////////////; 57/// \f$ \frac{\pi}{4} \f$; 58constexpr Double_t PiOver4(); 59{; 60 return Pi() / 4.0;; 61}; 62 ; 63////////////////////////////////////////////////////////////////////////////////; 64/// \f$ \frac{1.}{\pi}\f$; 65constexpr Double_t InvPi(); 66{; 67 return 1.0 / Pi();; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Conversion from radian to degree: \f$ \frac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126/////////////////////////////////////////,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:3075,Testability,log,log,3075,rac{1.}{\pi}\f$; 65constexpr Double_t InvPi(); 66{; 67 return 1.0 / Pi();; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Conversion from radian to degree: \f$ \frac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133//////////////////////////////////////////////////////////,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:3097,Testability,log,log,3097,rac{1.}{\pi}\f$; 65constexpr Double_t InvPi(); 66{; 67 return 1.0 / Pi();; 68}; 69 ; 70////////////////////////////////////////////////////////////////////////////////; 71/// Conversion from radian to degree: \f$ \frac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133//////////////////////////////////////////////////////////,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:3293,Testability,log,log,3293,rac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Gravitational constant in: \f$ m^{3} kg^{-1} s^{-2} \f$; 135constexpr Double_t G(); 136{; 137 // use 2018 value from NIST (https://physics.nist.gov/cgi-bin/cuu/Value?bg|search_for=G); 1,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:3320,Testability,log,log,3320,rac{180}{\pi} \f$; 72constexpr Double_t RadToDeg(); 73{; 74 return 180.0 / Pi();; 75}; 76 ; 77////////////////////////////////////////////////////////////////////////////////; 78/// Conversion from degree to radian: \f$ \frac{\pi}{180} \f$; 79constexpr Double_t DegToRad(); 80{; 81 return Pi() / 180.0;; 82}; 83 ; 84////////////////////////////////////////////////////////////////////////////////; 85/// \f$ \sqrt{2} \f$; 86constexpr Double_t Sqrt2(); 87{; 88 return 1.4142135623730950488016887242097;; 89}; 90 ; 91////////////////////////////////////////////////////////////////////////////////; 92/// Base of natural log: \f$ e \f$; 93constexpr Double_t E(); 94{; 95 return 2.71828182845904523536;; 96}; 97 ; 98////////////////////////////////////////////////////////////////////////////////; 99/// Natural log of 10 (to convert log to ln); 100constexpr Double_t Ln10(); 101{; 102 return 2.30258509299404568402;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Base-10 log of e (to convert ln to log); 107constexpr Double_t LogE(); 108{; 109 return 0.43429448190325182765;; 110}; 111 ; 112////////////////////////////////////////////////////////////////////////////////; 113/// Velocity of light in \f$ m s^{-1} \f$; 114constexpr Double_t C(); 115{; 116 return 2.99792458e8;; 117}; 118 ; 119////////////////////////////////////////////////////////////////////////////////; 120/// \f$ cm s^{-1} \f$; 121constexpr Double_t Ccgs(); 122{; 123 return 100.0 * C();; 124}; 125 ; 126////////////////////////////////////////////////////////////////////////////////; 127/// Speed of light uncertainty.; 128constexpr Double_t CUncertainty(); 129{; 130 return 0.0;; 131}; 132 ; 133////////////////////////////////////////////////////////////////////////////////; 134/// Gravitational constant in: \f$ m^{3} kg^{-1} s^{-2} \f$; 135constexpr Double_t G(); 136{; 137 // use 2018 value from NIST (https://physics.nist.gov/cgi-bin/cuu/Value?bg|search_for=G); 1,MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:28294,Testability,log,logarithm,28294,"3 ; 724////////////////////////////////////////////////////////////////////////////////; 725/// Returns `x` raised to the power `y`.; 726 ; 727inline LongDouble_t TMath::Power(LongDouble_t x, Long64_t y); 728 { return std::pow(x,(LongDouble_t)y); }; 729 ; 730////////////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { retu",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:28375,Testability,log,log,28375,"/////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795/",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:28513,Testability,log,logarithm,28513,"/////////////////////////////////////////////////////////////////////////; 731/// Returns `x` raised to the power `y`.; 732 ; 733inline LongDouble_t TMath::Power(Long64_t x, Long64_t y); 734 { return std::pow(x,y); }; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795/",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:39504,Testability,log,logsum,39504,"rst != last ) {; 1067 if ( *w < 0) {; 1068 ::Error(""TMath::Mean"",""w[%d] = %.4e < 0 ?!"",i,*w);; 1069 return 0;; 1070 }; 1071 sum += (*w) * (*first);; 1072 sumw += (*w) ;; 1073 ++w;; 1074 ++first;; 1075 ++i;; 1076 }; 1077 if (sumw <= 0) {; 1078 ::Error(""TMath::Mean"",""sum of weights == 0 ?!"");; 1079 return 0;; 1080 }; 1081 ; 1082 return sum/sumw;; 1083}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Returns the weighted mean of an array a with length n.; 1087 ; 1088template <typename T>; 1089Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w); 1090{; 1091 if (w) {; 1092 return TMath::Mean(a, a+n, w);; 1093 } else {; 1094 return TMath::Mean(a, a+n);; 1095 }; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Returns the geometric mean of an array defined by the iterators.; 1100/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1101 ; 1102template <typename Iterator>; 1103Double_t TMath::GeomMean(Iterator first, Iterator last); 1104{; 1105 Double_t logsum = 0.;; 1106 Long64_t n = 0;; 1107 while ( first != last ) {; 1108 if (*first == 0) return 0.;; 1109 Double_t absa = (Double_t) TMath::Abs(*first);; 1110 logsum += TMath::Log(absa);; 1111 ++first;; 1112 ++n;; 1113 }; 1114 ; 1115 return TMath::Exp(logsum/n);; 1116}; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the geometric mean of an array a of size n.; 1120/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1121 ; 1122template <typename T>; 1123Double_t TMath::GeomMean(Long64_t n, const T *a); 1124{; 1125 return TMath::GeomMean(a, a+n);; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/// Returns the Standard Deviation of an array defined by the iterators.; 1130/// Note that this function returns the sigma(standard deviation) and; 1131/// not the root mean square of the ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:39664,Testability,log,logsum,39664,"83}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Returns the weighted mean of an array a with length n.; 1087 ; 1088template <typename T>; 1089Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w); 1090{; 1091 if (w) {; 1092 return TMath::Mean(a, a+n, w);; 1093 } else {; 1094 return TMath::Mean(a, a+n);; 1095 }; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Returns the geometric mean of an array defined by the iterators.; 1100/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1101 ; 1102template <typename Iterator>; 1103Double_t TMath::GeomMean(Iterator first, Iterator last); 1104{; 1105 Double_t logsum = 0.;; 1106 Long64_t n = 0;; 1107 while ( first != last ) {; 1108 if (*first == 0) return 0.;; 1109 Double_t absa = (Double_t) TMath::Abs(*first);; 1110 logsum += TMath::Log(absa);; 1111 ++first;; 1112 ++n;; 1113 }; 1114 ; 1115 return TMath::Exp(logsum/n);; 1116}; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the geometric mean of an array a of size n.; 1120/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1121 ; 1122template <typename T>; 1123Double_t TMath::GeomMean(Long64_t n, const T *a); 1124{; 1125 return TMath::GeomMean(a, a+n);; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/// Returns the Standard Deviation of an array defined by the iterators.; 1130/// Note that this function returns the sigma(standard deviation) and; 1131/// not the root mean square of the array.; 1132///; 1133/// Use the two pass algorithm, which is slower (! a factor of 2) but much more; 1134/// precise. Since we have a vector the 2 pass algorithm is still faster than the; 1135/// Welford algorithm. (See also ROOT-5545); 1136 ; 1137template <typename Iterator>; 1138Double_t TMath::RMS(Iterator first, Iterator last); 1139{; 1140 ; ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:39757,Testability,log,logsum,39757,"83}; 1084 ; 1085////////////////////////////////////////////////////////////////////////////////; 1086/// Returns the weighted mean of an array a with length n.; 1087 ; 1088template <typename T>; 1089Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w); 1090{; 1091 if (w) {; 1092 return TMath::Mean(a, a+n, w);; 1093 } else {; 1094 return TMath::Mean(a, a+n);; 1095 }; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Returns the geometric mean of an array defined by the iterators.; 1100/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1101 ; 1102template <typename Iterator>; 1103Double_t TMath::GeomMean(Iterator first, Iterator last); 1104{; 1105 Double_t logsum = 0.;; 1106 Long64_t n = 0;; 1107 while ( first != last ) {; 1108 if (*first == 0) return 0.;; 1109 Double_t absa = (Double_t) TMath::Abs(*first);; 1110 logsum += TMath::Log(absa);; 1111 ++first;; 1112 ++n;; 1113 }; 1114 ; 1115 return TMath::Exp(logsum/n);; 1116}; 1117 ; 1118////////////////////////////////////////////////////////////////////////////////; 1119/// Returns the geometric mean of an array a of size n.; 1120/// \f[ GeomMean = (\prod_{i=0}^{n-1} |a[i]|)^{1/n} \f]; 1121 ; 1122template <typename T>; 1123Double_t TMath::GeomMean(Long64_t n, const T *a); 1124{; 1125 return TMath::GeomMean(a, a+n);; 1126}; 1127 ; 1128////////////////////////////////////////////////////////////////////////////////; 1129/// Returns the Standard Deviation of an array defined by the iterators.; 1130/// Note that this function returns the sigma(standard deviation) and; 1131/// not the root mean square of the array.; 1132///; 1133/// Use the two pass algorithm, which is slower (! a factor of 2) but much more; 1134/// precise. Since we have a vector the 2 pass algorithm is still faster than the; 1135/// Welford algorithm. (See also ROOT-5545); 1136 ; 1137template <typename Iterator>; 1138Double_t TMath::RMS(Iterator first, Iterator last); 1139{; 1140 ; ",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:56745,Testability,test,test,56745," x.Definition TMath.cxx:1590; TMath::KOrdStatElement KOrdStat(Size n, const Element *a, Size k, Size *work=0)Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements).Definition TMath.h:1359; TMath::GausDouble_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE)Calculates a gaussian function with mean and sigma.Definition TMath.cxx:471; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::GUncertaintyconstexpr Double_t GUncertainty()Gravitational constant uncertainty.Definition TMath.h:150; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; TMath::FactorialDouble_t Factorial(Int_t i)Computes factorial(n).Definition TMath.cxx:252; TMath::RMSDouble_t RMS(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the Standard Deviation of an array a with length n.Definition TMath.h:1188; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::GhbarCUncertaintyconstexpr Double_t GhbarCUncertainty()uncertainty.Definition TMath.h:166; TMath::LocMinLong64_t LocMin(Long64_t n, const T *a)Returns index of array with the minimum element.Definition TMath.h:982; TMath::Ccgsconstexpr Double_t Ccgs()Definition TMath.h:121; TMath::SigmaUncertaintyconstexpr Double_t SigmaUncertainty()Stefan-Boltzmann constant uncertainty.Definition TMath.h:277; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::BinomialIDouble_t BinomialI(Double_t p, Int_t n, Int_t k)Suppose an event occurs with probability p per trial Then the probability P of its occurring k or mor...Definition TMath.cxx:2141; TMath::VavilovDouble_t Vavilov(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov probability density functi",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:58669,Testability,log,logarithm,58669,"ppa, Double_t beta2)Returns the value of the Vavilov probability density function.Definition TMath.cxx:2778; TMath::BinomialDouble_t Binomial(Int_t n, Int_t k)Calculates the binomial coefficient n over k.Definition TMath.cxx:2111; TMath::NormalizeFloat_t Normalize(Float_t v[3])Normalize a vector v in place.Definition TMath.cxx:518; TMath::NaUncertaintyconstexpr Double_t NaUncertainty()Avogadro constant (Avogadro's Number) uncertainty.Definition TMath.h:291; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::Log2Double_t Log2(Double_t x)Returns the binary (base-2) logarithm of x.Definition TMath.cxx:107; TMath::BesselK1Double_t BesselK1(Double_t x)Modified Bessel function I_1(x)Definition TMath.cxx:1529; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::BubbleHighvoid BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2)Bubble sort variant to obtain the order of an array's elements into an index in order to do more usef...Definition TMath.cxx:1314; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::BesselI1Double_t BesselI1(Double_t x)Modified Bessel function K_0(x)Definition TMath.cxx:1494; TMath::ErfDouble_t Erf(Double_t x)Computation of the error function erf(x).Definition TMath.cxx:190; TMath::PermuteBool_t Permute(Int_t n, Int_t *a)Simple recursive algorithm to find the permutations of n natural numbers, not necessarily all dist",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:64623,Testability,log,log,64623,"uble_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::RUncertaintyconstexpr Double_t RUncertainty()Universal gas constant uncertainty.Definition TMath.h:309; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::LocMaxLong64_t LocMax(Long64_t n, const T *a)Returns index of array with the maximum element.Definition TMath.h:1012; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::GnUncertaintyconstexpr Double_t GnUncertainty()Standard acceleration of gravity uncertainty.Definition TMath.h:181; TMath::Hcgsconstexpr Double_t Hcgs()Definition TMath.h:195; TMath::HUncertaintyconstexpr Double_t HUncertainty()Planck's constant uncertainty.Definition TMath.h:202; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)C",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:64995,Testability,log,logarithm,64995," Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::LocMaxLong64_t LocMax(Long64_t n, const T *a)Returns index of array with the maximum element.Definition TMath.h:1012; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; TMath::GnUncertaintyconstexpr Double_t GnUncertainty()Standard acceleration of gravity uncertainty.Definition TMath.h:181; TMath::Hcgsconstexpr Double_t Hcgs()Definition TMath.h:195; TMath::HUncertaintyconstexpr Double_t HUncertainty()Planck's constant uncertainty.Definition TMath.h:202; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::DegToRadconstexpr Double_t DegToRad()Conversion from degree to radian: .Definition TMath.h:79; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::Sigmaconstexpr Double_t Sigma()Stefan-Boltzmann constant in : .Definition TMath.h:270; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H(",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:66659,Testability,log,log,66659,"ition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::PiOver4constexpr Double_t PiOver4()Definition TMath.h:58; TMath::CosDouble_t Cos(Double_t)Returns the c",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:66686,Testability,log,log,66686,"ition TMath.cxx:2011; TMath::Kcgsconstexpr Double_t Kcgs()Definition TMath.h:254; TMath::SqDouble_t Sq(Double_t x)Returns x*x.Definition TMath.h:656; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::Hconstexpr Double_t H()Planck's constant in : .Definition TMath.h:188; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::CeilNintInt_t CeilNint(Double_t x)Returns the nearest integer of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::PiOver4constexpr Double_t PiOver4()Definition TMath.h:58; TMath::CosDouble_t Cos(Double_t)Returns the c",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:67294,Testability,log,log,67294,"teger of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::PiOver4constexpr Double_t PiOver4()Definition TMath.h:58; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Quantilesvoid Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7)Computes sample quantiles, corresponding to the given probabilities.Definition TMath.cxx:1207; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::StruveH0Double_t StruveH0(Double_t x)Bessel function Y1(x) for positive x.Definition TMath.cxx:1777; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::LnGammaDouble_t LnGamma(Double_t z)Computation of ln[gamma(z)] for all z",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:67316,Testability,log,log,67316,"teger of TMath::Ceil(x).Definition TMath.h:674; TMath::LdexpDouble_t Ldexp(Double_t x, Int_t exp)Returns the result of multiplying x (the significant) by 2 raised to the power of exp (the exponent).Definition TMath.h:715; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::LogEconstexpr Double_t LogE()Base-10 log of e (to convert ln to log)Definition TMath.h:107; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MWairconstexpr Double_t MWair()Molecular weight of dry air 1976 US Standard Atmosphere in orDefinition TMath.h:317; TMath::Gcgsconstexpr Double_t Gcgs()Definition TMath.h:143; TMath::StruveL0Double_t StruveL0(Double_t x)Struve functions of order 1.Definition TMath.cxx:1923; TMath::NormQuantileDouble_t NormQuantile(Double_t p)Computes quantiles for standard normal distribution N(0, 1) at probability p.Definition TMath.cxx:2456; TMath::Ln10constexpr Double_t Ln10()Natural log of 10 (to convert log to ln)Definition TMath.h:100; TMath::HypotDouble_t Hypot(Double_t x, Double_t y)Returns sqrt(x*x + y*y)Definition TMath.cxx:59; TMath::EulerGammaconstexpr Double_t EulerGamma()Euler-Mascheroni Constant.Definition TMath.h:332; TMath::PiOver4constexpr Double_t PiOver4()Definition TMath.h:58; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::Quantilesvoid Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob, Bool_t isSorted=kTRUE, Int_t *index=nullptr, Int_t type=7)Computes sample quantiles, corresponding to the given probabilities.Definition TMath.cxx:1207; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::StruveH0Double_t StruveH0(Double_t x)Bessel function Y1(x) for positive x.Definition TMath.cxx:1777; TMath::Rconstexpr Double_t R()Universal gas constant ( ) inDefinition TMath.h:302; TMath::LnGammaDouble_t LnGamma(Double_t z)Computation of ln[gamma(z)] for all z",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMath_8h_source.html:72154,Testability,log,logarithm,72154," TMath::Hbarconstexpr Double_t Hbar()in :Definition TMath.h:211; TMath::StruveH1Double_t StruveH1(Double_t x)Struve functions of order 0.Definition TMath.cxx:1846; TMath::FreqDouble_t Freq(Double_t x)Computation of the normal frequency function freq(x).Definition TMath.cxx:270; TMath::TanDouble_t Tan(Double_t)Returns the tangent of an angle of x radians.Definition TMath.h:600; TMath::LandauIDouble_t LandauI(Double_t x)Returns the cumulative (lower tail integral) of the Landau distribution function at point x.Definition TMath.cxx:2845; TMath::StdDevDouble_t StdDev(Long64_t n, const T *a, const Double_t *w=nullptr)Definition TMath.h:527; TMath::ATanHDouble_t ATanH(Double_t)Returns the area hyperbolic tangent of x.Definition TMath.cxx:95; TMath::RadToDegconstexpr Double_t RadToDeg()Conversion from radian to degree: .Definition TMath.h:72; TMath::BesselI0Double_t BesselI0(Double_t x)Integer order modified Bessel function K_n(x)Definition TMath.cxx:1426; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::StudentIDouble_t StudentI(Double_t T, Double_t ndf)Calculates the cumulative distribution function of Student's t-distribution second parameter stands f...Definition TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::GhbarCconstexpr Double_t GhbarC()inDefinition TMath.h:158; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath",MatchSource.WIKI,doc/master/TMath_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html
https://root.cern/doc/master/TMatrixDBasefwd_8h.html:217,Integrability,depend,dependency,217,". ROOT: math/matrix/inc/TMatrixDBasefwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixDBasefwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixDBasefwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTBase< Double_t > TMatrixDBase;  . Typedef Documentation. ◆ TMatrixDBase. typedef TMatrixTBase<Double_t> TMatrixDBase. Definition at line 26 of file TMatrixDBasefwd.h. mathmatrixincTMatrixDBasefwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixDBasefwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixDBasefwd_8h.html
https://root.cern/doc/master/TMatrixDSymfwd_8h.html:215,Integrability,depend,dependency,215,". ROOT: math/matrix/inc/TMatrixDSymfwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixDSymfwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixDSymfwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTSym< Double_t > TMatrixDSym;  . Typedef Documentation. ◆ TMatrixDSym. typedef TMatrixTSym<Double_t> TMatrixDSym. Definition at line 23 of file TMatrixDSymfwd.h. mathmatrixincTMatrixDSymfwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixDSymfwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixDSymfwd_8h.html
https://root.cern/doc/master/TMatrixFBasefwd_8h.html:217,Integrability,depend,dependency,217,". ROOT: math/matrix/inc/TMatrixFBasefwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TMatrixFBasefwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TMatrixFBasefwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TMatrixTBase< Float_t > TMatrixFBase;  . Typedef Documentation. ◆ TMatrixFBase. typedef TMatrixTBase<Float_t> TMatrixFBase. Definition at line 26 of file TMatrixFBasefwd.h. mathmatrixincTMatrixFBasefwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixFBasefwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixFBasefwd_8h.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:5290,Availability,toler,tolerance,5290,"osed, kInverted and kAtA.; 117 ; 118template <class Element>; 119TMatrixT<Element>::TMatrixT(EMatrixCreatorsOp1 op, const TMatrixT<Element> &prototype); 120{; 121 R__ASSERT(prototype.IsValid());; 122 ; 123 switch (op) {; 124 case kZero:; 125 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 126 break;; 127 ; 128 case kUnit:; 129 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 130 this->UnitMatrix();; 131 break;; 132 ; 133 case kTransposed:; 134 Allocate(prototype.GetNcols(), prototype.GetNrows(), prototype.GetColLwb(), prototype.GetRowLwb());; 135 Transpose(prototype);; 136 break;; 137 ; 138 case kInverted: {; 139 Allocate(prototype.GetNrows(), prototype.GetNcols(), prototype.GetRowLwb(), prototype.GetColLwb(), 1);; 140 *this = prototype;; 141 // Since the user can not control the tolerance of this newly created matrix; 142 // we put it to the smallest possible number; 143 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 144 this->Invert();; 145 this->SetTol(oldTol);; 146 break;; 147 }; 148 ; 149 case kAtA:; 150 Allocate(prototype.GetNcols(), prototype.GetNcols(), prototype.GetColLwb(), prototype.GetColLwb(), 1);; 151 TMult(prototype, prototype);; 152 break;; 153 ; 154 default: Error(""TMatrixT(EMatrixCreatorOp1)"", ""operation %d not yet implemented"", op);; 155 }; 156}; 157 ; 158////////////////////////////////////////////////////////////////////////////////; 159/// Constructor of matrix applying a specific operation to two prototypes.; 160/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:125173,Availability,error,error,125173,".h:37; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; templateClassImp#define templateClassImp(name)Definition Rtypes.h:427; kPlus@ kPlusDefinition TAttMarker.h:53; TBuffer.h; operator<=Bool_t operator<=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:108; operator>Bool_t operator>(const TDatime &d1, const TDatime &d2)Definition TDatime.h:110; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; operator>=Bool_t operator>=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:112; operator<Bool_t operator<(const TDatime &d1, const TDatime &d2)Definition TDatime.h:106; TDecompLU.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent co",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:125308,Availability,error,error,125308,"94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; templateClassImp#define templateClassImp(name)Definition Rtypes.h:427; kPlus@ kPlusDefinition TAttMarker.h:53; TBuffer.h; operator<=Bool_t operator<=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:108; operator>Bool_t operator>(const TDatime &d1, const TDatime &d2)Definition TDatime.h:110; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; operator>=Bool_t operator>=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:112; operator<Bool_t operator<(const TDatime &d1, const TDatime &d2)Definition TDatime.h:106; TDecompLU.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth ",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:6256,Energy Efficiency,allocate,allocated,6256,"ype;; 141 // Since the user can not control the tolerance of this newly created matrix; 142 // we put it to the smallest possible number; 143 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 144 this->Invert();; 145 this->SetTol(oldTol);; 146 break;; 147 }; 148 ; 149 case kAtA:; 150 Allocate(prototype.GetNcols(), prototype.GetNcols(), prototype.GetColLwb(), prototype.GetColLwb(), 1);; 151 TMult(prototype, prototype);; 152 break;; 153 ; 154 default: Error(""TMatrixT(EMatrixCreatorOp1)"", ""operation %d not yet implemented"", op);; 155 }; 156}; 157 ; 158////////////////////////////////////////////////////////////////////////////////; 159/// Constructor of matrix applying a specific operation to two prototypes.; 160/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->S",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:9991,Energy Efficiency,allocate,allocated,9991,");; 250 *this = a;; 251 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 252 this->Invert();; 253 this->SetTol(oldTol);; 254 *this *= b;; 255 break;; 256 }; 257 ; 258 case kPlus: {; 259 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 260 Plus(a, b);; 261 break;; 262 }; 263 ; 264 case kMinus: {; 265 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 266 Minus(a, b);; 267 break;; 268 }; 269 ; 270 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 271 }; 272}; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Constructor of matrix applying a specific operation to two prototypes.; 276/// Example: TMatrixT<Element> a(10,12), b(12,5); ...; TMatrixT<Element> c(a, TMatrixT::kMult, b);; 277/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b); 278/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 279 ; 280template <class Element>; 281TMatrixT<Element>::TMatrixT(const TMatrixTSym<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 282{; 283 R__ASSERT(a.IsValid());; 284 R__ASSERT(b.IsValid());; 285 ; 286 switch (op) {; 287 case kMult:; 288 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 289 Mult(a, b);; 290 break;; 291 ; 292 case kTransposeMult:; 293 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 294 TMult(a, b);; 295 break;; 296 ; 297 case kMultTranspose:; 298 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 299 MultT(a, b);; 300 break;; 301 ; 302 case kInvMult: {; 303 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 304 // if size(a) == size(b), perform in place computation; 305 if (a.GetNrows() == b.GetNcols()) {; 306 *this = a;; 307 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 308 this->Invert();; 309 this->",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:138333,Energy Efficiency,power,power,138333,"TMatrixT< Element > & operator/=(const TMatrixTDiag_const< Element > &diag)Divide a matrix row by the diagonal of another matrix matrix(i,j) /= diag(j)Definition TMatrixT.cxx:2109; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::ResizeToTVectorT< Element > & ResizeTo(Int_t lwb, Int_t upb)Resize the vector to [lwb:upb] .Definition TVectorT.cxx:294; bool; double; int; unsigned int; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this ",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:26958,Integrability,rout,routine,26958,"m(CblasRowMajor, CblasRight, CblasUpper, fNrows, fNcols, 1.0, bp, b.GetNcols(), ap, a.GetNcols(), 0.0,; 772 cp, fNcols);; 773 else if (typeid(Element) != typeid(Float_t)); 774 cblas_ssymm(CblasRowMajor, CblasRight, CblasUpper, fNrows, fNcols, 1.0, bp, b.GetNcols(), ap, a.GetNcols(), 0.0,; 775 cp, fNcols);; 776 else; 777 Error(""Mult"", ""type %s not implemented in BLAS library"", typeid(Element));; 778#else; 779 const Int_t na = a.GetNoElements();; 780 const Int_t nb = b.GetNoElements();; 781 const Int_t ncolsa = a.GetNcols();; 782 const Int_t ncolsb = b.GetNcols();; 783 const Element *const ap = a.GetMatrixArray();; 784 const Element *const bp = b.GetMatrixArray();; 785 Element *cp = this->GetMatrixArray();; 786 ; 787 AMultB(ap, na, ncolsa, bp, nb, ncolsb, cp);; 788#endif; 789}; 790 ; 791////////////////////////////////////////////////////////////////////////////////; 792/// Matrix multiplication, with A symmetric and B symmetric.; 793/// (Actually copied for the moment routine for B general); 794/// Replace this matrix with C such that C = A * B.; 795 ; 796template <class Element>; 797void TMatrixT<Element>::Mult(const TMatrixTSym<Element> &a, const TMatrixTSym<Element> &b); 798{; 799 if (gMatrixCheck) {; 800 R__ASSERT(a.IsValid());; 801 R__ASSERT(b.IsValid());; 802 if (a.GetNcols() != b.GetNrows() || a.GetColLwb() != b.GetRowLwb()) {; 803 Error(""Mult"", ""A rows and B columns incompatible"");; 804 return;; 805 }; 806 ; 807 if (this->GetMatrixArray() == a.GetMatrixArray()) {; 808 Error(""Mult"", ""this->GetMatrixArray() == a.GetMatrixArray()"");; 809 return;; 810 }; 811 ; 812 if (this->GetMatrixArray() == b.GetMatrixArray()) {; 813 Error(""Mult"", ""this->GetMatrixArray() == b.GetMatrixArray()"");; 814 return;; 815 }; 816 }; 817 ; 818#ifdef CBLAS; 819 const Element *ap = a.GetMatrixArray();; 820 const Element *bp = b.GetMatrixArray();; 821 Element *cp = this->GetMatrixArray();; 822 if (typeid(Element) == typeid(Double_t)); 823 cblas_dsymm(CblasRowMajor, CblasLeft, CblasUpper, fNr",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:37532,Integrability,depend,depends,37532,"b] x [col_lwb..col_upb]); 1047 ; 1048template <class Element>; 1049TMatrixT<Element> &TMatrixT<Element>::Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Element *data); 1050{; 1051 if (gMatrixCheck) {; 1052 if (row_upb < row_lwb) {; 1053 Error(""Use"", ""row_upb=%d < row_lwb=%d"", row_upb, row_lwb);; 1054 return *this;; 1055 }; 1056 if (col_upb < col_lwb) {; 1057 Error(""Use"", ""col_upb=%d < col_lwb=%d"", col_upb, col_lwb);; 1058 return *this;; 1059 }; 1060 }; 1061 ; 1062 Clear();; 1063 this->fNrows = row_upb - row_lwb + 1;; 1064 this->fNcols = col_upb - col_lwb + 1;; 1065 this->fRowLwb = row_lwb;; 1066 this->fColLwb = col_lwb;; 1067 this->fNelems = this->fNrows * this->fNcols;; 1068 fElements = data;; 1069 this->fIsOwner = kFALSE;; 1070 ; 1071 return *this;; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Get submatrix [row_lwb..row_upb] x [col_lwb..col_upb]; The indexing range of the; 1076/// returned matrix depends on the argument option:; 1077///; 1078/// option == ""S"" : return [0..row_upb-row_lwb][0..col_upb-col_lwb] (default); 1079/// else : return [row_lwb..row_upb][col_lwb..col_upb]; 1080 ; 1081template <class Element>; 1082TMatrixTBase<Element> &TMatrixT<Element>::GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb,; 1083 TMatrixTBase<Element> &target, Option_t *option) const; 1084{; 1085 if (gMatrixCheck) {; 1086 R__ASSERT(this->IsValid());; 1087 if (row_lwb < this->fRowLwb || row_lwb > this->fRowLwb + this->fNrows - 1) {; 1088 Error(""GetSub"", ""row_lwb out of bounds"");; 1089 return target;; 1090 }; 1091 if (col_lwb < this->fColLwb || col_lwb > this->fColLwb + this->fNcols - 1) {; 1092 Error(""GetSub"", ""col_lwb out of bounds"");; 1093 return target;; 1094 }; 1095 if (row_upb < this->fRowLwb || row_upb > this->fRowLwb + this->fNrows - 1) {; 1096 Error(""GetSub"", ""row_upb out of bounds"");; 1097 return target;; 1098 }; 1099 if (col_upb < this->fColLwb || col_upb > this->fColLwb + th",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:107686,Integrability,rout,routine,107686,,MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:108632,Integrability,rout,routine,108632,"/////////////////////////////; 3078/// Elementary routine to calculate matrix multiplication A*B; 3079 ; 3080template <class Element>; 3081void TMatrixTAutoloadOps::AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb,; 3082 Int_t ncolsb, Element *cp); 3083{; 3084 const Element *arp0 = ap; // Pointer to A[i,0];; 3085 while (arp0 < ap + na) {; 3086 for (const Element *bcp = bp; bcp < bp + ncolsb;) { // Pointer to the j-th column of B, Start bcp = B[0,0]; 3087 const Element *arp = arp0; // Pointer to the i-th row of A, reset to A[i,0]; 3088 Element cij = 0;; 3089 while (bcp < bp + nb) { // Scan the i-th row of A and; 3090 cij += *arp++ * *bcp; // the j-th col of B; 3091 bcp += ncolsb;; 3092 }; 3093 *cp++ = cij;; 3094 bcp -= nb - 1; // Set bcp to the (j+1)-th col; 3095 }; 3096 arp0 += ncolsa; // Set ap to the (i+1)-th row; 3097 }; 3098}; 3099 ; 3100////////////////////////////////////////////////////////////////////////////////; 3101/// Elementary routine to calculate matrix multiplication A^T*B; 3102 ; 3103template <class Element>; 3104void TMatrixTAutoloadOps::AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb,; 3105 Int_t ncolsb, Element *cp); 3106{; 3107 const Element *acp0 = ap; // Pointer to A[i,0];; 3108 while (acp0 < ap + ncolsa) {; 3109 for (const Element *bcp = bp; bcp < bp + ncolsb;) { // Pointer to the j-th column of B, Start bcp = B[0,0]; 3110 const Element *acp = acp0; // Pointer to the i-th column of A, reset to A[0,i]; 3111 Element cij = 0;; 3112 while (bcp < bp + nb) { // Scan the i-th column of A and; 3113 cij += *acp * *bcp; // the j-th col of B; 3114 acp += ncolsa;; 3115 bcp += ncolsb;; 3116 }; 3117 *cp++ = cij;; 3118 bcp -= nb - 1; // Set bcp to the (j+1)-th col; 3119 }; 3120 acp0++; // Set acp0 to the (i+1)-th col; 3121 }; 3122}; 3123 ; 3124////////////////////////////////////////////////////////////////////////////////; 3125/// Elementary routine to calculate matrix multiplication",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:109594,Integrability,rout,routine,109594,"/////////////; 3101/// Elementary routine to calculate matrix multiplication A^T*B; 3102 ; 3103template <class Element>; 3104void TMatrixTAutoloadOps::AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb,; 3105 Int_t ncolsb, Element *cp); 3106{; 3107 const Element *acp0 = ap; // Pointer to A[i,0];; 3108 while (acp0 < ap + ncolsa) {; 3109 for (const Element *bcp = bp; bcp < bp + ncolsb;) { // Pointer to the j-th column of B, Start bcp = B[0,0]; 3110 const Element *acp = acp0; // Pointer to the i-th column of A, reset to A[0,i]; 3111 Element cij = 0;; 3112 while (bcp < bp + nb) { // Scan the i-th column of A and; 3113 cij += *acp * *bcp; // the j-th col of B; 3114 acp += ncolsa;; 3115 bcp += ncolsb;; 3116 }; 3117 *cp++ = cij;; 3118 bcp -= nb - 1; // Set bcp to the (j+1)-th col; 3119 }; 3120 acp0++; // Set acp0 to the (i+1)-th col; 3121 }; 3122}; 3123 ; 3124////////////////////////////////////////////////////////////////////////////////; 3125/// Elementary routine to calculate matrix multiplication A*B^T; 3126 ; 3127template <class Element>; 3128void TMatrixTAutoloadOps::AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb,; 3129 Int_t ncolsb, Element *cp); 3130{; 3131 const Element *arp0 = ap; // Pointer to A[i,0];; 3132 while (arp0 < ap + na) {; 3133 const Element *brp0 = bp; // Pointer to B[j,0];; 3134 while (brp0 < bp + nb) {; 3135 const Element *arp = arp0; // Pointer to the i-th row of A, reset to A[i,0]; 3136 const Element *brp = brp0; // Pointer to the j-th row of B, reset to B[j,0]; 3137 Element cij = 0;; 3138 while (brp < brp0 + ncolsb) // Scan the i-th row of A and; 3139 cij += *arp++ * *brp++; // the j-th row of B; 3140 *cp++ = cij;; 3141 brp0 += ncolsb; // Set brp0 to the (j+1)-th row; 3142 }; 3143 arp0 += ncolsa; // Set arp0 to the (i+1)-th row; 3144 }; 3145}; 3146 ; 3147////////////////////////////////////////////////////////////////////////////////; 3148/// Stream an object of class TMatr",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:138829,Integrability,rout,routine,138829,"oUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::ResizeToTVectorT< Element > & ResizeTo(Int_t lwb, Int_t upb)Resize the vector to [lwb:upb] .Definition TVectorT.cxx:294; bool; double; int; unsigned int; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; ",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:139068,Integrability,rout,routine,139068,"T< Element > & ResizeTo(Int_t lwb, Int_t upb)Resize the vector to [lwb:upb] .Definition TVectorT.cxx:294; bool; double; int; unsigned int; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator|",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:139490,Integrability,rout,routine,139490," and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator||TMatrixT< Element > operator||(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical OR.Definition TMatrixT.cxx:2525; TMatrixTAutoloadOps::operator<TMatrixT< Element > operator<(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 < source2Definition TMatrixT.cxx:2779; TMatrixTAutoloadOps::operator>TMatrixT< Element > operator>(const TMatrixT< Element > &",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:7045,Performance,perform,perform,7045,"TMatrixT<Element> c(a, TMatrixT::kMult, b);; 161/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b);; 162/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 163 ; 164template <class Element>; 165TMatrixT<Element>::TMatrixT(const TMatrixT<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 166{; 167 R__ASSERT(a.IsValid());; 168 R__ASSERT(b.IsValid());; 169 ; 170 switch (op) {; 171 case kMult:; 172 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 173 Mult(a, b);; 174 break;; 175 ; 176 case kTransposeMult:; 177 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 178 TMult(a, b);; 179 break;; 180 ; 181 case kMultTranspose:; 182 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 183 MultT(a, b);; 184 break;; 185 ; 186 case kInvMult: {; 187 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 188 // if size(a) == size(b), perform in place computation; 189 if (a.GetNrows() == b.GetNcols()) {; 190 *this = a;; 191 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 192 this->Invert();; 193 this->SetTol(oldTol);; 194 *this *= b;; 195 } else {; 196 TMatrixT<Element> ainv = a;; 197 const Element oldTol = ainv.SetTol(std::numeric_limits<Element>::min());; 198 ainv.Invert();; 199 ainv.SetTol(oldTol);; 200 Mult(ainv, b);; 201 }; 202 break;; 203 }; 204 ; 205 case kPlus: {; 206 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 207 Plus(a, b);; 208 break;; 209 }; 210 ; 211 case kMinus: {; 212 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 213 Minus(a, b);; 214 break;; 215 }; 216 ; 217 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 218 }; 219}; 220 ; 221////////////////////////////////////////////////////////////////////////////////; 222/// Constructor of matrix applying a specific operation to two prot",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:10783,Performance,perform,perform,10783,"atrixT<Element> c(a, TMatrixT::kMult, b);; 277/// Supported operations are: kMult (a*b), kTransposeMult (a'*b), kInvMult (a^(-1)*b); 278/// Whenever kInvMult is invoked and b is not squared, additional memory is allocated for a^(-1); 279 ; 280template <class Element>; 281TMatrixT<Element>::TMatrixT(const TMatrixTSym<Element> &a, EMatrixCreatorsOp2 op, const TMatrixT<Element> &b); 282{; 283 R__ASSERT(a.IsValid());; 284 R__ASSERT(b.IsValid());; 285 ; 286 switch (op) {; 287 case kMult:; 288 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 289 Mult(a, b);; 290 break;; 291 ; 292 case kTransposeMult:; 293 Allocate(a.GetNcols(), b.GetNcols(), a.GetColLwb(), b.GetColLwb(), 1);; 294 TMult(a, b);; 295 break;; 296 ; 297 case kMultTranspose:; 298 Allocate(a.GetNrows(), b.GetNrows(), a.GetRowLwb(), b.GetRowLwb(), 1);; 299 MultT(a, b);; 300 break;; 301 ; 302 case kInvMult: {; 303 Allocate(a.GetNrows(), b.GetNcols(), a.GetRowLwb(), b.GetColLwb(), 1);; 304 // if size(a) == size(b), perform in place computation; 305 if (a.GetNrows() == b.GetNcols()) {; 306 *this = a;; 307 const Element oldTol = this->SetTol(std::numeric_limits<Element>::min());; 308 this->Invert();; 309 this->SetTol(oldTol);; 310 *this *= b;; 311 } else {; 312 TMatrixTSym<Element> ainv = a;; 313 const Element oldTol = ainv.SetTol(std::numeric_limits<Element>::min());; 314 ainv.Invert();; 315 ainv.SetTol(oldTol);; 316 Mult(ainv, b);; 317 }; 318 break;; 319 }; 320 ; 321 case kPlus: {; 322 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 323 Plus(a, b);; 324 break;; 325 }; 326 ; 327 case kMinus: {; 328 Allocate(a.GetNrows(), a.GetNcols(), a.GetRowLwb(), a.GetColLwb(), 1);; 329 Minus(a, b);; 330 break;; 331 }; 332 ; 333 default: Error(""TMatrixT(EMatrixCreatorOp2)"", ""operation %d not yet implemented"", op);; 334 }; 335}; 336 ; 337////////////////////////////////////////////////////////////////////////////////; 338/// Constructor of matrix applying a specific operation to two p",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:90671,Testability,log,logical,90671,"rixT<Element> target;; 2553 ; 2554 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2555 Error(""operator||(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2556 return target;; 2557 }; 2558 ; 2559 target.ResizeTo(source1);; 2560 ; 2561 const Element *sp1 = source1.GetMatrixArray();; 2562 const Element *sp2 = source2.GetMatrixArray();; 2563 Element *tp = target.GetMatrixArray();; 2564 const Element *const tp_last = tp + target.GetNoElements();; 2565 while (tp < tp_last); 2566 *tp++ = (*sp1++ != 0.0 || *sp2++ != 0.0);; 2567 ; 2568 return target;; 2569}; 2570 ; 2571////////////////////////////////////////////////////////////////////////////////; 2572/// Logical OR; 2573 ; 2574template <class Element>; 2575TMatrixT<Element> TMatrixTAutoloadOps::operator||(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2576{; 2577 return operator||(source2, source1);; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/// logical operation source1 > source2; 2582 ; 2583template <class Element>; 2584TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2585{; 2586 TMatrixT<Element> target;; 2587 ; 2588 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2589 Error(""operator|(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2590 return target;; 2591 }; 2592 ; 2593 target.ResizeTo(source1);; 2594 ; 2595 const Element *sp1 = source1.GetMatrixArray();; 2596 const Element *sp2 = source2.GetMatrixArray();; 2597 Element *tp = target.GetMatrixArray();; 2598 const Element *const tp_last = tp + target.GetNoElements();; 2599 while (tp < tp_last) {; 2600 *tp++ = (*sp1) > (*sp2);; 2601 sp1++;; 2602 sp2++;; 2603 }; 2604 ; 2605 return target;; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// logical operation source1 > source2; 2610 ; 2611template <class Elemen",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:91583,Testability,log,logical,91583,"eration source1 > source2; 2582 ; 2583template <class Element>; 2584TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2585{; 2586 TMatrixT<Element> target;; 2587 ; 2588 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2589 Error(""operator|(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2590 return target;; 2591 }; 2592 ; 2593 target.ResizeTo(source1);; 2594 ; 2595 const Element *sp1 = source1.GetMatrixArray();; 2596 const Element *sp2 = source2.GetMatrixArray();; 2597 Element *tp = target.GetMatrixArray();; 2598 const Element *const tp_last = tp + target.GetNoElements();; 2599 while (tp < tp_last) {; 2600 *tp++ = (*sp1) > (*sp2);; 2601 sp1++;; 2602 sp2++;; 2603 }; 2604 ; 2605 return target;; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// logical operation source1 > source2; 2610 ; 2611template <class Element>; 2612TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2613{; 2614 TMatrixT<Element> target;; 2615 ; 2616 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2617 Error(""operator>(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2618 return target;; 2619 }; 2620 ; 2621 target.ResizeTo(source1);; 2622 ; 2623 const Element *sp1 = source1.GetMatrixArray();; 2624 const Element *sp2 = source2.GetMatrixArray();; 2625 Element *tp = target.GetMatrixArray();; 2626 const Element *const tp_last = tp + target.GetNoElements();; 2627 while (tp < tp_last) {; 2628 *tp++ = (*sp1) > (*sp2);; 2629 sp1++;; 2630 sp2++;; 2631 }; 2632 ; 2633 return target;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// logical operation source1 > source2; 2638 ; 2639template <class Element>; 2640TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixTSym<Element> &source1, const TMatrixT<E",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:92501,Testability,log,logical,92501,"ce2); 2613{; 2614 TMatrixT<Element> target;; 2615 ; 2616 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2617 Error(""operator>(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2618 return target;; 2619 }; 2620 ; 2621 target.ResizeTo(source1);; 2622 ; 2623 const Element *sp1 = source1.GetMatrixArray();; 2624 const Element *sp2 = source2.GetMatrixArray();; 2625 Element *tp = target.GetMatrixArray();; 2626 const Element *const tp_last = tp + target.GetNoElements();; 2627 while (tp < tp_last) {; 2628 *tp++ = (*sp1) > (*sp2);; 2629 sp1++;; 2630 sp2++;; 2631 }; 2632 ; 2633 return target;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// logical operation source1 > source2; 2638 ; 2639template <class Element>; 2640TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2641{; 2642 return operator<=(source2, source1);; 2643}; 2644 ; 2645////////////////////////////////////////////////////////////////////////////////; 2646/// logical operation source1 >= source2; 2647 ; 2648template <class Element>; 2649TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2650{; 2651 TMatrixT<Element> target;; 2652 ; 2653 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2654 Error(""operator>=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2655 return target;; 2656 }; 2657 ; 2658 target.ResizeTo(source1);; 2659 ; 2660 const Element *sp1 = source1.GetMatrixArray();; 2661 const Element *sp2 = source2.GetMatrixArray();; 2662 Element *tp = target.GetMatrixArray();; 2663 const Element *const tp_last = tp + target.GetNoElements();; 2664 while (tp < tp_last) {; 2665 *tp++ = (*sp1) >= (*sp2);; 2666 sp1++;; 2667 sp2++;; 2668 }; 2669 ; 2670 return target;; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// lo",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:92858,Testability,log,logical,92858,"ce2); 2613{; 2614 TMatrixT<Element> target;; 2615 ; 2616 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2617 Error(""operator>(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2618 return target;; 2619 }; 2620 ; 2621 target.ResizeTo(source1);; 2622 ; 2623 const Element *sp1 = source1.GetMatrixArray();; 2624 const Element *sp2 = source2.GetMatrixArray();; 2625 Element *tp = target.GetMatrixArray();; 2626 const Element *const tp_last = tp + target.GetNoElements();; 2627 while (tp < tp_last) {; 2628 *tp++ = (*sp1) > (*sp2);; 2629 sp1++;; 2630 sp2++;; 2631 }; 2632 ; 2633 return target;; 2634}; 2635 ; 2636////////////////////////////////////////////////////////////////////////////////; 2637/// logical operation source1 > source2; 2638 ; 2639template <class Element>; 2640TMatrixT<Element> TMatrixTAutoloadOps::operator>(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2641{; 2642 return operator<=(source2, source1);; 2643}; 2644 ; 2645////////////////////////////////////////////////////////////////////////////////; 2646/// logical operation source1 >= source2; 2647 ; 2648template <class Element>; 2649TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2650{; 2651 TMatrixT<Element> target;; 2652 ; 2653 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2654 Error(""operator>=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2655 return target;; 2656 }; 2657 ; 2658 target.ResizeTo(source1);; 2659 ; 2660 const Element *sp1 = source1.GetMatrixArray();; 2661 const Element *sp2 = source2.GetMatrixArray();; 2662 Element *tp = target.GetMatrixArray();; 2663 const Element *const tp_last = tp + target.GetNoElements();; 2664 while (tp < tp_last) {; 2665 *tp++ = (*sp1) >= (*sp2);; 2666 sp1++;; 2667 sp2++;; 2668 }; 2669 ; 2670 return target;; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// lo",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:93774,Testability,log,logical,93774,"on source1 >= source2; 2647 ; 2648template <class Element>; 2649TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2650{; 2651 TMatrixT<Element> target;; 2652 ; 2653 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2654 Error(""operator>=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2655 return target;; 2656 }; 2657 ; 2658 target.ResizeTo(source1);; 2659 ; 2660 const Element *sp1 = source1.GetMatrixArray();; 2661 const Element *sp2 = source2.GetMatrixArray();; 2662 Element *tp = target.GetMatrixArray();; 2663 const Element *const tp_last = tp + target.GetNoElements();; 2664 while (tp < tp_last) {; 2665 *tp++ = (*sp1) >= (*sp2);; 2666 sp1++;; 2667 sp2++;; 2668 }; 2669 ; 2670 return target;; 2671}; 2672 ; 2673////////////////////////////////////////////////////////////////////////////////; 2674/// logical operation source1 >= source2; 2675 ; 2676template <class Element>; 2677TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2678{; 2679 TMatrixT<Element> target;; 2680 ; 2681 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2682 Error(""operator>=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2683 return target;; 2684 }; 2685 ; 2686 target.ResizeTo(source1);; 2687 ; 2688 const Element *sp1 = source1.GetMatrixArray();; 2689 const Element *sp2 = source2.GetMatrixArray();; 2690 Element *tp = target.GetMatrixArray();; 2691 const Element *const tp_last = tp + target.GetNoElements();; 2692 while (tp < tp_last) {; 2693 *tp++ = (*sp1) >= (*sp2);; 2694 sp1++;; 2695 sp2++;; 2696 }; 2697 ; 2698 return target;; 2699}; 2700 ; 2701////////////////////////////////////////////////////////////////////////////////; 2702/// logical operation source1 >= source2; 2703 ; 2704template <class Element>; 2705TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixTSym<Element> &source1, const TMatr",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:94696,Testability,log,logical,94696,"2); 2678{; 2679 TMatrixT<Element> target;; 2680 ; 2681 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2682 Error(""operator>=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2683 return target;; 2684 }; 2685 ; 2686 target.ResizeTo(source1);; 2687 ; 2688 const Element *sp1 = source1.GetMatrixArray();; 2689 const Element *sp2 = source2.GetMatrixArray();; 2690 Element *tp = target.GetMatrixArray();; 2691 const Element *const tp_last = tp + target.GetNoElements();; 2692 while (tp < tp_last) {; 2693 *tp++ = (*sp1) >= (*sp2);; 2694 sp1++;; 2695 sp2++;; 2696 }; 2697 ; 2698 return target;; 2699}; 2700 ; 2701////////////////////////////////////////////////////////////////////////////////; 2702/// logical operation source1 >= source2; 2703 ; 2704template <class Element>; 2705TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2706{; 2707 return operator<(source2, source1);; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// logical operation source1 <= source2; 2712 ; 2713template <class Element>; 2714TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2715{; 2716 TMatrixT<Element> target;; 2717 ; 2718 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2719 Error(""operator<=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2720 return target;; 2721 }; 2722 ; 2723 target.ResizeTo(source1);; 2724 ; 2725 const Element *sp1 = source1.GetMatrixArray();; 2726 const Element *sp2 = source2.GetMatrixArray();; 2727 Element *tp = target.GetMatrixArray();; 2728 const Element *const tp_last = tp + target.GetNoElements();; 2729 while (tp < tp_last) {; 2730 *tp++ = (*sp1) <= (*sp2);; 2731 sp1++;; 2732 sp2++;; 2733 }; 2734 ; 2735 return target;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// l",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:95054,Testability,log,logical,95054,"2); 2678{; 2679 TMatrixT<Element> target;; 2680 ; 2681 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2682 Error(""operator>=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2683 return target;; 2684 }; 2685 ; 2686 target.ResizeTo(source1);; 2687 ; 2688 const Element *sp1 = source1.GetMatrixArray();; 2689 const Element *sp2 = source2.GetMatrixArray();; 2690 Element *tp = target.GetMatrixArray();; 2691 const Element *const tp_last = tp + target.GetNoElements();; 2692 while (tp < tp_last) {; 2693 *tp++ = (*sp1) >= (*sp2);; 2694 sp1++;; 2695 sp2++;; 2696 }; 2697 ; 2698 return target;; 2699}; 2700 ; 2701////////////////////////////////////////////////////////////////////////////////; 2702/// logical operation source1 >= source2; 2703 ; 2704template <class Element>; 2705TMatrixT<Element> TMatrixTAutoloadOps::operator>=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2706{; 2707 return operator<(source2, source1);; 2708}; 2709 ; 2710////////////////////////////////////////////////////////////////////////////////; 2711/// logical operation source1 <= source2; 2712 ; 2713template <class Element>; 2714TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2715{; 2716 TMatrixT<Element> target;; 2717 ; 2718 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2719 Error(""operator<=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2720 return target;; 2721 }; 2722 ; 2723 target.ResizeTo(source1);; 2724 ; 2725 const Element *sp1 = source1.GetMatrixArray();; 2726 const Element *sp2 = source2.GetMatrixArray();; 2727 Element *tp = target.GetMatrixArray();; 2728 const Element *const tp_last = tp + target.GetNoElements();; 2729 while (tp < tp_last) {; 2730 *tp++ = (*sp1) <= (*sp2);; 2731 sp1++;; 2732 sp2++;; 2733 }; 2734 ; 2735 return target;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// l",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:95970,Testability,log,logical,95970,"on source1 <= source2; 2712 ; 2713template <class Element>; 2714TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2715{; 2716 TMatrixT<Element> target;; 2717 ; 2718 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2719 Error(""operator<=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2720 return target;; 2721 }; 2722 ; 2723 target.ResizeTo(source1);; 2724 ; 2725 const Element *sp1 = source1.GetMatrixArray();; 2726 const Element *sp2 = source2.GetMatrixArray();; 2727 Element *tp = target.GetMatrixArray();; 2728 const Element *const tp_last = tp + target.GetNoElements();; 2729 while (tp < tp_last) {; 2730 *tp++ = (*sp1) <= (*sp2);; 2731 sp1++;; 2732 sp2++;; 2733 }; 2734 ; 2735 return target;; 2736}; 2737 ; 2738////////////////////////////////////////////////////////////////////////////////; 2739/// logical operation source1 <= source2; 2740 ; 2741template <class Element>; 2742TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2743{; 2744 TMatrixT<Element> target;; 2745 ; 2746 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2747 Error(""operator<=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2748 return target;; 2749 }; 2750 ; 2751 target.ResizeTo(source1);; 2752 ; 2753 const Element *sp1 = source1.GetMatrixArray();; 2754 const Element *sp2 = source2.GetMatrixArray();; 2755 Element *tp = target.GetMatrixArray();; 2756 const Element *const tp_last = tp + target.GetNoElements();; 2757 while (tp < tp_last) {; 2758 *tp++ = (*sp1) <= (*sp2);; 2759 sp1++;; 2760 sp2++;; 2761 }; 2762 ; 2763 return target;; 2764}; 2765 ; 2766////////////////////////////////////////////////////////////////////////////////; 2767/// logical operation source1 <= source2; 2768 ; 2769template <class Element>; 2770TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixTSym<Element> &source1, const TMatr",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:96892,Testability,log,logical,96892,"; 2744 TMatrixT<Element> target;; 2745 ; 2746 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2747 Error(""operator<=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2748 return target;; 2749 }; 2750 ; 2751 target.ResizeTo(source1);; 2752 ; 2753 const Element *sp1 = source1.GetMatrixArray();; 2754 const Element *sp2 = source2.GetMatrixArray();; 2755 Element *tp = target.GetMatrixArray();; 2756 const Element *const tp_last = tp + target.GetNoElements();; 2757 while (tp < tp_last) {; 2758 *tp++ = (*sp1) <= (*sp2);; 2759 sp1++;; 2760 sp2++;; 2761 }; 2762 ; 2763 return target;; 2764}; 2765 ; 2766////////////////////////////////////////////////////////////////////////////////; 2767/// logical operation source1 <= source2; 2768 ; 2769template <class Element>; 2770TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2771{; 2772 return operator>(source2, source1);; 2773}; 2774 ; 2775////////////////////////////////////////////////////////////////////////////////; 2776/// logical operation source1 < source2; 2777 ; 2778template <class Element>; 2779TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2780{; 2781 TMatrixT<Element> target;; 2782 ; 2783 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2784 Error(""operator<(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2785 return target;; 2786 }; 2787 ; 2788 const Element *sp1 = source1.GetMatrixArray();; 2789 const Element *sp2 = source2.GetMatrixArray();; 2790 Element *tp = target.GetMatrixArray();; 2791 const Element *const tp_last = tp + target.GetNoElements();; 2792 while (tp < tp_last) {; 2793 *tp++ = (*sp1) < (*sp2);; 2794 sp1++;; 2795 sp2++;; 2796 }; 2797 ; 2798 return target;; 2799}; 2800 ; 2801////////////////////////////////////////////////////////////////////////////////; 2802/// logical operation source1 < source2; 2803 ; 2804templa",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:97250,Testability,log,logical,97250,"; 2744 TMatrixT<Element> target;; 2745 ; 2746 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2747 Error(""operator<=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2748 return target;; 2749 }; 2750 ; 2751 target.ResizeTo(source1);; 2752 ; 2753 const Element *sp1 = source1.GetMatrixArray();; 2754 const Element *sp2 = source2.GetMatrixArray();; 2755 Element *tp = target.GetMatrixArray();; 2756 const Element *const tp_last = tp + target.GetNoElements();; 2757 while (tp < tp_last) {; 2758 *tp++ = (*sp1) <= (*sp2);; 2759 sp1++;; 2760 sp2++;; 2761 }; 2762 ; 2763 return target;; 2764}; 2765 ; 2766////////////////////////////////////////////////////////////////////////////////; 2767/// logical operation source1 <= source2; 2768 ; 2769template <class Element>; 2770TMatrixT<Element> TMatrixTAutoloadOps::operator<=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2771{; 2772 return operator>(source2, source1);; 2773}; 2774 ; 2775////////////////////////////////////////////////////////////////////////////////; 2776/// logical operation source1 < source2; 2777 ; 2778template <class Element>; 2779TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2780{; 2781 TMatrixT<Element> target;; 2782 ; 2783 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2784 Error(""operator<(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2785 return target;; 2786 }; 2787 ; 2788 const Element *sp1 = source1.GetMatrixArray();; 2789 const Element *sp2 = source2.GetMatrixArray();; 2790 Element *tp = target.GetMatrixArray();; 2791 const Element *const tp_last = tp + target.GetNoElements();; 2792 while (tp < tp_last) {; 2793 *tp++ = (*sp1) < (*sp2);; 2794 sp1++;; 2795 sp2++;; 2796 }; 2797 ; 2798 return target;; 2799}; 2800 ; 2801////////////////////////////////////////////////////////////////////////////////; 2802/// logical operation source1 < source2; 2803 ; 2804templa",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:98123,Testability,log,logical,98123,"///////////////////; 2776/// logical operation source1 < source2; 2777 ; 2778template <class Element>; 2779TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2780{; 2781 TMatrixT<Element> target;; 2782 ; 2783 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2784 Error(""operator<(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2785 return target;; 2786 }; 2787 ; 2788 const Element *sp1 = source1.GetMatrixArray();; 2789 const Element *sp2 = source2.GetMatrixArray();; 2790 Element *tp = target.GetMatrixArray();; 2791 const Element *const tp_last = tp + target.GetNoElements();; 2792 while (tp < tp_last) {; 2793 *tp++ = (*sp1) < (*sp2);; 2794 sp1++;; 2795 sp2++;; 2796 }; 2797 ; 2798 return target;; 2799}; 2800 ; 2801////////////////////////////////////////////////////////////////////////////////; 2802/// logical operation source1 < source2; 2803 ; 2804template <class Element>; 2805TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2806{; 2807 TMatrixT<Element> target;; 2808 ; 2809 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2810 Error(""operator<(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2811 return target;; 2812 }; 2813 ; 2814 target.ResizeTo(source1);; 2815 ; 2816 const Element *sp1 = source1.GetMatrixArray();; 2817 const Element *sp2 = source2.GetMatrixArray();; 2818 Element *tp = target.GetMatrixArray();; 2819 const Element *const tp_last = tp + target.GetNoElements();; 2820 while (tp < tp_last) {; 2821 *tp++ = (*sp1) < (*sp2);; 2822 sp1++;; 2823 sp2++;; 2824 }; 2825 ; 2826 return target;; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// logical operation source1 < source2; 2831 ; 2832template <class Element>; 2833TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixTSym<Element> &source1, const TMatrixT<E",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:99041,Testability,log,logical,99041,"ce2); 2806{; 2807 TMatrixT<Element> target;; 2808 ; 2809 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2810 Error(""operator<(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2811 return target;; 2812 }; 2813 ; 2814 target.ResizeTo(source1);; 2815 ; 2816 const Element *sp1 = source1.GetMatrixArray();; 2817 const Element *sp2 = source2.GetMatrixArray();; 2818 Element *tp = target.GetMatrixArray();; 2819 const Element *const tp_last = tp + target.GetNoElements();; 2820 while (tp < tp_last) {; 2821 *tp++ = (*sp1) < (*sp2);; 2822 sp1++;; 2823 sp2++;; 2824 }; 2825 ; 2826 return target;; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// logical operation source1 < source2; 2831 ; 2832template <class Element>; 2833TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2834{; 2835 return operator>=(source2, source1);; 2836}; 2837 ; 2838////////////////////////////////////////////////////////////////////////////////; 2839/// logical operation source1 != source2; 2840 ; 2841template <class Element>; 2842TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2843{; 2844 TMatrixT<Element> target;; 2845 ; 2846 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2847 Error(""operator!=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2848 return target;; 2849 }; 2850 ; 2851 target.ResizeTo(source1);; 2852 ; 2853 const Element *sp1 = source1.GetMatrixArray();; 2854 const Element *sp2 = source2.GetMatrixArray();; 2855 Element *tp = target.GetMatrixArray();; 2856 const Element *const tp_last = tp + target.GetNoElements();; 2857 while (tp != tp_last) {; 2858 *tp++ = (*sp1) != (*sp2);; 2859 sp1++;; 2860 sp2++;; 2861 }; 2862 ; 2863 return target;; 2864}; 2865 ; 2866////////////////////////////////////////////////////////////////////////////////; 2867/// l",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:99398,Testability,log,logical,99398,"ce2); 2806{; 2807 TMatrixT<Element> target;; 2808 ; 2809 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2810 Error(""operator<(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2811 return target;; 2812 }; 2813 ; 2814 target.ResizeTo(source1);; 2815 ; 2816 const Element *sp1 = source1.GetMatrixArray();; 2817 const Element *sp2 = source2.GetMatrixArray();; 2818 Element *tp = target.GetMatrixArray();; 2819 const Element *const tp_last = tp + target.GetNoElements();; 2820 while (tp < tp_last) {; 2821 *tp++ = (*sp1) < (*sp2);; 2822 sp1++;; 2823 sp2++;; 2824 }; 2825 ; 2826 return target;; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// logical operation source1 < source2; 2831 ; 2832template <class Element>; 2833TMatrixT<Element> TMatrixTAutoloadOps::operator<(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2834{; 2835 return operator>=(source2, source1);; 2836}; 2837 ; 2838////////////////////////////////////////////////////////////////////////////////; 2839/// logical operation source1 != source2; 2840 ; 2841template <class Element>; 2842TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2843{; 2844 TMatrixT<Element> target;; 2845 ; 2846 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2847 Error(""operator!=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2848 return target;; 2849 }; 2850 ; 2851 target.ResizeTo(source1);; 2852 ; 2853 const Element *sp1 = source1.GetMatrixArray();; 2854 const Element *sp2 = source2.GetMatrixArray();; 2855 Element *tp = target.GetMatrixArray();; 2856 const Element *const tp_last = tp + target.GetNoElements();; 2857 while (tp != tp_last) {; 2858 *tp++ = (*sp1) != (*sp2);; 2859 sp1++;; 2860 sp2++;; 2861 }; 2862 ; 2863 return target;; 2864}; 2865 ; 2866////////////////////////////////////////////////////////////////////////////////; 2867/// l",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:100315,Testability,log,logical,100315,"on source1 != source2; 2840 ; 2841template <class Element>; 2842TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixT<Element> &source2); 2843{; 2844 TMatrixT<Element> target;; 2845 ; 2846 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2847 Error(""operator!=(const TMatrixT&,const TMatrixT&)"", ""matrices not compatible"");; 2848 return target;; 2849 }; 2850 ; 2851 target.ResizeTo(source1);; 2852 ; 2853 const Element *sp1 = source1.GetMatrixArray();; 2854 const Element *sp2 = source2.GetMatrixArray();; 2855 Element *tp = target.GetMatrixArray();; 2856 const Element *const tp_last = tp + target.GetNoElements();; 2857 while (tp != tp_last) {; 2858 *tp++ = (*sp1) != (*sp2);; 2859 sp1++;; 2860 sp2++;; 2861 }; 2862 ; 2863 return target;; 2864}; 2865 ; 2866////////////////////////////////////////////////////////////////////////////////; 2867/// logical operation source1 != source2; 2868 ; 2869template <class Element>; 2870TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2871{; 2872 TMatrixT<Element> target;; 2873 ; 2874 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2875 Error(""operator!=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2876 return target;; 2877 }; 2878 ; 2879 target.ResizeTo(source1);; 2880 ; 2881 const Element *sp1 = source1.GetMatrixArray();; 2882 const Element *sp2 = source2.GetMatrixArray();; 2883 Element *tp = target.GetMatrixArray();; 2884 const Element *const tp_last = tp + target.GetNoElements();; 2885 while (tp != tp_last) {; 2886 *tp++ = (*sp1) != (*sp2);; 2887 sp1++;; 2888 sp2++;; 2889 }; 2890 ; 2891 return target;; 2892}; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// logical operation source1 != source2; 2896 ; 2897template <class Element>; 2898TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixTSym<Element> &source1, const TMat",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:101238,Testability,log,logical,101238,"TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2871{; 2872 TMatrixT<Element> target;; 2873 ; 2874 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2875 Error(""operator!=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2876 return target;; 2877 }; 2878 ; 2879 target.ResizeTo(source1);; 2880 ; 2881 const Element *sp1 = source1.GetMatrixArray();; 2882 const Element *sp2 = source2.GetMatrixArray();; 2883 Element *tp = target.GetMatrixArray();; 2884 const Element *const tp_last = tp + target.GetNoElements();; 2885 while (tp != tp_last) {; 2886 *tp++ = (*sp1) != (*sp2);; 2887 sp1++;; 2888 sp2++;; 2889 }; 2890 ; 2891 return target;; 2892}; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// logical operation source1 != source2; 2896 ; 2897template <class Element>; 2898TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2899{; 2900 return operator!=(source2, source1);; 2901}; 2902 ; 2903/*; 2904////////////////////////////////////////////////////////////////////////////////; 2905/// logical operation source1 != val; 2906 ; 2907template<class Element>; 2908TMatrixT<Element> operator!=(const TMatrixT<Element> &source1,Element val); 2909{; 2910 TMatrixT<Element> target; target.ResizeTo(source1);; 2911 ; 2912 const Element *sp = source1.GetMatrixArray();; 2913 Element *tp = target.GetMatrixArray();; 2914 const Element * const tp_last = tp+target.GetNoElements();; 2915 while (tp != tp_last) {; 2916 *tp++ = (*sp != val); sp++;; 2917 }; 2918 ; 2919 return target;; 2920}; 2921 ; 2922////////////////////////////////////////////////////////////////////////////////; 2923/// logical operation source1 != val; 2924 ; 2925template<class Element>; 2926TMatrixT<Element> operator!=(Element val,const TMatrixT<Element> &source1); 2927{; 2928 return operator!=(source1,val);; 29",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:101605,Testability,log,logical,101605,"TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixT<Element> &source1, const TMatrixTSym<Element> &source2); 2871{; 2872 TMatrixT<Element> target;; 2873 ; 2874 if (gMatrixCheck && !AreCompatible(source1, source2)) {; 2875 Error(""operator!=(const TMatrixT&,const TMatrixTSym&)"", ""matrices not compatible"");; 2876 return target;; 2877 }; 2878 ; 2879 target.ResizeTo(source1);; 2880 ; 2881 const Element *sp1 = source1.GetMatrixArray();; 2882 const Element *sp2 = source2.GetMatrixArray();; 2883 Element *tp = target.GetMatrixArray();; 2884 const Element *const tp_last = tp + target.GetNoElements();; 2885 while (tp != tp_last) {; 2886 *tp++ = (*sp1) != (*sp2);; 2887 sp1++;; 2888 sp2++;; 2889 }; 2890 ; 2891 return target;; 2892}; 2893 ; 2894////////////////////////////////////////////////////////////////////////////////; 2895/// logical operation source1 != source2; 2896 ; 2897template <class Element>; 2898TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2899{; 2900 return operator!=(source2, source1);; 2901}; 2902 ; 2903/*; 2904////////////////////////////////////////////////////////////////////////////////; 2905/// logical operation source1 != val; 2906 ; 2907template<class Element>; 2908TMatrixT<Element> operator!=(const TMatrixT<Element> &source1,Element val); 2909{; 2910 TMatrixT<Element> target; target.ResizeTo(source1);; 2911 ; 2912 const Element *sp = source1.GetMatrixArray();; 2913 Element *tp = target.GetMatrixArray();; 2914 const Element * const tp_last = tp+target.GetNoElements();; 2915 while (tp != tp_last) {; 2916 *tp++ = (*sp != val); sp++;; 2917 }; 2918 ; 2919 return target;; 2920}; 2921 ; 2922////////////////////////////////////////////////////////////////////////////////; 2923/// logical operation source1 != val; 2924 ; 2925template<class Element>; 2926TMatrixT<Element> operator!=(Element val,const TMatrixT<Element> &source1); 2927{; 2928 return operator!=(source1,val);; 29",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:102197,Testability,log,logical,102197,"e1 != source2; 2896 ; 2897template <class Element>; 2898TMatrixT<Element> TMatrixTAutoloadOps::operator!=(const TMatrixTSym<Element> &source1, const TMatrixT<Element> &source2); 2899{; 2900 return operator!=(source2, source1);; 2901}; 2902 ; 2903/*; 2904////////////////////////////////////////////////////////////////////////////////; 2905/// logical operation source1 != val; 2906 ; 2907template<class Element>; 2908TMatrixT<Element> operator!=(const TMatrixT<Element> &source1,Element val); 2909{; 2910 TMatrixT<Element> target; target.ResizeTo(source1);; 2911 ; 2912 const Element *sp = source1.GetMatrixArray();; 2913 Element *tp = target.GetMatrixArray();; 2914 const Element * const tp_last = tp+target.GetNoElements();; 2915 while (tp != tp_last) {; 2916 *tp++ = (*sp != val); sp++;; 2917 }; 2918 ; 2919 return target;; 2920}; 2921 ; 2922////////////////////////////////////////////////////////////////////////////////; 2923/// logical operation source1 != val; 2924 ; 2925template<class Element>; 2926TMatrixT<Element> operator!=(Element val,const TMatrixT<Element> &source1); 2927{; 2928 return operator!=(source1,val);; 2929}; 2930*/; 2931 ; 2932////////////////////////////////////////////////////////////////////////////////; 2933/// Modify addition: target += scalar * source.; 2934 ; 2935template <class Element>; 2936TMatrixT<Element> &TMatrixTAutoloadOps::Add(TMatrixT<Element> &target, Element scalar, const TMatrixT<Element> &source); 2937{; 2938 if (gMatrixCheck && !AreCompatible(target, source)) {; 2939 ::Error(""Add(TMatrixT &,Element,const TMatrixT &)"", ""matrices not compatible"");; 2940 return target;; 2941 }; 2942 ; 2943 const Element *sp = source.GetMatrixArray();; 2944 Element *tp = target.GetMatrixArray();; 2945 const Element *ftp = tp + target.GetNoElements();; 2946 if (scalar == 0) {; 2947 while (tp < ftp); 2948 *tp++ = scalar * (*sp++);; 2949 } else if (scalar == 1.) {; 2950 while (tp < ftp); 2951 *tp++ = (*sp++);; 2952 } else {; 2953 while (tp < ftp); 2954 *tp",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:138601,Testability,log,logical,138601,"inition TObject.h:296; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TStringBasic string class.Definition TString.h:139; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVectorTTVectorT.Definition TVectorT.h:27; TVectorT::ResizeToTVectorT< Element > & ResizeTo(Int_t lwb, Int_t upb)Resize the vector to [lwb:upb] .Definition TVectorT.cxx:294; bool; double; int; unsigned int; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMatrixTAutoloadOps::operator!=TMatrixT< Element > operator!=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 != source2Definition TMatrixT.cxx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:139702,Testability,log,logical,139702,"xx:2842; TMatrixTAutoloadOps::AMultBtvoid AMultBt(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B^T.Definition TMatrixT.cxx:3128; TMatrixTAutoloadOps::AMultBvoid AMultB(const Element *const ap, Int_t na, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A*B.Definition TMatrixT.cxx:3081; TMatrixTAutoloadOps::operator+TMatrixT< Element > operator+(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator||TMatrixT< Element > operator||(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical OR.Definition TMatrixT.cxx:2525; TMatrixTAutoloadOps::operator<TMatrixT< Element > operator<(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 < source2Definition TMatrixT.cxx:2779; TMatrixTAutoloadOps::operator>TMatrixT< Element > operator>(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 > source2Definition TMatrixT.cxx:2584; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Eleme",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:140282,Testability,log,logical,140282,", const TMatrixT< Element > &source2)operation this = source1+source2Definition TMatrixT.cxx:2303; TMatrixTAutoloadOps::AtMultBvoid AtMultB(const Element *const ap, Int_t ncolsa, const Element *const bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator||TMatrixT< Element > operator||(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical OR.Definition TMatrixT.cxx:2525; TMatrixTAutoloadOps::operator<TMatrixT< Element > operator<(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 < source2Definition TMatrixT.cxx:2779; TMatrixTAutoloadOps::operator>TMatrixT< Element > operator>(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 > source2Definition TMatrixT.cxx:2584; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; TMatrixTAutoloadOps::ElementDivTMatrixT< Element > & ElementDiv(TMatrixT< Element > &target, const TMatrixT< Element > &source)Divide target by the source, element-by-element.Definition TMatrixT.cxx:3025; TMatrixTAutoloadOps::MultElement1 Mult(const TVectorT< Element1 > &v1, const TMatrixT< Element2 > &m, const TVectorT< Element3 > &v2)Perform v1 * M * v2, a scalar result.Definition TVectorT.cxx:1542; TMatrixTAutoloadOps::operator-TMatrixT< Element > operator-(const TMatrixT< Element > &so",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:140478,Testability,log,logical,140478,"nst bp, Int_t nb, Int_t ncolsb, Element *cp)Elementary routine to calculate matrix multiplication A^T*B.Definition TMatrixT.cxx:3104; TMatrixTAutoloadOps::operator>=TMatrixT< Element > operator>=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 >= source2Definition TMatrixT.cxx:2649; TMatrixTAutoloadOps::ElementMultTMatrixT< Element > & ElementMult(TMatrixT< Element > &target, const TMatrixT< Element > &source)Multiply target by the source, element-by-element.Definition TMatrixT.cxx:2985; TMatrixTAutoloadOps::operator||TMatrixT< Element > operator||(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical OR.Definition TMatrixT.cxx:2525; TMatrixTAutoloadOps::operator<TMatrixT< Element > operator<(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 < source2Definition TMatrixT.cxx:2779; TMatrixTAutoloadOps::operator>TMatrixT< Element > operator>(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 > source2Definition TMatrixT.cxx:2584; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; TMatrixTAutoloadOps::ElementDivTMatrixT< Element > & ElementDiv(TMatrixT< Element > &target, const TMatrixT< Element > &source)Divide target by the source, element-by-element.Definition TMatrixT.cxx:3025; TMatrixTAutoloadOps::MultElement1 Mult(const TVectorT< Element1 > &v1, const TMatrixT< Element2 > &m, const TVectorT< Element3 > &v2)Perform v1 * M * v2, a scalar result.Definition TVectorT.cxx:1542; TMatrixTAutoloadOps::operator-TMatrixT< Element > operator-(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1-source2Definition TMatrixT.cxx:2354; TMatrixTAutoloadOps::operator<=TMatrixT< Element > operator<=(const TMatrixT< Element > &sou",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMatrixT_8cxx_source.html:141476,Testability,log,logical,141476,"xT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 > source2Definition TMatrixT.cxx:2584; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; TMatrixTAutoloadOps::ElementDivTMatrixT< Element > & ElementDiv(TMatrixT< Element > &target, const TMatrixT< Element > &source)Divide target by the source, element-by-element.Definition TMatrixT.cxx:3025; TMatrixTAutoloadOps::MultElement1 Mult(const TVectorT< Element1 > &v1, const TMatrixT< Element2 > &m, const TVectorT< Element3 > &v2)Perform v1 * M * v2, a scalar result.Definition TVectorT.cxx:1542; TMatrixTAutoloadOps::operator-TMatrixT< Element > operator-(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)operation this = source1-source2Definition TMatrixT.cxx:2354; TMatrixTAutoloadOps::operator<=TMatrixT< Element > operator<=(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)logical operation source1 <= source2Definition TMatrixT.cxx:2714; TMatrixTAutoloadOps::operator&&TMatrixT< Element > operator&&(const TMatrixT< Element > &source1, const TMatrixT< Element > &source2)Logical AND.Definition TMatrixT.cxx:2466; TMatrixTAutoloadOps::operator*TMatrixT< Element > operator*(Element val, const TMatrixT< Element > &source)operation this = val*sourceDefinition TMatrixT.cxx:2405; TMatrixTAutoloadOps::AreCompatibleBool_t AreCompatible(const TMatrixTBase< Element1 > &m1, const TMatrixTBase< Element2 > &m2, Int_t verbose=0)Check that matrice sm1 and m2 areboth valid and have identical shapes .Definition TMatrixTBase.cxx:888; v2@ v2Definition rootcling_impl.cxx:3702; v@ vDefinition rootcling_impl.cxx:3699; v1@ v1Definition rootcling_impl.cxx:3701; mTMarker mDefinition textangle.C:8. mathmatrixsrcTMatrixT.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:42 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMatrixT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2309,Availability,down,download,2309,"; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits,",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:4052,Availability,down,down,4052,"find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a li",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:4768,Availability,error,error,4768,"inear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a va",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:4836,Availability,error,error,4836,"inear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a va",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:4886,Availability,error,errors,4886,"inear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a va",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:7515,Availability,error,errors,7515,"meter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from finding the right minimum. On the other hand, if one or more; 135parameters is near its limit at the minimum, this may be because the true; 136minimum is indeed at a limit, or it may be because the minimizer has; 137become ``blocked'' at a limit. This may normally happen only if the; 138parameter is so close to a limit (internal value at an odd multiple of; 139\f$\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, as",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:7645,Availability,error,error,7645,"limit, or it may be because the minimizer has; 137become ``blocked'' at a limit. This may normally happen only if the; 138parameter is so close to a limit (internal value at an odd multiple of; 139\f$\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:7677,Availability,error,errors,7677,"limit, or it may be because the minimizer has; 137become ``blocked'' at a limit. This may normally happen only if the; 138parameter is so close to a limit (internal value at an odd multiple of; 139\f$\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:7903,Availability,error,errors,7903,"\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods i",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8047,Availability,error,error,8047," at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own cu",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8089,Availability,error,error,8089,"6is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any g",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8135,Availability,error,errors,8135,"6is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any g",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8297,Availability,reliab,reliability,8297,"151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8325,Availability,error,error,8325,"151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8545,Availability,error,error,8545,"r errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:8943,Availability,error,error,8943,"c. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MIN",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:9302,Availability,error,errors,9302,"s error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. C",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:9401,Availability,error,error,9401,"tatistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:9453,Availability,reliab,reliable,9453,"tatistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10036,Availability,error,error,10036,"stimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10514,Availability,error,errors,10514," 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the mini",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10732,Availability,error,errors,10732,"eve that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermin",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10811,Availability,error,errors,10811,"elieves the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that th",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10896,Availability,error,errors,10896,"T may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of th",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:11622,Availability,recover,recovers,11622," has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:12079,Availability,error,error,12079,"n must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other m",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:12422,Availability,error,errors,12422,"of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:12869,Availability,error,error,12869,"ample that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that t",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13496,Availability,error,errors,13496,"ecomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13599,Availability,error,errors,13599,"ecomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13650,Availability,error,errors,13650," the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th eleme",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13739,Availability,error,errors,13739,"oth cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformatio",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:14067,Availability,error,error,14067,"problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:14198,Availability,error,error,14198,"problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:14526,Availability,error,error,14526,"t reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exac",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:14593,Availability,error,error,14593,"t reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exac",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:14893,Availability,error,error,14893,"he result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the d",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15006,Availability,error,errors,15006,"re no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-line",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15155,Availability,error,error,15155,"esponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h"";",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15419,Availability,error,errors,15419,"ameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMin",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15521,Availability,error,error,15521,"ept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMinuit;; 338 ; 339static const char charal[29] = "" .ABCDEFGHIJKLMNOPQRSTUVWXYZ"";; 340 ; 341ClassImp(TMinuit);; 342 ; 343///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15625,Availability,error,error,15625,"ept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMinuit;; 338 ; 339static const char charal[29] = "" .ABCDEFGHIJKLMNOPQRSTUVWXYZ"";; 340 ; 341ClassImp(TMinuit);; 342 ; 343///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15936,Availability,error,errors,15936,"inates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMinuit;; 338 ; 339static const char charal[29] = "" .ABCDEFGHIJKLMNOPQRSTUVWXYZ"";; 340 ; 341ClassImp(TMinuit);; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Minuit normal constructor; 345///; 346 ; 347TMinuit::TMinuit(): TNamed(""MINUIT"",""The Minimization package""); 348{; 349 if (TMinuit::Class()->IsCallingNew() != TClass::kRealNew) {; 350 //preset all pointers to null; 351 fCpnam = nullptr;; 352 fU = nullptr;; 353 fAlim = nullptr;; 354 fBlim = nullptr;; 355 fPstar = nullptr;; 356 fGin = nullptr;; 357 fNvarl = nullptr;; 358 fNiof",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:15973,Availability,error,errors,15973,"inates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMinuit;; 338 ; 339static const char charal[29] = "" .ABCDEFGHIJKLMNOPQRSTUVWXYZ"";; 340 ; 341ClassImp(TMinuit);; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Minuit normal constructor; 345///; 346 ; 347TMinuit::TMinuit(): TNamed(""MINUIT"",""The Minimization package""); 348{; 349 if (TMinuit::Class()->IsCallingNew() != TClass::kRealNew) {; 350 //preset all pointers to null; 351 fCpnam = nullptr;; 352 fU = nullptr;; 353 fAlim = nullptr;; 354 fBlim = nullptr;; 355 fPstar = nullptr;; 356 fGin = nullptr;; 357 fNvarl = nullptr;; 358 fNiof",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:23915,Availability,avail,available,23915,"ar];; 579 fSIMPy = new Double_t[fMaxpar];; 580 fVERTq = new Double_t[fMaxpar];; 581 fVERTs = new Double_t[fMaxpar];; 582 fVERTpp = new Double_t[fMaxpar];; 583 fCOMDplist = new Double_t[fMaxpar];; 584 fPARSplist = new Double_t[fMaxpar];; 585 ; 586 for (int i = 0; i < fMaxpar; i++) {; 587 fErp[i] = 0;; 588 fErn[i] = 0;; 589 }; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Make a clone of an object using the Streamer facility.; 594/// Function pointer is copied to Clone; 595 ; 596TObject *TMinuit::Clone(const char *newname) const; 597{; 598 TMinuit *named = (TMinuit*)TNamed::Clone(newname);; 599 named->fFCN=fFCN;; 600 return named;; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Execute a Minuit command; 605///; 606/// Equivalent to MNEXCM except that the command is given as a character string.; 607/// See TMinuit::mnhelp for the full list of available commands; 608/// See also the; 609/// [complete documentation of all the available commands](https://root.cern/sites/d35c7d8c.web.cern.ch/files/minuit.pdf); 610///; 611/// Returns the status of the execution:; 612/// - 0: command executed normally; 613/// - 1: command is blank, ignored; 614/// - 2: command line unreadable, ignored; 615/// - 3: unknown command, ignored; 616/// - 4: abnormal termination (e.g., MIGRAD not converged); 617/// - 5: command is a request to read PARAMETER definitions; 618/// - 6: 'SET INPUT' command; 619/// - 7: 'SET TITLE' command; 620/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit f",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:23998,Availability,avail,available,23998,"ar];; 579 fSIMPy = new Double_t[fMaxpar];; 580 fVERTq = new Double_t[fMaxpar];; 581 fVERTs = new Double_t[fMaxpar];; 582 fVERTpp = new Double_t[fMaxpar];; 583 fCOMDplist = new Double_t[fMaxpar];; 584 fPARSplist = new Double_t[fMaxpar];; 585 ; 586 for (int i = 0; i < fMaxpar; i++) {; 587 fErp[i] = 0;; 588 fErn[i] = 0;; 589 }; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Make a clone of an object using the Streamer facility.; 594/// Function pointer is copied to Clone; 595 ; 596TObject *TMinuit::Clone(const char *newname) const; 597{; 598 TMinuit *named = (TMinuit*)TNamed::Clone(newname);; 599 named->fFCN=fFCN;; 600 return named;; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Execute a Minuit command; 605///; 606/// Equivalent to MNEXCM except that the command is given as a character string.; 607/// See TMinuit::mnhelp for the full list of available commands; 608/// See also the; 609/// [complete documentation of all the available commands](https://root.cern/sites/d35c7d8c.web.cern.ch/files/minuit.pdf); 610///; 611/// Returns the status of the execution:; 612/// - 0: command executed normally; 613/// - 1: command is blank, ignored; 614/// - 2: command line unreadable, ignored; 615/// - 3: unknown command, ignored; 616/// - 4: abnormal termination (e.g., MIGRAD not converged); 617/// - 5: command is a request to read PARAMETER definitions; 618/// - 6: 'SET INPUT' command; 619/// - 7: 'SET TITLE' command; 620/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit f",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:25114,Availability,error,errors,25114,", ignored; 614/// - 2: command line unreadable, ignored; 615/// - 3: unknown command, ignored; 616/// - 4: abnormal termination (e.g., MIGRAD not converged); 617/// - 5: command is a request to read PARAMETER definitions; 618/// - 6: 'SET INPUT' command; 619/// - 7: 'SET TITLE' command; 620/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; 636/// using npoints (>=4) points. The TMinuit status will be; 637/// - 0 on success and; 638/// - -1 if errors in the calling sequence (pa1, pa2 not variable); 639/// - 1 if less than four points can be found; 640/// - 2 if npoints<4; 641/// - n>3 if only n points can be found (n < npoints); 642/// The status can be obtained via TMinuit::GetStatus().; 643///; 644/// To get the n-sigma contour the ERRDEF parameter in Minuit has to set; 645/// to n^2. The fcn function has to be set before the routine is called.; 646///; 647/// The TGraph object is created via the interpreter. The user must cast it; 648/// to a TGraph*. Note that the TGraph is created with npoints+1 in order to; 649/// close the contour (setting last point equal to first point).; 650///; 651/// You can find an example in $ROOTSYS/tutorials/fit/fitcont.C; 652 ; 653TObject *TMinuit::Contour(Int_t npoints, Int_t pa1, Int_t pa2); 654{; 655 if (npoints<4) {; 656 // we need at least 4 points; 657 fStatus= 2;; 658 return (TObject *)nullptr;; 659 }; 660 Int_t npfound;; 661 Double_t *xcoor = new Double_t[npoints+1];; 662 Double_t *ycoor = new Double_t[npoints+1];; 663 mncont(pa1,pa2,npoints,xcoor,ycoor,npfound);; 664 if",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:31445,Availability,error,error,31445,"e of the function, FVAL,; 812 which is usually a chisquare or log likelihood.; 813 if (iflag == 3) {; 814 will come here only after the fit is finished.; 815 Perform any final calculations, output fitted data, etc.; 816 }; 817*/; 818// See concrete examples in TH1::H1FitChisquare, H1FitLikelihood; 819 ; 820 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 821 return 0;; 822}; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// fix a parameter; 826 ; 827Int_t TMinuit::FixParameter( Int_t parNo); 828{; 829 Int_t err;; 830 Double_t tmp[1];; 831 tmp[0] = parNo+1; //set internal Minuit numbering; 832 ; 833 mnexcm( ""FIX"", tmp, 1, err );; 834 ; 835 return err;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// return parameter value and error; 840 ; 841Int_t TMinuit::GetParameter( Int_t parNo, Double_t &currentValue, Double_t &currentError ) const; 842{; 843 Int_t err;; 844 TString name; // ignored; 845 Double_t bnd1, bnd2; // ignored; 846 ; 847 mnpout( parNo, name, currentValue, currentError, bnd1, bnd2, err );; 848 ; 849 return err;; 850}; 851 ; 852////////////////////////////////////////////////////////////////////////////////; 853/// returns the number of currently fixed parameters; 854 ; 855Int_t TMinuit::GetNumFixedPars() const; 856{; 857 return fNpfix;; 858}; 859 ; 860////////////////////////////////////////////////////////////////////////////////; 861/// returns the number of currently free parameters; 862 ; 863Int_t TMinuit::GetNumFreePars() const; 864{; 865 return fNpar;; 866}; 867 ; 868////////////////////////////////////////////////////////////////////////////////; 869/// returns the total number of parameters that have been defined; 870/// as fixed or free. The constant parameters are not counted.; 871 ; 872Int_t TMinuit::GetNumPars() const; 873{; 874 return fNpar + fNpfix;; 875}; 876 ; 877//////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:33287,Availability,error,error,33287,"ly fixed parameters; 854 ; 855Int_t TMinuit::GetNumFixedPars() const; 856{; 857 return fNpfix;; 858}; 859 ; 860////////////////////////////////////////////////////////////////////////////////; 861/// returns the number of currently free parameters; 862 ; 863Int_t TMinuit::GetNumFreePars() const; 864{; 865 return fNpar;; 866}; 867 ; 868////////////////////////////////////////////////////////////////////////////////; 869/// returns the total number of parameters that have been defined; 870/// as fixed or free. The constant parameters are not counted.; 871 ; 872Int_t TMinuit::GetNumPars() const; 873{; 874 return fNpar + fNpfix;; 875}; 876 ; 877////////////////////////////////////////////////////////////////////////////////; 878/// invokes the MIGRAD minimizer; 879 ; 880Int_t TMinuit::Migrad(); 881{; 882 Int_t err;; 883 Double_t tmp[1];; 884 tmp[0] = 0;; 885 ; 886 mnexcm( ""MIGRAD"", tmp, 0, err );; 887 ; 888 return err;; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// release a parameter; 893 ; 894Int_t TMinuit::Release( Int_t parNo); 895{; 896 Int_t err;; 897 Double_t tmp[1];; 898 tmp[0] = parNo+1; //set internal Minuit numbering; 899 ; 900 mnexcm( ""RELEASE"", tmp, 1, err );; 901 ; 902 return err;; 903}; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// To get the n-sigma contour the error def parameter ""up"" has to set to n^2.; 907 ; 908Int_t TMinuit::SetErrorDef( Double_t up ); 909{; 910 Int_t err;; 911 ; 912 mnexcm( ""SET ERRDEF"", &up, 1, err );; 913 ; 914 return err;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// To set the address of the minimization function; 919 ; 920void TMinuit::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 921{; 922 fFCN = fcn;; 923}; 924 ; 925////////////////////////////////////////////////////////////////////////////////; 926/// Static function called when Se",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:47784,Availability,error,errors,47784,"),X(KE2)) = AMIN+UP; 1383///; 1384/// where FMIN is the minimum of FCN with respect to all; 1385/// the other NPAR-2 variable parameters (if any).; 1386///; 1387/// IERRF on return will be equal to the number of points found:; 1388/// - NPTU if normal termination with NPTU points found; 1389/// - -1 if errors in the calling sequence (KE1, KE2 not variable); 1390/// - 0 if less than four points can be found (using MNMNOT); 1391/// - n>3 if only n points can be found (n < NPTU); 1392///; 1393/// input arguments: parx, pary, devs, ngrid; 1394 ; 1395void TMinuit::mncont(Int_t ike1, Int_t ike2, Int_t nptu, Double_t *xptu, Double_t *yptu, Int_t &ierrf); 1396{; 1397 /* System generated locals */; 1398 Int_t i__1;; 1399 ; 1400 /* Local variables */; 1401 Double_t d__1, d__2;; 1402 Double_t dist, xdir, ydir, aopt, u1min, u2min;; 1403 Double_t abest, scalx, scaly;; 1404 Double_t a1, a2, val2mi, val2pl, dc, sclfac, bigdis, sigsav;; 1405 Int_t nall, iold, line, mpar, ierr, inew, move, next, i, j, nfcol, iercr;; 1406 Int_t idist=0, npcol, kints, i2, i1, lr, nfcnco=0, ki1, ki2, ki3, ke3;; 1407 Int_t nowpts, istrav, nfmxin, isw2, isw4;; 1408 Bool_t ldebug;; 1409 ; 1410 /* Function Body */; 1411 Int_t ke1 = ike1+1;; 1412 Int_t ke2 = ike2+1;; 1413 ldebug = fIdbg[6] >= 1;; 1414 if (ke1 <= 0 || ke2 <= 0) goto L1350;; 1415 if (ke1 > fNu || ke2 > fNu) goto L1350;; 1416 ki1 = fNiofex[ke1-1];; 1417 ki2 = fNiofex[ke2-1];; 1418 if (ki1 <= 0 || ki2 <= 0) goto L1350;; 1419 if (ki1 == ki2) goto L1350;; 1420 if (nptu < 4) goto L1400;; 1421 ; 1422 nfcnco = fNfcn;; 1423 fNfcnmx = (nptu + 5)*100*(fNpar + 1);; 1424// The minimum; 1425 mncuve();; 1426 u1min = fU[ke1-1];; 1427 u2min = fU[ke2-1];; 1428 ierrf = 0;; 1429 fCfrom = ""MNContour "";; 1430 fNfcnfr = nfcnco;; 1431 if (fISW[4] >= 0) {; 1432 Printf("" START MNCONTOUR CALCULATION OF %4d POINTS ON CONTOUR."",nptu);; 1433 if (fNpar > 2) {; 1434 if (fNpar == 3) {; 1435 ki3 = 6 - ki1 - ki2;; 1436 ke3 = fNexofi[ki3-1];; 1437 Printf("" EACH POINT IS A MINI",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:56796,Availability,error,errors,56796,"1641 fU[ke2-1] = u2min;; 1642 goto L2000;; 1643// Error returns; 1644L1350:; 1645 Printf("" INVALID PARAMETER NUMBERS."");; 1646 goto L1450;; 1647L1400:; 1648 Printf("" LESS THAN FOUR POINTS REQUESTED."");; 1649L1450:; 1650 ierrf = -1;; 1651 fCstatu = ""USER ERROR"";; 1652 goto L2000;; 1653L1500:; 1654 Printf("" MNCONT UNABLE TO FIND FOUR POINTS."");; 1655 fU[ke1-1] = u1min;; 1656 fU[ke2-1] = u2min;; 1657 ierrf = 0;; 1658 fCstatu = ""FAILED"";; 1659L2000:; 1660 fCfrom = ""MNContour "";; 1661 fNfcnfr = nfcnco;; 1662}; 1663 ; 1664////////////////////////////////////////////////////////////////////////////////; 1665/// Cracks the free-format input; 1666///; 1667/// Cracks the free-format input, expecting zero or more; 1668/// alphanumeric fields (which it joins into COMAND(1:LNC)); 1669/// followed by one or more numeric fields separated by; 1670/// blanks and/or one comma. The numeric fields are put into; 1671/// the LLIST (but at most MXP) elements of PLIST.; 1672///; 1673/// IERR :; 1674/// - = 0 if no errors,; 1675/// - = 1 if error(s).; 1676 ; 1677void TMinuit::mncrck(TString cardbuf, Int_t maxcwd, TString &comand, Int_t &lnc,; 1678 Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t); 1679{; 1680 /* Initialized data */; 1681 ; 1682 char *cnull = nullptr;; 1683 const char *cnumer = ""123456789-.0+"";; 1684 ; 1685 /* Local variables */; 1686 Int_t ifld, iend, lend, left, nreq, ipos, kcmnd, nextb, ic, ibegin, ltoadd;; 1687 Int_t ielmnt, lelmnt[25], nelmnt;; 1688 TString ctemp;; 1689 char *celmnt[25];; 1690 char command[25];; 1691 ; 1692 /* Function Body */; 1693 char *crdbuf = (char*)cardbuf.Data();; 1694 lend = cardbuf.Length();; 1695 ielmnt = 0;; 1696 nextb = 1;; 1697 ierr = 0;; 1698// loop over words CELMNT; 1699L10:; 1700 for (ipos = nextb; ipos <= lend; ++ipos) {; 1701 ibegin = ipos;; 1702 if (crdbuf[ipos-1] == ' ') continue;; 1703 if (crdbuf[ipos-1] == ',') goto L250;; 1704 goto L150;; 1705 }; 1706 goto L300;; 1707L150:; 1708// found beginning of word, look for end",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:56822,Availability,error,error,56822,"1641 fU[ke2-1] = u2min;; 1642 goto L2000;; 1643// Error returns; 1644L1350:; 1645 Printf("" INVALID PARAMETER NUMBERS."");; 1646 goto L1450;; 1647L1400:; 1648 Printf("" LESS THAN FOUR POINTS REQUESTED."");; 1649L1450:; 1650 ierrf = -1;; 1651 fCstatu = ""USER ERROR"";; 1652 goto L2000;; 1653L1500:; 1654 Printf("" MNCONT UNABLE TO FIND FOUR POINTS."");; 1655 fU[ke1-1] = u1min;; 1656 fU[ke2-1] = u2min;; 1657 ierrf = 0;; 1658 fCstatu = ""FAILED"";; 1659L2000:; 1660 fCfrom = ""MNContour "";; 1661 fNfcnfr = nfcnco;; 1662}; 1663 ; 1664////////////////////////////////////////////////////////////////////////////////; 1665/// Cracks the free-format input; 1666///; 1667/// Cracks the free-format input, expecting zero or more; 1668/// alphanumeric fields (which it joins into COMAND(1:LNC)); 1669/// followed by one or more numeric fields separated by; 1670/// blanks and/or one comma. The numeric fields are put into; 1671/// the LLIST (but at most MXP) elements of PLIST.; 1672///; 1673/// IERR :; 1674/// - = 0 if no errors,; 1675/// - = 1 if error(s).; 1676 ; 1677void TMinuit::mncrck(TString cardbuf, Int_t maxcwd, TString &comand, Int_t &lnc,; 1678 Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t); 1679{; 1680 /* Initialized data */; 1681 ; 1682 char *cnull = nullptr;; 1683 const char *cnumer = ""123456789-.0+"";; 1684 ; 1685 /* Local variables */; 1686 Int_t ifld, iend, lend, left, nreq, ipos, kcmnd, nextb, ic, ibegin, ltoadd;; 1687 Int_t ielmnt, lelmnt[25], nelmnt;; 1688 TString ctemp;; 1689 char *celmnt[25];; 1690 char command[25];; 1691 ; 1692 /* Function Body */; 1693 char *crdbuf = (char*)cardbuf.Data();; 1694 lend = cardbuf.Length();; 1695 ielmnt = 0;; 1696 nextb = 1;; 1697 ierr = 0;; 1698// loop over words CELMNT; 1699L10:; 1700 for (ipos = nextb; ipos <= lend; ++ipos) {; 1701 ibegin = ipos;; 1702 if (crdbuf[ipos-1] == ' ') continue;; 1703 if (crdbuf[ipos-1] == ',') goto L250;; 1704 goto L150;; 1705 }; 1706 goto L300;; 1707L150:; 1708// found beginning of word, look for end",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:69931,Availability,error,error,69931,"ould be impossible!); 2052 fLimset = kFALSE;; 2053 if (aopt > aulim) {; 2054 aopt = aulim;; 2055 fLimset = kTRUE;; 2056 }; 2057// Evaluate function at new point AOPT; 2058 mneval(aopt, fnext, ierev);; 2059// debug printout:; 2060 if (ldebug) {; 2061 Printf("" MNCROS: calls=%8d AIM=%10.5f F,A=%10.5f%10.5f"",fNfcn,aim,fnext,aopt);; 2062 }; 2063 if (ierev > 0) goto L900;; 2064 if (fLimset && fnext <= aim) goto L930;; 2065 ++ipt;; 2066 fXpt[ipt-1] = aopt;; 2067 fYpt[ipt-1] = fnext;; 2068 fChpt[ipt-1] = charal[ipt-1];; 2069// Replace odd point by new one; 2070 alsb[iout-1] = aopt;; 2071 flsb[iout-1] = fnext;; 2072// the new point may not be the best, but it is the only one; 2073// which could be good enough to pass convergence criteria; 2074 ibest = iout;; 2075 goto L500;; 2076 ; 2077// Contour has been located, return point to MNCONT OR MINOS; 2078L800:; 2079 iercr = 0;; 2080 goto L1000;; 2081// error in the minimization; 2082L900:; 2083 if (ierev == 1) goto L940;; 2084 goto L950;; 2085// parameter up against limit; 2086L930:; 2087 iercr = 1;; 2088 goto L1000;; 2089// too many calls to FCN; 2090L940:; 2091 iercr = 2;; 2092 goto L1000;; 2093// cannot find next point; 2094L950:; 2095 iercr = 3;; 2096// in any case; 2097L1000:; 2098 if (ldebug) {; 2099 itoohi = 0;; 2100 for (i = 1; i <= ipt; ++i) {; 2101 if (fYpt[i-1] > aim + fUp) {; 2102 fYpt[i-1] = aim + fUp;; 2103 fChpt[i-1] = '+';; 2104 itoohi = 1;; 2105 }; 2106 }; 2107 fChpt[ipt] = 0;; 2108 chsign = ""POSI"";; 2109 if (fXdircr < 0) chsign = ""NEGA"";; 2110 if (fKe2cr == 0) {; 2111 Printf("" %sTIVE MINOS ERROR, PARAMETER %3d"",chsign,fKe1cr);; 2112 }; 2113 if (itoohi == 1) {; 2114 Printf(""POINTS LABELLED '+' WERE TOO HIGH TO PLOT."");; 2115 }; 2116 if (iercr == 1) {; 2117 Printf(""RIGHTMOST POINT IS UP AGAINST LIMIT."");; 2118 }; 2119 mnplot(fXpt, fYpt, fChpt, ipt, fNpagwd, fNpagln);; 2120 }; 2121}; 2122 ; 2123////////////////////////////////////////////////////////////////////////////////; 2124/// Makes sure that the current poi",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:71143,Availability,error,error,71143,"2095 iercr = 3;; 2096// in any case; 2097L1000:; 2098 if (ldebug) {; 2099 itoohi = 0;; 2100 for (i = 1; i <= ipt; ++i) {; 2101 if (fYpt[i-1] > aim + fUp) {; 2102 fYpt[i-1] = aim + fUp;; 2103 fChpt[i-1] = '+';; 2104 itoohi = 1;; 2105 }; 2106 }; 2107 fChpt[ipt] = 0;; 2108 chsign = ""POSI"";; 2109 if (fXdircr < 0) chsign = ""NEGA"";; 2110 if (fKe2cr == 0) {; 2111 Printf("" %sTIVE MINOS ERROR, PARAMETER %3d"",chsign,fKe1cr);; 2112 }; 2113 if (itoohi == 1) {; 2114 Printf(""POINTS LABELLED '+' WERE TOO HIGH TO PLOT."");; 2115 }; 2116 if (iercr == 1) {; 2117 Printf(""RIGHTMOST POINT IS UP AGAINST LIMIT."");; 2118 }; 2119 mnplot(fXpt, fYpt, fChpt, ipt, fNpagwd, fNpagln);; 2120 }; 2121}; 2122 ; 2123////////////////////////////////////////////////////////////////////////////////; 2124/// Makes sure that the current point is a local minimum; 2125///; 2126/// Makes sure that the current point is a local; 2127/// minimum and that the error matrix exists,; 2128/// or at least something good enough for MINOS and MNCONT; 2129 ; 2130void TMinuit::mncuve(); 2131{; 2132 /* Local variables */; 2133 Double_t dxdi, wint;; 2134 Int_t ndex, iext, i, j;; 2135 ; 2136 if (fISW[3] < 1) {; 2137 Printf("" FUNCTION MUST BE MINIMIZED BEFORE CALLING %s"",(const char*)fCfrom);; 2138 fApsi = fEpsi;; 2139 mnmigr();; 2140 }; 2141 if (fISW[1] < 3) {; 2142 mnhess();; 2143 if (fISW[1] < 1) {; 2144 mnwarn(""W"", fCfrom, ""NO ERROR MATRIX. WILL IMPROVISE."");; 2145 for (i = 1; i <= fNpar; ++i) {; 2146 ndex = i*(i-1) / 2;; 2147 for (j = 1; j <= i-1; ++j) {; 2148 ++ndex;; 2149 fVhmat[ndex-1] = 0;; 2150 }; 2151 ++ndex;; 2152 if (fG2[i-1] <= 0) {; 2153 wint = fWerr[i-1];; 2154 iext = fNexofi[i-1];; 2155 if (fNvarl[iext-1] > 1) {; 2156 mndxdi(fX[i-1], i-1, dxdi);; 2157 if (TMath::Abs(dxdi) < .001) wint = .01;; 2158 else wint /= TMath::Abs(dxdi);; 2159 }; 2160 fG2[i-1] = fUp / (wint*wint);; 2161 }; 2162 fVhmat[ndex-1] = 2 / fG2[i-1];; 2163 }; 2164 fISW[1] = 1;; 2165 fDcovar = 1;; 2166 } else mnwerr();; 2167 }; 2168}; 2169 ; 2170",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:81615,Availability,error,error,81615,"];; 2442 r = TMath::Sqrt(c*c + 1);; 2443 work[n + j] = s*work[n + i]*r;; 2444 s = 1 / r;; 2445 c /= r;; 2446 goto L190;; 2447L180:; 2448 c = work[n + i] / pt;; 2449 r = TMath::Sqrt(c*c + 1);; 2450 work[n + j] = s*pt*r;; 2451 s = c / r;; 2452 c = 1 / r;; 2453L190:; 2454 pt = c*work[i] - s*gl;; 2455 work[j] = h + s*(c*gl + s*work[i]);; 2456 for (k = 1; k <= n; ++k) {; 2457 h = a[k + j*ndima];; 2458 a[k + j*ndima] = s*a[k + i*ndima] + c*h;; 2459 a[k + i*ndima] = c*a[k + i*ndima] - s*h;; 2460 }; 2461 }; 2462 work[n + l] = s*pt;; 2463 work[l] = c*pt;; 2464 ; 2465 if (TMath::Abs(work[n + l]) > b) goto L160;; 2466 ; 2467L205:; 2468 work[l] += f;; 2469 }; 2470 for (i = 1; i <= n1; ++i) {; 2471 k = i;; 2472 pt = work[i];; 2473 i1 = i + 1;; 2474 for (j = i1; j <= n; ++j) {; 2475 if (work[j] >= pt) continue;; 2476 k = j;; 2477 pt = work[j];; 2478 }; 2479 ; 2480 if (k == i) continue;; 2481 ; 2482 work[k] = work[i];; 2483 work[i] = pt;; 2484 for (j = 1; j <= n; ++j) {; 2485 pt = a[j + i*ndima];; 2486 a[j + i*ndima] = a[j + k*ndima];; 2487 a[j + k*ndima] = pt;; 2488 }; 2489 }; 2490 ifault = 0;; 2491}; 2492 ; 2493////////////////////////////////////////////////////////////////////////////////; 2494/// Calculates the external error matrix from the internal matrix; 2495///; 2496/// Note that if the matrix is declared like Double_t matrix[5][5]; 2497/// in the calling program, one has to call mnemat with, eg; 2498///; 2499/// gMinuit->mnemat(&matrix[0][0],5);; 2500 ; 2501void TMinuit::mnemat(Double_t *emat, Int_t ndim); 2502{; 2503 /* System generated locals */; 2504 Int_t emat_dim1, emat_offset;; 2505 ; 2506 /* Local variables */; 2507 Double_t dxdi, dxdj;; 2508 Int_t i, j, k, npard, k2, kk, iz, nperln, kga, kgb;; 2509 TString ctemp;; 2510 ; 2511 /* Parameter adjustments */; 2512 emat_dim1 = ndim;; 2513 emat_offset = emat_dim1 + 1;; 2514 emat -= emat_offset;; 2515 ; 2516 /* Function Body */; 2517 if (fISW[1] < 1) return;; 2518 if (fISW[4] >= 2) {; 2519 Printf("" EXTERNAL ERROR MATRIX.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:83904,Availability,error,errors,83904,"in(nperln,13);; 2533 if (fISW[4] >= 1 && npard > nperln) {; 2534 Printf("" ELEMENTS ABOVE DIAGONAL ARE NOT PRINTED."");; 2535 }; 2536// I counts the rows of the matrix; 2537 for (i = 1; i <= npard; ++i) {; 2538 mndxdi(fX[i-1], i-1, dxdi);; 2539 kga = i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1],",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:84074,Availability,error,errors,84074," i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 re",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:84135,Availability,error,error,84135," i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 re",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:84147,Availability,error,error,84147," i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 re",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:84261,Availability,error,error,84261,"k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 return;; 2602// ERROR. parameter number not valid; 2603L900:; 2604 eplus = 0;; 2605 eminus = 0;; 2606 eparab = 0;; 2607 gcc = 0;; 2608}; 2609 ; 2610////////////////////////////////////////////////////////////////////////////////; 2611/// Evaluates the function being analysed by MNCROS; 2612///; 2613/// Evaluates the function being analysed by MNCROS, which is; 2614/// generally the minimum of FCN with respect to all remaining; 2615/// variable parameters. The class data members contains the; 2616/// data necessary to know the values of U(KE1CR) and U(KE2CR); 2",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:98319,Availability,error,error,98319,"tep = 2;; 3090 rno = 0;; 3091 izero = 0;; 3092 for (i = 1; i <= fNpar; ++i) {; 3093 mnrn15(rno, izero);; 3094 rno = rno*2 - 1;; 3095 fX[i-1] += rno*step*fWerr[i-1];; 3096 }; 3097 mninex(fX);; 3098 mnamin();; 3099 mnrset(0);; 3100 return;; 3101// blank line; 3102L3300:; 3103 Printf("" BLANK COMMAND IGNORED."");; 3104 ierflg = 1;; 3105 return;; 3106// obsolete commands; 3107// covariance; 3108L3400:; 3109 Printf("" THE *COVARIANCE* COMMAND IS OSBSOLETE. THE COVARIANCE MATRIX IS NOW SAVED IN A DIFFERENT FORMAT WITH THE *SAVE* COMMAND AND READ IN WITH:*SET COVARIANCE*"");; 3110 ierflg = 3;; 3111 return;; 3112// printout; 3113L3500:; 3114 cneway = ""SET PRInt "";; 3115 goto L3100;; 3116// gradient; 3117L3600:; 3118 cneway = ""SET GRAd "";; 3119 goto L3100;; 3120// matout; 3121L3700:; 3122 cneway = ""SHOW COVar"";; 3123 goto L3100;; 3124// error def; 3125L3800:; 3126 cneway = ""SET ERRdef"";; 3127 goto L3100;; 3128// limits; 3129L3900:; 3130 cneway = ""SET LIMits"";; 3131 goto L3100;; 3132// punch; 3133L4000:; 3134 cneway = ""SAVE "";; 3135// come from obsolete commands; 3136L3100:; 3137 Printf("" OBSOLETE COMMAND:%s PLEASE USE:%s"",(const char*)fCword; 3138 ,(const char*)cneway);; 3139 fCword = cneway;; 3140 if (fCword == ""SAVE "") goto L1500;; 3141 goto L700;; 3142//; 3143}; 3144 ; 3145////////////////////////////////////////////////////////////////////////////////; 3146/// Transforms the external parameter values U to internal values; 3147///; 3148/// Transforms the external parameter values U to internal; 3149/// values in the dense array PINT.; 3150 ; 3151void TMinuit::mnexin(Double_t *pint); 3152{; 3153 Double_t pinti;; 3154 Int_t iint, iext;; 3155 ; 3156 fLimset = kFALSE;; 3157 for (iint = 1; iint <= fNpar; ++iint) {; 3158 iext = fNexofi[iint-1];; 3159 mnpint(fU[iext-1], iext-1, pinti);; 3160 pint[iint-1] = pinti;; 3161 }; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Removes parameter IINT from the internal parameter list;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:108603,Availability,error,error,108603,"423{; 3424 TString comd = command;; 3425 mnhelp(comd);; 3426}; 3427 ; 3428////////////////////////////////////////////////////////////////////////////////; 3429/// HELP routine for MINUIT interactive commands; 3430///; 3431/// - COMD ='*' or """" prints a global help for all commands; 3432/// - COMD =Command_name: print detailed help for one command.; 3433/// Note that at least 3 characters must be given for the command; 3434/// name.; 3435///; 3436/// Author: Rene Brun; 3437/// comments extracted from the MINUIT documentation file.; 3438 ; 3439void TMinuit::mnhelp(TString comd); 3440{; 3441//______________________________________________________________________________; 3442//; 3443// Global HELP: Summary of all commands; 3444//; 3445 comd.ToUpper();; 3446 if( comd.Length() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List of MINUIT Interactive commands:"");; 3448 Printf("" CLEar Reset all parameter names and values undefined"");; 3449 Printf("" CONtour Make contour map of the user function"");; 3450 Printf("" EXIT Exit from Interactive Minuit"");; 3451 Printf("" FIX Cause parameter(s) to remain constant"");; 3452 Printf("" HESse Calculate the Hessian or error matrix."");; 3453 Printf("" IMPROVE Search for a new minimum around current minimum"");; 3454 Printf("" MIGrad Minimize by the method of Migrad"");; 3455 Printf("" MINImize MIGRAD + SIMPLEX method if Migrad fails"");; 3456 Printf("" MINOs Exact (non-linear) parameter error analysis"");; 3457 Printf("" MNContour Calculate one MINOS function contour"");; 3458 Printf("" PARameter Define or redefine new parameters and values"");; 3459 Printf("" RELease Make previously FIXed parameters variable again"");; 3460 Printf("" REStore Release last parameter fixed"");; 3461 Printf("" SAVe Save current parameter values on a file"");; 3462 Printf("" SCAn Scan the user function by varying parameters"");; 3463 Printf("" SEEk Minimize by the method of Monte Carlo"");; 3464 Printf("" SET Set various MINUIT constan",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:108869,Availability,error,error,108869,"ngth() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List of MINUIT Interactive commands:"");; 3448 Printf("" CLEar Reset all parameter names and values undefined"");; 3449 Printf("" CONtour Make contour map of the user function"");; 3450 Printf("" EXIT Exit from Interactive Minuit"");; 3451 Printf("" FIX Cause parameter(s) to remain constant"");; 3452 Printf("" HESse Calculate the Hessian or error matrix."");; 3453 Printf("" IMPROVE Search for a new minimum around current minimum"");; 3454 Printf("" MIGrad Minimize by the method of Migrad"");; 3455 Printf("" MINImize MIGRAD + SIMPLEX method if Migrad fails"");; 3456 Printf("" MINOs Exact (non-linear) parameter error analysis"");; 3457 Printf("" MNContour Calculate one MINOS function contour"");; 3458 Printf("" PARameter Define or redefine new parameters and values"");; 3459 Printf("" RELease Make previously FIXed parameters variable again"");; 3460 Printf("" REStore Release last parameter fixed"");; 3461 Printf("" SAVe Save current parameter values on a file"");; 3462 Printf("" SCAn Scan the user function by varying parameters"");; 3463 Printf("" SEEk Minimize by the method of Monte Carlo"");; 3464 Printf("" SET Set various MINUIT constants or conditions"");; 3465 Printf("" SHOw Show values of current constants or conditions"");; 3466 Printf("" SIMplex Minimize by the method of Simplex"");; 3467 goto L99;; 3468 }; 3469 ; 3470//______________________________________________________________________________; 3471//; 3472// Command CLEAR; 3473//; 3474 if( !strncmp(comd.Data(),""CLE"",3) ) {; 3475 Printf("" ***>CLEAR"");; 3476 Printf("" Resets all parameter names and values to undefined."");; 3477 Printf("" Must normally be followed by a PARameters command or "");; 3478 Printf("" equivalent, in order to define parameter values."");; 3479 goto L99;; 3480 }; 3481//______________________________________________________________________________; 3482//; 3483// Command CONTOUR; 3484//; 3485 if( !strncmp(comd.Data(),""CON"",3) )",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:113581,Availability,error,error,113581," CALL FCN"");; 3531 Printf("" with IFLAG=3, to allow FCN to perform any calculations"");; 3532 Printf("" associated with the final fitted parameter values, unless a"");; 3533 Printf("" CALL FCN 3 command has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parno> to be removed from the list of"");; 3543 Printf("" variable parameters, and their value(s) will remain constant"");; 3544 Printf("" during subsequent minimizations, etc., until another command"");; 3545 Printf("" changes their value(s) or status."");; 3546 goto L99;; 3547 }; 3548//______________________________________________________________________________; 3549//; 3550// Command HESSE; 3551//; 3552 if( !strncmp(comd.Data(),""HES"",3) ) {; 3553 Printf("" ***>HESse [maxcalls]"");; 3554 Printf("" Calculate, by finite differences, the Hessian or error matrix."");; 3555 Printf("" That is, it calculates the full matrix of second derivatives"");; 3556 Printf("" of the function with respect to the currently variable"");; 3557 Printf("" parameters, and inverts it, printing out the resulting error"");; 3558 Printf("" matrix. The optional argument [maxcalls] specifies the"");; 3559 Printf("" (approximate) maximum number of function calls after which"");; 3560 Printf("" the calculation will be stopped."");; 3561 goto L99;; 3562 }; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distin",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:113820,Availability,error,error,113820,"d has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parno> to be removed from the list of"");; 3543 Printf("" variable parameters, and their value(s) will remain constant"");; 3544 Printf("" during subsequent minimizations, etc., until another command"");; 3545 Printf("" changes their value(s) or status."");; 3546 goto L99;; 3547 }; 3548//______________________________________________________________________________; 3549//; 3550// Command HESSE; 3551//; 3552 if( !strncmp(comd.Data(),""HES"",3) ) {; 3553 Printf("" ***>HESse [maxcalls]"");; 3554 Printf("" Calculate, by finite differences, the Hessian or error matrix."");; 3555 Printf("" That is, it calculates the full matrix of second derivatives"");; 3556 Printf("" of the function with respect to the currently variable"");; 3557 Printf("" parameters, and inverts it, printing out the resulting error"");; 3558 Printf("" matrix. The optional argument [maxcalls] specifies the"");; 3559 Printf("" (approximate) maximum number of function calls after which"");; 3560 Printf("" the calculation will be stopped."");; 3561 goto L99;; 3562 }; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:114969,Availability,toler,tolerance,114969,"; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//___________________________________",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115261,Availability,error,error,115261,"minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by th",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115328,Availability,reliab,reliable,115328,"minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by th",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115660,Availability,toler,tolerance,115660,"e calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115690,Availability,toler,tolerance,115690,"e calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115786,Availability,toler,tolerance,115786,"_____________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxca",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115949,Availability,toler,tolerance,115949,"ls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"")",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:116224,Availability,toler,tolerance,116224,"ameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:116836,Availability,error,error,116836,"d vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:116987,Availability,error,errors,116987," 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable param",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:117062,Availability,error,errors,117062,"),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable parameters (if any)."");; 3639 Printf("" Minuit will try to find npts points on the contour (default 20)"");; 3640 Printf("" If only two parameters are variable at the time, it is not"");; 3",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:117131,Availability,reliab,reliable,117131,"),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable parameters (if any)."");; 3639 Printf("" Minuit will try to find npts points on the contour (default 20)"");; 3640 Printf("" If only two parameters are variable at the time, it is not"");; 3",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:124866,Availability,error,errors,124866,"____________________________________________________________________________; 3756//; 3757// Command SET; 3758//; 3759 if( !strncmp(comd.Data(),""SET"",3) ) {; 3760 Printf("" ***>SET <option_name>"");; 3761 Printf("" SET BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; 3770 Printf("" knows that the FCN function value is not calculated to"");; 3771 Printf("" the nominal machine accuracy. Typical values of <accuracy>"");; 3772 Printf("" are between 10**-5 and 10**-14."");; 3773 ; 3774 Printf("" "");; 3775 Printf("" SET ERRordef <up>"");; 3776 Printf("" Sets the value of UP (default value= 1.), defining parameter"");; 3777 Printf("" errors. Minuit defines parameter errors as the change"");; 3778 Printf("" in parameter value required to change the function value"");; 3779 Printf("" by UP. Normally, for chisquared fits UP=1, and for negative"");; 3780 Printf("" log likelihood, UP=0.5."");; 3781 ; 3782 Printf("" "");; 3783 Printf("" SET GRAdient [force]"");; 3784 Printf("" Informs Minuit that the user function is prepared to"");; 3785 Printf("" calculate its own first derivatives and return their values"");; 3786 Printf("" in the array GRAD when IFLAG=2 (see specs of FCN)."");; 3787 Printf("" If [force] is not specified, Minuit will calculate"");; 3788 Printf("" the FCN derivatives by finite differences at the current"");; 3789 Printf("" point and compare with the user calculation at that point,"");; 3790 Printf("" accepting the user values only if they agree."");; 3791 Printf("" If [force]=1, Minuit does not do its own derivative"");; 3792 Printf("" calculation, and uses the derivatives calculated in FCN."");; 3793 ; 3794 Printf",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:124899,Availability,error,errors,124899,"and SET; 3758//; 3759 if( !strncmp(comd.Data(),""SET"",3) ) {; 3760 Printf("" ***>SET <option_name>"");; 3761 Printf("" SET BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; 3770 Printf("" knows that the FCN function value is not calculated to"");; 3771 Printf("" the nominal machine accuracy. Typical values of <accuracy>"");; 3772 Printf("" are between 10**-5 and 10**-14."");; 3773 ; 3774 Printf("" "");; 3775 Printf("" SET ERRordef <up>"");; 3776 Printf("" Sets the value of UP (default value= 1.), defining parameter"");; 3777 Printf("" errors. Minuit defines parameter errors as the change"");; 3778 Printf("" in parameter value required to change the function value"");; 3779 Printf("" by UP. Normally, for chisquared fits UP=1, and for negative"");; 3780 Printf("" log likelihood, UP=0.5."");; 3781 ; 3782 Printf("" "");; 3783 Printf("" SET GRAdient [force]"");; 3784 Printf("" Informs Minuit that the user function is prepared to"");; 3785 Printf("" calculate its own first derivatives and return their values"");; 3786 Printf("" in the array GRAD when IFLAG=2 (see specs of FCN)."");; 3787 Printf("" If [force] is not specified, Minuit will calculate"");; 3788 Printf("" the FCN derivatives by finite differences at the current"");; 3789 Printf("" point and compare with the user calculation at that point,"");; 3790 Printf("" accepting the user values only if they agree."");; 3791 Printf("" If [force]=1, Minuit does not do its own derivative"");; 3792 Printf("" calculation, and uses the derivatives calculated in FCN."");; 3793 ; 3794 Printf("" "");; 3795 Printf("" SET INPut [unitno] [filename]"");; 3796 Printf("" Causes Minuit, in data-dri",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:127810,Availability,error,error,127810,"rintf("" Fortran 77 and the results may depend on the system;"");; 3809 Printf("" for example, if a filename is given under VM/CMS, it must"");; 3810 Printf("" be preceded by a slash."");; 3811 ; 3812 Printf("" "");; 3813 Printf("" SET INTeractive"");; 3814 Printf("" Informs Minuit that it is running interactively."");; 3815 ; 3816 Printf("" "");; 3817 Printf("" SET LIMits [parno] [lolim] [uplim]"");; 3818 Printf("" Allows the user to change the limits on one or all"");; 3819 Printf("" parameters. If no arguments are specified, all limits are"");; 3820 Printf("" removed from all parameters. If [parno] alone is specified,"");; 3821 Printf("" limits are removed from parameter [parno]."");; 3822 Printf("" If all arguments are specified, then parameter [parno] will"");; 3823 Printf("" be bounded between [lolim] and [uplim]."");; 3824 Printf("" Limits can be specified in either order, Minuit will take"");; 3825 Printf("" the smaller as [lolim] and the larger as [uplim]."");; 3826 Printf("" However, if [lolim] is equal to [uplim], an error condition"");; 3827 Printf("" results."");; 3828 ; 3829 Printf("" "");; 3830 Printf("" SET LINesperpage"");; 3831 Printf("" Sets the number of lines for one page of output."");; 3832 Printf("" Default value is 24 for interactive mode"");; 3833 ; 3834 Printf("" "");; 3835 Printf("" SET NOGradient"");; 3836 Printf("" The inverse of SET GRAdient, instructs Minuit not to"");; 3837 Printf("" use the first derivatives calculated by the user in FCN."");; 3838 ; 3839 Printf("" "");; 3840 Printf("" SET NOWarnings"");; 3841 Printf("" Suppresses Minuit warning messages."");; 3842 ; 3843 Printf("" "");; 3844 Printf("" SET OUTputfile <unitno>"");; 3845 Printf("" Instructs Minuit to write further output to unit <unitno>."");; 3846 ; 3847 Printf("" "");; 3848 Printf("" SET PAGethrow <integer>"");; 3849 Printf("" Sets the carriage control character for ``new page'' to"");; 3850 Printf("" <integer>. Thus the value 1 produces a new page, and 0"");; 3851 Printf("" produces a blank line, on some devices (see TOPofpage)"");; 3852 ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:130364,Availability,reliab,reliable,130364,"ommand, and are currently <level>=:"");; 3865 Printf("" [-1] no output except from SHOW commands"");; 3866 Printf("" [0] minimum output"");; 3867 Printf("" [1] default value, normal output"");; 3868 Printf("" [2] additional output giving intermediate results."");; 3869 Printf("" [3] maximum output, showing progress of minimizations."");; 3870 Printf("" Note: See also the SET WARnings command."");; 3871 ; 3872 Printf("" "");; 3873 Printf("" SET RANdomgenerator <seed>"");; 3874 Printf("" Sets the seed of the random number generator used in SEEk."");; 3875 Printf("" This can be any integer between 10000 and 900000000, for"");; 3876 Printf("" example one which was output from a SHOw RANdom command of"");; 3877 Printf("" a previous run."");; 3878 ; 3879 Printf("" "");; 3880 Printf("" SET STRategy <level>"");; 3881 Printf("" Sets the strategy to be used in calculating first and second"");; 3882 Printf("" derivatives and in certain minimization methods."");; 3883 Printf("" In general, low values of <level> mean fewer function calls"");; 3884 Printf("" and high values mean more reliable minimization."");; 3885 Printf("" Currently allowed values are 0, 1 (default), and 2."");; 3886 ; 3887 Printf("" "");; 3888 Printf("" SET TITle"");; 3889 Printf("" Informs Minuit that the next input line is to be considered"");; 3890 Printf("" the (new) title for this task or sub-task. This is for"");; 3891 Printf("" the convenience of the user in reading their output."");; 3892 ; 3893 Printf("" "");; 3894 Printf("" SET WARnings"");; 3895 Printf("" Instructs Minuit to output warning messages when suspicious"");; 3896 Printf("" conditions arise which may indicate unreliable results."");; 3897 Printf("" This is the default."");; 3898 ; 3899 Printf("" "");; 3900 Printf("" SET WIDthpage"");; 3901 Printf("" Informs Minuit of the output page width."");; 3902 Printf("" Default values are 80 for interactive jobs"");; 3903 goto L99;; 3904 }; 3905//______________________________________________________________________________; 3906//; 3907// Command SHOW; 3908//; 3909",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:131770,Availability,error,error,131770," the user in reading their output."");; 3892 ; 3893 Printf("" "");; 3894 Printf("" SET WARnings"");; 3895 Printf("" Instructs Minuit to output warning messages when suspicious"");; 3896 Printf("" conditions arise which may indicate unreliable results."");; 3897 Printf("" This is the default."");; 3898 ; 3899 Printf("" "");; 3900 Printf("" SET WIDthpage"");; 3901 Printf("" Informs Minuit of the output page width."");; 3902 Printf("" Default values are 80 for interactive jobs"");; 3903 goto L99;; 3904 }; 3905//______________________________________________________________________________; 3906//; 3907// Command SHOW; 3908//; 3909 if( !strncmp(comd.Data(),""SHO"",3) ) {; 3910 Printf("" ***>SHOw <option_name>"");; 3911 Printf("" All SET XXXX commands have a corresponding SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:131896,Availability,error,error,131896,"sages when suspicious"");; 3896 Printf("" conditions arise which may indicate unreliable results."");; 3897 Printf("" This is the default."");; 3898 ; 3899 Printf("" "");; 3900 Printf("" SET WIDthpage"");; 3901 Printf("" Informs Minuit of the output page width."");; 3902 Printf("" Default values are 80 for interactive jobs"");; 3903 goto L99;; 3904 }; 3905//______________________________________________________________________________; 3906//; 3907// Command SHOW; 3908//; 3909 if( !strncmp(comd.Data(),""SHO"",3) ) {; 3910 Printf("" ***>SHOw <option_name>"");; 3911 Printf("" All SET XXXX commands have a corresponding SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:132417,Availability,toler,tolerance,132417,"ng SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 39",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:132766,Availability,toler,tolerance,132766,"HOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 3966//; 3967// Command TOPOFPAGE; 3968//; 3969 if( !strncmp(comd.Data(),""TOP"",3) ) {; 3970 Printf("" ***>TOPofpage"");; 3971 Printf("" Causes Minuit to write the character specified in a"");; 3972 Printf("" SET PAGet",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:132818,Availability,toler,tolerance,132818,"f("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 3966//; 3967// Command TOPOFPAGE; 3968//; 3969 if( !strncmp(comd.Data(),""TOP"",3) ) {; 3970 Printf("" ***>TOPofpage"");; 3971 Printf("" Causes Minuit to write the character specified in a"");; 3972 Printf("" SET PAGethrow command (default = 1) to column 1 of the output"");; 3973 Printf("" file, which may or may not position your output medium to"");; 3974 Printf("" ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:140474,Availability,failure,failure,140474,"Syy[j-1]) / (; 4147 fDirin[i-1]*fDirin[j-1]);; 4148 ndex = i*(i-1) / 2 + j;; 4149 fVhmat[ndex-1] = elem;; 4150 }; 4151 }; 4152L214:; 4153 mninex(fX);; 4154// verify matrix positive-definite; 4155 mnpsdf();; 4156 for (i = 1; i <= fNpar; ++i) {; 4157 for (j = 1; j <= i; ++j) {; 4158 ndex = i*(i-1) / 2 + j;; 4159 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[ndex-1];; 4160 fP[j + i*fMaxpar - fMaxpar-1] = fP[i + j*fMaxpar - fMaxpar-1];; 4161 }; 4162 }; 4163 mnvert(fP, fMaxint, fMaxint, fNpar, ifail);; 4164 if (ifail > 0) {; 4165 mnwarn(""W"", ""HESSE"", ""Matrix inversion fails."");; 4166 goto L390;; 4167 }; 4168// calculate e d m; 4169 fEDM = 0;; 4170 ; 4171 for (i = 1; i <= fNpar; ++i) {; 4172// off-diagonal elements; 4173 ndex = i*(i-1) / 2;; 4174 for (j = 1; j <= i-1; ++j) {; 4175 ++ndex;; 4176 ztemp = fP[i + j*fMaxpar - fMaxpar-1]*2;; 4177 fEDM += fGrd[i-1]*ztemp*fGrd[j-1];; 4178 fVhmat[ndex-1] = ztemp;; 4179 }; 4180// diagonal elements; 4181 ++ndex;; 4182 fVhmat[ndex-1] = fP[i + i*fMaxpar - fMaxpar-1]*2;; 4183 fEDM += fP[i + i*fMaxpar - fMaxpar-1]*(fGrd[i-1]*fGrd[i-1]);; 4184 }; 4185 if (fISW[4] >= 1 && fISW[1] == 3 && fItaur == 0) {; 4186 Printf("" COVARIANCE MATRIX CALCULATED SUCCESSFULLY"");; 4187 }; 4188 goto L900;; 4189// failure to invert 2nd deriv matrix; 4190L390:; 4191 fISW[1] = 1;; 4192 fDcovar = 1;; 4193 fCstatu = ""FAILED "";; 4194 if (fISW[4] >= 0) {; 4195 Printf("" MNHESS FAILS AND WILL RETURN DIAGONAL MATRIX. "");; 4196 }; 4197 for (i = 1; i <= fNpar; ++i) {; 4198 ndex = i*(i-1) / 2;; 4199 for (j = 1; j <= i-1; ++j) {; 4200 ++ndex;; 4201 fVhmat[ndex-1] = 0;; 4202 }; 4203 ++ndex;; 4204 g2i = fG2[i-1];; 4205 if (g2i <= 0) g2i = 1;; 4206 fVhmat[ndex-1] = 2 / g2i;; 4207 }; 4208L900:; 4209 return;; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// Calculate first derivatives (GRD) and uncertainties (DGRD); 4214///; 4215/// and appropriate step sizes GSTEP; 4216/// Called from MNHESS and MNGRAD; 4217 ; 4218void TMinu",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:156858,Availability,toler,tolerance,156858,"; 4699 Printf("" NO LIMITS SPECIFIED. PARAMETER %3d IS ALREADY UNLIMITED. NO CHANGE."",i2);; 4700 }; 4701 goto L900;; 4702// put on limits; 4703L235:; 4704 fAlim[i2-1] = TMath::Min(fWord7[1],fWord7[2]);; 4705 fBlim[i2-1] = TMath::Max(fWord7[1],fWord7[2]);; 4706 fNvarl[i2-1] = 4;; 4707 if (fISW[4] > 0) {; 4708 Printf("" PARAMETER %3d LIMITS SET TO %15.5g%15.5g"",i2,fAlim[i2-1],fBlim[i2-1]);; 4709 }; 4710 fCstatu = ""NEW LIMITS"";; 4711 if (kint <= 0) fGsteps[ifx-1] = -.1;; 4712 else fGstep[kint-1] = -.1;; 4713 ; 4714L900:; 4715 if (fCstatu != ""NO CHANGE "") {; 4716 mnexin(fX);; 4717 mnrset(1);; 4718 }; 4719}; 4720 ; 4721////////////////////////////////////////////////////////////////////////////////; 4722/// Perform a line search from position START; 4723///; 4724/// along direction STEP, where the length of vector STEP; 4725/// gives the expected position of minimum.; 4726/// - FSTART is value of function at START; 4727/// - SLOPE (if non-zero) is df/dx along STEP at START; 4728/// - TOLER is initial tolerance of minimum in direction STEP; 4729///; 4730/// SLAMBG and ALPHA control the maximum individual steps allowed.; 4731/// The first step is always =1. The max length of second step is SLAMBG.; 4732/// The max size of subsequent steps is the maximum previous successful; 4733/// step multiplied by ALPHA + the size of most recent successful step,; 4734/// but cannot be smaller than SLAMBG.; 4735 ; 4736void TMinuit::mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler); 4737{; 4738 /* Local variables */; 4739 Double_t xpq[12], ypq[12], slam, sdev, coeff[3], denom, flast;; 4740 Double_t fvals[3], xvals[3], f1, fvmin, xvmin, ratio, f2, f3 = 0., fvmax;; 4741 Double_t toler8, toler9, overal, undral, slamin, slamax, slopem;; 4742 Int_t i, nparx=0, nvmax=0, nxypt, kk, ipt;; 4743 Bool_t ldebug;; 4744 TString cmess;; 4745 char chpq[13];; 4746 int l65, l70, l80;; 4747 ; 4748 /* Function Body */; 4749 l65 = 0; l70 = 0; l80 = 0;; 4750 ldebug = fIdbg[",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:157363,Availability,toler,toler,157363,"GE "") {; 4716 mnexin(fX);; 4717 mnrset(1);; 4718 }; 4719}; 4720 ; 4721////////////////////////////////////////////////////////////////////////////////; 4722/// Perform a line search from position START; 4723///; 4724/// along direction STEP, where the length of vector STEP; 4725/// gives the expected position of minimum.; 4726/// - FSTART is value of function at START; 4727/// - SLOPE (if non-zero) is df/dx along STEP at START; 4728/// - TOLER is initial tolerance of minimum in direction STEP; 4729///; 4730/// SLAMBG and ALPHA control the maximum individual steps allowed.; 4731/// The first step is always =1. The max length of second step is SLAMBG.; 4732/// The max size of subsequent steps is the maximum previous successful; 4733/// step multiplied by ALPHA + the size of most recent successful step,; 4734/// but cannot be smaller than SLAMBG.; 4735 ; 4736void TMinuit::mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler); 4737{; 4738 /* Local variables */; 4739 Double_t xpq[12], ypq[12], slam, sdev, coeff[3], denom, flast;; 4740 Double_t fvals[3], xvals[3], f1, fvmin, xvmin, ratio, f2, f3 = 0., fvmax;; 4741 Double_t toler8, toler9, overal, undral, slamin, slamax, slopem;; 4742 Int_t i, nparx=0, nvmax=0, nxypt, kk, ipt;; 4743 Bool_t ldebug;; 4744 TString cmess;; 4745 char chpq[13];; 4746 int l65, l70, l80;; 4747 ; 4748 /* Function Body */; 4749 l65 = 0; l70 = 0; l80 = 0;; 4750 ldebug = fIdbg[1] >= 1;; 4751// starting values for overall limits on total step SLAM; 4752 overal = 1e3;; 4753 undral = -100;; 4754// debug check if start is ok; 4755 if (ldebug) {; 4756 mninex(&start[0]);; 4757 Eval(nparx, fGin, f1, fU, 4); ++fNfcn;; 4758 if (f1 != fstart) {; 4759 Printf("" MNLINE start point not consistent, F values, parameters="");; 4760 for (kk = 1; kk <= fNpar; ++kk) {; 4761 Printf("" %14.5e"",fX[kk-1]);; 4762 }; 4763 }; 4764 }; 4765// set up linear search along STEP; 4766 fvmin = fstart;; 4767 xvmin = 0;; 4768 nxypt = 1;; 4769 chpq[0] = cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:159185,Availability,toler,toler,159185,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:160216,Availability,toler,toler,160216,"st = f1;; 4801// can iterate on two-points (cut) if no imprvmnt; 4802 ; 4803 do {; 4804 denom = (flast - fstart - slope*slam)*2 / (slam*slam);; 4805 slam = 1;; 4806 if (denom != 0) slam = -slope / denom;; 4807 if (slam < 0) slam = slamax;; 4808 if (slam > slamax) slam = slamax;; 4809 if (slam < toler8) slam = toler8;; 4810 if (slam < slamin) {; 4811 l80 = 1;; 4812 break;; 4813 }; 4814 if (TMath::Abs(slam - 1) < toler8 && f1 < fstart) {; 4815 l70 = 1;; 4816 break;; 4817 }; 4818 if (TMath::Abs(slam - 1) < toler8) slam = toler8 + 1;; 4819 if (nxypt >= 12) {; 4820 l65 = 1;; 4821 break;; 4822 }; 4823 for (i = 1; i <= fNpar; ++i) { fX[i-1] = start[i-1] + slam*step[i-1]; }; 4824 mninex(fX);; 4825 nparx = fNpar;; 4826 Eval(nparx, fGin, f2, fU, 4); ++fNfcn;; 4827 ++nxypt;; 4828 chpq[nxypt-1] = charal[nxypt-1];; 4829 xpq[nxypt-1] = slam;; 4830 ypq[nxypt-1] = f2;; 4831 if (f2 < fvmin) {; 4832 fvmin = f2;; 4833 xvmin = slam;; 4834 }; 4835 if (fstart == fvmin) {; 4836 flast = f2;; 4837 toler8 = toler*slam;; 4838 overal = slam - toler8;; 4839 slamax = overal;; 4840 }; 4841 } while (fstart == fvmin);; 4842 ; 4843 if (!l65 && !l70 && !l80) {; 4844// quadr interp using 3 points; 4845 xvals[0] = xpq[0];; 4846 fvals[0] = ypq[0];; 4847 xvals[1] = xpq[nxypt-2];; 4848 fvals[1] = ypq[nxypt-2];; 4849 xvals[2] = xpq[nxypt-1];; 4850 fvals[2] = ypq[nxypt-1];; 4851// begin iteration, calculate desired step; 4852 do {; 4853 slamax = TMath::Max(slamax,TMath::Abs(xvmin)*2);; 4854 mnpfit(xvals, fvals, 3, coeff, sdev);; 4855 if (coeff[2] <= 0) {; 4856 slopem = coeff[2]*2*xvmin + coeff[1];; 4857 if (slopem <= 0) slam = xvmin + slamax;; 4858 else slam = xvmin - slamax;; 4859 } else {; 4860 slam = -coeff[1] / (coeff[2]*2);; 4861 if (slam > xvmin + slamax) slam = xvmin + slamax;; 4862 if (slam < xvmin - slamax) slam = xvmin - slamax;; 4863 }; 4864 if (slam > 0) {; 4865 if (slam > overal); 4866 slam = overal;; 4867 else if (slam < undral); 4868 slam = undral;; 4869 }; 4870 ; 4871// come here if step was",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:163147,Availability,toler,tolerance,163147," FUNCTION CALLS "";; 4935 Printf("" MNLINE DEBUG: steps="");; 4936 for (kk = 1; kk <= fNpar; ++kk) {; 4937 Printf("" %12.4g"",step[kk-1]);; 4938 }; 4939 }; 4940// stop because within tolerance; 4941 if (l70 && ldebug) cmess = "" LINE SEARCH HAS ATTAINED TOLERANCE "";; 4942 if (l80 && ldebug) cmess = "" STEP SIZE AT ARITHMETICALLY ALLOWED MINIMUM"";; 4943 ; 4944 fAmin = fvmin;; 4945 for (i = 1; i <= fNpar; ++i) {; 4946 fDirin[i-1] = step[i-1]*xvmin;; 4947 fX[i-1] = start[i-1] + fDirin[i-1];; 4948 }; 4949 mninex(fX);; 4950 if (xvmin < 0) {; 4951 mnwarn(""D"", ""MNLINE"", "" LINE MINIMUM IN BACKWARDS DIRECTION"");; 4952 }; 4953 if (fvmin == fstart) {; 4954 mnwarn(""D"", ""MNLINE"", "" LINE SEARCH FINDS NO IMPROVEMENT "");; 4955 }; 4956 if (ldebug) {; 4957 Printf("" AFTER %3d POINTS,%s"",nxypt,(const char*)cmess);; 4958 mnplot(xpq, ypq, chpq, nxypt, fNpagwd, fNpagln);; 4959 }; 4960}; 4961 ; 4962////////////////////////////////////////////////////////////////////////////////; 4963/// Prints the covariance matrix v when KODE=1; 4964///; 4965/// always prints the global correlations, and; 4966/// calculates and prints the individual correlation coefficients; 4967 ; 4968void TMinuit::mnmatu(Int_t kode); 4969{; 4970 /* Local variables */; 4971 Int_t ndex, i, j, m, n, ncoef, nparm, id, it, ix;; 4972 Int_t nsofar, ndi, ndj, iso, isw2, isw5;; 4973 TString ctemp;; 4974 ; 4975 isw2 = fISW[1];; 4976 if (isw2 < 1) {; 4977 Printf(""%s"",(const char*)fCovmes[isw2]);; 4978 return;; 4979 }; 4980 if (fNpar == 0) {; 4981 Printf("" MNMATU: NPAR=0"");; 4982 return;; 4983 }; 4984// external error matrix; 4985 if (kode == 1) {; 4986 isw5 = fISW[4];; 4987 fISW[4] = 2;; 4988 mnemat(fP, fMaxint);; 4989 if (isw2 < 3) {; 4990 Printf(""%s"",(const char*)fCovmes[isw2]);; 4991 }; 4992 fISW[4] = isw5;; 4993 }; 4994// correlation coeffs; 4995 if (fNpar <= 1) return;; 4996 mnwerr();; 4997// NCOEF is number of coeff. that fit on one line, not to exceed 20; 4998 ncoef = (fNpagwd - 19) / 6;; 4999 ncoef = TMath::Min(ncoef,20);; 5000 n",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:164535,Availability,error,error,164535," FUNCTION CALLS "";; 4935 Printf("" MNLINE DEBUG: steps="");; 4936 for (kk = 1; kk <= fNpar; ++kk) {; 4937 Printf("" %12.4g"",step[kk-1]);; 4938 }; 4939 }; 4940// stop because within tolerance; 4941 if (l70 && ldebug) cmess = "" LINE SEARCH HAS ATTAINED TOLERANCE "";; 4942 if (l80 && ldebug) cmess = "" STEP SIZE AT ARITHMETICALLY ALLOWED MINIMUM"";; 4943 ; 4944 fAmin = fvmin;; 4945 for (i = 1; i <= fNpar; ++i) {; 4946 fDirin[i-1] = step[i-1]*xvmin;; 4947 fX[i-1] = start[i-1] + fDirin[i-1];; 4948 }; 4949 mninex(fX);; 4950 if (xvmin < 0) {; 4951 mnwarn(""D"", ""MNLINE"", "" LINE MINIMUM IN BACKWARDS DIRECTION"");; 4952 }; 4953 if (fvmin == fstart) {; 4954 mnwarn(""D"", ""MNLINE"", "" LINE SEARCH FINDS NO IMPROVEMENT "");; 4955 }; 4956 if (ldebug) {; 4957 Printf("" AFTER %3d POINTS,%s"",nxypt,(const char*)cmess);; 4958 mnplot(xpq, ypq, chpq, nxypt, fNpagwd, fNpagln);; 4959 }; 4960}; 4961 ; 4962////////////////////////////////////////////////////////////////////////////////; 4963/// Prints the covariance matrix v when KODE=1; 4964///; 4965/// always prints the global correlations, and; 4966/// calculates and prints the individual correlation coefficients; 4967 ; 4968void TMinuit::mnmatu(Int_t kode); 4969{; 4970 /* Local variables */; 4971 Int_t ndex, i, j, m, n, ncoef, nparm, id, it, ix;; 4972 Int_t nsofar, ndi, ndj, iso, isw2, isw5;; 4973 TString ctemp;; 4974 ; 4975 isw2 = fISW[1];; 4976 if (isw2 < 1) {; 4977 Printf(""%s"",(const char*)fCovmes[isw2]);; 4978 return;; 4979 }; 4980 if (fNpar == 0) {; 4981 Printf("" MNMATU: NPAR=0"");; 4982 return;; 4983 }; 4984// external error matrix; 4985 if (kode == 1) {; 4986 isw5 = fISW[4];; 4987 fISW[4] = 2;; 4988 mnemat(fP, fMaxint);; 4989 if (isw2 < 3) {; 4990 Printf(""%s"",(const char*)fCovmes[isw2]);; 4991 }; 4992 fISW[4] = isw5;; 4993 }; 4994// correlation coeffs; 4995 if (fNpar <= 1) return;; 4996 mnwerr();; 4997// NCOEF is number of coeff. that fit on one line, not to exceed 20; 4998 ncoef = (fNpagwd - 19) / 6;; 4999 ncoef = TMath::Min(ncoef,20);; 5000 n",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:166961,Availability,toler,toler,166961,"s"",(const char*)ctemp);; 5023 if (i <= nparm) continue;; 5024 ctemp = "" "";; 5025 for (iso = 1; iso <= 10; ++iso) {; 5026 nsofar = nparm;; 5027 nparm = TMath::Min(fNpar,nsofar + ncoef);; 5028 for (it = nsofar + 1; it <= nparm; ++it) {; 5029 ctemp = ctemp + TString::Format("" %6.3f"",fMATUvline[it-1]);; 5030 }; 5031 Printf(""%s"",(const char*)ctemp);; 5032 if (i <= nparm) break;; 5033 }; 5034 }; 5035 if (isw2 < 3) {; 5036 Printf("" %s"",(const char*)fCovmes[isw2]);; 5037 }; 5038}; 5039 ; 5040////////////////////////////////////////////////////////////////////////////////; 5041/// Performs a local function minimization; 5042///; 5043/// Performs a local function minimization using basically the; 5044/// method of Davidon-Fletcher-Powell as modified by Fletcher; 5045///; 5046/// ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; 5047 ; 5048void TMinuit::mnmigr(); 5049{; 5050 /* Local variables */; 5051 Double_t gdel, gami, vlen, dsum, gssq, vsum, d;; 5052 Double_t fzero, fs, ri, delgam, rhotol;; 5053 Double_t gdgssq, gvg, vgi;; 5054 Int_t npfn, ndex, iext, i, j, m, n, npsdf, nparx;; 5055 Int_t iswtr, lined2, kk, nfcnmg, nrstrt,iter;; 5056 Bool_t ldebug;; 5057 Double_t toler = 0.05;; 5058 ; 5059 if (fNpar <= 0) return;; 5060 if (fAmin == fUndefi) mnamin();; 5061 ldebug = kFALSE; if ( fIdbg[4] >= 1) ldebug = kTRUE;; 5062 fCfrom = ""MIGRAD "";; 5063 fNfcnfr = fNfcn;; 5064 nfcnmg = fNfcn;; 5065 fCstatu = ""INITIATE "";; 5066 iswtr = fISW[4] - 2*fItaur;; 5067 npfn = fNfcn;; 5068 nparx = fNpar;; 5069 vlen = (Double_t) (fNpar*(fNpar + 1) / 2);; 5070 nrstrt = 0;; 5071 npsdf = 0;; 5072 lined2 = 0;; 5073 fISW[3] = -1;; 5074 rhotol = fApsi*.001;; 5075 if (iswtr >= 1) {; 5076 Printf("" START MIGRAD MINIMIZATION. STRATEGY %2d. CONVERGENCE WHEN EDM .LT.%9.2e"",fIstrat,rhotol);; 5077 }; 5078// initialization strategy; 5079 if (fIstrat < 2 || fISW[1] >= 3) goto L2;; 5080// come (back) here to restart completely; 5081L1:; 5082 if (nrstrt > fIstrat) {; 5083 fCstatu = ""FAILED "";; 5084 fISW[3]",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:168678,Availability,toler,toler,168678,"u = ""INITIATE "";; 5066 iswtr = fISW[4] - 2*fItaur;; 5067 npfn = fNfcn;; 5068 nparx = fNpar;; 5069 vlen = (Double_t) (fNpar*(fNpar + 1) / 2);; 5070 nrstrt = 0;; 5071 npsdf = 0;; 5072 lined2 = 0;; 5073 fISW[3] = -1;; 5074 rhotol = fApsi*.001;; 5075 if (iswtr >= 1) {; 5076 Printf("" START MIGRAD MINIMIZATION. STRATEGY %2d. CONVERGENCE WHEN EDM .LT.%9.2e"",fIstrat,rhotol);; 5077 }; 5078// initialization strategy; 5079 if (fIstrat < 2 || fISW[1] >= 3) goto L2;; 5080// come (back) here to restart completely; 5081L1:; 5082 if (nrstrt > fIstrat) {; 5083 fCstatu = ""FAILED "";; 5084 fISW[3] = -1;; 5085 goto L230;; 5086 }; 5087// get full covariance and gradient; 5088 mnhess();; 5089 mnwerr();; 5090 npsdf = 0;; 5091 if (fISW[1] >= 1) goto L10;; 5092// get gradient at start point; 5093L2:; 5094 mninex(fX);; 5095 if (fISW[2] == 1) {; 5096 Eval(nparx, fGin, fzero, fU, 2); ++fNfcn;; 5097 }; 5098 mnderi();; 5099 if (fISW[1] >= 1) goto L10;; 5100// sometimes start with diagonal matrix; 5101 for (i = 1; i <= fNpar; ++i) {; 5102 fMIGRxxs[i-1] = fX[i-1];; 5103 fMIGRstep[i-1] = 0;; 5104 }; 5105// do line search if second derivative negative; 5106 ++lined2;; 5107 if (lined2 < (fIstrat + 1)*fNpar) {; 5108 for (i = 1; i <= fNpar; ++i) {; 5109 if (fG2[i-1] > 0) continue;; 5110 if (fGrd[i-1] > 0) fMIGRstep[i-1] = -TMath::Abs(fGstep[i-1]);; 5111 else fMIGRstep[i-1] = TMath::Abs(fGstep[i-1]);; 5112 gdel = fMIGRstep[i-1]*fGrd[i-1];; 5113 fs = fAmin;; 5114 mnline(fMIGRxxs, fs, fMIGRstep, gdel, toler);; 5115 mnwarn(""D"", ""MNMIGR"", ""Negative G2 line search"");; 5116 iext = fNexofi[i-1];; 5117 if (ldebug) {; 5118 Printf("" Negative G2 line search, param %3d %13.3g%13.3g"",iext,fs,fAmin);; 5119 }; 5120 goto L2;; 5121 }; 5122 }; 5123// make diagonal error matrix; 5124 for (i = 1; i <= fNpar; ++i) {; 5125 ndex = i*(i-1) / 2;; 5126 for (j = 1; j <= i-1; ++j) {; 5127 ++ndex;; 5128 fVhmat[ndex-1] = 0;; 5129 }; 5130 ++ndex;; 5131 if (fG2[i-1] <= 0) fG2[i-1] = 1;; 5132 fVhmat[ndex-1] = 2 / fG2[i-1];; 5133 }; 5134",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:168930,Availability,error,error,168930,"(fISW[1] >= 1) goto L10;; 5100// sometimes start with diagonal matrix; 5101 for (i = 1; i <= fNpar; ++i) {; 5102 fMIGRxxs[i-1] = fX[i-1];; 5103 fMIGRstep[i-1] = 0;; 5104 }; 5105// do line search if second derivative negative; 5106 ++lined2;; 5107 if (lined2 < (fIstrat + 1)*fNpar) {; 5108 for (i = 1; i <= fNpar; ++i) {; 5109 if (fG2[i-1] > 0) continue;; 5110 if (fGrd[i-1] > 0) fMIGRstep[i-1] = -TMath::Abs(fGstep[i-1]);; 5111 else fMIGRstep[i-1] = TMath::Abs(fGstep[i-1]);; 5112 gdel = fMIGRstep[i-1]*fGrd[i-1];; 5113 fs = fAmin;; 5114 mnline(fMIGRxxs, fs, fMIGRstep, gdel, toler);; 5115 mnwarn(""D"", ""MNMIGR"", ""Negative G2 line search"");; 5116 iext = fNexofi[i-1];; 5117 if (ldebug) {; 5118 Printf("" Negative G2 line search, param %3d %13.3g%13.3g"",iext,fs,fAmin);; 5119 }; 5120 goto L2;; 5121 }; 5122 }; 5123// make diagonal error matrix; 5124 for (i = 1; i <= fNpar; ++i) {; 5125 ndex = i*(i-1) / 2;; 5126 for (j = 1; j <= i-1; ++j) {; 5127 ++ndex;; 5128 fVhmat[ndex-1] = 0;; 5129 }; 5130 ++ndex;; 5131 if (fG2[i-1] <= 0) fG2[i-1] = 1;; 5132 fVhmat[ndex-1] = 2 / fG2[i-1];; 5133 }; 5134 fDcovar = 1;; 5135 if (ldebug) {; 5136 Printf("" DEBUG MNMIGR, STARTING MATRIX DIAGONAL, VHMAT="");; 5137 for (kk = 1; kk <= Int_t(vlen); ++kk) {; 5138 Printf("" %10.2g"",fVhmat[kk-1]);; 5139 }; 5140 }; 5141// ready to start first iteration; 5142L10:; 5143 ++nrstrt;; 5144 if (nrstrt > fIstrat + 1) {; 5145 fCstatu = ""FAILED "";; 5146 goto L230;; 5147 }; 5148 fs = fAmin;; 5149// get EDM and set up loop; 5150 fEDM = 0;; 5151 for (i = 1; i <= fNpar; ++i) {; 5152 fMIGRgs[i-1] = fGrd[i-1];; 5153 fMIGRxxs[i-1] = fX[i-1];; 5154 ndex = i*(i-1) / 2;; 5155 for (j = 1; j <= i-1; ++j) {; 5156 ++ndex;; 5157 fEDM += fMIGRgs[i-1]*fVhmat[ndex-1]*fMIGRgs[j-1];; 5158 }; 5159 ++ndex;; 5160 fEDM += fMIGRgs[i-1]*fMIGRgs[i-1]*.5*fVhmat[ndex-1];; 5161 }; 5162 fEDM = fEDM*.5*(fDcovar*3 + 1);; 5163 if (fEDM < 0) {; 5164 mnwarn(""W"", ""MIGRAD"", ""STARTING MATRIX NOT POS-DEFINITE."");; 5165 fISW[1] = 0;; 5166 fDcovar = 1;; 5167 goto ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:171128,Availability,toler,toler,171128,"i = 1; i <= fNpar; ++i) {; 5181 ri = 0;; 5182 gssq += fMIGRgs[i-1]*fMIGRgs[i-1];; 5183 for (j = 1; j <= fNpar; ++j) {; 5184 m = TMath::Max(i,j);; 5185 n = TMath::Min(i,j);; 5186 ndex = m*(m-1) / 2 + n;; 5187 ri += fVhmat[ndex-1]*fMIGRgs[j-1];; 5188 }; 5189 fMIGRstep[i-1] = ri*-.5;; 5190 gdel += fMIGRstep[i-1]*fMIGRgs[i-1];; 5191 }; 5192 if (gssq == 0) {; 5193 mnwarn(""D"", ""MIGRAD"", "" FIRST DERIVATIVES OF FCN ARE ALL ZERO"");; 5194 goto L300;; 5195 }; 5196// if gdel positive, V not posdef; 5197 if (gdel >= 0) {; 5198 mnwarn(""D"", ""MIGRAD"", "" NEWTON STEP NOT DESCENT."");; 5199 if (npsdf == 1) goto L1;; 5200 mnpsdf();; 5201 npsdf = 1;; 5202 goto L24;; 5203 }; 5204// do line search; 5205 mnline(fMIGRxxs, fs, fMIGRstep, gdel, toler);; 5206 if (fAmin == fs) goto L200;; 5207 fCfrom = ""MIGRAD "";; 5208 fNfcnfr = nfcnmg;; 5209 fCstatu = ""PROGRESS "";; 5210// get gradient at new point; 5211 mninex(fX);; 5212 if (fISW[2] == 1) {; 5213 Eval(nparx, fGin, fzero, fU, 2); ++fNfcn;; 5214 }; 5215 mnderi();; 5216// calculate new EDM; 5217 npsdf = 0;; 5218L81:; 5219 fEDM = 0;; 5220 gvg = 0;; 5221 delgam = 0;; 5222 gdgssq = 0;; 5223 for (i = 1; i <= fNpar; ++i) {; 5224 ri = 0;; 5225 vgi = 0;; 5226 for (j = 1; j <= fNpar; ++j) {; 5227 m = TMath::Max(i,j);; 5228 n = TMath::Min(i,j);; 5229 ndex = m*(m-1) / 2 + n;; 5230 vgi += fVhmat[ndex-1]*(fGrd[j-1] - fMIGRgs[j-1]);; 5231 ri += fVhmat[ndex-1]*fGrd[j-1];; 5232 }; 5233 fMIGRvg[i-1] = vgi*.5;; 5234 gami = fGrd[i-1] - fMIGRgs[i-1];; 5235 gdgssq += gami*gami;; 5236 gvg += gami*fMIGRvg[i-1];; 5237 delgam += fDirin[i-1]*gami;; 5238 fEDM += fGrd[i-1]*ri*.5;; 5239 }; 5240 fEDM = fEDM*.5*(fDcovar*3 + 1);; 5241// if EDM negative, not positive-definite; 5242 if (fEDM < 0 || gvg <= 0) {; 5243 mnwarn(""D"", ""MIGRAD"", ""NOT POS-DEF. EDM OR GVG NEGATIVE."");; 5244 fCstatu = ""NOT POSDEF"";; 5245 if (npsdf == 1) goto L230;; 5246 mnpsdf();; 5247 npsdf = 1;; 5248 goto L81;; 5249 }; 5250// print information about this iteration; 5251 ++iter;; 5252 if (iswtr >= 3 || (isw",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:176130,Availability,error,error,176130,"rat < 1) {; 5339 if (fISW[4] >= 0) {; 5340 Printf("" MIGRAD FAILS WITH STRATEGY=0. WILL TRY WITH STRATEGY=1."");; 5341 }; 5342 fIstrat = 1;; 5343 }; 5344 goto L1;; 5345// fails to converge; 5346L230:; 5347 if (iswtr >= 0) {; 5348 Printf("" MIGRAD TERMINATED WITHOUT CONVERGENCE."");; 5349 }; 5350 if (fISW[1] == 3) fISW[1] = 1;; 5351 fISW[3] = -1;; 5352 goto L400;; 5353// apparent convergence; 5354L300:; 5355 if (iswtr >= 0) {; 5356 Printf("" MIGRAD MINIMIZATION HAS CONVERGED."");; 5357 }; 5358 if (fItaur == 0) {; 5359 if (fIstrat >= 2 || (fIstrat == 1 && fISW[1] < 3)) {; 5360 if (fISW[4] >= 0) {; 5361 Printf("" MIGRAD WILL VERIFY CONVERGENCE AND ERROR MATRIX."");; 5362 }; 5363 mnhess();; 5364 mnwerr();; 5365 npsdf = 0;; 5366 if (fEDM > rhotol) goto L10;; 5367 }; 5368 }; 5369 fCstatu = ""CONVERGED "";; 5370 fISW[3] = 1;; 5371// come here in any case; 5372L400:; 5373 fCfrom = ""MIGRAD "";; 5374 fNfcnfr = nfcnmg;; 5375 mninex(fX);; 5376 mnwerr();; 5377 if (iswtr >= 0) mnprin(3, fAmin);; 5378 if (iswtr >= 1) mnmatu(1);; 5379}; 5380 ; 5381////////////////////////////////////////////////////////////////////////////////; 5382/// Performs a MINOS error analysis; 5383///; 5384/// Performs a MINOS error analysis on those parameters for; 5385/// which it is requested on the MINOS command by calling; 5386/// MNMNOT for each parameter requested.; 5387 ; 5388void TMinuit::mnmnos(); 5389{; 5390 /* Local variables */; 5391 Double_t val2mi, val2pl;; 5392 Int_t nbad, ilax, ilax2, ngood, nfcnmi, iin, knt;; 5393 ; 5394 if (fNpar <= 0) goto L700;; 5395 ngood = 0;; 5396 nbad = 0;; 5397 nfcnmi = fNfcn;; 5398// loop over parameters requested; 5399 for (knt = 1; knt <= fNpar; ++knt) {; 5400 if (Int_t(fWord7[1]) == 0) {; 5401 ilax = fNexofi[knt-1];; 5402 } else {; 5403 if (knt >= 7) break;; 5404 ilax = Int_t(fWord7[knt]);; 5405 if (ilax == 0) break;; 5406 if (ilax > 0 && ilax <= fNu) {; 5407 if (fNiofex[ilax-1] > 0) goto L565;; 5408 }; 5409 Printf("" PARAMETER NUMBER %3d NOT A VARIABLE. IGNORED."",ilax);; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:176180,Availability,error,error,176180,"rat < 1) {; 5339 if (fISW[4] >= 0) {; 5340 Printf("" MIGRAD FAILS WITH STRATEGY=0. WILL TRY WITH STRATEGY=1."");; 5341 }; 5342 fIstrat = 1;; 5343 }; 5344 goto L1;; 5345// fails to converge; 5346L230:; 5347 if (iswtr >= 0) {; 5348 Printf("" MIGRAD TERMINATED WITHOUT CONVERGENCE."");; 5349 }; 5350 if (fISW[1] == 3) fISW[1] = 1;; 5351 fISW[3] = -1;; 5352 goto L400;; 5353// apparent convergence; 5354L300:; 5355 if (iswtr >= 0) {; 5356 Printf("" MIGRAD MINIMIZATION HAS CONVERGED."");; 5357 }; 5358 if (fItaur == 0) {; 5359 if (fIstrat >= 2 || (fIstrat == 1 && fISW[1] < 3)) {; 5360 if (fISW[4] >= 0) {; 5361 Printf("" MIGRAD WILL VERIFY CONVERGENCE AND ERROR MATRIX."");; 5362 }; 5363 mnhess();; 5364 mnwerr();; 5365 npsdf = 0;; 5366 if (fEDM > rhotol) goto L10;; 5367 }; 5368 }; 5369 fCstatu = ""CONVERGED "";; 5370 fISW[3] = 1;; 5371// come here in any case; 5372L400:; 5373 fCfrom = ""MIGRAD "";; 5374 fNfcnfr = nfcnmg;; 5375 mninex(fX);; 5376 mnwerr();; 5377 if (iswtr >= 0) mnprin(3, fAmin);; 5378 if (iswtr >= 1) mnmatu(1);; 5379}; 5380 ; 5381////////////////////////////////////////////////////////////////////////////////; 5382/// Performs a MINOS error analysis; 5383///; 5384/// Performs a MINOS error analysis on those parameters for; 5385/// which it is requested on the MINOS command by calling; 5386/// MNMNOT for each parameter requested.; 5387 ; 5388void TMinuit::mnmnos(); 5389{; 5390 /* Local variables */; 5391 Double_t val2mi, val2pl;; 5392 Int_t nbad, ilax, ilax2, ngood, nfcnmi, iin, knt;; 5393 ; 5394 if (fNpar <= 0) goto L700;; 5395 ngood = 0;; 5396 nbad = 0;; 5397 nfcnmi = fNfcn;; 5398// loop over parameters requested; 5399 for (knt = 1; knt <= fNpar; ++knt) {; 5400 if (Int_t(fWord7[1]) == 0) {; 5401 ilax = fNexofi[knt-1];; 5402 } else {; 5403 if (knt >= 7) break;; 5404 ilax = Int_t(fWord7[knt]);; 5405 if (ilax == 0) break;; 5406 if (ilax > 0 && ilax <= fNu) {; 5407 if (fNiofex[ilax-1] > 0) goto L565;; 5408 }; 5409 Printf("" PARAMETER NUMBER %3d NOT A VARIABLE. IGNORED."",ilax);; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:178415,Availability,error,error,178415," if (ngood == 0 && nbad == 0) goto L700;; 5430 if (ngood > 0 && nbad == 0) fCstatu = ""SUCCESSFUL"";; 5431 if (ngood == 0 && nbad > 0) fCstatu = ""FAILURE "";; 5432 if (ngood > 0 && nbad > 0) fCstatu = ""PROBLEMS "";; 5433 if (fISW[4] >= 0) mnprin(4, fAmin);; 5434 if (fISW[4] >= 2) mnmatu(0);; 5435 return;; 5436// new minimum found; 5437L650:; 5438 fCfrom = ""MINOS "";; 5439 fNfcnfr = nfcnmi;; 5440 fCstatu = ""NEW MINIMU"";; 5441 if (fISW[4] >= 0) mnprin(4, fAmin);; 5442 Printf("" NEW MINIMUM FOUND. GO BACK TO MINIMIZATION STEP."");; 5443 Printf("" ================================================="");; 5444 Printf("" V"");; 5445 Printf("" V"");; 5446 Printf("" V"");; 5447 Printf("" VVVVVVV"");; 5448 Printf("" VVVVV"");; 5449 Printf("" VVV"");; 5450 Printf("" V\n"");; 5451 return;; 5452L700:; 5453 Printf("" THERE ARE NO MINOS ERRORS TO CALCULATE."");; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Performs a MINOS error analysis on one parameter; 5458///; 5459/// The parameter ILAX is varied, and the minimum of the; 5460/// function with respect to the other parameters is followed; 5461/// until it crosses the value FMIN+UP.; 5462 ; 5463void TMinuit::mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi); 5464{; 5465 /* System generated locals */; 5466 Int_t i__1;; 5467 ; 5468 /* Local variables */; 5469 Double_t delu, aopt, eros;; 5470 Double_t abest, xunit, dc, ut, sigsav, du1;; 5471 Double_t fac, sig, sav;; 5472 Int_t marc, isig, mpar, ndex, imax, indx, ierr, i, j;; 5473 Int_t iercr, it, istrav, nfmxin, nlimit, isw2, isw4;; 5474 TString csig;; 5475 ; 5476// save and prepare start vals; 5477 isw2 = fISW[1];; 5478 isw4 = fISW[3];; 5479 sigsav = fEDM;; 5480 istrav = fIstrat;; 5481 dc = fDcovar;; 5482 fLnewmn = kFALSE;; 5483 fApsi = fEpsi*.5;; 5484 abest = fAmin;; 5485 mpar = fNpar;; 5486 nfmxin = fNfcnmx;; 5487 for (i = 1; i <= mpar; ++i) { fXt[i-1] = fX[i-1]; }; 5488 i__1 = mpar*(mpar + 1) / 2;; 5489 for (j = 1; j <= i__1;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:180671,Availability,error,error,180671,"5494 it = fNiofex[ilax-1];; 5495 fErp[it-1] = 0;; 5496 fErn[it-1] = 0;; 5497 mninex(fXt);; 5498 ut = fU[ilax-1];; 5499 if (fNvarl[ilax-1] == 1) {; 5500 fAlim[ilax-1] = ut - fMNOTw[it-1]*100;; 5501 fBlim[ilax-1] = ut + fMNOTw[it-1]*100;; 5502 }; 5503 ndex = it*(it + 1) / 2;; 5504 xunit = TMath::Sqrt(fUp / fVthmat[ndex-1]);; 5505 marc = 0;; 5506 for (i = 1; i <= mpar; ++i) {; 5507 if (i == it) continue;; 5508 ++marc;; 5509 imax = TMath::Max(it,i);; 5510 indx = imax*(imax-1) / 2 + TMath::Min(it,i);; 5511 fMNOTxdev[marc-1] = xunit*fVthmat[indx-1];; 5512 }; 5513// fix the parameter in question; 5514 mnfixp(it-1, ierr);; 5515 if (ierr > 0) {; 5516 Printf("" MINUIT ERROR. CANNOT FIX PARAMETER %4d INTERNAL %3d"",ilax,it);; 5517 goto L700;; 5518 }; 5519// Nota Bene: from here on, NPAR=MPAR-1; 5520// Remember: MNFIXP squeezes IT out of X, XT, WERR, and VHMAT,; 5521// not W, VTHMAT; 5522 for (isig = 1; isig <= 2; ++isig) {; 5523 if (isig == 1) {; 5524 sig = 1;; 5525 csig = ""POSI"";; 5526 } else {; 5527 sig = -1;; 5528 csig = ""NEGA"";; 5529 }; 5530// sig=sign of error being calcd; 5531 if (fISW[4] > 1) {; 5532 Printf("" DETERMINATION OF %sTIVE MINOS ERROR FOR PARAMETER %d %s""; 5533 ,(const char*)csig,ilax; 5534 ,(const char*)fCpnam[ilax-1]);; 5535 }; 5536 if (fISW[1] <= 0) {; 5537 mnwarn(""D"", ""MINOS"", ""NO COVARIANCE MATRIX."");; 5538 }; 5539 nlimit = fNfcn + nfmxin;; 5540 fIstrat = TMath::Max(istrav-1,0);; 5541 du1 = fMNOTw[it-1];; 5542 fU[ilax-1] = ut + sig*du1;; 5543 fU[ilax-1] = TMath::Min(fU[ilax-1],fBlim[ilax-1]);; 5544 fU[ilax-1] = TMath::Max(fU[ilax-1],fAlim[ilax-1]);; 5545 delu = fU[ilax-1] - ut;; 5546// stop if already at limit with negligible step size; 5547// add also a check if both numerator and denominarot are not zero (ROOT-10835)(LM); 5548 if ( (delu == 0 && ut == 0) ||; 5549 (TMath::Abs(delu) / (TMath::Abs(ut) + TMath::Abs(fU[ilax-1])) < fEpsmac)) goto L440;; 5550 fac = delu / fMNOTw[it-1];; 5551 for (i = 1; i <= fNpar; ++i) {; 5552 fX[i-1] = fXt[i-1] + fac*fMNOTxdev",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:182100,Availability,error,error,182100,"im[ilax-1]);; 5544 fU[ilax-1] = TMath::Max(fU[ilax-1],fAlim[ilax-1]);; 5545 delu = fU[ilax-1] - ut;; 5546// stop if already at limit with negligible step size; 5547// add also a check if both numerator and denominarot are not zero (ROOT-10835)(LM); 5548 if ( (delu == 0 && ut == 0) ||; 5549 (TMath::Abs(delu) / (TMath::Abs(ut) + TMath::Abs(fU[ilax-1])) < fEpsmac)) goto L440;; 5550 fac = delu / fMNOTw[it-1];; 5551 for (i = 1; i <= fNpar; ++i) {; 5552 fX[i-1] = fXt[i-1] + fac*fMNOTxdev[i-1];; 5553 }; 5554 if (fISW[4] > 1) {; 5555 Printf("" PARAMETER %4d SET TO%11.3e + %10.3e = %12.3e"",ilax,ut,delu,fU[ilax-1]);; 5556 }; 5557// loop to hit AMIN+UP; 5558 fKe1cr = ilax;; 5559 fKe2cr = 0;; 5560 fXmidcr = fU[ilax-1];; 5561 fXdircr = delu;; 5562 ; 5563 fAmin = abest;; 5564 fNfcnmx = nlimit - fNfcn;; 5565 mncros(aopt, iercr);; 5566 if (abest - fAmin > fUp*.01) goto L650;; 5567 if (iercr == 1) goto L440;; 5568 if (iercr == 2) goto L450;; 5569 if (iercr == 3) goto L460;; 5570// error successfully calculated; 5571 eros = fXmidcr - ut + aopt*fXdircr;; 5572 if (fISW[4] > 1) {; 5573 Printf("" THE %4sTIVE MINOS ERROR OF PARAMETER %3d %10s, IS %12.4e""; 5574 ,(const char*)csig,ilax; 5575 ,(const char*)fCpnam[ilax-1],eros);; 5576 }; 5577 goto L480;; 5578// failure returns; 5579L440:; 5580 if (fISW[4] >= 1) {; 5581 Printf("" THE %4sTIVE MINOS ERROR OF PARAMETER %3d, %s EXCEEDS ITS LIMIT.""; 5582 ,(const char*)csig,ilax; 5583 ,(const char*)fCpnam[ilax-1]);; 5584 }; 5585 eros = fUndefi;; 5586 goto L480;; 5587L450:; 5588 if (fISW[4] >= 1) {; 5589 Printf("" THE %4sTIVE MINOS ERROR %4d REQUIRES MORE THAN %5d FUNCTION CALLS.""; 5590 ,(const char*)csig,ilax,nfmxin);; 5591 }; 5592 eros = 0;; 5593 goto L480;; 5594L460:; 5595 if (fISW[4] >= 1) {; 5596 Printf("" %4sTIVE MINOS ERROR NOT CALCULATED FOR PARAMETER %d""; 5597 ,(const char*)csig,ilax);; 5598 }; 5599 eros = 0;; 5600 ; 5601L480:; 5602 if (fISW[4] > 1) {; 5603 Printf("" **************************************************************************"");; 56",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:182375,Availability,failure,failure,182375," == 0 && ut == 0) ||; 5549 (TMath::Abs(delu) / (TMath::Abs(ut) + TMath::Abs(fU[ilax-1])) < fEpsmac)) goto L440;; 5550 fac = delu / fMNOTw[it-1];; 5551 for (i = 1; i <= fNpar; ++i) {; 5552 fX[i-1] = fXt[i-1] + fac*fMNOTxdev[i-1];; 5553 }; 5554 if (fISW[4] > 1) {; 5555 Printf("" PARAMETER %4d SET TO%11.3e + %10.3e = %12.3e"",ilax,ut,delu,fU[ilax-1]);; 5556 }; 5557// loop to hit AMIN+UP; 5558 fKe1cr = ilax;; 5559 fKe2cr = 0;; 5560 fXmidcr = fU[ilax-1];; 5561 fXdircr = delu;; 5562 ; 5563 fAmin = abest;; 5564 fNfcnmx = nlimit - fNfcn;; 5565 mncros(aopt, iercr);; 5566 if (abest - fAmin > fUp*.01) goto L650;; 5567 if (iercr == 1) goto L440;; 5568 if (iercr == 2) goto L450;; 5569 if (iercr == 3) goto L460;; 5570// error successfully calculated; 5571 eros = fXmidcr - ut + aopt*fXdircr;; 5572 if (fISW[4] > 1) {; 5573 Printf("" THE %4sTIVE MINOS ERROR OF PARAMETER %3d %10s, IS %12.4e""; 5574 ,(const char*)csig,ilax; 5575 ,(const char*)fCpnam[ilax-1],eros);; 5576 }; 5577 goto L480;; 5578// failure returns; 5579L440:; 5580 if (fISW[4] >= 1) {; 5581 Printf("" THE %4sTIVE MINOS ERROR OF PARAMETER %3d, %s EXCEEDS ITS LIMIT.""; 5582 ,(const char*)csig,ilax; 5583 ,(const char*)fCpnam[ilax-1]);; 5584 }; 5585 eros = fUndefi;; 5586 goto L480;; 5587L450:; 5588 if (fISW[4] >= 1) {; 5589 Printf("" THE %4sTIVE MINOS ERROR %4d REQUIRES MORE THAN %5d FUNCTION CALLS.""; 5590 ,(const char*)csig,ilax,nfmxin);; 5591 }; 5592 eros = 0;; 5593 goto L480;; 5594L460:; 5595 if (fISW[4] >= 1) {; 5596 Printf("" %4sTIVE MINOS ERROR NOT CALCULATED FOR PARAMETER %d""; 5597 ,(const char*)csig,ilax);; 5598 }; 5599 eros = 0;; 5600 ; 5601L480:; 5602 if (fISW[4] > 1) {; 5603 Printf("" **************************************************************************"");; 5604 }; 5605 if (sig < 0) {; 5606 fErn[it-1] = eros;; 5607 if (ilax2 > 0 && ilax2 <= fNu) val2mi = fU[ilax2-1];; 5608 } else {; 5609 fErp[it-1] = eros;; 5610 if (ilax2 > 0 && ilax2 <= fNu) val2pl = fU[ilax2-1];; 5611 }; 5612 }; 5613// parameter finished. reset v; 56",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:190471,Availability,error,error,190471,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:190938,Availability,error,error,190938,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:193201,Availability,error,error,193201,"r*)crdbuf, ""'"");; 5879 if (kapo1 == 0) goto L150;; 5880 kapo2 = strspn((const char*)crdbuf + kapo1, ""'"");; 5881 if (kapo2 == 0) goto L150;; 5882// new (free-field) format; 5883 kapo2 += kapo1;; 5884// skip leading blanks if any; 5885 for (istart = 1; istart <= kapo1-1; ++istart) {; 5886 if (crdbuf(istart-1,1) != ' ') goto L120;; 5887 }; 5888 goto L210;; 5889L120:; 5890// parameter number integer; 5891 celmnt = crdbuf(istart-1, kapo1-istart);; 5892 if (scanf((const char*)celmnt,&fk)) {;}; 5893 k = Int_t(fk);; 5894 if (k <= 0) goto L210;; 5895 cnamk = ""PARAM "" + celmnt;; 5896 if (kapo2 - kapo1 > 1) {; 5897 cnamk = crdbuf(kapo1, kapo2-1-kapo1);; 5898 }; 5899// special handling if comma or blanks and a comma follow 'name'; 5900 for (icy = kapo2 + 1; icy <= lenbuf; ++icy) {; 5901 if (crdbuf(icy-1,1) == ',') goto L139;; 5902 if (crdbuf(icy-1,1) != ' ') goto L140;; 5903 }; 5904 uk = 0;; 5905 wk = 0;; 5906 a = 0;; 5907 b = 0;; 5908 goto L170;; 5909L139:; 5910 ++icy;; 5911L140:; 5912 ibegin = icy;; 5913 ctemp = crdbuf(ibegin-1,lenbuf-ibegin);; 5914 mncrck(ctemp, 20, comand, lnc, fMaxpar, fPARSplist, llist, ierr, fIsyswr);; 5915 if (ierr > 0) goto L180;; 5916 uk = fPARSplist[0];; 5917 wk = 0;; 5918 if (llist >= 2) wk = fPARSplist[1];; 5919 a = 0;; 5920 if (llist >= 3) a = fPARSplist[2];; 5921 b = 0;; 5922 if (llist >= 4) b = fPARSplist[3];; 5923 goto L170;; 5924// old (fixed-field) format; 5925L150:; 5926 if (scanf((const char*)crdbuf,&xk,stmp,&uk,&wk,&a,&b)) {;}; 5927 cnamk = stmp;; 5928 k = Int_t(xk);; 5929 if (k == 0) goto L210;; 5930// parameter format cracked, implement parameter definition; 5931L170:; 5932 mnparm(k-1, cnamk, uk, wk, a, b, ierr);; 5933 icondn = ierr;; 5934 return;; 5935// format or other error; 5936L180:; 5937 icondn = 1;; 5938 return;; 5939// end of data; 5940L210:; 5941 icondn = 2;; 5942}; 5943 ; 5944////////////////////////////////////////////////////////////////////////////////; 5945/// To fit a parabola to npar2p points; 5946///; 5947/// - npar2p no.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204129,Availability,error,errors,204129," no limits); 6239/// - IUINT: the internal parameter number (or zero if not variable,; 6240/// or negative if undefined).; 6241///; 6242/// Note also: If IUEXT is negative, then it is -internal parameter; 6243/// number, and IUINT is returned as the EXTERNAL number.; 6244/// Except for IUINT, this is exactly the inverse of MNPARM; 6245/// User-called; 6246 ; 6247void TMinuit::mnpout(Int_t iuext1, TString &chnam, Double_t &val, Double_t &err, Double_t &xlolim, Double_t &xuplim, Int_t &iuint) const; 6248{; 6249 /* Local variables */; 6250 Int_t iint, iext, nvl;; 6251 ; 6252 Int_t iuext = iuext1 + 1;; 6253 xlolim = 0;; 6254 xuplim = 0;; 6255 err = 0;; 6256 if (iuext == 0) goto L100;; 6257 if (iuext < 0) {; 6258// internal parameter number specified; 6259 iint = -(iuext);; 6260 if (iint > fNpar) goto L100;; 6261 iext = fNexofi[iint-1];; 6262 iuint = iext;; 6263 } else {; 6264// external parameter number specified; 6265 iext = iuext;; 6266 if (iext > fNu) goto L100;; 6267 iint = fNiofex[iext-1];; 6268 iuint = iint;; 6269 }; 6270// in both cases; 6271 nvl = fNvarl[iext-1];; 6272 if (nvl < 0) goto L100;; 6273 chnam = fCpnam[iext-1];; 6274 val = fU[iext-1];; 6275 if (iint > 0) err = fWerr[iint-1];; 6276 if (nvl == 4) {; 6277 xlolim = fAlim[iext-1];; 6278 xuplim = fBlim[iext-1];; 6279 }; 6280 return;; 6281// parameter is undefined; 6282L100:; 6283 iuint = -1;; 6284 chnam = ""undefined"";; 6285 val = 0;; 6286}; 6287 ; 6288////////////////////////////////////////////////////////////////////////////////; 6289/// Prints the values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204315,Availability,error,errors,204315,"6264// external parameter number specified; 6265 iext = iuext;; 6266 if (iext > fNu) goto L100;; 6267 iint = fNiofex[iext-1];; 6268 iuint = iint;; 6269 }; 6270// in both cases; 6271 nvl = fNvarl[iext-1];; 6272 if (nvl < 0) goto L100;; 6273 chnam = fCpnam[iext-1];; 6274 val = fU[iext-1];; 6275 if (iint > 0) err = fWerr[iint-1];; 6276 if (nvl == 4) {; 6277 xlolim = fAlim[iext-1];; 6278 xuplim = fBlim[iext-1];; 6279 }; 6280 return;; 6281// parameter is undefined; 6282L100:; 6283 iuint = -1;; 6284 chnam = ""undefined"";; 6285 val = 0;; 6286}; 6287 ; 6288////////////////////////////////////////////////////////////////////////////////; 6289/// Prints the values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204351,Availability,error,errors,204351,"6264// external parameter number specified; 6265 iext = iuext;; 6266 if (iext > fNu) goto L100;; 6267 iint = fNiofex[iext-1];; 6268 iuint = iint;; 6269 }; 6270// in both cases; 6271 nvl = fNvarl[iext-1];; 6272 if (nvl < 0) goto L100;; 6273 chnam = fCpnam[iext-1];; 6274 val = fU[iext-1];; 6275 if (iint > 0) err = fWerr[iint-1];; 6276 if (nvl == 4) {; 6277 xlolim = fAlim[iext-1];; 6278 xuplim = fBlim[iext-1];; 6279 }; 6280 return;; 6281// parameter is undefined; 6282L100:; 6283 iuint = -1;; 6284 chnam = ""undefined"";; 6285 val = 0;; 6286}; 6287 ; 6288////////////////////////////////////////////////////////////////////////////////; 6289/// Prints the values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204408,Availability,error,errors,204408,"6264// external parameter number specified; 6265 iext = iuext;; 6266 if (iext > fNu) goto L100;; 6267 iint = fNiofex[iext-1];; 6268 iuint = iint;; 6269 }; 6270// in both cases; 6271 nvl = fNvarl[iext-1];; 6272 if (nvl < 0) goto L100;; 6273 chnam = fCpnam[iext-1];; 6274 val = fU[iext-1];; 6275 if (iint > 0) err = fWerr[iint-1];; 6276 if (nvl == 4) {; 6277 xlolim = fAlim[iext-1];; 6278 xuplim = fBlim[iext-1];; 6279 }; 6280 return;; 6281// parameter is undefined; 6282L100:; 6283 iuint = -1;; 6284 chnam = ""undefined"";; 6285 val = 0;; 6286}; 6287 ; 6288////////////////////////////////////////////////////////////////////////////////; 6289/// Prints the values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204473,Availability,error,errors,204473,"values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; 6329 for (k = 1; k <= 6; ++k) {; 6330 colhdu[k-1] = ""UNDEFINED"";; 6331 colhdl[k-1] = ""COLUMN HEAD"";; 6332 }; 6333// print title if Minos errors, and title exists.; 6334 if (ikode == 4 && fCtitl != fCundef) {; 6335 Printf("" MINUIT TASK: %s"",(const char*)fCtitl);; 6336 }; 6337// report function value and status; 6338 if (fval == fUndefi) cheval = "" unknown "";; 6339 else cheval.Form(""%g"",fval);; 6340 ; 6341 if (fEDM == fBigedm) chedm = "" unknown "";; 6342 else chedm.Form(""%g"",fEDM);; 6343 ; 6344 nc = fNfcn - fNfcnfr;; 6345 Printf("" FCN=%s FROM %8s STATUS=%10s %6d CALLS %9d TOTAL""; 6346 ,(const char*)cheval; 6347 ,(const char*)fCfrom; 6348 ,(const cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204487,Availability,error,errors,204487,"values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; 6329 for (k = 1; k <= 6; ++k) {; 6330 colhdu[k-1] = ""UNDEFINED"";; 6331 colhdl[k-1] = ""COLUMN HEAD"";; 6332 }; 6333// print title if Minos errors, and title exists.; 6334 if (ikode == 4 && fCtitl != fCundef) {; 6335 Printf("" MINUIT TASK: %s"",(const char*)fCtitl);; 6336 }; 6337// report function value and status; 6338 if (fval == fUndefi) cheval = "" unknown "";; 6339 else cheval.Form(""%g"",fval);; 6340 ; 6341 if (fEDM == fBigedm) chedm = "" unknown "";; 6342 else chedm.Form(""%g"",fEDM);; 6343 ; 6344 nc = fNfcn - fNfcnfr;; 6345 Printf("" FCN=%s FROM %8s STATUS=%10s %6d CALLS %9d TOTAL""; 6346 ,(const char*)cheval; 6347 ,(const char*)fCfrom; 6348 ,(const cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:205432,Availability,error,errors,205432,"values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; 6329 for (k = 1; k <= 6; ++k) {; 6330 colhdu[k-1] = ""UNDEFINED"";; 6331 colhdl[k-1] = ""COLUMN HEAD"";; 6332 }; 6333// print title if Minos errors, and title exists.; 6334 if (ikode == 4 && fCtitl != fCundef) {; 6335 Printf("" MINUIT TASK: %s"",(const char*)fCtitl);; 6336 }; 6337// report function value and status; 6338 if (fval == fUndefi) cheval = "" unknown "";; 6339 else cheval.Form(""%g"",fval);; 6340 ; 6341 if (fEDM == fBigedm) chedm = "" unknown "";; 6342 else chedm.Form(""%g"",fEDM);; 6343 ; 6344 nc = fNfcn - fNfcnfr;; 6345 Printf("" FCN=%s FROM %8s STATUS=%10s %6d CALLS %9d TOTAL""; 6346 ,(const char*)cheval; 6347 ,(const char*)fCfrom; 6348 ,(const cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:210970,Availability,error,error,210970,"f(""%4d %-11s%14.5e%-14s%14.5e%14.5e"",i; 6475 ,(const char*)cnambf,fU[i-1]; 6476 ,(const char*)colhdu[0],fAlim[i-1],fBlim[i-1]);; 6477 } else {; 6478 Printf(""%4d %-11s%14.5e%s"",i; 6479 ,(const char*)cnambf,fU[i-1],(const char*)colhdu[0]);; 6480 }; 6481 }; 6482 ; 6483 if (fUp != fUpdflt) {; 6484 Printf("" ERR DEF= %g"",fUp);; 6485 }; 6486 return;; 6487}; 6488 ; 6489////////////////////////////////////////////////////////////////////////////////; 6490/// Calculates the eigenvalues of v to see if positive-def; 6491///; 6492/// if not, adds constant along diagonal to make positive.; 6493 ; 6494void TMinuit::mnpsdf(); 6495{; 6496 /* Local variables */; 6497 Double_t dgmin, pAdd, pmin, pmax, dg, epspdf, epsmin;; 6498 Int_t ndex, i, j, ndexd, ip, ifault;; 6499 TString chbuff, ctemp;; 6500 ; 6501 epsmin = 1e-6;; 6502 epspdf = TMath::Max(epsmin,fEpsma2);; 6503 dgmin = fVhmat[0];; 6504// Check if negative or zero on diagonal; 6505 for (i = 1; i <= fNpar; ++i) {; 6506 ndex = i*(i + 1) / 2;; 6507 if (fVhmat[ndex-1] <= 0) {; 6508 mnwarn(""W"", fCfrom, TString::Format(""Negative diagonal element %d in Error Matrix"",i));; 6509 }; 6510 if (fVhmat[ndex-1] < dgmin) dgmin = fVhmat[ndex-1];; 6511 }; 6512 if (dgmin <= 0) {; 6513 dg = epspdf + 1 - dgmin;; 6514 mnwarn(""W"", fCfrom, TString::Format(""%g added to diagonal of error matrix"",dg));; 6515 } else {; 6516 dg = 0;; 6517 }; 6518// Store VHMAT in P, make sure diagonal pos.; 6519 for (i = 1; i <= fNpar; ++i) {; 6520 ndex = i*(i-1) / 2;; 6521 ndexd = ndex + i;; 6522 fVhmat[ndexd-1] += dg;; 6523 if (fVhmat[ndexd-1]==0) {; 6524 fPSDFs[i-1] = 1 / 1e-19; // a totally arbitrary silly small value; 6525 } else {; 6526 fPSDFs[i-1] = 1 / TMath::Sqrt(fVhmat[ndexd-1]);; 6527 }; 6528 for (j = 1; j <= i; ++j) {; 6529 ++ndex;; 6530 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[ndex-1]*fPSDFs[i-1]*fPSDFs[j-1];; 6531 }; 6532 }; 6533// call eigen (p,p,maxint,npar,pstar,-npar); 6534 mneig(fP, fMaxint, fNpar, fMaxint, fPstar, epspdf, ifault);; 6535 pmin = fPstar[0];; 65",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:215865,Availability,error,errors,215865,"; 6635 ; 6636 do {; 6637 next_seed = inseed = starting_seed;; 6638 ; 6639 // Determine the next seed.; 6640 k = next_seed / 53668;; 6641 next_seed = (next_seed - k*53668)*40014 - k*12211;; 6642 if (next_seed < 0) next_seed += 2147483563;; 6643 ; 6644 val = Double_t(next_seed*4.656613e-10);; 6645 ; 6646 // If more than one thread gets here, one will manage the update; 6647 // of g_iseed the other we go for at least one more round.; 6648 // This is not reproduceable; 6649 } while (! g_iseed.compare_exchange_strong(starting_seed, next_seed) );; 6650 }; 6651}; 6652 ; 6653////////////////////////////////////////////////////////////////////////////////; 6654/// Resets function value and errors to UNDEFINED; 6655///; 6656/// - If IOPT=1,; 6657/// - If IOPT=0, sets only MINOS errors to undefined; 6658/// Called from MNCLER and whenever problem changes, for example; 6659/// after SET LIMITS, SET PARAM, CALL FCN 6; 6660 ; 6661void TMinuit::mnrset(Int_t iopt); 6662{; 6663 Int_t iext, i;; 6664 ; 6665 fCstatu = ""RESET "";; 6666 if (iopt >= 1) {; 6667 fAmin = fUndefi;; 6668 fFval3 = TMath::Abs(fAmin)*2 + 1;; 6669 fEDM = fBigedm;; 6670 fISW[3] = 0;; 6671 fISW[1] = 0;; 6672 fDcovar = 1;; 6673 fISW[0] = 0;; 6674 }; 6675 fLnolim = kTRUE;; 6676 for (i = 1; i <= fNpar; ++i) {; 6677 iext = fNexofi[i-1];; 6678 if (fNvarl[iext-1] >= 4) fLnolim = kFALSE;; 6679 fErp[i-1] = 0;; 6680 fErn[i-1] = 0;; 6681 fGlobcc[i-1] = 0;; 6682 }; 6683 if (fISW[1] >= 1) {; 6684 fISW[1] = 1;; 6685 fDcovar = TMath::Max(fDcovar,.5);; 6686 }; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Writes current parameter values and step sizes onto file ISYSSA; 6691///; 6692/// in format which can be reread by Minuit for restarting.; 6693/// The covariance matrix is also output if it exists.; 6694 ; 6695void TMinuit::mnsave(); 6696{; 6697 Printf(""mnsave is dummy in TMinuit"");; 6698 ; 6699}; 6700 ; 6701///////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:215954,Availability,error,errors,215954,"; 6635 ; 6636 do {; 6637 next_seed = inseed = starting_seed;; 6638 ; 6639 // Determine the next seed.; 6640 k = next_seed / 53668;; 6641 next_seed = (next_seed - k*53668)*40014 - k*12211;; 6642 if (next_seed < 0) next_seed += 2147483563;; 6643 ; 6644 val = Double_t(next_seed*4.656613e-10);; 6645 ; 6646 // If more than one thread gets here, one will manage the update; 6647 // of g_iseed the other we go for at least one more round.; 6648 // This is not reproduceable; 6649 } while (! g_iseed.compare_exchange_strong(starting_seed, next_seed) );; 6650 }; 6651}; 6652 ; 6653////////////////////////////////////////////////////////////////////////////////; 6654/// Resets function value and errors to UNDEFINED; 6655///; 6656/// - If IOPT=1,; 6657/// - If IOPT=0, sets only MINOS errors to undefined; 6658/// Called from MNCLER and whenever problem changes, for example; 6659/// after SET LIMITS, SET PARAM, CALL FCN 6; 6660 ; 6661void TMinuit::mnrset(Int_t iopt); 6662{; 6663 Int_t iext, i;; 6664 ; 6665 fCstatu = ""RESET "";; 6666 if (iopt >= 1) {; 6667 fAmin = fUndefi;; 6668 fFval3 = TMath::Abs(fAmin)*2 + 1;; 6669 fEDM = fBigedm;; 6670 fISW[3] = 0;; 6671 fISW[1] = 0;; 6672 fDcovar = 1;; 6673 fISW[0] = 0;; 6674 }; 6675 fLnolim = kTRUE;; 6676 for (i = 1; i <= fNpar; ++i) {; 6677 iext = fNexofi[i-1];; 6678 if (fNvarl[iext-1] >= 4) fLnolim = kFALSE;; 6679 fErp[i-1] = 0;; 6680 fErn[i-1] = 0;; 6681 fGlobcc[i-1] = 0;; 6682 }; 6683 if (fISW[1] >= 1) {; 6684 fISW[1] = 1;; 6685 fDcovar = TMath::Max(fDcovar,.5);; 6686 }; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Writes current parameter values and step sizes onto file ISYSSA; 6691///; 6692/// in format which can be reread by Minuit for restarting.; 6693/// The covariance matrix is also output if it exists.; 6694 ; 6695void TMinuit::mnsave(); 6696{; 6697 Printf(""mnsave is dummy in TMinuit"");; 6698 ; 6699}; 6700 ; 6701///////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:235594,Availability,error,errors,235594,"= ""REPORTED "";; 7315 Printf(""%s"",(const char*)cwarn);; 7316 if (! fLwarn) mnwarn(""W"", ""SHO"", ""SHO"");; 7317 return;; 7318// show random; 7319L1150:; 7320 val = 0;; 7321 mnrn15(val, igrain);; 7322 ikseed = igrain;; 7323 Printf("" MINUIT RNDM SEED IS CURRENTLY=%d"",ikseed);; 7324 val = 3;; 7325 iseed = ikseed;; 7326 mnrn15(val, iseed);; 7327 return;; 7328// show title; 7329L1160:; 7330 Printf("" TITLE OF CURRENT TASK IS:%s"",(const char*)fCtitl);; 7331 return;; 7332// show strategy; 7333L1170:; 7334 Printf("" ALLOWED STRATEGIES ARE:"");; 7335 Printf("" %s"",cstrat[0].Data());; 7336 Printf("" %s"",cstrat[1].Data());; 7337 Printf("" %s"",cstrat[2].Data());; 7338L1172:; 7339 Printf("" NOW USING STRATEGY %s"",(const char*)cstrat[fIstrat]);; 7340 return;; 7341// show eigenvalues; 7342L1180:; 7343 iswsav = fISW[4];; 7344 fISW[4] = 3;; 7345 if (fISW[1] < 1) {; 7346 Printf(""%s"",(const char*)fCovmes[0]);; 7347 } else {; 7348 mnpsdf();; 7349 }; 7350 fISW[4] = iswsav;; 7351 return;; 7352// show page throw; 7353L1190:; 7354 Printf("" PAGE THROW CARRIAGE CONTROL = %d"",fNewpag);; 7355 if (fNewpag == 0) {; 7356 Printf("" NO PAGE THROWS IN MINUIT OUTPUT"");; 7357 }; 7358 return;; 7359// show minos errors; 7360L1200:; 7361 for (ii = 1; ii <= fNpar; ++ii) {; 7362 if (fErp[ii-1] > 0 || fErn[ii-1] < 0) goto L1204;; 7363 }; 7364 Printf("" THERE ARE NO MINOS ERRORS CURRENTLY VALID."");; 7365 return;; 7366L1204:; 7367 mnprin(4, fAmin);; 7368 return;; 7369// show epsmac; 7370L1210:; 7371 Printf("" FLOATING-POINT NUMBERS ASSUMED ACCURATE TO %g"",fEpsmac);; 7372 return;; 7373// show outputfiles; 7374L1220:; 7375 Printf("" MINUIT PRIMARY OUTPUT TO UNIT %d"",fIsyswr);; 7376 return;; 7377// show version; 7378L1250:; 7379 Printf("" THIS IS MINUIT VERSION:%s"",(const char*)fCvrsn);; 7380 return;; 7381// show nodebug, debug; 7382L1270:; 7383 for (id = 0; id <= 6; ++id) {; 7384 copt = ""OFF"";; 7385 if (fIdbg[id] >= 1) copt = ""ON "";; 7386 Printf("" DEBUG OPTION %3d IS %3s :%s""; 7387 ,id,(const char*)copt,(const char*)cdbopt[id])",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:239526,Availability,failure,failure,239526,"uble_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2 = rho1 + alpha*gamma;; 7458 wg = 1 / Double_t(fNpar);; 7459 if (fISW[4] >= 0) {; 7460 Printf("" START SIMPLEX MINIMIZATION. CONVERGENCE WHEN EDM .LT. %g"",fEpsi);; 7461 }; 7462 for (i = 1; i <= fNpar; ++i) {; 7463 fDirin[i-1] = fWerr[i-1];; 7464 mndxdi(fX[i-1], i-1, dxdi);; 7465 if (dxdi != 0) fDirin[i-1] = fWerr[i-1] / dxdi;; 7466 dmin_ = fEpsma2*TMath::Abs(fX[i-1]);; 7467 if (fDirin[i-1] < dmin_) fDirin[i-1] = dmin_;; 7468 }; 7469// choose the initial simplex using single-parameter searches; 7470L1:; 7471 ynpp1 = fAmin;; 7472 jl = nparp1;; 7473 fSIMPy[nparp1-1] = fAmin;; 7474 absmin = fAmin;; 7475 for (i = 1; i <= fNpar; ++i) {; 7476 aming = fAmin;; 7477 fPbar[i-1] = fX[i-1];; 7478 bestx = fX[i-1];; 7479 kg = 0;; 7480 ns = 0;; 7481 nf = 0;; 7482L4:; 7483 fX[i-1] = bestx + fDirin[i-1];; 7484 mninex(fX);; 7485 Eval(nparx, fGin, f, fU, 4); ++fNfcn;; 7486 if (f <= aming) goto L6;; 7487// failure; 7488 if (kg == 1) goto L8;; 7489 kg = -1;; 7490 ++nf;; 7491 fDirin[i-1] *= -.4;; 7492 if (nf < 3) goto L4;; 7493 ns = 6;; 7494// success; 7495L6:; 7496 bestx = fX[i-1];; 7497 fDirin[i-1] *= 3;; 7498 aming = f;; 7499 fCstatu = ""PROGRESS "";; 7500 kg = 1;; 7501 ++ns;; 7502 if (ns < 6) goto L4;; 7503// local minimum found in ith direction; 7504L8:; 7505 fSIMPy[i-1] = aming;; 7506 if (aming < absmin) jl = i;; 7507 if (aming < absmin) absmin = aming;; 7508 fX[i-1] = bestx;; 7509 for (k = 1; k <= fNpar; ++k) { fP[k + i*fMaxpar - fMaxpar-1] = fX[k-1]; }; 7510 }; 7511 jh = nparp1;; 7512 fAmin = fSIMPy[jl-1];; 7513 mnrazz(ynpp1, fPbar, fSIMPy, jh, jl);; 7514 for",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248225,Availability,failure,failure,248225,"01 /* Local variables */; 7702 Double_t si;; 7703 Int_t i, j, k, kp1, km1;; 7704 ; 7705 /* Parameter adjustments */; 7706 a_offset = l + 1;; 7707 a -= a_offset;; 7708 ; 7709 /* Function Body */; 7710 ifail = 0;; 7711 if (n < 1) goto L100;; 7712 if (n > fMaxint) goto L100;; 7713// scale matrix by sqrt of diag elements; 7714 for (i = 1; i <= n; ++i) {; 7715 si = a[i + i*l];; 7716 if (si <= 0) goto L100;; 7717 fVERTs[i-1] = 1 / TMath::Sqrt(si);; 7718 }; 7719 for (i = 1; i <= n; ++i) {; 7720 for (j = 1; j <= n; ++j) {; 7721 a[i + j*l] = a[i + j*l]*fVERTs[i-1]*fVERTs[j-1];; 7722 }; 7723 }; 7724// start main loop; 7725 for (i = 1; i <= n; ++i) {; 7726 k = i;; 7727// preparation for elimination step1; 7728 if (a[k + k*l] != 0) fVERTq[k-1] = 1 / a[k + k*l];; 7729 else goto L100;; 7730 fVERTpp[k-1] = 1;; 7731 a[k + k*l] = 0;; 7732 kp1 = k + 1;; 7733 km1 = k - 1;; 7734 if (km1 < 0) goto L100;; 7735 else if (km1 == 0) goto L50;; 7736 else goto L40;; 7737L40:; 7738 for (j = 1; j <= km1; ++j) {; 7739 fVERTpp[j-1] = a[j + k*l];; 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:251048,Availability,error,errors,251048,"21 return;; 7822 }; 7823 ; 7824// 'SHO WARnings', ask if any suppressed mess in buffer; 7825 if (copt == ""W"") {; 7826 ityp = 1;; 7827 ctyp = ""WARNING"";; 7828 } else {; 7829 ityp = 2;; 7830 ctyp = ""*DEBUG*"";; 7831 }; 7832 if (fNwrmes[ityp-1] > 0) {; 7833 englsh = "" WAS SUPPRESSED. "";; 7834 if (fNwrmes[ityp-1] > 1) englsh = ""S WERE SUPPRESSED."";; 7835 Printf("" %5d MINUIT %s MESSAGE%s"",fNwrmes[ityp-1]; 7836 ,(const char*)ctyp,(const char*)englsh);; 7837 nm = fNwrmes[ityp-1];; 7838 ic = 0;; 7839 if (nm > kMAXMES) {; 7840 Printf("" ONLY THE MOST RECENT 10 WILL BE LISTED BELOW."");; 7841 nm = kMAXMES;; 7842 ic = fIcirc[ityp-1];; 7843 }; 7844 Printf("" CALLS ORIGIN MESSAGE"");; 7845 for (i = 1; i <= nm; ++i) {; 7846 ++ic;; 7847 if (ic > kMAXMES) ic = 1;; 7848 Printf("" %6d %s %s"", fNfcwar[ic],fOrigin[ic].Data(),fWarmes[ic].Data());; 7849 }; 7850 fNwrmes[ityp-1] = 0;; 7851 Printf("" "");; 7852 }; 7853}; 7854 ; 7855////////////////////////////////////////////////////////////////////////////////; 7856/// Calculates the WERR, external parameter errors; 7857///; 7858/// and the global correlation coefficients, to be called; 7859/// whenever a new covariance matrix is available.; 7860 ; 7861void TMinuit::mnwerr(); 7862{; 7863 Double_t denom, ba, al, dx, du1, du2;; 7864 Int_t ndex, ierr, i, j, k, l, ndiag, k1, iin;; 7865 ; 7866// calculate external error if v exists; 7867 if (fISW[1] >= 1) {; 7868 for (l = 1; l <= fNpar; ++l) {; 7869 ndex = l*(l + 1) / 2;; 7870 dx = TMath::Sqrt(TMath::Abs(fVhmat[ndex-1]*fUp));; 7871 i = fNexofi[l-1];; 7872 if (fNvarl[i-1] > 1) {; 7873 al = fAlim[i-1];; 7874 ba = fBlim[i-1] - al;; 7875 du1 = al + 0.5*(TMath::Sin(fX[l-1] + dx) + 1)*ba - fU[i-1];; 7876 du2 = al + 0.5*(TMath::Sin(fX[l-1] - dx) + 1)*ba - fU[i-1];; 7877 if (dx > 1) du1 = ba;; 7878 dx = 0.5*(TMath::Abs(du1) + TMath::Abs(du2));; 7879 }; 7880 fWerr[l-1] = dx;; 7881 }; 7882 }; 7883// global correlation coefficients; 7884 if (fISW[1] >= 1) {; 7885 for (i = 1; i <= fNpar; ++i) {; 7886 fGlobcc[i-1] ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:251172,Availability,avail,available,251172,"21 return;; 7822 }; 7823 ; 7824// 'SHO WARnings', ask if any suppressed mess in buffer; 7825 if (copt == ""W"") {; 7826 ityp = 1;; 7827 ctyp = ""WARNING"";; 7828 } else {; 7829 ityp = 2;; 7830 ctyp = ""*DEBUG*"";; 7831 }; 7832 if (fNwrmes[ityp-1] > 0) {; 7833 englsh = "" WAS SUPPRESSED. "";; 7834 if (fNwrmes[ityp-1] > 1) englsh = ""S WERE SUPPRESSED."";; 7835 Printf("" %5d MINUIT %s MESSAGE%s"",fNwrmes[ityp-1]; 7836 ,(const char*)ctyp,(const char*)englsh);; 7837 nm = fNwrmes[ityp-1];; 7838 ic = 0;; 7839 if (nm > kMAXMES) {; 7840 Printf("" ONLY THE MOST RECENT 10 WILL BE LISTED BELOW."");; 7841 nm = kMAXMES;; 7842 ic = fIcirc[ityp-1];; 7843 }; 7844 Printf("" CALLS ORIGIN MESSAGE"");; 7845 for (i = 1; i <= nm; ++i) {; 7846 ++ic;; 7847 if (ic > kMAXMES) ic = 1;; 7848 Printf("" %6d %s %s"", fNfcwar[ic],fOrigin[ic].Data(),fWarmes[ic].Data());; 7849 }; 7850 fNwrmes[ityp-1] = 0;; 7851 Printf("" "");; 7852 }; 7853}; 7854 ; 7855////////////////////////////////////////////////////////////////////////////////; 7856/// Calculates the WERR, external parameter errors; 7857///; 7858/// and the global correlation coefficients, to be called; 7859/// whenever a new covariance matrix is available.; 7860 ; 7861void TMinuit::mnwerr(); 7862{; 7863 Double_t denom, ba, al, dx, du1, du2;; 7864 Int_t ndex, ierr, i, j, k, l, ndiag, k1, iin;; 7865 ; 7866// calculate external error if v exists; 7867 if (fISW[1] >= 1) {; 7868 for (l = 1; l <= fNpar; ++l) {; 7869 ndex = l*(l + 1) / 2;; 7870 dx = TMath::Sqrt(TMath::Abs(fVhmat[ndex-1]*fUp));; 7871 i = fNexofi[l-1];; 7872 if (fNvarl[i-1] > 1) {; 7873 al = fAlim[i-1];; 7874 ba = fBlim[i-1] - al;; 7875 du1 = al + 0.5*(TMath::Sin(fX[l-1] + dx) + 1)*ba - fU[i-1];; 7876 du2 = al + 0.5*(TMath::Sin(fX[l-1] - dx) + 1)*ba - fU[i-1];; 7877 if (dx > 1) du1 = ba;; 7878 dx = 0.5*(TMath::Abs(du1) + TMath::Abs(du2));; 7879 }; 7880 fWerr[l-1] = dx;; 7881 }; 7882 }; 7883// global correlation coefficients; 7884 if (fISW[1] >= 1) {; 7885 for (i = 1; i <= fNpar; ++i) {; 7886 fGlobcc[i-1] ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:251355,Availability,error,error,251355," ,(const char*)ctyp,(const char*)englsh);; 7837 nm = fNwrmes[ityp-1];; 7838 ic = 0;; 7839 if (nm > kMAXMES) {; 7840 Printf("" ONLY THE MOST RECENT 10 WILL BE LISTED BELOW."");; 7841 nm = kMAXMES;; 7842 ic = fIcirc[ityp-1];; 7843 }; 7844 Printf("" CALLS ORIGIN MESSAGE"");; 7845 for (i = 1; i <= nm; ++i) {; 7846 ++ic;; 7847 if (ic > kMAXMES) ic = 1;; 7848 Printf("" %6d %s %s"", fNfcwar[ic],fOrigin[ic].Data(),fWarmes[ic].Data());; 7849 }; 7850 fNwrmes[ityp-1] = 0;; 7851 Printf("" "");; 7852 }; 7853}; 7854 ; 7855////////////////////////////////////////////////////////////////////////////////; 7856/// Calculates the WERR, external parameter errors; 7857///; 7858/// and the global correlation coefficients, to be called; 7859/// whenever a new covariance matrix is available.; 7860 ; 7861void TMinuit::mnwerr(); 7862{; 7863 Double_t denom, ba, al, dx, du1, du2;; 7864 Int_t ndex, ierr, i, j, k, l, ndiag, k1, iin;; 7865 ; 7866// calculate external error if v exists; 7867 if (fISW[1] >= 1) {; 7868 for (l = 1; l <= fNpar; ++l) {; 7869 ndex = l*(l + 1) / 2;; 7870 dx = TMath::Sqrt(TMath::Abs(fVhmat[ndex-1]*fUp));; 7871 i = fNexofi[l-1];; 7872 if (fNvarl[i-1] > 1) {; 7873 al = fAlim[i-1];; 7874 ba = fBlim[i-1] - al;; 7875 du1 = al + 0.5*(TMath::Sin(fX[l-1] + dx) + 1)*ba - fU[i-1];; 7876 du2 = al + 0.5*(TMath::Sin(fX[l-1] - dx) + 1)*ba - fU[i-1];; 7877 if (dx > 1) du1 = ba;; 7878 dx = 0.5*(TMath::Abs(du1) + TMath::Abs(du2));; 7879 }; 7880 fWerr[l-1] = dx;; 7881 }; 7882 }; 7883// global correlation coefficients; 7884 if (fISW[1] >= 1) {; 7885 for (i = 1; i <= fNpar; ++i) {; 7886 fGlobcc[i-1] = 0;; 7887 k1 = i*(i-1) / 2;; 7888 for (j = 1; j <= i; ++j) {; 7889 k = k1 + j;; 7890 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[k-1];; 7891 fP[j + i*fMaxpar - fMaxpar-1] = fP[i + j*fMaxpar - fMaxpar-1];; 7892 }; 7893 }; 7894 mnvert(fP, fMaxint, fMaxint, fNpar, ierr);; 7895 if (ierr == 0) {; 7896 for (iin = 1; iin <= fNpar; ++iin) {; 7897 ndiag = iin*(iin + 1) / 2;; 7898 denom = fP[iin + iin*fMaxpar - fMaxpar",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:257209,Availability,error,errorDefinition,257209,"uginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; snprintf#define snprintfDefinition civetweb.c:1540; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:259191,Availability,error,errors,259191,"it.cxx:855; TMinuit::fUDouble_t * fUDefinition TMinuit.h:68; TMinuit::mnpfitvirtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDef",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:259354,Availability,error,errors,259354," &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2c",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:260533,Availability,error,error,260533,"Minuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::fPDouble_t * fPDefinition TMinuit.h:91; TMinuit::fNblockInt_t fNblockDefinition TMinuit.h:143; TMinuit::fCvrsnTString fCvrsnDefinition TMinuit.h:171; TMinuit::fGlobccDouble_t * fGlobccDefinition TMinuit.h:74; TMinuit::mnclervirtual void mncler()Resets the parameter list to UNDEFINED.Definition TMinuit.cxx:1103; TMinuit::mnplotvirtual void mnplot(Double_t *xpt, Double_t *ypt, char *chpt, Int_t nxypt, Int_t npagwd, Int_t npagln)Plots points in array xypt onto one page with labelled axes.Definition TMinuit.cxx:6068; TMinuit::Migradvirtual Int_t Migrad()invokes the MIGRAD minimizerDefinition TMinuit.cxx:880; TMinuit::fUpDouble_t fUpDefinition TMinuit.h:50; TMinuit::fGRADgfDouble_t * fGRADgfDefinition TMinuit.h:103; TMinuit::fDirinsDouble_t * fDirinsDefinition TMinuit.h:80; TMinuit::mncomdvirtual void mncomd(const char *crdbin, Int_t &icon",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:263027,Availability,error,error,263027,"cxx:3362; TMinuit::fXmidcrDouble_t fXmidcrDefinition TMinuit.h:63; TMinuit::fMIGRxxsDouble_t * fMIGRxxsDefinition TMinuit.h:112; TMinuit::fNpagwdInt_t fNpagwdDefinition TMinuit.h:134; TMinuit::fPARSplistDouble_t * fPARSplistDefinition TMinuit.h:124; TMinuit::fApsiDouble_t fApsiDefinition TMinuit.h:54; TMinuit::fBigedmDouble_t fBigedmDefinition TMinuit.h:61; TMinuit::~TMinuit~TMinuit() overrideMinuit default destructor.Definition TMinuit.cxx:497; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinu",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:263238,Availability,toler,toler,263238,"listDouble_t * fPARSplistDefinition TMinuit.h:124; TMinuit::fApsiDouble_t fApsiDefinition TMinuit.h:54; TMinuit::fBigedmDouble_t fBigedmDefinition TMinuit.h:61; TMinuit::~TMinuit~TMinuit() overrideMinuit default destructor.Definition TMinuit.cxx:497; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinuit.h:108; TMinuit::fNfcnlcInt_t fNfcnlcDefinition TMinuit.h:147; TMinuit::fISWInt_t fISW[7]Definition TMinuit.h:141; TMinuit::fHESSyyDouble_t * fHESSyyDefinition TMinuit.h:104; TMinuit::fGraphicsMode",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:268750,Availability,error,error,268750,"ar5Definition TMinuit.h:44; TMinuit::fCOMDplistDouble_t * fCOMDplistDefinition TMinuit.h:123; TMinuit::fLnolimBool_t fLnolimDefinition TMinuit.h:160; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Doubl",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:269104,Availability,error,errors,269104,"nition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::Set",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:272291,Availability,error,error,272291," * fGrdDefinition TMinuit.h:81; TMinuit::mntinyvirtual void mntiny(Double_t epsp1, Double_t &epsbak)To find the machine precision.Definition TMinuit.cxx:7661; TMinuit::mninexvirtual void mninex(Double_t *pint)Transforms from internal coordinates (PINT) to external (U)Definition TMinuit.cxx:4506; TMinuit::fCtitlTString fCtitlDefinition TMinuit.h:168; TMinuit::mnpintvirtual void mnpint(Double_t &pexti, Int_t i, Double_t &pinti)Calculates the internal parameter value PINTI.Definition TMinuit.cxx:6017; TMinuit::fCONTwDouble_t * fCONTwDefinition TMinuit.h:101; TMinuit::fNfcwarInt_t fNfcwar[20]Definition TMinuit.h:152; TMinuit::fMIGRvgDouble_t * fMIGRvgDefinition TMinuit.h:111; TMinuit::mnfixpvirtual void mnfixp(Int_t iint, Int_t &ierr)Removes parameter IINT from the internal parameter list.Definition TMinuit.cxx:3169; TMinuit::fIsyswrInt_t fIsyswrDefinition TMinuit.h:132; TMinuit::fG2Double_t * fG2Definition TMinuit.h:82; TMinuit::mnmnotvirtual void mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi)Performs a MINOS error analysis on one parameter.Definition TMinuit.cxx:5463; TMinuit::fNpaglnInt_t fNpaglnDefinition TMinuit.h:135; TMinuit::fMNOTxdevDouble_t * fMNOTxdevDefinition TMinuit.h:113; TMinuit::mncrckvirtual void mncrck(TString crdbuf, Int_t maxcwd, TString &comand, Int_t &lnc, Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t isyswr)Cracks the free-format input.Definition TMinuit.cxx:1677; TMinuit::fMNOTgccDouble_t * fMNOTgccDefinition TMinuit.h:115; TMinuit::DefineParametervirtual Int_t DefineParameter(Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit)Define a parameter.Definition TMinuit.cxx:695; TMinuit::fMaxpar2Int_t fMaxpar2Definition TMinuit.h:46; TMinuit::fFval3Double_t fFval3Definition TMinuit.h:52; TMinuit::fVhmatDouble_t * fVhmatDefinition TMinuit.h:89; TMinuit::fNstkrdInt_t fNstkrdDefinition TMinuit.h:138; TMinuit::mnstatvirtual void mnstat(Double_t &fmin, Double_t &fe",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:275888,Availability,error,error,275888,"npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Co",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:276085,Availability,error,error,276085,"uble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:32917,Deployability,release,release,32917,"ly fixed parameters; 854 ; 855Int_t TMinuit::GetNumFixedPars() const; 856{; 857 return fNpfix;; 858}; 859 ; 860////////////////////////////////////////////////////////////////////////////////; 861/// returns the number of currently free parameters; 862 ; 863Int_t TMinuit::GetNumFreePars() const; 864{; 865 return fNpar;; 866}; 867 ; 868////////////////////////////////////////////////////////////////////////////////; 869/// returns the total number of parameters that have been defined; 870/// as fixed or free. The constant parameters are not counted.; 871 ; 872Int_t TMinuit::GetNumPars() const; 873{; 874 return fNpar + fNpfix;; 875}; 876 ; 877////////////////////////////////////////////////////////////////////////////////; 878/// invokes the MIGRAD minimizer; 879 ; 880Int_t TMinuit::Migrad(); 881{; 882 Int_t err;; 883 Double_t tmp[1];; 884 tmp[0] = 0;; 885 ; 886 mnexcm( ""MIGRAD"", tmp, 0, err );; 887 ; 888 return err;; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// release a parameter; 893 ; 894Int_t TMinuit::Release( Int_t parNo); 895{; 896 Int_t err;; 897 Double_t tmp[1];; 898 tmp[0] = parNo+1; //set internal Minuit numbering; 899 ; 900 mnexcm( ""RELEASE"", tmp, 1, err );; 901 ; 902 return err;; 903}; 904 ; 905////////////////////////////////////////////////////////////////////////////////; 906/// To get the n-sigma contour the error def parameter ""up"" has to set to n^2.; 907 ; 908Int_t TMinuit::SetErrorDef( Double_t up ); 909{; 910 Int_t err;; 911 ; 912 mnexcm( ""SET ERRDEF"", &up, 1, err );; 913 ; 914 return err;; 915}; 916 ; 917////////////////////////////////////////////////////////////////////////////////; 918/// To set the address of the minimization function; 919 ; 920void TMinuit::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 921{; 922 fFCN = fcn;; 923}; 924 ; 925////////////////////////////////////////////////////////////////////////////////; 926/// Static function called when Se",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:92843,Deployability,release,release,92843,"2852 ierflg = 4;; 2853 if (fISW[0] == 1) return;; 2854 if (fCword(0,3) == ""MIG"") return;; 2855 ; 2856 fNfcnmx = fNfcnmx + nf - fNfcn;; 2857 nf = fNfcn;; 2858 mnsimp();; 2859 if (fISW[0] == 1) return;; 2860 fNfcnmx = fNfcnmx + nf - fNfcn;; 2861 mnmigr();; 2862 if (fISW[3] >= 1) ierflg = 0;; 2863 mnwerr();; 2864 return;; 2865// minos; 2866L500:; 2867 nsuper = fNfcn + ((fNpar + 1) << 1)*fNfcnmx;; 2868// possible loop over new minima; 2869 fEpsi = fUp*.1;; 2870L510:; 2871 fCfrom = cname[i-1]; // ensure that mncuve complains about MINOS not MIGRAD; 2872 mncuve();; 2873 mnmnos();; 2874 if (! fLnewmn) return;; 2875 mnrset(0);; 2876 mnmigr();; 2877 mnwerr();; 2878 if (fNfcn < nsuper) goto L510;; 2879 Printf("" TOO MANY FUNCTION CALLS. MINOS GIVES UP"");; 2880 ierflg = 4;; 2881 return;; 2882// set, show; 2883L700:; 2884 mnset();; 2885 return;; 2886// top of page; 2887 ; 2888L800:; 2889 Printf(""1"");; 2890 return;; 2891// fix; 2892L900:; 2893 ltofix = kTRUE;; 2894// (also release); 2895L901:; 2896 lfreed = kFALSE;; 2897 lfixed = kFALSE;; 2898 if (llist == 0) {; 2899 Printf(""%s: NO PARAMETERS REQUESTED "",(const char*)fCword);; 2900 return;; 2901 }; 2902 for (ilist = 1; ilist <= llist; ++ilist) {; 2903 iext = Int_t(plist[ilist-1]);; 2904 chwhy = "" IS UNDEFINED."";; 2905 if (iext <= 0) goto L930;; 2906 if (iext > fNu) goto L930;; 2907 if (fNvarl[iext-1] < 0) goto L930;; 2908 chwhy = "" IS CONSTANT. "";; 2909 if (fNvarl[iext-1] == 0) goto L930;; 2910 iint = fNiofex[iext-1];; 2911 if (ltofix) {; 2912 chwhy = "" ALREADY FIXED."";; 2913 if (iint == 0) goto L930;; 2914 mnfixp(iint-1, ierr);; 2915 if (ierr == 0) lfixed = kTRUE;; 2916 else ierflg = 4;; 2917 } else {; 2918 chwhy = "" ALREADY VARIABLE."";; 2919 if (iint > 0) goto L930;; 2920 krl = -abs(iext);; 2921 mnfree(krl);; 2922 lfreed = kTRUE;; 2923 }; 2924 continue;; 2925L930:; 2926 if (fISW[4] >= 0) Printf("" PARAMETER %4d %s IGNORED."",iext,(const char*)chwhy);; 2927 }; 2928 if (lfreed || lfixed) mnrset(0);; 2929 if (lfreed) {; 2930 fISW[1] ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:94378,Deployability,release,release,94378,"= 4;; 2917 } else {; 2918 chwhy = "" ALREADY VARIABLE."";; 2919 if (iint > 0) goto L930;; 2920 krl = -abs(iext);; 2921 mnfree(krl);; 2922 lfreed = kTRUE;; 2923 }; 2924 continue;; 2925L930:; 2926 if (fISW[4] >= 0) Printf("" PARAMETER %4d %s IGNORED."",iext,(const char*)chwhy);; 2927 }; 2928 if (lfreed || lfixed) mnrset(0);; 2929 if (lfreed) {; 2930 fISW[1] = 0;; 2931 fDcovar = 1;; 2932 fEDM = fBigedm;; 2933 fISW[3] = 0;; 2934 }; 2935 mnwerr();; 2936 if (fISW[4] > 1) mnprin(5, fAmin);; 2937 return;; 2938// restore; 2939L1000:; 2940 it = Int_t(fWord7[0]);; 2941 if (it > 1 || it < 0) goto L1005;; 2942 lfreed = fNpfix > 0;; 2943 mnfree(it);; 2944 if (lfreed) {; 2945 mnrset(0);; 2946 fISW[1] = 0;; 2947 fDcovar = 1;; 2948 fEDM = fBigedm;; 2949 }; 2950 return;; 2951L1005:; 2952 Printf("" IGNORED. UNKNOWN ARGUMENT:%4d"",it);; 2953 ierflg = 3;; 2954 return;; 2955// release; 2956L1100:; 2957 ltofix = kFALSE;; 2958 goto L901;; 2959// scan; 2960L1200:; 2961 iext = Int_t(fWord7[0]);; 2962 if (iext <= 0) goto L1210;; 2963 it2 = 0;; 2964 if (iext <= fNu) it2 = fNiofex[iext-1];; 2965 if (it2 <= 0) goto L1250;; 2966 ; 2967L1210:; 2968 mnscan();; 2969 return;; 2970L1250:; 2971 Printf("" PARAMETER %4d NOT VARIABLE."",iext);; 2972 ierflg = 3;; 2973 return;; 2974// contour; 2975L1300:; 2976 ke1 = Int_t(fWord7[0]);; 2977 ke2 = Int_t(fWord7[1]);; 2978 if (ke1 == 0) {; 2979 if (fNpar == 2) {; 2980 ke1 = fNexofi[0];; 2981 ke2 = fNexofi[1];; 2982 } else {; 2983 Printf(""%s: NO PARAMETERS REQUESTED "",(const char*)fCword);; 2984 ierflg = 3;; 2985 return;; 2986 }; 2987 }; 2988 fNfcnmx = 1000;; 2989 mncntr(ke1-1, ke2-1, ierrf);; 2990 if (ierrf > 0) ierflg = 3;; 2991 return;; 2992// hesse; 2993L1400:; 2994 mnhess();; 2995 mnwerr();; 2996 if (fISW[4] >= 0) mnprin(2, fAmin);; 2997 if (fISW[4] >= 1) mnmatu(1);; 2998 return;; 2999// save; 3000L1500:; 3001 mnsave();; 3002 return;; 3003// improve; 3004L1600:; 3005 mncuve();; 3006 mnimpr();; 3007 if (fLnewmn) goto L400;; 3008 ierflg = 4;; 3009 return;; 3010// call",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:102782,Deployability,release,release,102782,"riable status; 3244///; 3245/// Restores one or more fixed parameter(s) to variable status; 3246/// by inserting it into the internal parameter list at the; 3247/// appropriate place.; 3248///; 3249/// - K = 0 means restore all parameters; 3250/// - K = 1 means restore the last parameter fixed; 3251/// - K = -I means restore external parameter I (if possible); 3252/// - IQ = fix-location where internal parameters were stored; 3253/// - IR = external number of parameter being restored; 3254/// - IS = internal number of parameter being restored; 3255 ; 3256void TMinuit::mnfree(Int_t k); 3257{; 3258 /* Local variables */; 3259 Double_t grdv, xv, dirinv, g2v, gstepv, xtv;; 3260 Int_t i, ipsav, ka, lc, ik, iq, ir, is;; 3261 ; 3262 if (k > 1) {; 3263 Printf("" CALL TO MNFREE IGNORED. ARGUMENT GREATER THAN ONE"");; 3264 }; 3265 if (fNpfix < 1) {; 3266 Printf("" CALL TO MNFREE IGNORED. THERE ARE NO FIXED PARAMETERS"");; 3267 }; 3268 if (k == 1 || k == 0) goto L40;; 3269 ; 3270// release parameter with specified external number; 3271 ka = abs(k);; 3272 if (fNiofex[ka-1] == 0) goto L15;; 3273 Printf("" IGNORED. PARAMETER SPECIFIED IS ALREADY VARIABLE."");; 3274 return;; 3275L15:; 3276 if (fNpfix < 1) goto L21;; 3277 for (ik = 1; ik <= fNpfix; ++ik) { if (fIpfix[ik-1] == ka) goto L24; }; 3278L21:; 3279 Printf("" PARAMETER %4d NOT FIXED. CANNOT BE RELEASED."",ka);; 3280 return;; 3281L24:; 3282 if (ik == fNpfix) goto L40;; 3283 ; 3284// move specified parameter to end of list; 3285 ipsav = ka;; 3286 xv = fXs[ik-1];; 3287 xtv = fXts[ik-1];; 3288 dirinv = fDirins[ik-1];; 3289 grdv = fGrds[ik-1];; 3290 g2v = fG2s[ik-1];; 3291 gstepv = fGsteps[ik-1];; 3292 for (i = ik + 1; i <= fNpfix; ++i) {; 3293 fIpfix[i-2] = fIpfix[i-1];; 3294 fXs[i-2] = fXs[i-1];; 3295 fXts[i-2] = fXts[i-1];; 3296 fDirins[i-2] = fDirins[i-1];; 3297 fGrds[i-2] = fGrds[i-1];; 3298 fG2s[i-2] = fG2s[i-1];; 3299 fGsteps[i-2] = fGsteps[i-1];; 3300 }; 3301 fIpfix[fNpfix-1] = ipsav;; 3302 fXs[fNpfix-1] = xv;; 3303 fXts[fNpfix-",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:172710,Deployability,update,update,172710,"(i = 1; i <= fNpar; ++i) {; 5224 ri = 0;; 5225 vgi = 0;; 5226 for (j = 1; j <= fNpar; ++j) {; 5227 m = TMath::Max(i,j);; 5228 n = TMath::Min(i,j);; 5229 ndex = m*(m-1) / 2 + n;; 5230 vgi += fVhmat[ndex-1]*(fGrd[j-1] - fMIGRgs[j-1]);; 5231 ri += fVhmat[ndex-1]*fGrd[j-1];; 5232 }; 5233 fMIGRvg[i-1] = vgi*.5;; 5234 gami = fGrd[i-1] - fMIGRgs[i-1];; 5235 gdgssq += gami*gami;; 5236 gvg += gami*fMIGRvg[i-1];; 5237 delgam += fDirin[i-1]*gami;; 5238 fEDM += fGrd[i-1]*ri*.5;; 5239 }; 5240 fEDM = fEDM*.5*(fDcovar*3 + 1);; 5241// if EDM negative, not positive-definite; 5242 if (fEDM < 0 || gvg <= 0) {; 5243 mnwarn(""D"", ""MIGRAD"", ""NOT POS-DEF. EDM OR GVG NEGATIVE."");; 5244 fCstatu = ""NOT POSDEF"";; 5245 if (npsdf == 1) goto L230;; 5246 mnpsdf();; 5247 npsdf = 1;; 5248 goto L81;; 5249 }; 5250// print information about this iteration; 5251 ++iter;; 5252 if (iswtr >= 3 || (iswtr == 2 && iter % 10 == 1)) {; 5253 mnwerr();; 5254 mnprin(3, fAmin);; 5255 }; 5256 if (gdgssq == 0) {; 5257 mnwarn(""D"", ""MIGRAD"", ""NO CHANGE IN FIRST DERIVATIVES OVER LAST STEP"");; 5258 }; 5259 if (delgam < 0) {; 5260 mnwarn(""D"", ""MIGRAD"", ""FIRST DERIVATIVES INCREASING ALONG SEARCH LINE"");; 5261 }; 5262// update covariance matrix; 5263 fCstatu = ""IMPROVEMENT"";; 5264 if (ldebug) {; 5265 Printf("" VHMAT 1 ="");; 5266 for (kk = 1; kk <= 10; ++kk) {; 5267 Printf("" %10.2g"",fVhmat[kk-1]);; 5268 }; 5269 }; 5270 dsum = 0;; 5271 vsum = 0;; 5272 for (i = 1; i <= fNpar; ++i) {; 5273 for (j = 1; j <= i; ++j) {; 5274 if(delgam == 0 || gvg == 0) d = 0;; 5275 else d = fDirin[i-1]*fDirin[j-1] / delgam - fMIGRvg[i-1]*fMIGRvg[j-1] / gvg;; 5276 dsum += TMath::Abs(d);; 5277 ndex = i*(i-1) / 2 + j;; 5278 fVhmat[ndex-1] += d*2;; 5279 vsum += TMath::Abs(fVhmat[ndex-1]);; 5280 }; 5281 }; 5282// smooth local fluctuations by averaging DCOVAR; 5283 fDcovar = (fDcovar + dsum / vsum)*.5;; 5284 if (iswtr >= 3 || ldebug) {; 5285 Printf("" RELATIVE CHANGE IN COV. MATRIX=%5.1f per cent"",fDcovar*100);; 5286 }; 5287 if (ldebug) {; 5288 Printf("" VH",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:177154,Deployability,update,update,177154,"od, nfcnmi, iin, knt;; 5393 ; 5394 if (fNpar <= 0) goto L700;; 5395 ngood = 0;; 5396 nbad = 0;; 5397 nfcnmi = fNfcn;; 5398// loop over parameters requested; 5399 for (knt = 1; knt <= fNpar; ++knt) {; 5400 if (Int_t(fWord7[1]) == 0) {; 5401 ilax = fNexofi[knt-1];; 5402 } else {; 5403 if (knt >= 7) break;; 5404 ilax = Int_t(fWord7[knt]);; 5405 if (ilax == 0) break;; 5406 if (ilax > 0 && ilax <= fNu) {; 5407 if (fNiofex[ilax-1] > 0) goto L565;; 5408 }; 5409 Printf("" PARAMETER NUMBER %3d NOT A VARIABLE. IGNORED."",ilax);; 5410 continue;; 5411 }; 5412L565:; 5413// calculate one pair of M E s; 5414 ilax2 = 0;; 5415 mnmnot(ilax, ilax2, val2pl, val2mi);; 5416 if (fLnewmn) goto L650;; 5417// update NGOOD and NBAD; 5418 iin = fNiofex[ilax-1];; 5419 if (fErp[iin-1] > 0) ++ngood;; 5420 else ++nbad;; 5421 if (fErn[iin-1] < 0) ++ngood;; 5422 else ++nbad;; 5423 }; 5424// end of loop; 5425// printout final values; 5426 fCfrom = ""MINOS "";; 5427 fNfcnfr = nfcnmi;; 5428 fCstatu = ""UNCHANGED "";; 5429 if (ngood == 0 && nbad == 0) goto L700;; 5430 if (ngood > 0 && nbad == 0) fCstatu = ""SUCCESSFUL"";; 5431 if (ngood == 0 && nbad > 0) fCstatu = ""FAILURE "";; 5432 if (ngood > 0 && nbad > 0) fCstatu = ""PROBLEMS "";; 5433 if (fISW[4] >= 0) mnprin(4, fAmin);; 5434 if (fISW[4] >= 2) mnmatu(0);; 5435 return;; 5436// new minimum found; 5437L650:; 5438 fCfrom = ""MINOS "";; 5439 fNfcnfr = nfcnmi;; 5440 fCstatu = ""NEW MINIMU"";; 5441 if (fISW[4] >= 0) mnprin(4, fAmin);; 5442 Printf("" NEW MINIMUM FOUND. GO BACK TO MINIMIZATION STEP."");; 5443 Printf("" ================================================="");; 5444 Printf("" V"");; 5445 Printf("" V"");; 5446 Printf("" V"");; 5447 Printf("" VVVVVVV"");; 5448 Printf("" VVVVV"");; 5449 Printf("" VVV"");; 5450 Printf("" V\n"");; 5451 return;; 5452L700:; 5453 Printf("" THERE ARE NO MINOS ERRORS TO CALCULATE."");; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Performs a MINOS error analysis on one parameter; 5458///; 5459//",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:184643,Deployability,update,updates,184643," {; 5603 Printf("" **************************************************************************"");; 5604 }; 5605 if (sig < 0) {; 5606 fErn[it-1] = eros;; 5607 if (ilax2 > 0 && ilax2 <= fNu) val2mi = fU[ilax2-1];; 5608 } else {; 5609 fErp[it-1] = eros;; 5610 if (ilax2 > 0 && ilax2 <= fNu) val2pl = fU[ilax2-1];; 5611 }; 5612 }; 5613// parameter finished. reset v; 5614// normal termination */; 5615 fItaur = 1;; 5616 mnfree(1);; 5617 i__1 = mpar*(mpar + 1) / 2;; 5618 for (j = 1; j <= i__1; ++j) { fVhmat[j-1] = fVthmat[j-1]; }; 5619 for (i = 1; i <= mpar; ++i) {; 5620 fWerr[i-1] = fMNOTw[i-1];; 5621 fGlobcc[i-1] = fMNOTgcc[i-1];; 5622 fX[i-1] = fXt[i-1];; 5623 }; 5624 mninex(fX);; 5625 fEDM = sigsav;; 5626 fAmin = abest;; 5627 fISW[1] = isw2;; 5628 fISW[3] = isw4;; 5629 fDcovar = dc;; 5630 goto L700;; 5631// new minimum; 5632L650:; 5633 fLnewmn = kTRUE;; 5634 fISW[1] = 0;; 5635 fDcovar = 1;; 5636 fISW[3] = 0;; 5637 sav = fU[ilax-1];; 5638 fItaur = 1;; 5639 mnfree(1);; 5640 fU[ilax-1] = sav;; 5641 mnexin(fX);; 5642 fEDM = fBigedm;; 5643// in any case; 5644L700:; 5645 fItaur = 0;; 5646 fNfcnmx = nfmxin;; 5647 fIstrat = istrav;; 5648}; 5649 ; 5650////////////////////////////////////////////////////////////////////////////////; 5651/// Implements one parameter definition; 5652///; 5653/// Called from MNPARS and user-callable; 5654/// Implements one parameter definition, that is:; 5655/// - K (external) parameter number; 5656/// - CNAMK parameter name; 5657/// - UK starting value; 5658/// - WK starting step size or uncertainty; 5659/// - A, B lower and upper physical parameter limits; 5660/// and sets up (updates) the parameter lists.; 5661/// Output:; 5662/// - IERFLG=0 if no problems; 5663/// - >0 if MNPARM unable to implement definition; 5664 ; 5665void TMinuit::mnparm(Int_t k1, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg); 5666{; 5667 /* Local variables */; 5668 Double_t vplu, a_small, gsmin, pinti, vminu, danger, sav, sav2;; 5669 Int_t ier",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:215537,Deployability,update,update,215537,"6615/// Note especially that VAL must not be undefined on input.; 6616///; 6617/// Set Default Starting Seed; 6618 ; 6619void TMinuit::mnrn15(Double_t &val, Int_t &inseed); 6620{; 6621 /* Initialized data */; 6622 ; 6623 static std::atomic<Int_t> g_iseed( 12345 );; 6624 ; 6625 Int_t k;; 6626 ; 6627 if (val == 3) {; 6628 // ""entry"" to set seed, flag is VAL=3; 6629 g_iseed.store(inseed, std::memory_order_release);; 6630 } else {; 6631 // Grab the local value. Two threads might comes here at the same; 6632 // time and will end up with the same results.; 6633 int starting_seed = g_iseed.load( std::memory_order_acquire );; 6634 int next_seed;; 6635 ; 6636 do {; 6637 next_seed = inseed = starting_seed;; 6638 ; 6639 // Determine the next seed.; 6640 k = next_seed / 53668;; 6641 next_seed = (next_seed - k*53668)*40014 - k*12211;; 6642 if (next_seed < 0) next_seed += 2147483563;; 6643 ; 6644 val = Double_t(next_seed*4.656613e-10);; 6645 ; 6646 // If more than one thread gets here, one will manage the update; 6647 // of g_iseed the other we go for at least one more round.; 6648 // This is not reproduceable; 6649 } while (! g_iseed.compare_exchange_strong(starting_seed, next_seed) );; 6650 }; 6651}; 6652 ; 6653////////////////////////////////////////////////////////////////////////////////; 6654/// Resets function value and errors to UNDEFINED; 6655///; 6656/// - If IOPT=1,; 6657/// - If IOPT=0, sets only MINOS errors to undefined; 6658/// Called from MNCLER and whenever problem changes, for example; 6659/// after SET LIMITS, SET PARAM, CALL FCN 6; 6660 ; 6661void TMinuit::mnrset(Int_t iopt); 6662{; 6663 Int_t iext, i;; 6664 ; 6665 fCstatu = ""RESET "";; 6666 if (iopt >= 1) {; 6667 fAmin = fUndefi;; 6668 fFval3 = TMath::Abs(fAmin)*2 + 1;; 6669 fEDM = fBigedm;; 6670 fISW[3] = 0;; 6671 fISW[1] = 0;; 6672 fDcovar = 1;; 6673 fISW[0] = 0;; 6674 }; 6675 fLnolim = kTRUE;; 6676 for (i = 1; i <= fNpar; ++i) {; 6677 iext = fNexofi[i-1];; 6678 if (fNvarl[iext-1] >= 4) fLnolim = kFALSE;; 667",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:258502,Deployability,release,release,258502,"a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition TMinuit.cxx:855; TMinuit::fUDouble_t * fUDefinition TMinuit.h:68; TMinuit::mnpfitvirtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhi",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:100166,Energy Efficiency,reduce,reduce,100166,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115086,Energy Efficiency,efficient,efficient,115086,"; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//___________________________________",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:277890,Energy Efficiency,power,power,277890,"tyle format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ahDefinition civetweb.c:8348; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. mathminuitsrcTMinuit.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:43 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:1098,Integrability,depend,depending,1098,"oot/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2636,Integrability,depend,depend,2636,"ssing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, whil",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2875,Integrability,depend,depending,2875,"legant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformat",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:5975,Integrability,depend,depends,5975,"ion, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; 131 ; 132If MIGRAD converges normally to a point where no parameter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from finding the right minimum. On the other hand, if one or more; 135parameters is near its limit at the minimum, this may be because the true; 136minimum is indeed at a limit, or it may be because the minimizer has; 137become ``blocked'' at a limit. This may normally happen only if the; 138parameter is so close to a limit (internal value at an odd multiple of; 139\f$\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a l",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:9991,Integrability,message,messages,9991,"stimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, the errors are usually quite accurate,; 194unless there has been a problem. MINUIT, when it prints out error values,; 195also gives some indication of how reliable it thinks they are. For; 196example, those marked <TT>CURRENT GUESS ERROR</TT> are only working values; 197not to be believed, and <TT>APPROXIMATE ERROR</TT> means that they have; 198been calculated but there is reason to believe that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:10674,Integrability,message,message,10674,"eve that they may not be; 199accurate.; 200 ; 201If no mitigating adjective is given, then at least MINUIT believes the; 202errors are accurate, although there is always a small chance that MINUIT; 203has been fooled. Some visible signs that MINUIT may have been fooled are:; 204 ; 205 ; 206 1. Warning messages produced during the minimization or error analysis.; 207 ; 208 2. Failure to find new minimum.; 209 ; 210 3. Value of <TT>EDM</TT> too big (estimated Distance to Minimum).; 211 ; 212 4. Correlation coefficients exactly equal to zero, unless some parameters; 213 are known to be uncorrelated with the others.; 214 ; 215 5. Correlation coefficients very close to one (greater than 0.99). This; 216 indicates both an exceptionally difficult problem, and one which has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermin",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:11963,Integrability,depend,dependence,11963,"rs; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numeric",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13008,Integrability,depend,dependence,13008,"NUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:25506,Integrability,rout,routine,25506,"/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; 636/// using npoints (>=4) points. The TMinuit status will be; 637/// - 0 on success and; 638/// - -1 if errors in the calling sequence (pa1, pa2 not variable); 639/// - 1 if less than four points can be found; 640/// - 2 if npoints<4; 641/// - n>3 if only n points can be found (n < npoints); 642/// The status can be obtained via TMinuit::GetStatus().; 643///; 644/// To get the n-sigma contour the ERRDEF parameter in Minuit has to set; 645/// to n^2. The fcn function has to be set before the routine is called.; 646///; 647/// The TGraph object is created via the interpreter. The user must cast it; 648/// to a TGraph*. Note that the TGraph is created with npoints+1 in order to; 649/// close the contour (setting last point equal to first point).; 650///; 651/// You can find an example in $ROOTSYS/tutorials/fit/fitcont.C; 652 ; 653TObject *TMinuit::Contour(Int_t npoints, Int_t pa1, Int_t pa2); 654{; 655 if (npoints<4) {; 656 // we need at least 4 points; 657 fStatus= 2;; 658 return (TObject *)nullptr;; 659 }; 660 Int_t npfound;; 661 Double_t *xcoor = new Double_t[npoints+1];; 662 Double_t *ycoor = new Double_t[npoints+1];; 663 mncont(pa1,pa2,npoints,xcoor,ycoor,npfound);; 664 if (npfound<4) {; 665 // mncont did go wrong; 666 Warning(""Contour"",""Cannot find more than 4 points, no TGraph returned"");; 667 fStatus= (npfound==0 ? 1 : npfound);; 668 delete [] xcoor;; 669 delete [] ycoor;; 670 return (TObject *)nullptr;; 671 }; 672 if (npfound!=npoints) {; 673 // mncont d",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:73991,Integrability,depend,depends,73991,"arting at the right place; 2193 mninex(fX);; 2194 nparx = fNpar;; 2195 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 2196 if (fs1 != fAmin) {; 2197 df = fAmin - fs1;; 2198 mnwarn(""D"", ""MNDERI"", TString::Format(""function value differs from AMIN by %12.3g"",df));; 2199 fAmin = fs1;; 2200 }; 2201 Printf("" FIRST DERIVATIVE DEBUG PRINTOUT. MNDERI"");; 2202 Printf("" PAR DERIV STEP MINSTEP OPTSTEP D1-D2 2ND DRV"");; 2203 }; 2204 dfmin = fEpsma2*8*(TMath::Abs(fAmin) + fUp);; 2205 if (fIstrat <= 0) {; 2206 ncyc = 2;; 2207 tlrstp = .5;; 2208 tlrgrd = .1;; 2209 } else if (fIstrat == 1) {; 2210 ncyc = 3;; 2211 tlrstp = .3;; 2212 tlrgrd = .05;; 2213 } else {; 2214 ncyc = 5;; 2215 tlrstp = .1;; 2216 tlrgrd = .02;; 2217 }; 2218// loop over variable parameters; 2219 for (i = 1; i <= fNpar; ++i) {; 2220 epspri = fEpsma2 + TMath::Abs(fGrd[i-1]*fEpsma2);; 2221// two-point derivatives always assumed necessary; 2222// maximum number of cycles over step size depends on strategy; 2223 xtf = fX[i-1];; 2224 stepb4 = 0;; 2225// loop as little as possible here!/; 2226 for (icyc = 1; icyc <= ncyc; ++icyc) {; 2227// theoretically best step; 2228 optstp = TMath::Sqrt(dfmin / (TMath::Abs(fG2[i-1]) + epspri));; 2229// step cannot decrease by more than a factor of ten; 2230 step = TMath::Max(optstp,TMath::Abs(fGstep[i-1]*.1));; 2231// but if parameter has limits, max step size = 0.5; 2232 if (fGstep[i-1] < 0 && step > .5) step = .5;; 2233// and not more than ten times the previous step; 2234 stpmax = TMath::Abs(fGstep[i-1])*10;; 2235 if (step > stpmax) step = stpmax;; 2236// minimum step size allowed by machine precision; 2237 stpmin = TMath::Abs(fEpsma2*fX[i-1])*8;; 2238 if (step < stpmin) step = stpmin;; 2239// end of iterations if step change less than factor 2; 2240 if (TMath::Abs((step - stepb4) / step) < tlrstp) goto L50;; 2241// take step positive; 2242 stepb4 = step;; 2243 if (fGstep[i-1] > 0) fGstep[i-1] = TMath::Abs(step);; 2244 else fGstep[i-1] = -TMath::Abs(step);; 2245 stepb4 = step;; 2246 fX[",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:83883,Integrability,rout,routine,83883,"in(nperln,13);; 2533 if (fISW[4] >= 1 && npard > nperln) {; 2534 Printf("" ELEMENTS ABOVE DIAGONAL ARE NOT PRINTED."");; 2535 }; 2536// I counts the rows of the matrix; 2537 for (i = 1; i <= npard; ++i) {; 2538 mndxdi(fX[i-1], i-1, dxdi);; 2539 kga = i*(i-1) / 2;; 2540 for (j = 1; j <= i; ++j) {; 2541 mndxdi(fX[j-1], j-1, dxdj);; 2542 kgb = kga + j;; 2543 emat[i + j*emat_dim1] = dxdi*fVhmat[kgb-1]*dxdj*fUp;; 2544 emat[j + i*emat_dim1] = emat[i + j*emat_dim1];; 2545 }; 2546 }; 2547// IZ is number of columns to be printed in row I; 2548 if (fISW[4] >= 2) {; 2549 for (i = 1; i <= npard; ++i) {; 2550 iz = npard;; 2551 if (npard >= nperln) iz = i;; 2552 ctemp = "" "";; 2553 for (k = 1; nperln < 0 ? k >= iz : k <= iz; k += nperln) {; 2554 k2 = k + nperln - 1;; 2555 if (k2 > iz) k2 = iz;; 2556 for (kk = k; kk <= k2; ++kk) {; 2557 ctemp += TString::Format(""%10.3e "",emat[i + kk*emat_dim1]);; 2558 }; 2559 Printf(""%s"",(const char*)ctemp);; 2560 }; 2561 }; 2562 }; 2563}; 2564 ; 2565////////////////////////////////////////////////////////////////////////////////; 2566/// Utility routine to get MINOS errors; 2567///; 2568/// Called by user.; 2569///; 2570/// NUMBER is the parameter number; 2571///; 2572/// values returned by MNERRS:; 2573/// - EPLUS, EMINUS are MINOS errors of parameter NUMBER,; 2574/// - EPARAB is 'parabolic' error (from error matrix).; 2575/// (Errors not calculated are set = 0); 2576/// - GCC is global correlation coefficient from error matrix; 2577 ; 2578void TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1],",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:107310,Integrability,interface,interface,107310," GRADIENT CALCULATION IN FCN"");; 3386 Printf("" PARAMETER G(IN FCN) G(MINUIT) DG(MINUIT) AGREEMENT"");; 3387 fISW[2] = 1;; 3388 lnone = kFALSE;; 3389 for (lc = 1; lc <= fNpar; ++lc) {; 3390 i = fNexofi[lc-1];; 3391 const char *cwd = ""GOOD"";; 3392 err = fDgrd[lc-1];; 3393 if (TMath::Abs(fGRADgf[lc-1] - fGrd[lc-1]) > err) {; 3394 cwd = "" BAD"";; 3395 fISW[2] = 0;; 3396 }; 3397 if (fGin[i-1] == fUndefi) {; 3398 cwd = ""NONE"";; 3399 lnone = kTRUE;; 3400 fGRADgf[lc-1] = 0;; 3401 fISW[2] = 0;; 3402 }; 3403 Printf("" %5d %10s%12.4e%12.4e%12.4e %s"",i; 3404 ,(const char*)fCpnam[i-1]; 3405 ,fGRADgf[lc-1],fGrd[lc-1],err,cwd);; 3406 }; 3407 if (lnone) {; 3408 Printf("" AGREEMENT=NONE MEANS FCN DID NOT CALCULATE THE DERIVATIVE"");; 3409 }; 3410 if (fISW[2] == 0) {; 3411 Printf("" MINUIT DOES NOT ACCEPT DERIVATIVE CALCULATIONS BY FCN"");; 3412 Printf("" TO FORCE ACCEPTANCE, ENTER *SET GRAD 1*"");; 3413 }; 3414 ; 3415L2000:; 3416 return;; 3417}; 3418 ; 3419////////////////////////////////////////////////////////////////////////////////; 3420/// interface to Minuit help; 3421 ; 3422void TMinuit::mnhelp(const char *command); 3423{; 3424 TString comd = command;; 3425 mnhelp(comd);; 3426}; 3427 ; 3428////////////////////////////////////////////////////////////////////////////////; 3429/// HELP routine for MINUIT interactive commands; 3430///; 3431/// - COMD ='*' or """" prints a global help for all commands; 3432/// - COMD =Command_name: print detailed help for one command.; 3433/// Note that at least 3 characters must be given for the command; 3434/// name.; 3435///; 3436/// Author: Rene Brun; 3437/// comments extracted from the MINUIT documentation file.; 3438 ; 3439void TMinuit::mnhelp(TString comd); 3440{; 3441//______________________________________________________________________________; 3442//; 3443// Global HELP: Summary of all commands; 3444//; 3445 comd.ToUpper();; 3446 if( comd.Length() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List o",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:107560,Integrability,rout,routine,107560," GRADIENT CALCULATION IN FCN"");; 3386 Printf("" PARAMETER G(IN FCN) G(MINUIT) DG(MINUIT) AGREEMENT"");; 3387 fISW[2] = 1;; 3388 lnone = kFALSE;; 3389 for (lc = 1; lc <= fNpar; ++lc) {; 3390 i = fNexofi[lc-1];; 3391 const char *cwd = ""GOOD"";; 3392 err = fDgrd[lc-1];; 3393 if (TMath::Abs(fGRADgf[lc-1] - fGrd[lc-1]) > err) {; 3394 cwd = "" BAD"";; 3395 fISW[2] = 0;; 3396 }; 3397 if (fGin[i-1] == fUndefi) {; 3398 cwd = ""NONE"";; 3399 lnone = kTRUE;; 3400 fGRADgf[lc-1] = 0;; 3401 fISW[2] = 0;; 3402 }; 3403 Printf("" %5d %10s%12.4e%12.4e%12.4e %s"",i; 3404 ,(const char*)fCpnam[i-1]; 3405 ,fGRADgf[lc-1],fGrd[lc-1],err,cwd);; 3406 }; 3407 if (lnone) {; 3408 Printf("" AGREEMENT=NONE MEANS FCN DID NOT CALCULATE THE DERIVATIVE"");; 3409 }; 3410 if (fISW[2] == 0) {; 3411 Printf("" MINUIT DOES NOT ACCEPT DERIVATIVE CALCULATIONS BY FCN"");; 3412 Printf("" TO FORCE ACCEPTANCE, ENTER *SET GRAD 1*"");; 3413 }; 3414 ; 3415L2000:; 3416 return;; 3417}; 3418 ; 3419////////////////////////////////////////////////////////////////////////////////; 3420/// interface to Minuit help; 3421 ; 3422void TMinuit::mnhelp(const char *command); 3423{; 3424 TString comd = command;; 3425 mnhelp(comd);; 3426}; 3427 ; 3428////////////////////////////////////////////////////////////////////////////////; 3429/// HELP routine for MINUIT interactive commands; 3430///; 3431/// - COMD ='*' or """" prints a global help for all commands; 3432/// - COMD =Command_name: print detailed help for one command.; 3433/// Note that at least 3 characters must be given for the command; 3434/// name.; 3435///; 3436/// Author: Rene Brun; 3437/// comments extracted from the MINUIT documentation file.; 3438 ; 3439void TMinuit::mnhelp(TString comd); 3440{; 3441//______________________________________________________________________________; 3442//; 3443// Global HELP: Summary of all commands; 3444//; 3445 comd.ToUpper();; 3446 if( comd.Length() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List o",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:115370,Integrability,message,messages,115370,"minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will be stopped."");; 3576 goto L99;; 3577 }; 3578//______________________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by th",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:119467,Integrability,message,message,119467,"______________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:126838,Integrability,depend,depend,126838," 3795 Printf("" SET INPut [unitno] [filename]"");; 3796 Printf("" Causes Minuit, in data-driven mode only, to read subsequent"");; 3797 Printf("" commands (or parameter definitions) from a different input"");; 3798 Printf("" file. If no [unitno] is specified, reading reverts to the"");; 3799 Printf("" previous input file, assuming that there was one."");; 3800 Printf("" If [unitno] is specified, and that unit has not been opened,"");; 3801 Printf("" then Minuit attempts to open the file [filename]} if a"");; 3802 Printf("" name is specified. If running in interactive mode and"");; 3803 Printf("" [filename] is not specified and [unitno] is not opened,"");; 3804 Printf("" Minuit prompts the user to enter a file name."");; 3805 Printf("" If the word REWIND is added to the command (note:no blanks"");; 3806 Printf("" between INPUT and REWIND), the file is rewound before"");; 3807 Printf("" reading. Note that this command is implemented in standard"");; 3808 Printf("" Fortran 77 and the results may depend on the system;"");; 3809 Printf("" for example, if a filename is given under VM/CMS, it must"");; 3810 Printf("" be preceded by a slash."");; 3811 ; 3812 Printf("" "");; 3813 Printf("" SET INTeractive"");; 3814 Printf("" Informs Minuit that it is running interactively."");; 3815 ; 3816 Printf("" "");; 3817 Printf("" SET LIMits [parno] [lolim] [uplim]"");; 3818 Printf("" Allows the user to change the limits on one or all"");; 3819 Printf("" parameters. If no arguments are specified, all limits are"");; 3820 Printf("" removed from all parameters. If [parno] alone is specified,"");; 3821 Printf("" limits are removed from parameter [parno]."");; 3822 Printf("" If all arguments are specified, then parameter [parno] will"");; 3823 Printf("" be bounded between [lolim] and [uplim]."");; 3824 Printf("" Limits can be specified in either order, Minuit will take"");; 3825 Printf("" the smaller as [lolim] and the larger as [uplim]."");; 3826 Printf("" However, if [lolim] is equal to [uplim], an error condition"");; 3827 Printf("" results."");; 3",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:128348,Integrability,message,messages,128348,"re specified, all limits are"");; 3820 Printf("" removed from all parameters. If [parno] alone is specified,"");; 3821 Printf("" limits are removed from parameter [parno]."");; 3822 Printf("" If all arguments are specified, then parameter [parno] will"");; 3823 Printf("" be bounded between [lolim] and [uplim]."");; 3824 Printf("" Limits can be specified in either order, Minuit will take"");; 3825 Printf("" the smaller as [lolim] and the larger as [uplim]."");; 3826 Printf("" However, if [lolim] is equal to [uplim], an error condition"");; 3827 Printf("" results."");; 3828 ; 3829 Printf("" "");; 3830 Printf("" SET LINesperpage"");; 3831 Printf("" Sets the number of lines for one page of output."");; 3832 Printf("" Default value is 24 for interactive mode"");; 3833 ; 3834 Printf("" "");; 3835 Printf("" SET NOGradient"");; 3836 Printf("" The inverse of SET GRAdient, instructs Minuit not to"");; 3837 Printf("" use the first derivatives calculated by the user in FCN."");; 3838 ; 3839 Printf("" "");; 3840 Printf("" SET NOWarnings"");; 3841 Printf("" Suppresses Minuit warning messages."");; 3842 ; 3843 Printf("" "");; 3844 Printf("" SET OUTputfile <unitno>"");; 3845 Printf("" Instructs Minuit to write further output to unit <unitno>."");; 3846 ; 3847 Printf("" "");; 3848 Printf("" SET PAGethrow <integer>"");; 3849 Printf("" Sets the carriage control character for ``new page'' to"");; 3850 Printf("" <integer>. Thus the value 1 produces a new page, and 0"");; 3851 Printf("" produces a blank line, on some devices (see TOPofpage)"");; 3852 ; 3853 ; 3854 Printf("" "");; 3855 Printf("" SET PARameter <parno> <value>"");; 3856 Printf("" Sets the value of parameter <parno> to <value>."");; 3857 Printf("" The parameter in question may be variable, fixed, or"");; 3858 Printf("" constant, but must be defined."");; 3859 ; 3860 Printf("" "");; 3861 Printf("" SET PRIntout <level>"");; 3862 Printf("" Sets the print level, determining how much output will be"");; 3863 Printf("" produced. Allowed values and their meanings are displayed"");; 3864 Printf("" after a ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:130843,Integrability,message,messages,130843,"in SEEk."");; 3875 Printf("" This can be any integer between 10000 and 900000000, for"");; 3876 Printf("" example one which was output from a SHOw RANdom command of"");; 3877 Printf("" a previous run."");; 3878 ; 3879 Printf("" "");; 3880 Printf("" SET STRategy <level>"");; 3881 Printf("" Sets the strategy to be used in calculating first and second"");; 3882 Printf("" derivatives and in certain minimization methods."");; 3883 Printf("" In general, low values of <level> mean fewer function calls"");; 3884 Printf("" and high values mean more reliable minimization."");; 3885 Printf("" Currently allowed values are 0, 1 (default), and 2."");; 3886 ; 3887 Printf("" "");; 3888 Printf("" SET TITle"");; 3889 Printf("" Informs Minuit that the next input line is to be considered"");; 3890 Printf("" the (new) title for this task or sub-task. This is for"");; 3891 Printf("" the convenience of the user in reading their output."");; 3892 ; 3893 Printf("" "");; 3894 Printf("" SET WARnings"");; 3895 Printf("" Instructs Minuit to output warning messages when suspicious"");; 3896 Printf("" conditions arise which may indicate unreliable results."");; 3897 Printf("" This is the default."");; 3898 ; 3899 Printf("" "");; 3900 Printf("" SET WIDthpage"");; 3901 Printf("" Informs Minuit of the output page width."");; 3902 Printf("" Default values are 80 for interactive jobs"");; 3903 goto L99;; 3904 }; 3905//______________________________________________________________________________; 3906//; 3907// Command SHOW; 3908//; 3909 if( !strncmp(comd.Data(),""SHO"",3) ) {; 3910 Printf("" ***>SHOw <option_name>"");; 3911 Printf("" All SET XXXX commands have a corresponding SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVa",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:133824,Integrability,depend,depending,133824,"he estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 3966//; 3967// Command TOPOFPAGE; 3968//; 3969 if( !strncmp(comd.Data(),""TOP"",3) ) {; 3970 Printf("" ***>TOPofpage"");; 3971 Printf("" Causes Minuit to write the character specified in a"");; 3972 Printf("" SET PAGethrow command (default = 1) to column 1 of the output"");; 3973 Printf("" file, which may or may not position your output medium to"");; 3974 Printf("" the top of a page depending on the device and system."");; 3975 goto L99;; 3976 }; 3977//______________________________________________________________________________; 3978 Printf("" Unknown MINUIT command. Type HELP for list of commands."");; 3979 ; 3980L99:; 3981 return;; 3982}; 3983 ; 3984////////////////////////////////////////////////////////////////////////////////; 3985/// Calculates the full second-derivative matrix of FCN; 3986///; 3987/// by taking finite differences. When calculating diagonal; 3988/// elements, it may iterate so that step size is nearly that; 3989/// which gives function change= UP/10. The first derivatives; 3990/// of course come as a free side effect, but with a smaller; 3991/// step size in order to obtain a known accuracy.; 3992 ; 3993void TMinuit::mnhess(); 3994{; 3995 /* Local variables */; 3996 Double_t dmin_, dxdi, elem, wint, tlrg2, ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:150037,Integrability,rout,routines,150037,"8 fLnewmn = kTRUE;; 4459 if (fISW[1] >= 1) {; 4460 fISW[1] = 1;; 4461 fDcovar = TMath::Max(fDcovar,.5);; 4462 } else fDcovar = 1;; 4463 fItaur = 0;; 4464 fNfcnmx = fNfcnmx + npfn - fNfcn;; 4465 fCstatu = ""NEW MINIMU"";; 4466 if (fISW[4] >= 0) {; 4467 Printf("" IMPROVE HAS FOUND A TRULY NEW MINIMUM"");; 4468 Printf("" *************************************"");; 4469 }; 4470 return;; 4471// return to previous region; 4472L280:; 4473 if (fISW[4] > 0) {; 4474 Printf("" COVARIANCE MATRIX WAS NOT POSITIVE-DEFINITE"");; 4475 }; 4476 goto L325;; 4477L300:; 4478 fISW[0] = 1;; 4479L325:; 4480 for (i = 1; i <= fNpar; ++i) {; 4481 fDirin[i-1] = fIMPRdsav[i-1]*.01;; 4482 fX[i-1] = fXt[i-1];; 4483 }; 4484 fAmin = fApsi;; 4485 fEDM = sigsav;; 4486L350:; 4487 mninex(fX);; 4488 if (fISW[4] > 0) {; 4489 Printf("" IMPROVE HAS RETURNED TO REGION OF ORIGINAL MINIMUM"");; 4490 }; 4491 fCstatu = ""UNCHANGED "";; 4492 mnrset(0);; 4493 if (fISW[1] < 2) goto L380;; 4494 if (loop < nloop && fISW[0] < 1) goto L20;; 4495L380:; 4496 if (iswtr >= 0) mnprin(5, fAmin);; 4497 fItaur = 0;; 4498}; 4499 ; 4500////////////////////////////////////////////////////////////////////////////////; 4501/// Transforms from internal coordinates (PINT) to external (U); 4502///; 4503/// The minimising routines which work in; 4504/// internal coordinates call this routine before calling FCN.; 4505 ; 4506void TMinuit::mninex(Double_t *pint); 4507{; 4508 Int_t i, j;; 4509 ; 4510 for (j = 0; j < fNpar; ++j) {; 4511 i = fNexofi[j]-1;; 4512 if (fNvarl[i] == 1) {; 4513 fU[i] = pint[j];; 4514 } else {; 4515 fU[i] = fAlim[i] + (TMath::Sin(pint[j]) + 1)*.5*(fBlim[i] - fAlim[i]);; 4516 }; 4517 }; 4518}; 4519 ; 4520////////////////////////////////////////////////////////////////////////////////; 4521/// Main initialization member function for MINUIT; 4522///; 4523/// It initializes some constants; 4524/// (including the logical I/O unit nos.),; 4525 ; 4526void TMinuit::mninit(Int_t i1, Int_t i2, Int_t i3); 4527{; 4528 /* Local variables *",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:150100,Integrability,rout,routine,150100,"8 fLnewmn = kTRUE;; 4459 if (fISW[1] >= 1) {; 4460 fISW[1] = 1;; 4461 fDcovar = TMath::Max(fDcovar,.5);; 4462 } else fDcovar = 1;; 4463 fItaur = 0;; 4464 fNfcnmx = fNfcnmx + npfn - fNfcn;; 4465 fCstatu = ""NEW MINIMU"";; 4466 if (fISW[4] >= 0) {; 4467 Printf("" IMPROVE HAS FOUND A TRULY NEW MINIMUM"");; 4468 Printf("" *************************************"");; 4469 }; 4470 return;; 4471// return to previous region; 4472L280:; 4473 if (fISW[4] > 0) {; 4474 Printf("" COVARIANCE MATRIX WAS NOT POSITIVE-DEFINITE"");; 4475 }; 4476 goto L325;; 4477L300:; 4478 fISW[0] = 1;; 4479L325:; 4480 for (i = 1; i <= fNpar; ++i) {; 4481 fDirin[i-1] = fIMPRdsav[i-1]*.01;; 4482 fX[i-1] = fXt[i-1];; 4483 }; 4484 fAmin = fApsi;; 4485 fEDM = sigsav;; 4486L350:; 4487 mninex(fX);; 4488 if (fISW[4] > 0) {; 4489 Printf("" IMPROVE HAS RETURNED TO REGION OF ORIGINAL MINIMUM"");; 4490 }; 4491 fCstatu = ""UNCHANGED "";; 4492 mnrset(0);; 4493 if (fISW[1] < 2) goto L380;; 4494 if (loop < nloop && fISW[0] < 1) goto L20;; 4495L380:; 4496 if (iswtr >= 0) mnprin(5, fAmin);; 4497 fItaur = 0;; 4498}; 4499 ; 4500////////////////////////////////////////////////////////////////////////////////; 4501/// Transforms from internal coordinates (PINT) to external (U); 4502///; 4503/// The minimising routines which work in; 4504/// internal coordinates call this routine before calling FCN.; 4505 ; 4506void TMinuit::mninex(Double_t *pint); 4507{; 4508 Int_t i, j;; 4509 ; 4510 for (j = 0; j < fNpar; ++j) {; 4511 i = fNexofi[j]-1;; 4512 if (fNvarl[i] == 1) {; 4513 fU[i] = pint[j];; 4514 } else {; 4515 fU[i] = fAlim[i] + (TMath::Sin(pint[j]) + 1)*.5*(fBlim[i] - fAlim[i]);; 4516 }; 4517 }; 4518}; 4519 ; 4520////////////////////////////////////////////////////////////////////////////////; 4521/// Main initialization member function for MINUIT; 4522///; 4523/// It initializes some constants; 4524/// (including the logical I/O unit nos.),; 4525 ; 4526void TMinuit::mninit(Int_t i1, Int_t i2, Int_t i3); 4527{; 4528 /* Local variables *",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248392,Integrability,message,messages,248392,"01 /* Local variables */; 7702 Double_t si;; 7703 Int_t i, j, k, kp1, km1;; 7704 ; 7705 /* Parameter adjustments */; 7706 a_offset = l + 1;; 7707 a -= a_offset;; 7708 ; 7709 /* Function Body */; 7710 ifail = 0;; 7711 if (n < 1) goto L100;; 7712 if (n > fMaxint) goto L100;; 7713// scale matrix by sqrt of diag elements; 7714 for (i = 1; i <= n; ++i) {; 7715 si = a[i + i*l];; 7716 if (si <= 0) goto L100;; 7717 fVERTs[i-1] = 1 / TMath::Sqrt(si);; 7718 }; 7719 for (i = 1; i <= n; ++i) {; 7720 for (j = 1; j <= n; ++j) {; 7721 a[i + j*l] = a[i + j*l]*fVERTs[i-1]*fVERTs[j-1];; 7722 }; 7723 }; 7724// start main loop; 7725 for (i = 1; i <= n; ++i) {; 7726 k = i;; 7727// preparation for elimination step1; 7728 if (a[k + k*l] != 0) fVERTq[k-1] = 1 / a[k + k*l];; 7729 else goto L100;; 7730 fVERTpp[k-1] = 1;; 7731 a[k + k*l] = 0;; 7732 kp1 = k + 1;; 7733 km1 = k - 1;; 7734 if (km1 < 0) goto L100;; 7735 else if (km1 == 0) goto L50;; 7736 else goto L40;; 7737L40:; 7738 for (j = 1; j <= km1; ++j) {; 7739 fVERTpp[j-1] = a[j + k*l];; 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248452,Integrability,message,message,248452,"01 /* Local variables */; 7702 Double_t si;; 7703 Int_t i, j, k, kp1, km1;; 7704 ; 7705 /* Parameter adjustments */; 7706 a_offset = l + 1;; 7707 a -= a_offset;; 7708 ; 7709 /* Function Body */; 7710 ifail = 0;; 7711 if (n < 1) goto L100;; 7712 if (n > fMaxint) goto L100;; 7713// scale matrix by sqrt of diag elements; 7714 for (i = 1; i <= n; ++i) {; 7715 si = a[i + i*l];; 7716 if (si <= 0) goto L100;; 7717 fVERTs[i-1] = 1 / TMath::Sqrt(si);; 7718 }; 7719 for (i = 1; i <= n; ++i) {; 7720 for (j = 1; j <= n; ++j) {; 7721 a[i + j*l] = a[i + j*l]*fVERTs[i-1]*fVERTs[j-1];; 7722 }; 7723 }; 7724// start main loop; 7725 for (i = 1; i <= n; ++i) {; 7726 k = i;; 7727// preparation for elimination step1; 7728 if (a[k + k*l] != 0) fVERTq[k-1] = 1 / a[k + k*l];; 7729 else goto L100;; 7730 fVERTpp[k-1] = 1;; 7731 a[k + k*l] = 0;; 7732 kp1 = k + 1;; 7733 km1 = k - 1;; 7734 if (km1 < 0) goto L100;; 7735 else if (km1 == 0) goto L50;; 7736 else goto L40;; 7737L40:; 7738 for (j = 1; j <= km1; ++j) {; 7739 fVERTpp[j-1] = a[j + k*l];; 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248511,Integrability,message,message,248511," 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 }",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248590,Integrability,rout,routine,248590,"(k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 } else {; 7805 ityp = 2;; 7806 if (fLrepor) {; 7807 Printf("" MINUIT DEBUG FOR %s"",(const char*",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248626,Integrability,message,message,248626,"(k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 } else {; 7805 ityp = 2;; 7806 if (fLrepor) {; 7807 Printf("" MINUIT DEBUG FOR %s"",(const char*",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248712,Integrability,message,message,248712,"; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 } else {; 7805 ityp = 2;; 7806 if (fLrepor) {; 7807 Printf("" MINUIT DEBUG FOR %s"",(const char*)corg);; 7808 Printf("" =============== %s "",(const char*)cmes);; 7809 return;; 7810 }; 7811 }; 7812// if appropriate flag is",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:248836,Integrability,message,messages,248836,"ion proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.; 7776/// - If COPT='D', CMES is a DEBug message from CORG.; 7777/// - If SET WARnings is in effect (the default), this routine; 7778/// prints the warning message CMES coming from CORG.; 7779/// - If SET NOWarnings is in effect, the warning message is; 7780/// stored in a circular buffer of length kMAXMES.; 7781/// - If called with CORG=CMES='SHO', it prints the messages in; 7782/// the circular buffer, FIFO, and empties the buffer.; 7783 ; 7784void TMinuit::mnwarn(const char *copt1, const char *corg1, const char *cmes1); 7785{; 7786 TString copt = copt1;; 7787 TString corg = corg1;; 7788 TString cmes = cmes1;; 7789 ; 7790 const Int_t kMAXMES = 10;; 7791 Int_t ityp, i, ic, nm;; 7792 TString englsh, ctyp;; 7793 ; 7794 if (corg(0,3) != ""SHO"" || cmes(0,3) != ""SHO"") {; 7795 ; 7796// Either print warning or put in buffer; 7797 if (copt == ""W"") {; 7798 ityp = 1;; 7799 if (fLwarn) {; 7800 Printf("" MINUIT WARNING IN %s"",(const char*)corg);; 7801 Printf("" ============== %s"",(const char*)cmes);; 7802 return;; 7803 }; 7804 } else {; 7805 ityp = 2;; 7806 if (fLrepor) {; 7807 Printf("" MINUIT DEBUG FOR %s"",(const char*)corg);; 7808 Printf("" =============== %s "",(const char*)cmes);; 7809 return;; 7810 }; 7811 }; 7812// if appropriate flag is off, fill circular buffer; 7813 if (fNwrmes[ityp-1] == 0) fIcirc[ityp-1] = 0;; 7814 ++fNwrmes[ityp-1];; 7815 ++fIcirc[ityp-1]",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:256743,Integrability,interface,interface,256743," THbookFile.cxx:95; TList.h; TMath.h; charalstatic const char charal[29]Definition TMinuit.cxx:339; InteractiveFCNmvoid InteractiveFCNm(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag)Static function called when SetFCN is called in interactive mode.Definition TMinuit.cxx:928; gMinuitTMinuit * gMinuitDefinition TMinuit.cxx:337; TMinuit.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; snprintf#define snprintfDefinition civetweb.c:1540; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:269083,Integrability,rout,routine,269083,"nition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::Set",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:269949,Integrability,rout,routine,269949,"n TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::SetPrintLevelvirtual Int_t SetPrintLevel(Int_t printLevel=0)set Minuit print level.Definition TMinuit.cxx:952; TMinuit::fMaxparInt_t fMaxparDefinition TMinuit.h:39; TMinuit::mnunptBool_t mnunpt(TString &cfname)Returns .TRUE.Definition TMinuit.cxx:7670; TMinuit::mnhessvirtual void mnhess()Calculates the full second-derivative matrix of FCN.Definition TMinuit.cxx:3993; TMinuit::fAlimDouble_t * fAlimDefinition TMinuit.h:69; TMinuit::fNiofexInt_t * fNiofexDefinition TMinuit.h:127; TMinuit::fIdbgInt_t fIdbg[11]Definition TMinuit.h:142; TMinuit::mnevalvirtual void mneval(Double_t anext, Double_t &fnext, Int_t &ierev)Evaluates the function being analysed by MNCROS.Definition TMinuit.cxx:2620; TMinuit::fEpsmacDouble_t fEpsmacDefinition TMinuit.h:56; TMinuit::fNewpagInt_t fNewpagDefinition TMinuit.h:136; TMinuit::mnsetvirtual void mnset()Interprets the commands that start with SET and SHOW.Definition TMinuit.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:273624,Integrability,message,messages,273624,"p, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t isyswr)Cracks the free-format input.Definition TMinuit.cxx:1677; TMinuit::fMNOTgccDouble_t * fMNOTgccDefinition TMinuit.h:115; TMinuit::DefineParametervirtual Int_t DefineParameter(Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit)Define a parameter.Definition TMinuit.cxx:695; TMinuit::fMaxpar2Int_t fMaxpar2Definition TMinuit.h:46; TMinuit::fFval3Double_t fFval3Definition TMinuit.h:52; TMinuit::fVhmatDouble_t * fVhmatDefinition TMinuit.h:89; TMinuit::fNstkrdInt_t fNstkrdDefinition TMinuit.h:138; TMinuit::mnstatvirtual void mnstat(Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat)Returns concerning the current status of the minimization.Definition TMinuit.cxx:7638; TMinuit::fNexofiInt_t * fNexofiDefinition TMinuit.h:128; TMinuit::fSEEKxbestDouble_t * fSEEKxbestDefinition TMinuit.h:118; TMinuit::mnwarnvirtual void mnwarn(const char *copt, const char *corg, const char *cmes)Prints Warning messages.Definition TMinuit.cxx:7784; TMinuit::fSEEKxmidDouble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s)",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:275768,Integrability,message,message,275768," TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Fo",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:276091,Integrability,message,message,276091,"uble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Resizevoid Resize(Ssiz_t n)Resize the string. Truncate or add blanks as necessary.Definition TString.cxx:1152; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:930,Modifiability,variab,variables,930,". ROOT: math/minuit/src/TMinuit.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMinuit.cxx. Go to the documentation of this file. 1// @(#)root/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format sta",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:1810,Modifiability,flexible,flexible,1810,"; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2218,Modifiability,variab,variables,2218,"meters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the par",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2661,Modifiability,variab,variable,2661,"ssing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, whil",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:3283,Modifiability,variab,variable,3283,"IT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be awar",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:5264,Modifiability,variab,variable,5264,"h; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:5818,Modifiability,variab,variable-metric,5818,"arameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; 131 ; 132If MIGRAD converges normally to a point where no parameter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from finding the right minimum. On the other hand, if one or more; 135parameters is near its limit at the minimum, this may be because the true; 136minimum is indeed at a limit, or it may be because the minimizer has; 137become ``blocked'' at a limit. This may normally happen only if the; 138parameter is so close to a limit (internal value at an odd multiple of; 139\f$\pm \frac{\pi}{2}\f$",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:13452,Modifiability,variab,variables,13452,"ct; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that this matrix has been calculated,; 289usually as the result of a Migrad minimization or a direct; 290calculation by Hesse which inverts the second derivative matrix.; 291 ; 292When there are no limits on the parameter in question, the error reported; 293by Minuit should therefore be exactly equal to the square root of the; 294corresponding diagonal element of the error matrix reported by Minuit.; 295 ; 296However, when there are limits on the parameter, there is a transformation; 297between the internal parameter values seen by Minuit (which are u",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:25159,Modifiability,variab,variable,25159,", ignored; 614/// - 2: command line unreadable, ignored; 615/// - 3: unknown command, ignored; 616/// - 4: abnormal termination (e.g., MIGRAD not converged); 617/// - 5: command is a request to read PARAMETER definitions; 618/// - 6: 'SET INPUT' command; 619/// - 7: 'SET TITLE' command; 620/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; 636/// using npoints (>=4) points. The TMinuit status will be; 637/// - 0 on success and; 638/// - -1 if errors in the calling sequence (pa1, pa2 not variable); 639/// - 1 if less than four points can be found; 640/// - 2 if npoints<4; 641/// - n>3 if only n points can be found (n < npoints); 642/// The status can be obtained via TMinuit::GetStatus().; 643///; 644/// To get the n-sigma contour the ERRDEF parameter in Minuit has to set; 645/// to n^2. The fcn function has to be set before the routine is called.; 646///; 647/// The TGraph object is created via the interpreter. The user must cast it; 648/// to a TGraph*. Note that the TGraph is created with npoints+1 in order to; 649/// close the contour (setting last point equal to first point).; 650///; 651/// You can find an example in $ROOTSYS/tutorials/fit/fitcont.C; 652 ; 653TObject *TMinuit::Contour(Int_t npoints, Int_t pa1, Int_t pa2); 654{; 655 if (npoints<4) {; 656 // we need at least 4 points; 657 fStatus= 2;; 658 return (TObject *)nullptr;; 659 }; 660 Int_t npfound;; 661 Double_t *xcoor = new Double_t[npoints+1];; 662 Double_t *ycoor = new Double_t[npoints+1];; 663 mncont(pa1,pa2,npoints,xcoor,ycoor,npfound);; 664 if",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:29362,Modifiability,variab,variable,29362,nuit arrays; 707 ; 708void TMinuit::DeleteArrays(); 709{; 710 if (fEmpty) return;; 711 delete [] fCpnam;; 712 delete [] fU;; 713 delete [] fAlim;; 714 delete [] fBlim;; 715 delete [] fErp;; 716 delete [] fErn;; 717 delete [] fWerr;; 718 delete [] fGlobcc;; 719 delete [] fNvarl;; 720 delete [] fNiofex;; 721 delete [] fNexofi;; 722 delete [] fX;; 723 delete [] fXt;; 724 delete [] fDirin;; 725 delete [] fXs;; 726 delete [] fXts;; 727 delete [] fDirins;; 728 delete [] fGrd;; 729 delete [] fG2;; 730 delete [] fGstep;; 731 delete [] fGin;; 732 delete [] fDgrd;; 733 delete [] fGrds;; 734 delete [] fG2s;; 735 delete [] fGsteps;; 736 delete [] fIpfix;; 737 delete [] fVhmat;; 738 delete [] fVthmat;; 739 delete [] fP;; 740 delete [] fPstar;; 741 delete [] fPstst;; 742 delete [] fPbar;; 743 delete [] fPrho;; 744 delete [] fWord7;; 745 delete [] fXpt;; 746 delete [] fYpt;; 747 delete [] fChpt;; 748 ; 749 delete [] fCONTgcc;; 750 delete [] fCONTw;; 751 delete [] fFIXPyy;; 752 delete [] fGRADgf;; 753 delete [] fHESSyy;; 754 delete [] fIMPRdsav;; 755 delete [] fIMPRy;; 756 delete [] fMATUvline;; 757 delete [] fMIGRflnu;; 758 delete [] fMIGRstep;; 759 delete [] fMIGRgs;; 760 delete [] fMIGRvg;; 761 delete [] fMIGRxxs;; 762 delete [] fMNOTxdev;; 763 delete [] fMNOTw;; 764 delete [] fMNOTgcc;; 765 delete [] fPSDFs;; 766 delete [] fSEEKxmid;; 767 delete [] fSEEKxbest;; 768 delete [] fSIMPy;; 769 delete [] fVERTq;; 770 delete [] fVERTs;; 771 delete [] fVERTpp;; 772 delete [] fCOMDplist;; 773 delete [] fPARSplist;; 774 ; 775 fEmpty = 1;; 776}; 777 ; 778////////////////////////////////////////////////////////////////////////////////; 779/// Evaluate the minimisation function; 780/// Input parameters:; 781/// - npar: number of currently variable parameters; 782/// - par: array of (constant and variable) parameters; 783/// - flag: Indicates what is to be calculated (see example below); 784/// - grad: array of gradients; 785/// Output parameters:; 786/// - fval: The calculated function value.,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:29420,Modifiability,variab,variable,29420,nuit arrays; 707 ; 708void TMinuit::DeleteArrays(); 709{; 710 if (fEmpty) return;; 711 delete [] fCpnam;; 712 delete [] fU;; 713 delete [] fAlim;; 714 delete [] fBlim;; 715 delete [] fErp;; 716 delete [] fErn;; 717 delete [] fWerr;; 718 delete [] fGlobcc;; 719 delete [] fNvarl;; 720 delete [] fNiofex;; 721 delete [] fNexofi;; 722 delete [] fX;; 723 delete [] fXt;; 724 delete [] fDirin;; 725 delete [] fXs;; 726 delete [] fXts;; 727 delete [] fDirins;; 728 delete [] fGrd;; 729 delete [] fG2;; 730 delete [] fGstep;; 731 delete [] fGin;; 732 delete [] fDgrd;; 733 delete [] fGrds;; 734 delete [] fG2s;; 735 delete [] fGsteps;; 736 delete [] fIpfix;; 737 delete [] fVhmat;; 738 delete [] fVthmat;; 739 delete [] fP;; 740 delete [] fPstar;; 741 delete [] fPstst;; 742 delete [] fPbar;; 743 delete [] fPrho;; 744 delete [] fWord7;; 745 delete [] fXpt;; 746 delete [] fYpt;; 747 delete [] fChpt;; 748 ; 749 delete [] fCONTgcc;; 750 delete [] fCONTw;; 751 delete [] fFIXPyy;; 752 delete [] fGRADgf;; 753 delete [] fHESSyy;; 754 delete [] fIMPRdsav;; 755 delete [] fIMPRy;; 756 delete [] fMATUvline;; 757 delete [] fMIGRflnu;; 758 delete [] fMIGRstep;; 759 delete [] fMIGRgs;; 760 delete [] fMIGRvg;; 761 delete [] fMIGRxxs;; 762 delete [] fMNOTxdev;; 763 delete [] fMNOTw;; 764 delete [] fMNOTgcc;; 765 delete [] fPSDFs;; 766 delete [] fSEEKxmid;; 767 delete [] fSEEKxbest;; 768 delete [] fSIMPy;; 769 delete [] fVERTq;; 770 delete [] fVERTs;; 771 delete [] fVERTpp;; 772 delete [] fCOMDplist;; 773 delete [] fPARSplist;; 774 ; 775 fEmpty = 1;; 776}; 777 ; 778////////////////////////////////////////////////////////////////////////////////; 779/// Evaluate the minimisation function; 780/// Input parameters:; 781/// - npar: number of currently variable parameters; 782/// - par: array of (constant and variable) parameters; 783/// - flag: Indicates what is to be calculated (see example below); 784/// - grad: array of gradients; 785/// Output parameters:; 786/// - fval: The calculated function value.,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:35246,Modifiability,variab,variables,35246,"0 Double_t result;; 941 m->Execute(result);; 942}; 943 ; 944////////////////////////////////////////////////////////////////////////////////; 945/// set Minuit print level.; 946///; 947/// printlevel:; 948/// - = -1 quiet (also suppress all warnings); 949/// - = 0 normal; 950/// - = 1 verbose; 951 ; 952Int_t TMinuit::SetPrintLevel( Int_t printLevel ); 953{; 954 Int_t err;; 955 Double_t tmp[1];; 956 tmp[0] = printLevel;; 957 ; 958 mnexcm( ""SET PRINT"", tmp, 1, err );; 959 ; 960 if (printLevel <=-1) mnexcm(""SET NOWarnings"",tmp,0,err);; 961 ; 962 return err;; 963}; 964 ; 965////////////////////////////////////////////////////////////////////////////////; 966/// Initialize AMIN; 967///; 968/// Called from many places. Initializes the value of AMIN by; 969/// calling the user function. Prints out the function value and; 970/// parameter values if Print Flag value is high enough.; 971 ; 972void TMinuit::mnamin(); 973{; 974 /* Local variables */; 975 Double_t fnew;; 976 Int_t nparx;; 977 ; 978 nparx = fNpar;; 979 if (fISW[4] >= 1) {; 980 Printf("" FIRST CALL TO USER FUNCTION AT NEW START POINT, WITH IFLAG=4."");; 981 }; 982 mnexin(fX);; 983 Eval(nparx, fGin, fnew, fU, 4); ++fNfcn;; 984 fAmin = fnew;; 985 fEDM = fBigedm;; 986}; 987 ; 988////////////////////////////////////////////////////////////////////////////////; 989/// Compute reasonable histogram intervals; 990///; 991/// Function TO DETERMINE REASONABLE HISTOGRAM INTERVALS; 992/// GIVEN ABSOLUTE UPPER AND LOWER BOUNDS A1 AND A2; 993/// AND DESIRED MAXIMUM NUMBER OF BINS NAA; 994/// PROGRAM MAKES REASONABLE BINNING FROM BL TO BH OF WIDTH BWID; 995/// F. JAMES, AUGUST, 1974 , stolen for Minuit, 1988; 996 ; 997void TMinuit::mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid); 998{; 999 /* Local variables */; 1000 Double_t awid,ah, al, sigfig, sigrnd, alb;; 1001 Int_t kwid, lwid, na=0, log_;; 1002 ; 1003 al = TMath::Min(a1,a2);; 1004 ah = TMath::Max(a1,a2);; 1005 if (al == ah) a",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:36122,Modifiability,variab,variables,36122,"// parameter values if Print Flag value is high enough.; 971 ; 972void TMinuit::mnamin(); 973{; 974 /* Local variables */; 975 Double_t fnew;; 976 Int_t nparx;; 977 ; 978 nparx = fNpar;; 979 if (fISW[4] >= 1) {; 980 Printf("" FIRST CALL TO USER FUNCTION AT NEW START POINT, WITH IFLAG=4."");; 981 }; 982 mnexin(fX);; 983 Eval(nparx, fGin, fnew, fU, 4); ++fNfcn;; 984 fAmin = fnew;; 985 fEDM = fBigedm;; 986}; 987 ; 988////////////////////////////////////////////////////////////////////////////////; 989/// Compute reasonable histogram intervals; 990///; 991/// Function TO DETERMINE REASONABLE HISTOGRAM INTERVALS; 992/// GIVEN ABSOLUTE UPPER AND LOWER BOUNDS A1 AND A2; 993/// AND DESIRED MAXIMUM NUMBER OF BINS NAA; 994/// PROGRAM MAKES REASONABLE BINNING FROM BL TO BH OF WIDTH BWID; 995/// F. JAMES, AUGUST, 1974 , stolen for Minuit, 1988; 996 ; 997void TMinuit::mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid); 998{; 999 /* Local variables */; 1000 Double_t awid,ah, al, sigfig, sigrnd, alb;; 1001 Int_t kwid, lwid, na=0, log_;; 1002 ; 1003 al = TMath::Min(a1,a2);; 1004 ah = TMath::Max(a1,a2);; 1005 if (al == ah) ah = al + 1;; 1006 ; 1007// IF NAA .EQ. -1 , PROGRAM USES BWID INPUT FROM CALLING ROUTINE; 1008 if (naa == -1) goto L150;; 1009L10:; 1010 na = naa - 1;; 1011 if (na < 1) na = 1;; 1012 ; 1013// GET NOMINAL BIN WIDTH IN EXPON FORM; 1014L20:; 1015 awid = (ah-al) / Double_t(na);; 1016 log_ = Int_t(TMath::Log10(awid));; 1017 if (awid <= 1) --log_;; 1018 sigfig = awid*TMath::Power(10, -log_);; 1019// ROUND MANTISSA UP TO 2, 2.5, 5, OR 10; 1020 if (sigfig > 2) goto L40;; 1021 sigrnd = 2;; 1022 goto L100;; 1023L40:; 1024 if (sigfig > 2.5) goto L50;; 1025 sigrnd = 2.5;; 1026 goto L100;; 1027L50:; 1028 if (sigfig > 5) goto L60;; 1029 sigrnd = 5;; 1030 goto L100;; 1031L60:; 1032 sigrnd = 1;; 1033 ++log_;; 1034L100:; 1035 bwid = sigrnd*TMath::Power(10, log_);; 1036 goto L200;; 1037// GET NEW BOUNDS FROM NEW WIDTH BWID; 1038L150:; 1",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:38122,Modifiability,variab,variables,38122,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:39577,Modifiability,variab,variables,39577,"i <= fNpar; ++i) {denom += fGrd[i-1]*(fXt[i-1] - pvec[i-1]); }; 1090 if (denom <= 0) {; 1091 fDcovar = 1;; 1092 fISW[1] = 0;; 1093 denom = 1;; 1094 }; 1095 ycalf = (f - fApsi) / denom;; 1096}; 1097 ; 1098////////////////////////////////////////////////////////////////////////////////; 1099/// Resets the parameter list to UNDEFINED; 1100///; 1101/// Called from MINUIT and by option from MNEXCM; 1102 ; 1103void TMinuit::mncler(); 1104{; 1105 Int_t i;; 1106 ; 1107 fNpfix = 0;; 1108 fNu = 0;; 1109 fNpar = 0;; 1110 fNfcn = 0;; 1111 fNwrmes[0] = 0;; 1112 fNwrmes[1] = 0;; 1113 for (i = 1; i <= fMaxext; ++i) {; 1114 fU[i-1] = 0;; 1115 fCpnam[i-1] = fCundef;; 1116 fNvarl[i-1] = -1;; 1117 fNiofex[i-1] = 0;; 1118 }; 1119 mnrset(1);; 1120 fCfrom = ""CLEAR "";; 1121 fNfcnfr = fNfcn;; 1122 fCstatu = ""UNDEFINED "";; 1123 fLnolim = kTRUE;; 1124 fLphead = kTRUE;; 1125}; 1126 ; 1127////////////////////////////////////////////////////////////////////////////////; 1128/// Print function contours in two variables, on line printer; 1129///; 1130/// input arguments: parx, pary, devs, ngrid; 1131 ; 1132void TMinuit::mncntr(Int_t ike1, Int_t ike2, Int_t &ierrf); 1133{; 1134 static const char *const clabel = ""0123456789ABCDEFGHIJ"";; 1135 ; 1136 /* Local variables */; 1137 Double_t d__1, d__2;; 1138 Double_t fcna[115], fcnb[115], contur[20];; 1139 Double_t ylabel, fmn, fmx, xlo, ylo, xup, yup;; 1140 Double_t devs, xsav, ysav, bwidx, bwidy, unext, ff, xb4;; 1141 Int_t i, ngrid, ixmid, nparx, ix, nx, ny, ki1, ki2, ixzero, iy, ics;; 1142 TString chmid, chln, chzero;; 1143 ; 1144 Int_t ke1 = ike1+1;; 1145 Int_t ke2 = ike2+1;; 1146 if (ke1 <= 0 || ke2 <= 0) goto L1350;; 1147 if (ke1 > fNu || ke2 > fNu) goto L1350;; 1148 ki1 = fNiofex[ke1-1];; 1149 ki2 = fNiofex[ke2-1];; 1150 if (ki1 <= 0 || ki2 <= 0) goto L1350;; 1151 if (ki1 == ki2) goto L1350;; 1152 ; 1153 if (fISW[1] < 1) {; 1154 mnhess();; 1155 mnwerr();; 1156 }; 1157 nparx = fNpar;; 1158 xsav = fU[ke1-1];; 1159 ysav = fU[ke2-1];; 1160 devs = fWo",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:39827,Modifiability,variab,variables,39827,"//////////////////////////////////; 1099/// Resets the parameter list to UNDEFINED; 1100///; 1101/// Called from MINUIT and by option from MNEXCM; 1102 ; 1103void TMinuit::mncler(); 1104{; 1105 Int_t i;; 1106 ; 1107 fNpfix = 0;; 1108 fNu = 0;; 1109 fNpar = 0;; 1110 fNfcn = 0;; 1111 fNwrmes[0] = 0;; 1112 fNwrmes[1] = 0;; 1113 for (i = 1; i <= fMaxext; ++i) {; 1114 fU[i-1] = 0;; 1115 fCpnam[i-1] = fCundef;; 1116 fNvarl[i-1] = -1;; 1117 fNiofex[i-1] = 0;; 1118 }; 1119 mnrset(1);; 1120 fCfrom = ""CLEAR "";; 1121 fNfcnfr = fNfcn;; 1122 fCstatu = ""UNDEFINED "";; 1123 fLnolim = kTRUE;; 1124 fLphead = kTRUE;; 1125}; 1126 ; 1127////////////////////////////////////////////////////////////////////////////////; 1128/// Print function contours in two variables, on line printer; 1129///; 1130/// input arguments: parx, pary, devs, ngrid; 1131 ; 1132void TMinuit::mncntr(Int_t ike1, Int_t ike2, Int_t &ierrf); 1133{; 1134 static const char *const clabel = ""0123456789ABCDEFGHIJ"";; 1135 ; 1136 /* Local variables */; 1137 Double_t d__1, d__2;; 1138 Double_t fcna[115], fcnb[115], contur[20];; 1139 Double_t ylabel, fmn, fmx, xlo, ylo, xup, yup;; 1140 Double_t devs, xsav, ysav, bwidx, bwidy, unext, ff, xb4;; 1141 Int_t i, ngrid, ixmid, nparx, ix, nx, ny, ki1, ki2, ixzero, iy, ics;; 1142 TString chmid, chln, chzero;; 1143 ; 1144 Int_t ke1 = ike1+1;; 1145 Int_t ke2 = ike2+1;; 1146 if (ke1 <= 0 || ke2 <= 0) goto L1350;; 1147 if (ke1 > fNu || ke2 > fNu) goto L1350;; 1148 ki1 = fNiofex[ke1-1];; 1149 ki2 = fNiofex[ke2-1];; 1150 if (ki1 <= 0 || ki2 <= 0) goto L1350;; 1151 if (ki1 == ki2) goto L1350;; 1152 ; 1153 if (fISW[1] < 1) {; 1154 mnhess();; 1155 mnwerr();; 1156 }; 1157 nparx = fNpar;; 1158 xsav = fU[ke1-1];; 1159 ysav = fU[ke2-1];; 1160 devs = fWord7[2];; 1161 if (devs <= 0) devs = 2;; 1162 xlo = fU[ke1-1] - devs*fWerr[ki1-1];; 1163 xup = fU[ke1-1] + devs*fWerr[ki1-1];; 1164 ylo = fU[ke2-1] - devs*fWerr[ki2-1];; 1165 yup = fU[ke2-1] + devs*fWerr[ki2-1];; 1166 ngrid = Int_t(fWord7[3]);; 1167 i",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:45610,Modifiability,variab,variables,45610,"78 fU[ke1-1] = xsav;; 1279 fU[ke2-1] = ysav;; 1280 ierrf = 0;; 1281 return;; 1282L1350:; 1283 Printf("" INVALID PARAMETER NUMBER(S) REQUESTED. IGNORED."");; 1284 ierrf = 1;; 1285}; 1286 ; 1287////////////////////////////////////////////////////////////////////////////////; 1288/// Reads a command string and executes; 1289///; 1290/// Called by user. 'Reads' a command string and executes.; 1291/// Equivalent to MNEXCM except that the command is given as a; 1292/// character string.; 1293///; 1294/// ICONDN =; 1295/// - 0: command executed normally; 1296/// - 1: command is blank, ignored; 1297/// - 2: command line unreadable, ignored; 1298/// - 3: unknown command, ignored; 1299/// - 4: abnormal termination (e.g., MIGRAD not converged); 1300/// - 5: command is a request to read PARAMETER definitions; 1301/// - 6: 'SET INPUT' command; 1302/// - 7: 'SET TITLE' command; 1303/// - 8: 'SET COVAR' command; 1304/// - 9: reserved; 1305/// - 10: END command; 1306/// - 11: EXIT or STOP command; 1307/// - 12: RETURN command; 1308///; 1309 ; 1310void TMinuit::mncomd(const char *crdbin, Int_t &icondn); 1311{; 1312 /* Local variables */; 1313 Int_t ierr, ipos, i, llist, lenbuf, lnc;; 1314 Bool_t leader;; 1315 TString comand, crdbuf, ctemp;; 1316 ; 1317 crdbuf = crdbin;; 1318 crdbuf.ToUpper();; 1319 lenbuf = crdbuf.Length();; 1320 icondn = 0;; 1321// record not case-sensitive, get upper case, strip leading blanks; 1322 leader = kTRUE;; 1323 ipos = 1;; 1324 for (i = 1; i <= TMath::Min(20,lenbuf); ++i) {; 1325 if (crdbuf[i-1] == '\'') break;; 1326 if (crdbuf[i-1] == ' ') {; 1327 if (leader) ++ipos;; 1328 continue;; 1329 }; 1330 leader = kFALSE;; 1331 }; 1332 ; 1333// blank or null command; 1334 if (ipos > lenbuf) {; 1335 Printf("" BLANK COMMAND IGNORED."");; 1336 icondn = 1;; 1337 return;; 1338 }; 1339// preemptive commands; 1340// if command is 'PARAMETER'; 1341 if (crdbuf(ipos-1,3) == ""PAR"") {; 1342 icondn = 5;; 1343 fLphead = kTRUE;; 1344 return;; 1345 }; 1346// if command is 'SET INPUT'",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:47597,Modifiability,variab,variable,47597," icondn = 5;; 1343 fLphead = kTRUE;; 1344 return;; 1345 }; 1346// if command is 'SET INPUT'; 1347 if (crdbuf(ipos-1,3) == ""SET INP"") {; 1348 icondn = 6;; 1349 fLphead = kTRUE;; 1350 return;; 1351 }; 1352// if command is 'SET TITLE'; 1353 if (crdbuf(ipos-1,7) == ""SET TIT"") {; 1354 icondn = 7;; 1355 fLphead = kTRUE;; 1356 return;; 1357 }; 1358// if command is 'SET COVARIANCE'; 1359 if (crdbuf(ipos-1,7) == ""SET COV"") {; 1360 icondn = 8;; 1361 fLphead = kTRUE;; 1362 return;; 1363 }; 1364// crack the command; 1365 ctemp = crdbuf(ipos-1,lenbuf-ipos+1);; 1366 mncrck(ctemp, 20, comand, lnc, fMaxpar, fCOMDplist, llist, ierr, fIsyswr);; 1367 if (ierr > 0) {; 1368 Printf("" COMMAND CANNOT BE INTERPRETED"");; 1369 icondn = 2;; 1370 return;; 1371 }; 1372 ; 1373 mnexcm(comand.Data(), fCOMDplist, llist, ierr);; 1374 icondn = ierr;; 1375}; 1376 ; 1377////////////////////////////////////////////////////////////////////////////////; 1378/// Find points along a contour where FCN is minimum; 1379///; 1380/// Find NPTU points along a contour where the function; 1381///; 1382/// FMIN (X(KE1),X(KE2)) = AMIN+UP; 1383///; 1384/// where FMIN is the minimum of FCN with respect to all; 1385/// the other NPAR-2 variable parameters (if any).; 1386///; 1387/// IERRF on return will be equal to the number of points found:; 1388/// - NPTU if normal termination with NPTU points found; 1389/// - -1 if errors in the calling sequence (KE1, KE2 not variable); 1390/// - 0 if less than four points can be found (using MNMNOT); 1391/// - n>3 if only n points can be found (n < NPTU); 1392///; 1393/// input arguments: parx, pary, devs, ngrid; 1394 ; 1395void TMinuit::mncont(Int_t ike1, Int_t ike2, Int_t nptu, Double_t *xptu, Double_t *yptu, Int_t &ierrf); 1396{; 1397 /* System generated locals */; 1398 Int_t i__1;; 1399 ; 1400 /* Local variables */; 1401 Double_t d__1, d__2;; 1402 Double_t dist, xdir, ydir, aopt, u1min, u2min;; 1403 Double_t abest, scalx, scaly;; 1404 Double_t a1, a2, val2mi, val2pl, dc, sclfac,",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:47829,Modifiability,variab,variable,47829,"),X(KE2)) = AMIN+UP; 1383///; 1384/// where FMIN is the minimum of FCN with respect to all; 1385/// the other NPAR-2 variable parameters (if any).; 1386///; 1387/// IERRF on return will be equal to the number of points found:; 1388/// - NPTU if normal termination with NPTU points found; 1389/// - -1 if errors in the calling sequence (KE1, KE2 not variable); 1390/// - 0 if less than four points can be found (using MNMNOT); 1391/// - n>3 if only n points can be found (n < NPTU); 1392///; 1393/// input arguments: parx, pary, devs, ngrid; 1394 ; 1395void TMinuit::mncont(Int_t ike1, Int_t ike2, Int_t nptu, Double_t *xptu, Double_t *yptu, Int_t &ierrf); 1396{; 1397 /* System generated locals */; 1398 Int_t i__1;; 1399 ; 1400 /* Local variables */; 1401 Double_t d__1, d__2;; 1402 Double_t dist, xdir, ydir, aopt, u1min, u2min;; 1403 Double_t abest, scalx, scaly;; 1404 Double_t a1, a2, val2mi, val2pl, dc, sclfac, bigdis, sigsav;; 1405 Int_t nall, iold, line, mpar, ierr, inew, move, next, i, j, nfcol, iercr;; 1406 Int_t idist=0, npcol, kints, i2, i1, lr, nfcnco=0, ki1, ki2, ki3, ke3;; 1407 Int_t nowpts, istrav, nfmxin, isw2, isw4;; 1408 Bool_t ldebug;; 1409 ; 1410 /* Function Body */; 1411 Int_t ke1 = ike1+1;; 1412 Int_t ke2 = ike2+1;; 1413 ldebug = fIdbg[6] >= 1;; 1414 if (ke1 <= 0 || ke2 <= 0) goto L1350;; 1415 if (ke1 > fNu || ke2 > fNu) goto L1350;; 1416 ki1 = fNiofex[ke1-1];; 1417 ki2 = fNiofex[ke2-1];; 1418 if (ki1 <= 0 || ki2 <= 0) goto L1350;; 1419 if (ki1 == ki2) goto L1350;; 1420 if (nptu < 4) goto L1400;; 1421 ; 1422 nfcnco = fNfcn;; 1423 fNfcnmx = (nptu + 5)*100*(fNpar + 1);; 1424// The minimum; 1425 mncuve();; 1426 u1min = fU[ke1-1];; 1427 u2min = fU[ke2-1];; 1428 ierrf = 0;; 1429 fCfrom = ""MNContour "";; 1430 fNfcnfr = nfcnco;; 1431 if (fISW[4] >= 0) {; 1432 Printf("" START MNCONTOUR CALCULATION OF %4d POINTS ON CONTOUR."",nptu);; 1433 if (fNpar > 2) {; 1434 if (fNpar == 3) {; 1435 ki3 = 6 - ki1 - ki2;; 1436 ke3 = fNexofi[ki3-1];; 1437 Printf("" EACH POINT IS A MINI",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:48218,Modifiability,variab,variables,48218,"),X(KE2)) = AMIN+UP; 1383///; 1384/// where FMIN is the minimum of FCN with respect to all; 1385/// the other NPAR-2 variable parameters (if any).; 1386///; 1387/// IERRF on return will be equal to the number of points found:; 1388/// - NPTU if normal termination with NPTU points found; 1389/// - -1 if errors in the calling sequence (KE1, KE2 not variable); 1390/// - 0 if less than four points can be found (using MNMNOT); 1391/// - n>3 if only n points can be found (n < NPTU); 1392///; 1393/// input arguments: parx, pary, devs, ngrid; 1394 ; 1395void TMinuit::mncont(Int_t ike1, Int_t ike2, Int_t nptu, Double_t *xptu, Double_t *yptu, Int_t &ierrf); 1396{; 1397 /* System generated locals */; 1398 Int_t i__1;; 1399 ; 1400 /* Local variables */; 1401 Double_t d__1, d__2;; 1402 Double_t dist, xdir, ydir, aopt, u1min, u2min;; 1403 Double_t abest, scalx, scaly;; 1404 Double_t a1, a2, val2mi, val2pl, dc, sclfac, bigdis, sigsav;; 1405 Int_t nall, iold, line, mpar, ierr, inew, move, next, i, j, nfcol, iercr;; 1406 Int_t idist=0, npcol, kints, i2, i1, lr, nfcnco=0, ki1, ki2, ki3, ke3;; 1407 Int_t nowpts, istrav, nfmxin, isw2, isw4;; 1408 Bool_t ldebug;; 1409 ; 1410 /* Function Body */; 1411 Int_t ke1 = ike1+1;; 1412 Int_t ke2 = ike2+1;; 1413 ldebug = fIdbg[6] >= 1;; 1414 if (ke1 <= 0 || ke2 <= 0) goto L1350;; 1415 if (ke1 > fNu || ke2 > fNu) goto L1350;; 1416 ki1 = fNiofex[ke1-1];; 1417 ki2 = fNiofex[ke2-1];; 1418 if (ki1 <= 0 || ki2 <= 0) goto L1350;; 1419 if (ki1 == ki2) goto L1350;; 1420 if (nptu < 4) goto L1400;; 1421 ; 1422 nfcnco = fNfcn;; 1423 fNfcnmx = (nptu + 5)*100*(fNpar + 1);; 1424// The minimum; 1425 mncuve();; 1426 u1min = fU[ke1-1];; 1427 u2min = fU[ke2-1];; 1428 ierrf = 0;; 1429 fCfrom = ""MNContour "";; 1430 fNfcnfr = nfcnco;; 1431 if (fISW[4] >= 0) {; 1432 Printf("" START MNCONTOUR CALCULATION OF %4d POINTS ON CONTOUR."",nptu);; 1433 if (fNpar > 2) {; 1434 if (fNpar == 3) {; 1435 ki3 = 6 - ki1 - ki2;; 1436 ke3 = fNexofi[ki3-1];; 1437 Printf("" EACH POINT IS A MINI",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:57131,Modifiability,variab,variables,57131," ""MNContour "";; 1661 fNfcnfr = nfcnco;; 1662}; 1663 ; 1664////////////////////////////////////////////////////////////////////////////////; 1665/// Cracks the free-format input; 1666///; 1667/// Cracks the free-format input, expecting zero or more; 1668/// alphanumeric fields (which it joins into COMAND(1:LNC)); 1669/// followed by one or more numeric fields separated by; 1670/// blanks and/or one comma. The numeric fields are put into; 1671/// the LLIST (but at most MXP) elements of PLIST.; 1672///; 1673/// IERR :; 1674/// - = 0 if no errors,; 1675/// - = 1 if error(s).; 1676 ; 1677void TMinuit::mncrck(TString cardbuf, Int_t maxcwd, TString &comand, Int_t &lnc,; 1678 Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t); 1679{; 1680 /* Initialized data */; 1681 ; 1682 char *cnull = nullptr;; 1683 const char *cnumer = ""123456789-.0+"";; 1684 ; 1685 /* Local variables */; 1686 Int_t ifld, iend, lend, left, nreq, ipos, kcmnd, nextb, ic, ibegin, ltoadd;; 1687 Int_t ielmnt, lelmnt[25], nelmnt;; 1688 TString ctemp;; 1689 char *celmnt[25];; 1690 char command[25];; 1691 ; 1692 /* Function Body */; 1693 char *crdbuf = (char*)cardbuf.Data();; 1694 lend = cardbuf.Length();; 1695 ielmnt = 0;; 1696 nextb = 1;; 1697 ierr = 0;; 1698// loop over words CELMNT; 1699L10:; 1700 for (ipos = nextb; ipos <= lend; ++ipos) {; 1701 ibegin = ipos;; 1702 if (crdbuf[ipos-1] == ' ') continue;; 1703 if (crdbuf[ipos-1] == ',') goto L250;; 1704 goto L150;; 1705 }; 1706 goto L300;; 1707L150:; 1708// found beginning of word, look for end; 1709 for (ipos = ibegin + 1; ipos <= lend; ++ipos) {; 1710 if (crdbuf[ipos-1] == ' ') goto L250;; 1711 if (crdbuf[ipos-1] == ',') goto L250;; 1712 }; 1713 ipos = lend + 1;; 1714L250:; 1715 iend = ipos - 1;; 1716 ++ielmnt;; 1717 if (iend >= ibegin) celmnt[ielmnt-1] = &crdbuf[ibegin-1];; 1718 else celmnt[ielmnt-1] = cnull;; 1719 lelmnt[ielmnt-1] = iend - ibegin + 1;; 1720 if (lelmnt[ielmnt-1] > 19) {; 1721 Printf("" MINUIT WARNING: INPUT DATA WORD TOO LONG."");;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:60774,Modifiability,variab,variables,60774,"anf(celmnt[ifld-1],""%lf"",&plist[llist-1]);; 1779 }; 1780 }; 1781// end loop over numeric fields; 1782L900:; 1783 if (lnc <= 0) lnc = 1;; 1784 comand = command;; 1785}; 1786 ; 1787////////////////////////////////////////////////////////////////////////////////; 1788/// Find point where MNEVAL=AMIN+UP; 1789///; 1790/// Find point where MNEVAL=AMIN+UP, along the line through; 1791/// XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; 1792/// are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; 1793/// only KE1CR is varied. From MNCONT, both are varied.; 1794/// Crossing point is at; 1795///; 1796/// (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); 1797 ; 1798void TMinuit::mncros(Double_t &aopt, Int_t &iercr); 1799{; 1800 /* Local variables */; 1801 Double_t alsb[3], flsb[3], bmin, bmax, zmid, sdev, zdir, zlim;; 1802 Double_t coeff[3], aleft, aulim, fdist, adist, aminsv;; 1803 Double_t anext, fnext, slope, s1, s2, x1, x2, ecarmn, ecarmx;; 1804 Double_t determ, rt, smalla, aright, aim, tla, tlf, dfda,ecart;; 1805 Int_t iout=0, i, ileft, ierev, maxlk, ibest, ik, it;; 1806 Int_t noless, iworst=0, iright, itoohi, kex, ipt;; 1807 Bool_t ldebug;; 1808 const char *chsign;; 1809 x2 = 0;; 1810 ; 1811 ldebug = fIdbg[6] >= 1;; 1812 aminsv = fAmin;; 1813// convergence when F is within TLF of AIM and next prediction; 1814// of AOPT is within TLA of previous value of AOPT; 1815 aim = fAmin + fUp;; 1816 tlf = fUp*.01;; 1817 tla = .01;; 1818 fXpt[0] = 0;; 1819 fYpt[0] = aim;; 1820 fChpt[0] = ' ';; 1821 ipt = 1;; 1822 if (fKe2cr == 0) {; 1823 fXpt[1] = -1;; 1824 fYpt[1] = fAmin;; 1825 fChpt[1] = '.';; 1826 ipt = 2;; 1827 }; 1828// find the largest allowed A; 1829 aulim = 100;; 1830 for (ik = 1; ik <= 2; ++ik) {; 1831 if (ik == 1) {; 1832 kex = fKe1cr;; 1833 zmid = fXmidcr;; 1834 zdir = fXdircr;; 1835 } else {; 1836 if (fKe2cr == 0) continue;; 1837 kex = fKe2cr;; 1838 zmid = fYmidcr;; 1839 zdir = fYdircr;; 1840 }; 1841 if (fNvarl[kex-1] <= 1) continue;; 1842 if (zdir == 0) c",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:71285,Modifiability,variab,variables,71285,"2095 iercr = 3;; 2096// in any case; 2097L1000:; 2098 if (ldebug) {; 2099 itoohi = 0;; 2100 for (i = 1; i <= ipt; ++i) {; 2101 if (fYpt[i-1] > aim + fUp) {; 2102 fYpt[i-1] = aim + fUp;; 2103 fChpt[i-1] = '+';; 2104 itoohi = 1;; 2105 }; 2106 }; 2107 fChpt[ipt] = 0;; 2108 chsign = ""POSI"";; 2109 if (fXdircr < 0) chsign = ""NEGA"";; 2110 if (fKe2cr == 0) {; 2111 Printf("" %sTIVE MINOS ERROR, PARAMETER %3d"",chsign,fKe1cr);; 2112 }; 2113 if (itoohi == 1) {; 2114 Printf(""POINTS LABELLED '+' WERE TOO HIGH TO PLOT."");; 2115 }; 2116 if (iercr == 1) {; 2117 Printf(""RIGHTMOST POINT IS UP AGAINST LIMIT."");; 2118 }; 2119 mnplot(fXpt, fYpt, fChpt, ipt, fNpagwd, fNpagln);; 2120 }; 2121}; 2122 ; 2123////////////////////////////////////////////////////////////////////////////////; 2124/// Makes sure that the current point is a local minimum; 2125///; 2126/// Makes sure that the current point is a local; 2127/// minimum and that the error matrix exists,; 2128/// or at least something good enough for MINOS and MNCONT; 2129 ; 2130void TMinuit::mncuve(); 2131{; 2132 /* Local variables */; 2133 Double_t dxdi, wint;; 2134 Int_t ndex, iext, i, j;; 2135 ; 2136 if (fISW[3] < 1) {; 2137 Printf("" FUNCTION MUST BE MINIMIZED BEFORE CALLING %s"",(const char*)fCfrom);; 2138 fApsi = fEpsi;; 2139 mnmigr();; 2140 }; 2141 if (fISW[1] < 3) {; 2142 mnhess();; 2143 if (fISW[1] < 1) {; 2144 mnwarn(""W"", fCfrom, ""NO ERROR MATRIX. WILL IMPROVISE."");; 2145 for (i = 1; i <= fNpar; ++i) {; 2146 ndex = i*(i-1) / 2;; 2147 for (j = 1; j <= i-1; ++j) {; 2148 ++ndex;; 2149 fVhmat[ndex-1] = 0;; 2150 }; 2151 ++ndex;; 2152 if (fG2[i-1] <= 0) {; 2153 wint = fWerr[i-1];; 2154 iext = fNexofi[i-1];; 2155 if (fNvarl[iext-1] > 1) {; 2156 mndxdi(fX[i-1], i-1, dxdi);; 2157 if (TMath::Abs(dxdi) < .001) wint = .01;; 2158 else wint /= TMath::Abs(dxdi);; 2159 }; 2160 fG2[i-1] = fUp / (wint*wint);; 2161 }; 2162 fVhmat[ndex-1] = 2 / fG2[i-1];; 2163 }; 2164 fISW[1] = 1;; 2165 fDcovar = 1;; 2166 } else mnwerr();; 2167 }; 2168}; 2169 ; 2170",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:72652,Modifiability,variab,variables,72652,"di);; 2157 if (TMath::Abs(dxdi) < .001) wint = .01;; 2158 else wint /= TMath::Abs(dxdi);; 2159 }; 2160 fG2[i-1] = fUp / (wint*wint);; 2161 }; 2162 fVhmat[ndex-1] = 2 / fG2[i-1];; 2163 }; 2164 fISW[1] = 1;; 2165 fDcovar = 1;; 2166 } else mnwerr();; 2167 }; 2168}; 2169 ; 2170////////////////////////////////////////////////////////////////////////////////; 2171/// Calculates the first derivatives of FCN (GRD); 2172///; 2173/// Calculates the first derivatives of FCN (GRD),; 2174/// either by finite differences or by transforming the user-; 2175/// supplied derivatives to internal coordinates,; 2176/// according to whether fISW[2] is zero or one.; 2177 ; 2178void TMinuit::mnderi(); 2179{; 2180 /* Local variables */; 2181 Double_t step, dfmin, stepb4, dd, df, fs1;; 2182 Double_t tlrstp, tlrgrd, epspri, optstp, stpmax, stpmin, fs2, grbfor=0, d1d2, xtf;; 2183 Int_t icyc, ncyc, iint, iext, i, nparx;; 2184 Bool_t ldebug;; 2185 ; 2186 nparx = fNpar;; 2187 ldebug = fIdbg[2] >= 1;; 2188 if (fAmin == fUndefi) mnamin();; 2189 if (fISW[2] == 1) goto L100;; 2190 ; 2191 if (ldebug) {; 2192// make sure starting at the right place; 2193 mninex(fX);; 2194 nparx = fNpar;; 2195 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 2196 if (fs1 != fAmin) {; 2197 df = fAmin - fs1;; 2198 mnwarn(""D"", ""MNDERI"", TString::Format(""function value differs from AMIN by %12.3g"",df));; 2199 fAmin = fs1;; 2200 }; 2201 Printf("" FIRST DERIVATIVE DEBUG PRINTOUT. MNDERI"");; 2202 Printf("" PAR DERIV STEP MINSTEP OPTSTEP D1-D2 2ND DRV"");; 2203 }; 2204 dfmin = fEpsma2*8*(TMath::Abs(fAmin) + fUp);; 2205 if (fIstrat <= 0) {; 2206 ncyc = 2;; 2207 tlrstp = .5;; 2208 tlrgrd = .1;; 2209 } else if (fIstrat == 1) {; 2210 ncyc = 3;; 2211 tlrstp = .3;; 2212 tlrgrd = .05;; 2213 } else {; 2214 ncyc = 5;; 2215 tlrstp = .1;; 2216 tlrgrd = .02;; 2217 }; 2218// loop over variable parameters; 2219 for (i = 1; i <= fNpar; ++i) {; 2220 epspri = fEpsma2 + TMath::Abs(fGrd[i-1]*fEpsma2);; 2221// two-point derivatives always assumed necessary; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:73775,Modifiability,variab,variable,73775,"arting at the right place; 2193 mninex(fX);; 2194 nparx = fNpar;; 2195 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 2196 if (fs1 != fAmin) {; 2197 df = fAmin - fs1;; 2198 mnwarn(""D"", ""MNDERI"", TString::Format(""function value differs from AMIN by %12.3g"",df));; 2199 fAmin = fs1;; 2200 }; 2201 Printf("" FIRST DERIVATIVE DEBUG PRINTOUT. MNDERI"");; 2202 Printf("" PAR DERIV STEP MINSTEP OPTSTEP D1-D2 2ND DRV"");; 2203 }; 2204 dfmin = fEpsma2*8*(TMath::Abs(fAmin) + fUp);; 2205 if (fIstrat <= 0) {; 2206 ncyc = 2;; 2207 tlrstp = .5;; 2208 tlrgrd = .1;; 2209 } else if (fIstrat == 1) {; 2210 ncyc = 3;; 2211 tlrstp = .3;; 2212 tlrgrd = .05;; 2213 } else {; 2214 ncyc = 5;; 2215 tlrstp = .1;; 2216 tlrgrd = .02;; 2217 }; 2218// loop over variable parameters; 2219 for (i = 1; i <= fNpar; ++i) {; 2220 epspri = fEpsma2 + TMath::Abs(fGrd[i-1]*fEpsma2);; 2221// two-point derivatives always assumed necessary; 2222// maximum number of cycles over step size depends on strategy; 2223 xtf = fX[i-1];; 2224 stepb4 = 0;; 2225// loop as little as possible here!/; 2226 for (icyc = 1; icyc <= ncyc; ++icyc) {; 2227// theoretically best step; 2228 optstp = TMath::Sqrt(dfmin / (TMath::Abs(fG2[i-1]) + epspri));; 2229// step cannot decrease by more than a factor of ten; 2230 step = TMath::Max(optstp,TMath::Abs(fGstep[i-1]*.1));; 2231// but if parameter has limits, max step size = 0.5; 2232 if (fGstep[i-1] < 0 && step > .5) step = .5;; 2233// and not more than ten times the previous step; 2234 stpmax = TMath::Abs(fGstep[i-1])*10;; 2235 if (step > stpmax) step = stpmax;; 2236// minimum step size allowed by machine precision; 2237 stpmin = TMath::Abs(fEpsma2*fX[i-1])*8;; 2238 if (step < stpmin) step = stpmin;; 2239// end of iterations if step change less than factor 2; 2240 if (TMath::Abs((step - stepb4) / step) < tlrstp) goto L50;; 2241// take step positive; 2242 stepb4 = step;; 2243 if (fGstep[i-1] > 0) fGstep[i-1] = TMath::Abs(step);; 2244 else fGstep[i-1] = -TMath::Abs(step);; 2245 stepb4 = step;; 2246 fX[",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:77273,Modifiability,variab,variables,77273,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:82013,Modifiability,variab,variables,82013,"];; 2442 r = TMath::Sqrt(c*c + 1);; 2443 work[n + j] = s*work[n + i]*r;; 2444 s = 1 / r;; 2445 c /= r;; 2446 goto L190;; 2447L180:; 2448 c = work[n + i] / pt;; 2449 r = TMath::Sqrt(c*c + 1);; 2450 work[n + j] = s*pt*r;; 2451 s = c / r;; 2452 c = 1 / r;; 2453L190:; 2454 pt = c*work[i] - s*gl;; 2455 work[j] = h + s*(c*gl + s*work[i]);; 2456 for (k = 1; k <= n; ++k) {; 2457 h = a[k + j*ndima];; 2458 a[k + j*ndima] = s*a[k + i*ndima] + c*h;; 2459 a[k + i*ndima] = c*a[k + i*ndima] - s*h;; 2460 }; 2461 }; 2462 work[n + l] = s*pt;; 2463 work[l] = c*pt;; 2464 ; 2465 if (TMath::Abs(work[n + l]) > b) goto L160;; 2466 ; 2467L205:; 2468 work[l] += f;; 2469 }; 2470 for (i = 1; i <= n1; ++i) {; 2471 k = i;; 2472 pt = work[i];; 2473 i1 = i + 1;; 2474 for (j = i1; j <= n; ++j) {; 2475 if (work[j] >= pt) continue;; 2476 k = j;; 2477 pt = work[j];; 2478 }; 2479 ; 2480 if (k == i) continue;; 2481 ; 2482 work[k] = work[i];; 2483 work[i] = pt;; 2484 for (j = 1; j <= n; ++j) {; 2485 pt = a[j + i*ndima];; 2486 a[j + i*ndima] = a[j + k*ndima];; 2487 a[j + k*ndima] = pt;; 2488 }; 2489 }; 2490 ifault = 0;; 2491}; 2492 ; 2493////////////////////////////////////////////////////////////////////////////////; 2494/// Calculates the external error matrix from the internal matrix; 2495///; 2496/// Note that if the matrix is declared like Double_t matrix[5][5]; 2497/// in the calling program, one has to call mnemat with, eg; 2498///; 2499/// gMinuit->mnemat(&matrix[0][0],5);; 2500 ; 2501void TMinuit::mnemat(Double_t *emat, Int_t ndim); 2502{; 2503 /* System generated locals */; 2504 Int_t emat_dim1, emat_offset;; 2505 ; 2506 /* Local variables */; 2507 Double_t dxdi, dxdj;; 2508 Int_t i, j, k, npard, k2, kk, iz, nperln, kga, kgb;; 2509 TString ctemp;; 2510 ; 2511 /* Parameter adjustments */; 2512 emat_dim1 = ndim;; 2513 emat_offset = emat_dim1 + 1;; 2514 emat -= emat_offset;; 2515 ; 2516 /* Function Body */; 2517 if (fISW[1] < 1) return;; 2518 if (fISW[4] >= 2) {; 2519 Printf("" EXTERNAL ERROR MATRIX.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:85490,Modifiability,variab,variable,85490,"TMinuit::mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc); 2579{; 2580 Double_t dxdi;; 2581 Int_t ndiag, iin, iex;; 2582 ; 2583 iex = number+1;; 2584 ; 2585 if (iex > fNu || iex <= 0) goto L900;; 2586 iin = fNiofex[iex-1];; 2587 if (iin <= 0) goto L900;; 2588 ; 2589// IEX is external number, IIN is internal number; 2590 eplus = fErp[iin-1];; 2591 if (eplus == fUndefi) eplus = 0;; 2592 eminus = fErn[iin-1];; 2593 if (eminus == fUndefi) eminus = 0;; 2594 mndxdi(fX[iin-1], iin-1, dxdi);; 2595 ndiag = iin*(iin + 1) / 2;; 2596 eparab = TMath::Abs(dxdi*TMath::Sqrt(TMath::Abs(fUp*fVhmat[ndiag- 1])));; 2597// global correlation coefficient; 2598 gcc = 0;; 2599 if (fISW[1] < 2) return;; 2600 gcc = fGlobcc[iin-1];; 2601 return;; 2602// ERROR. parameter number not valid; 2603L900:; 2604 eplus = 0;; 2605 eminus = 0;; 2606 eparab = 0;; 2607 gcc = 0;; 2608}; 2609 ; 2610////////////////////////////////////////////////////////////////////////////////; 2611/// Evaluates the function being analysed by MNCROS; 2612///; 2613/// Evaluates the function being analysed by MNCROS, which is; 2614/// generally the minimum of FCN with respect to all remaining; 2615/// variable parameters. The class data members contains the; 2616/// data necessary to know the values of U(KE1CR) and U(KE2CR); 2617/// to be used, namely U(KE1CR) = XMIDCR + ANEXT*XDIRCR; 2618/// and (if KE2CR .NE. 0) U(KE2CR) = YMIDCR + ANEXT*YDIRCR; 2619 ; 2620void TMinuit::mneval(Double_t anext, Double_t &fnext, Int_t &ierev); 2621{; 2622 Int_t nparx;; 2623 ; 2624 fU[fKe1cr-1] = fXmidcr + anext*fXdircr;; 2625 if (fKe2cr != 0) fU[fKe2cr-1] = fYmidcr + anext*fYdircr;; 2626 mninex(fX);; 2627 nparx = fNpar;; 2628 Eval(nparx, fGin, fnext, fU, 4); ++fNfcn;; 2629 ierev = 0;; 2630 if (fNpar > 0) {; 2631 fItaur = 1;; 2632 fAmin = fnext;; 2633 fISW[0] = 0;; 2634 mnmigr();; 2635 fItaur = 0;; 2636 fnext = fAmin;; 2637 if (fISW[0] >= 1) ierev = 1;; 2638 if (fISW[3] < 1) ierev = 2;; 2639 }; 2640}; 2641 ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:88117,Modifiability,variab,variables,88117,"4: abnormal termination (e.g., MIGRAD not converged); 2656/// - 9: reserved; 2657/// - 10: END command; 2658/// - 11: EXIT or STOP command; 2659/// - 12: RETURN command; 2660///; 2661/// see also; 2662/// [the possible list of all Minuit commands](https://root.cern/sites/d35c7d8c.web.cern.ch/files/minuit.pdf).; 2663 ; 2664void TMinuit::mnexcm(const char *command, Double_t *plist, Int_t llist, Int_t &ierflg); 2665{; 2666 /* Initialized data */; 2667 ; 2668 TString comand = command;; 2669 static const char *const cname[40] = {; 2670 ""MINImize "",; 2671 ""SEEk "",; 2672 ""SIMplex "",; 2673 ""MIGrad "",; 2674 ""MINOs "",; 2675 ""SET xxx "",; 2676 ""SHOw xxx "",; 2677 ""TOP of pag"",; 2678 ""FIX "",; 2679 ""REStore "",; 2680 ""RELease "",; 2681 ""SCAn "",; 2682 ""CONtour "",; 2683 ""HESse "",; 2684 ""SAVe "",; 2685 ""IMProve "",; 2686 ""CALl fcn "",; 2687 ""STAndard "",; 2688 ""END "",; 2689 ""EXIt "",; 2690 ""RETurn "",; 2691 ""CLEar "",; 2692 ""HELP "",; 2693 ""MNContour "",; 2694 ""STOp "",; 2695 ""JUMp "",; 2696 "" "",; 2697 "" "",; 2698 "" "",; 2699 "" "",; 2700 "" "",; 2701 "" "",; 2702 "" "",; 2703 ""COVARIANCE"",; 2704 ""PRINTOUT "",; 2705 ""GRADIENT "",; 2706 ""MATOUT "",; 2707 ""ERROR DEF "",; 2708 ""LIMITS "",; 2709 ""PUNCH ""};; 2710 ; 2711 Int_t nntot = 40;; 2712 ; 2713 /* Local variables */; 2714 Double_t step, xptu[101], yptu[101], f, rno;; 2715 Int_t icol, kcol, ierr, iint, iext, lnow, nptu, i, iflag, ierrf;; 2716 Int_t ilist, nparx, izero, nf, lk, it, iw, inonde, nsuper;; 2717 Int_t it2, ke1, ke2, nowprt, kll, krl;; 2718 TString chwhy, c26, cvblnk, cneway, comd;; 2719 TString ctemp;; 2720 Bool_t lfreed, ltofix, lfixed;; 2721 ; 2722// alphabetical order of command names!; 2723 ; 2724 /* Function Body */; 2725 ; 2726 lk = comand.Length();; 2727 if (lk > 20) lk = 20;; 2728 fCword = comand;; 2729 fCword.ToUpper();; 2730// Copy the first MAXP arguments into WORD7, making; 2731// sure that WORD7(1)=0 if LLIST=0; 2732 for (iw = 1; iw <= fMaxpar; ++iw) {; 2733 fWord7[iw-1] = 0;; 2734 if (iw <= llist) fWord7[iw-1] = plist[iw-1];; 2735 }; 273",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:99635,Modifiability,variab,variables,99635," goto L700;; 3142//; 3143}; 3144 ; 3145////////////////////////////////////////////////////////////////////////////////; 3146/// Transforms the external parameter values U to internal values; 3147///; 3148/// Transforms the external parameter values U to internal; 3149/// values in the dense array PINT.; 3150 ; 3151void TMinuit::mnexin(Double_t *pint); 3152{; 3153 Double_t pinti;; 3154 Int_t iint, iext;; 3155 ; 3156 fLimset = kFALSE;; 3157 for (iint = 1; iint <= fNpar; ++iint) {; 3158 iext = fNexofi[iint-1];; 3159 mnpint(fU[iext-1], iext-1, pinti);; 3160 pint[iint-1] = pinti;; 3161 }; 3162}; 3163 ; 3164////////////////////////////////////////////////////////////////////////////////; 3165/// Removes parameter IINT from the internal parameter list; 3166///; 3167/// and arranges the rest of the list to fill the hole.; 3168 ; 3169void TMinuit::mnfixp(Int_t iint1, Int_t &ierr); 3170{; 3171 /* Local variables */; 3172 Double_t yyover;; 3173 Int_t kold, nold, ndex, knew, iext, i, j, m, n, lc, ik;; 3174 ; 3175// first see if it can be done; 3176 ierr = 0;; 3177 Int_t iint = iint1+1;; 3178 if (iint > fNpar || iint <= 0) {; 3179 ierr = 1;; 3180 Printf("" MINUIT ERROR. ARGUMENT TO MNFIXP=%4d"",iint);; 3181 return;; 3182 }; 3183 iext = fNexofi[iint-1];; 3184 if (fNpfix >= fMaxpar) {; 3185 ierr = 1;; 3186 Printf("" MINUIT CANNOT FIX PARAMETER %4d MAXIMUM NUMBER THAT CAN BE FIXED IS %d"",iext,fMaxpar);; 3187 return;; 3188 }; 3189// reduce number of variable parameters by one; 3190 ; 3191 fNiofex[iext-1] = 0;; 3192 nold = fNpar;; 3193 --fNpar;; 3194// save values in case parameter is later restored; 3195 ; 3196 ++fNpfix;; 3197 fIpfix[fNpfix-1] = iext;; 3198 lc = iint;; 3199 fXs[fNpfix-1] = fX[lc-1];; 3200 fXts[fNpfix-1] = fXt[lc-1];; 3201 fDirins[fNpfix-1] = fWerr[lc-1];; 3202 fGrds[fNpfix-1] = fGrd[lc-1];; 3203 fG2s[fNpfix-1] = fG2[lc-1];; 3204 fGsteps[fNpfix-1] = fGstep[lc-1];; 3205// shift values for other parameters to fill hole; 3206 for (ik = iext + 1; ik <= fNu; ++ik) {; 3207 i",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:100183,Modifiability,variab,variable,100183,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:101798,Modifiability,variab,variable,101798,"-1];; 3184 if (fNpfix >= fMaxpar) {; 3185 ierr = 1;; 3186 Printf("" MINUIT CANNOT FIX PARAMETER %4d MAXIMUM NUMBER THAT CAN BE FIXED IS %d"",iext,fMaxpar);; 3187 return;; 3188 }; 3189// reduce number of variable parameters by one; 3190 ; 3191 fNiofex[iext-1] = 0;; 3192 nold = fNpar;; 3193 --fNpar;; 3194// save values in case parameter is later restored; 3195 ; 3196 ++fNpfix;; 3197 fIpfix[fNpfix-1] = iext;; 3198 lc = iint;; 3199 fXs[fNpfix-1] = fX[lc-1];; 3200 fXts[fNpfix-1] = fXt[lc-1];; 3201 fDirins[fNpfix-1] = fWerr[lc-1];; 3202 fGrds[fNpfix-1] = fGrd[lc-1];; 3203 fG2s[fNpfix-1] = fG2[lc-1];; 3204 fGsteps[fNpfix-1] = fGstep[lc-1];; 3205// shift values for other parameters to fill hole; 3206 for (ik = iext + 1; ik <= fNu; ++ik) {; 3207 if (fNiofex[ik-1] > 0) {; 3208 lc = fNiofex[ik-1] - 1;; 3209 fNiofex[ik-1] = lc;; 3210 fNexofi[lc-1] = ik;; 3211 fX[lc-1] = fX[lc];; 3212 fXt[lc-1] = fXt[lc];; 3213 fDirin[lc-1] = fDirin[lc];; 3214 fWerr[lc-1] = fWerr[lc];; 3215 fGrd[lc-1] = fGrd[lc];; 3216 fG2[lc-1] = fG2[lc];; 3217 fGstep[lc-1] = fGstep[lc];; 3218 }; 3219 }; 3220 if (fISW[1] <= 0) return;; 3221// remove one row and one column from variance matrix; 3222 if (fNpar <= 0) return;; 3223 for (i = 1; i <= nold; ++i) {; 3224 m = TMath::Max(i,iint);; 3225 n = TMath::Min(i,iint);; 3226 ndex = m*(m-1) / 2 + n;; 3227 fFIXPyy[i-1] = fVhmat[ndex-1];; 3228 }; 3229 yyover = 1 / fFIXPyy[iint-1];; 3230 knew = 0;; 3231 kold = 0;; 3232 for (i = 1; i <= nold; ++i) {; 3233 for (j = 1; j <= i; ++j) {; 3234 ++kold;; 3235 if (j == iint || i == iint) continue;; 3236 ++knew;; 3237 fVhmat[knew-1] = fVhmat[kold-1] - fFIXPyy[j-1]*fFIXPyy[i-1]*yyover;; 3238 }; 3239 }; 3240}; 3241 ; 3242////////////////////////////////////////////////////////////////////////////////; 3243/// Restores one or more fixed parameter(s) to variable status; 3244///; 3245/// Restores one or more fixed parameter(s) to variable status; 3246/// by inserting it into the internal parameter list at the; 3247/// appropriate place.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:101875,Modifiability,variab,variable,101875,"-1];; 3184 if (fNpfix >= fMaxpar) {; 3185 ierr = 1;; 3186 Printf("" MINUIT CANNOT FIX PARAMETER %4d MAXIMUM NUMBER THAT CAN BE FIXED IS %d"",iext,fMaxpar);; 3187 return;; 3188 }; 3189// reduce number of variable parameters by one; 3190 ; 3191 fNiofex[iext-1] = 0;; 3192 nold = fNpar;; 3193 --fNpar;; 3194// save values in case parameter is later restored; 3195 ; 3196 ++fNpfix;; 3197 fIpfix[fNpfix-1] = iext;; 3198 lc = iint;; 3199 fXs[fNpfix-1] = fX[lc-1];; 3200 fXts[fNpfix-1] = fXt[lc-1];; 3201 fDirins[fNpfix-1] = fWerr[lc-1];; 3202 fGrds[fNpfix-1] = fGrd[lc-1];; 3203 fG2s[fNpfix-1] = fG2[lc-1];; 3204 fGsteps[fNpfix-1] = fGstep[lc-1];; 3205// shift values for other parameters to fill hole; 3206 for (ik = iext + 1; ik <= fNu; ++ik) {; 3207 if (fNiofex[ik-1] > 0) {; 3208 lc = fNiofex[ik-1] - 1;; 3209 fNiofex[ik-1] = lc;; 3210 fNexofi[lc-1] = ik;; 3211 fX[lc-1] = fX[lc];; 3212 fXt[lc-1] = fXt[lc];; 3213 fDirin[lc-1] = fDirin[lc];; 3214 fWerr[lc-1] = fWerr[lc];; 3215 fGrd[lc-1] = fGrd[lc];; 3216 fG2[lc-1] = fG2[lc];; 3217 fGstep[lc-1] = fGstep[lc];; 3218 }; 3219 }; 3220 if (fISW[1] <= 0) return;; 3221// remove one row and one column from variance matrix; 3222 if (fNpar <= 0) return;; 3223 for (i = 1; i <= nold; ++i) {; 3224 m = TMath::Max(i,iint);; 3225 n = TMath::Min(i,iint);; 3226 ndex = m*(m-1) / 2 + n;; 3227 fFIXPyy[i-1] = fVhmat[ndex-1];; 3228 }; 3229 yyover = 1 / fFIXPyy[iint-1];; 3230 knew = 0;; 3231 kold = 0;; 3232 for (i = 1; i <= nold; ++i) {; 3233 for (j = 1; j <= i; ++j) {; 3234 ++kold;; 3235 if (j == iint || i == iint) continue;; 3236 ++knew;; 3237 fVhmat[knew-1] = fVhmat[kold-1] - fFIXPyy[j-1]*fFIXPyy[i-1]*yyover;; 3238 }; 3239 }; 3240}; 3241 ; 3242////////////////////////////////////////////////////////////////////////////////; 3243/// Restores one or more fixed parameter(s) to variable status; 3244///; 3245/// Restores one or more fixed parameter(s) to variable status; 3246/// by inserting it into the internal parameter list at the; 3247/// appropriate place.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:102413,Modifiability,variab,variables,102413,"m*(m-1) / 2 + n;; 3227 fFIXPyy[i-1] = fVhmat[ndex-1];; 3228 }; 3229 yyover = 1 / fFIXPyy[iint-1];; 3230 knew = 0;; 3231 kold = 0;; 3232 for (i = 1; i <= nold; ++i) {; 3233 for (j = 1; j <= i; ++j) {; 3234 ++kold;; 3235 if (j == iint || i == iint) continue;; 3236 ++knew;; 3237 fVhmat[knew-1] = fVhmat[kold-1] - fFIXPyy[j-1]*fFIXPyy[i-1]*yyover;; 3238 }; 3239 }; 3240}; 3241 ; 3242////////////////////////////////////////////////////////////////////////////////; 3243/// Restores one or more fixed parameter(s) to variable status; 3244///; 3245/// Restores one or more fixed parameter(s) to variable status; 3246/// by inserting it into the internal parameter list at the; 3247/// appropriate place.; 3248///; 3249/// - K = 0 means restore all parameters; 3250/// - K = 1 means restore the last parameter fixed; 3251/// - K = -I means restore external parameter I (if possible); 3252/// - IQ = fix-location where internal parameters were stored; 3253/// - IR = external number of parameter being restored; 3254/// - IS = internal number of parameter being restored; 3255 ; 3256void TMinuit::mnfree(Int_t k); 3257{; 3258 /* Local variables */; 3259 Double_t grdv, xv, dirinv, g2v, gstepv, xtv;; 3260 Int_t i, ipsav, ka, lc, ik, iq, ir, is;; 3261 ; 3262 if (k > 1) {; 3263 Printf("" CALL TO MNFREE IGNORED. ARGUMENT GREATER THAN ONE"");; 3264 }; 3265 if (fNpfix < 1) {; 3266 Printf("" CALL TO MNFREE IGNORED. THERE ARE NO FIXED PARAMETERS"");; 3267 }; 3268 if (k == 1 || k == 0) goto L40;; 3269 ; 3270// release parameter with specified external number; 3271 ka = abs(k);; 3272 if (fNiofex[ka-1] == 0) goto L15;; 3273 Printf("" IGNORED. PARAMETER SPECIFIED IS ALREADY VARIABLE."");; 3274 return;; 3275L15:; 3276 if (fNpfix < 1) goto L21;; 3277 for (ik = 1; ik <= fNpfix; ++ik) { if (fIpfix[ik-1] == ka) goto L24; }; 3278L21:; 3279 Printf("" PARAMETER %4d NOT FIXED. CANNOT BE RELEASED."",ka);; 3280 return;; 3281L24:; 3282 if (ik == fNpfix) goto L40;; 3283 ; 3284// move specified parameter to end of list; 3285",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:105657,Modifiability,variab,variables,105657,"///////////////////////////////////////////; 3354/// Interprets the SET GRAD command; 3355///; 3356/// - Called from MNSET; 3357/// - Interprets the SET GRAD command, which informs MINUIT whether; 3358/// - the first derivatives of FCN will be calculated by the user; 3359/// - inside FCN. It can check the user derivative calculation; 3360/// - by comparing it with a finite difference approximation.; 3361 ; 3362void TMinuit::mngrad(); 3363{; 3364 /* Local variables */; 3365 Double_t fzero, err;; 3366 Int_t i, nparx, lc, istsav;; 3367 Bool_t lnone;; 3368 ; 3369 fISW[2] = 1;; 3370 nparx = fNpar;; 3371 if (fWord7[0] > 0) goto L2000;; 3372 ; 3373// get user-calculated first derivatives from FCN; 3374 for (i = 1; i <= fNu; ++i) { fGin[i-1] = fUndefi; }; 3375 mninex(fX);; 3376 Eval(nparx, fGin, fzero, fU, 2); ++fNfcn;; 3377 mnderi();; 3378 for (i = 1; i <= fNpar; ++i) { fGRADgf[i-1] = fGrd[i-1]; }; 3379// get MINUIT-calculated first derivatives; 3380 fISW[2] = 0;; 3381 istsav = fIstrat;; 3382 fIstrat = 2;; 3383 mnhes1();; 3384 fIstrat = istsav;; 3385 Printf("" CHECK OF GRADIENT CALCULATION IN FCN"");; 3386 Printf("" PARAMETER G(IN FCN) G(MINUIT) DG(MINUIT) AGREEMENT"");; 3387 fISW[2] = 1;; 3388 lnone = kFALSE;; 3389 for (lc = 1; lc <= fNpar; ++lc) {; 3390 i = fNexofi[lc-1];; 3391 const char *cwd = ""GOOD"";; 3392 err = fDgrd[lc-1];; 3393 if (TMath::Abs(fGRADgf[lc-1] - fGrd[lc-1]) > err) {; 3394 cwd = "" BAD"";; 3395 fISW[2] = 0;; 3396 }; 3397 if (fGin[i-1] == fUndefi) {; 3398 cwd = ""NONE"";; 3399 lnone = kTRUE;; 3400 fGRADgf[lc-1] = 0;; 3401 fISW[2] = 0;; 3402 }; 3403 Printf("" %5d %10s%12.4e%12.4e%12.4e %s"",i; 3404 ,(const char*)fCpnam[i-1]; 3405 ,fGRADgf[lc-1],fGrd[lc-1],err,cwd);; 3406 }; 3407 if (lnone) {; 3408 Printf("" AGREEMENT=NONE MEANS FCN DID NOT CALCULATE THE DERIVATIVE"");; 3409 }; 3410 if (fISW[2] == 0) {; 3411 Printf("" MINUIT DOES NOT ACCEPT DERIVATIVE CALCULATIONS BY FCN"");; 3412 Printf("" TO FORCE ACCEPTANCE, ENTER *SET GRAD 1*"");; 3413 }; 3414 ; 3415L2000:; 3416 return",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:109081,Modifiability,variab,variable,109081,"ngth() == 0 || comd[0] == '*' || comd[0] == '?' || comd[0] == 0 || comd==""HELP"" ) {; 3447 Printf("" ==>List of MINUIT Interactive commands:"");; 3448 Printf("" CLEar Reset all parameter names and values undefined"");; 3449 Printf("" CONtour Make contour map of the user function"");; 3450 Printf("" EXIT Exit from Interactive Minuit"");; 3451 Printf("" FIX Cause parameter(s) to remain constant"");; 3452 Printf("" HESse Calculate the Hessian or error matrix."");; 3453 Printf("" IMPROVE Search for a new minimum around current minimum"");; 3454 Printf("" MIGrad Minimize by the method of Migrad"");; 3455 Printf("" MINImize MIGRAD + SIMPLEX method if Migrad fails"");; 3456 Printf("" MINOs Exact (non-linear) parameter error analysis"");; 3457 Printf("" MNContour Calculate one MINOS function contour"");; 3458 Printf("" PARameter Define or redefine new parameters and values"");; 3459 Printf("" RELease Make previously FIXed parameters variable again"");; 3460 Printf("" REStore Release last parameter fixed"");; 3461 Printf("" SAVe Save current parameter values on a file"");; 3462 Printf("" SCAn Scan the user function by varying parameters"");; 3463 Printf("" SEEk Minimize by the method of Monte Carlo"");; 3464 Printf("" SET Set various MINUIT constants or conditions"");; 3465 Printf("" SHOw Show values of current constants or conditions"");; 3466 Printf("" SIMplex Minimize by the method of Simplex"");; 3467 goto L99;; 3468 }; 3469 ; 3470//______________________________________________________________________________; 3471//; 3472// Command CLEAR; 3473//; 3474 if( !strncmp(comd.Data(),""CLE"",3) ) {; 3475 Printf("" ***>CLEAR"");; 3476 Printf("" Resets all parameter names and values to undefined."");; 3477 Printf("" Must normally be followed by a PARameters command or "");; 3478 Printf("" equivalent, in order to define parameter values."");; 3479 goto L99;; 3480 }; 3481//______________________________________________________________________________; 3482//; 3483// Command CONTOUR; 3484//; 3485 if( !strncmp(comd.Data(),""CON"",3) )",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:110447,Modifiability,variab,variable,110447,"y the method of Simplex"");; 3467 goto L99;; 3468 }; 3469 ; 3470//______________________________________________________________________________; 3471//; 3472// Command CLEAR; 3473//; 3474 if( !strncmp(comd.Data(),""CLE"",3) ) {; 3475 Printf("" ***>CLEAR"");; 3476 Printf("" Resets all parameter names and values to undefined."");; 3477 Printf("" Must normally be followed by a PARameters command or "");; 3478 Printf("" equivalent, in order to define parameter values."");; 3479 goto L99;; 3480 }; 3481//______________________________________________________________________________; 3482//; 3483// Command CONTOUR; 3484//; 3485 if( !strncmp(comd.Data(),""CON"",3) ) {; 3486 Printf("" ***>CONTOUR <par1> <par2> [devs] [ngrid]"");; 3487 Printf("" Instructs Minuit to trace contour lines of the user function"");; 3488 Printf("" with respect to the two parameters whose external numbers"");; 3489 Printf("" are <par1> and <par2>."");; 3490 Printf("" Other variable parameters of the function, if any, will have"");; 3491 Printf("" their values fixed at the current values during the contour"");; 3492 Printf("" tracing. The optional parameter [devs] (default value 2.)"");; 3493 Printf("" gives the number of standard deviations in each parameter"");; 3494 Printf("" which should lie entirely within the plotting area."");; 3495 Printf("" Optional parameter [ngrid] (default value 25 unless page"");; 3496 Printf("" size is too small) determines the resolution of the plot,"");; 3497 Printf("" i.e. the number of rows and columns of the grid at which the"");; 3498 Printf("" function will be evaluated. [See also MNContour.]"");; 3499 goto L99;; 3500 }; 3501//______________________________________________________________________________; 3502//; 3503// Command END; 3504//; 3505 if( !strncmp(comd.Data(),""END"",3) ) {; 3506 Printf("" ***>END"");; 3507 Printf("" Signals the end of a data block (i.e., the end of a fit),"");; 3508 Printf("" and implies that execution should continue, because another"");; 3509 Printf("" Data Block follows. A Data",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:113091,Modifiability,variab,variable,113091,"unless a CALL FCN 3 command has already"");; 3520 Printf("" been executed at the current FCN value."");; 3521 goto L99;; 3522 }; 3523//______________________________________________________________________________; 3524//; 3525// Command EXIT; 3526//; 3527 if( !strncmp(comd.Data(),""EXI"",3) ) {; 3528 Printf("" ***>EXIT"");; 3529 Printf("" Signals the end of execution."");; 3530 Printf("" The EXIT command first causes Minuit to issue a CALL FCN"");; 3531 Printf("" with IFLAG=3, to allow FCN to perform any calculations"");; 3532 Printf("" associated with the final fitted parameter values, unless a"");; 3533 Printf("" CALL FCN 3 command has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parno> to be removed from the list of"");; 3543 Printf("" variable parameters, and their value(s) will remain constant"");; 3544 Printf("" during subsequent minimizations, etc., until another command"");; 3545 Printf("" changes their value(s) or status."");; 3546 goto L99;; 3547 }; 3548//______________________________________________________________________________; 3549//; 3550// Command HESSE; 3551//; 3552 if( !strncmp(comd.Data(),""HES"",3) ) {; 3553 Printf("" ***>HESse [maxcalls]"");; 3554 Printf("" Calculate, by finite differences, the Hessian or error matrix."");; 3555 Printf("" That is, it calculates the full matrix of second derivatives"");; 3556 Printf("" of the function with respect to the currently variable"");; 3557 Printf("" parameters, and inverts it, printing out the resulting error"");; 3558 Printf("" matrix. The optional argument [maxcalls] specifies the"");; 3559 Printf("" (approximate) maximum number of function calls after which"");; 3560 Printf("" the calculation will be stopped."");; 3561 goto L99;; 3562 }; 3563//____________________________________",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:113738,Modifiability,variab,variable,113738,"d has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parno> to be removed from the list of"");; 3543 Printf("" variable parameters, and their value(s) will remain constant"");; 3544 Printf("" during subsequent minimizations, etc., until another command"");; 3545 Printf("" changes their value(s) or status."");; 3546 goto L99;; 3547 }; 3548//______________________________________________________________________________; 3549//; 3550// Command HESSE; 3551//; 3552 if( !strncmp(comd.Data(),""HES"",3) ) {; 3553 Printf("" ***>HESse [maxcalls]"");; 3554 Printf("" Calculate, by finite differences, the Hessian or error matrix."");; 3555 Printf("" That is, it calculates the full matrix of second derivatives"");; 3556 Printf("" of the function with respect to the currently variable"");; 3557 Printf("" parameters, and inverts it, printing out the resulting error"");; 3558 Printf("" matrix. The optional argument [maxcalls] specifies the"");; 3559 Printf("" (approximate) maximum number of function calls after which"");; 3560 Printf("" the calculation will be stopped."");; 3561 goto L99;; 3562 }; 3563//______________________________________________________________________________; 3564//; 3565// Command IMPROVE; 3566//; 3567 if( !strncmp(comd.Data(),""IMP"",3) ) {; 3568 Printf("" ***>IMPROVE [maxcalls]"");; 3569 Printf("" If a previous minimization has converged, and the current"");; 3570 Printf("" values of the parameters therefore correspond to a local"");; 3571 Printf("" minimum of the function, this command requests a search for"");; 3572 Printf("" additional distinct local minima."");; 3573 Printf("" The optional argument [maxcalls] specifies the (approximate"");; 3574 Printf("" maximum number of function calls after which the calculation"");; 3575 Printf("" will ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:117017,Modifiability,variab,variable,117017," 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable param",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:117974,Modifiability,variab,variable,117974," performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable parameters (if any)."");; 3639 Printf("" Minuit will try to find npts points on the contour (default 20)"");; 3640 Printf("" If only two parameters are variable at the time, it is not"");; 3641 Printf("" necessary to specify their numbers. To calculate more than"");; 3642 Printf("" one contour, it is necessary to SET ERRordef to the appropriate"");; 3643 Printf("" value and issue the MNContour command for each contour."");; 3644 goto L99;; 3645 }; 3646//______________________________________________________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Pr",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:118131,Modifiability,variab,variable,118131,"ery"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" parameters par1 and par2, with FCN minimized always with"");; 3638 Printf("" respect to all other NPAR-2 variable parameters (if any)."");; 3639 Printf("" Minuit will try to find npts points on the contour (default 20)"");; 3640 Printf("" If only two parameters are variable at the time, it is not"");; 3641 Printf("" necessary to specify their numbers. To calculate more than"");; 3642 Printf("" one contour, it is necessary to SET ERRordef to the appropriate"");; 3643 Printf("" value and issue the MNContour command for each contour."");; 3644 goto L99;; 3645 }; 3646//______________________________________________________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:119274,Modifiability,variab,variable,119274,"iate"");; 3643 Printf("" value and issue the MNContour command for each contour."");; 3644 goto L99;; 3645 }; 3646//______________________________________________________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero n",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:119412,Modifiability,variab,variable,119412,"iate"");; 3643 Printf("" value and issue the MNContour command for each contour."");; 3644 goto L99;; 3645 }; 3646//______________________________________________________________________________; 3647//; 3648// Command PARAMETER; 3649//; 3650 if( !strncmp(comd.Data(),""PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero n",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:119624,Modifiability,variab,variable,119624,"PAR"",3) ) {; 3651 Printf("" ***>PARameters"");; 3652 Printf("" followed by one or more parameter definitions."");; 3653 Printf("" Parameter definitions are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Pri",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:119707,Modifiability,variab,variable,119707,"are of the form:"");; 3654 Printf("" <number> ''name'' <value> <step> [lolim] [uplim] "");; 3655 Printf("" for example:"");; 3656 Printf("" 3 ''K width'' 1.2 0.1"");; 3657 Printf("" the last definition is followed by a blank line or a zero."");; 3658 goto L99;; 3659 }; 3660//______________________________________________________________________________; 3661//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Printf("" Signals the end of a data block, and instructs Minuit to return"");; 3695 Printf("" to the program which called it. The RETurn command first"");",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:120159,Modifiability,variab,variable,120159,"1//; 3662// Command RELEASE; 3663//; 3664 if( !strncmp(comd.Data(),""REL"",3) ) {; 3665 Printf("" ***>RELease <parno> [parno] ... [parno]"");; 3666 Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Printf("" Signals the end of a data block, and instructs Minuit to return"");; 3695 Printf("" to the program which called it. The RETurn command first"");; 3696 Printf("" causes Minuit to CALL FCN with IFLAG=3, in order to allow FCN"");; 3697 Printf("" to perform any calculations associated with the final fitted"");; 3698 Printf("" parameter values, unless a CALL FCN 3 command has already been"");; 3699 Printf("" executed at the current FCN value."");; 3700 goto L99;; 3701 }; 3702//_________________________",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:120257,Modifiability,variab,variable,120257,"Printf("" If <parno> is the number of a previously variable parameter"");; 3667 Printf("" which has been fixed by a command: FIX <parno>, then that"");; 3668 Printf("" parameter will return to variable status. Otherwise a warning"");; 3669 Printf("" message is printed and the command is ignored."");; 3670 Printf("" Note that this command operates only on parameters which were"");; 3671 Printf("" at one time variable and have been FIXed. It cannot make"");; 3672 Printf("" constant parameters variable; that must be done by redefining"");; 3673 Printf("" the parameter with a PARameters command."");; 3674 goto L99;; 3675 }; 3676//______________________________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Printf("" Signals the end of a data block, and instructs Minuit to return"");; 3695 Printf("" to the program which called it. The RETurn command first"");; 3696 Printf("" causes Minuit to CALL FCN with IFLAG=3, in order to allow FCN"");; 3697 Printf("" to perform any calculations associated with the final fitted"");; 3698 Printf("" parameter values, unless a CALL FCN 3 command has already been"");; 3699 Printf("" executed at the current FCN value."");; 3700 goto L99;; 3701 }; 3702//______________________________________________________________________________; 3703//; 3704// Command SAVE; 3705//; 3706 if( !strncmp(comd.Data(),""SAV"",3) ) {; 3707 Pri",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:122285,Modifiability,variab,variable,122285,"saved on a file in"");; 3709 Printf("" such a format that they can be read in again as Minuit"");; 3710 Printf("" parameter definitions. If the covariance matrix exists, it is"");; 3711 Printf("" also output in such a format. The unit number is by default 7,"");; 3712 Printf("" or that specified by the user in their call to MINTIO or"");; 3713 Printf("" MNINIT. The user is responsible for opening the file previous"");; 3714 Printf("" to issuing the [SAVe] command (except where this can be done"");; 3715 Printf("" interactively)."");; 3716 goto L99;; 3717 }; 3718//______________________________________________________________________________; 3719//; 3720// Command SCAN; 3721//; 3722 if( !strncmp(comd.Data(),""SCA"",3) ) {; 3723 Printf("" ***>SCAn [parno] [numpts] [from] [to]"");; 3724 Printf("" Scans the value of the user function by varying parameter"");; 3725 Printf("" number [parno], leaving all other parameters fixed at the"");; 3726 Printf("" current value. If [parno] is not specified, all variable"");; 3727 Printf("" parameters are scanned in sequence."");; 3728 Printf("" The number of points [numpts] in the scan is 40 by default,"");; 3729 Printf("" and cannot exceed 100. The range of the scan is by default"");; 3730 Printf("" 2 standard deviations on each side of the current best value,"");; 3731 Printf("" but can be specified as from [from] to [to]."");; 3732 Printf("" After each scan, if a new minimum is found, the best parameter"");; 3733 Printf("" values are retained as start values for future scans or"");; 3734 Printf("" minimizations. The curve resulting from each scan is plotted"");; 3735 Printf("" on the output unit in order to show the approximate behaviour"");; 3736 Printf("" of the function."");; 3737 Printf("" This command is not intended for minimization, but is sometimes"");; 3738 Printf("" useful for debugging the user function or finding a"");; 3739 Printf("" reasonable starting point."");; 3740 goto L99;; 3741 }; 3742//_________________________________________________________________________",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:123548,Modifiability,variab,variable,123548," Printf("" 2 standard deviations on each side of the current best value,"");; 3731 Printf("" but can be specified as from [from] to [to]."");; 3732 Printf("" After each scan, if a new minimum is found, the best parameter"");; 3733 Printf("" values are retained as start values for future scans or"");; 3734 Printf("" minimizations. The curve resulting from each scan is plotted"");; 3735 Printf("" on the output unit in order to show the approximate behaviour"");; 3736 Printf("" of the function."");; 3737 Printf("" This command is not intended for minimization, but is sometimes"");; 3738 Printf("" useful for debugging the user function or finding a"");; 3739 Printf("" reasonable starting point."");; 3740 goto L99;; 3741 }; 3742//______________________________________________________________________________; 3743//; 3744// Command SEEK; 3745//; 3746 if( !strncmp(comd.Data(),""SEE"",3) ) {; 3747 Printf("" ***>SEEk [maxcalls] [devs]"");; 3748 Printf("" Causes a Monte Carlo minimization of the function, by choosing"");; 3749 Printf("" random values of the variable parameters, chosen uniformly"");; 3750 Printf("" over a hypercube centered at the current best value."");; 3751 Printf("" The region size is by default 3 standard deviations on each"");; 3752 Printf("" side, but can be changed by specifying the value of [devs]."");; 3753 goto L99;; 3754 }; 3755//______________________________________________________________________________; 3756//; 3757// Command SET; 3758//; 3759 if( !strncmp(comd.Data(),""SET"",3) ) {; 3760 Printf("" ***>SET <option_name>"");; 3761 Printf("" SET BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:128989,Modifiability,variab,variable,128989,""" Default value is 24 for interactive mode"");; 3833 ; 3834 Printf("" "");; 3835 Printf("" SET NOGradient"");; 3836 Printf("" The inverse of SET GRAdient, instructs Minuit not to"");; 3837 Printf("" use the first derivatives calculated by the user in FCN."");; 3838 ; 3839 Printf("" "");; 3840 Printf("" SET NOWarnings"");; 3841 Printf("" Suppresses Minuit warning messages."");; 3842 ; 3843 Printf("" "");; 3844 Printf("" SET OUTputfile <unitno>"");; 3845 Printf("" Instructs Minuit to write further output to unit <unitno>."");; 3846 ; 3847 Printf("" "");; 3848 Printf("" SET PAGethrow <integer>"");; 3849 Printf("" Sets the carriage control character for ``new page'' to"");; 3850 Printf("" <integer>. Thus the value 1 produces a new page, and 0"");; 3851 Printf("" produces a blank line, on some devices (see TOPofpage)"");; 3852 ; 3853 ; 3854 Printf("" "");; 3855 Printf("" SET PARameter <parno> <value>"");; 3856 Printf("" Sets the value of parameter <parno> to <value>."");; 3857 Printf("" The parameter in question may be variable, fixed, or"");; 3858 Printf("" constant, but must be defined."");; 3859 ; 3860 Printf("" "");; 3861 Printf("" SET PRIntout <level>"");; 3862 Printf("" Sets the print level, determining how much output will be"");; 3863 Printf("" produced. Allowed values and their meanings are displayed"");; 3864 Printf("" after a SHOw PRInt command, and are currently <level>=:"");; 3865 Printf("" [-1] no output except from SHOW commands"");; 3866 Printf("" [0] minimum output"");; 3867 Printf("" [1] default value, normal output"");; 3868 Printf("" [2] additional output giving intermediate results."");; 3869 Printf("" [3] maximum output, showing progress of minimizations."");; 3870 Printf("" Note: See also the SET WARnings command."");; 3871 ; 3872 Printf("" "");; 3873 Printf("" SET RANdomgenerator <seed>"");; 3874 Printf("" Sets the seed of the random number generator used in SEEk."");; 3875 Printf("" This can be any integer between 10000 and 900000000, for"");; 3876 Printf("" example one which was output from a SHOw RANdom command of""",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:134626,Modifiability,variab,variables,134626,"e top of a page depending on the device and system."");; 3975 goto L99;; 3976 }; 3977//______________________________________________________________________________; 3978 Printf("" Unknown MINUIT command. Type HELP for list of commands."");; 3979 ; 3980L99:; 3981 return;; 3982}; 3983 ; 3984////////////////////////////////////////////////////////////////////////////////; 3985/// Calculates the full second-derivative matrix of FCN; 3986///; 3987/// by taking finite differences. When calculating diagonal; 3988/// elements, it may iterate so that step size is nearly that; 3989/// which gives function change= UP/10. The first derivatives; 3990/// of course come as a free side effect, but with a smaller; 3991/// step size in order to obtain a known accuracy.; 3992 ; 3993void TMinuit::mnhess(); 3994{; 3995 /* Local variables */; 3996 Double_t dmin_, dxdi, elem, wint, tlrg2, d, dlast, ztemp, g2bfor;; 3997 Double_t df, aimsag, fs1, tlrstp, fs2, stpinm, g2i, sag=0, xtf, xti, xtj;; 3998 Int_t icyc, ncyc, ndex, idrv, iext, npar2, i, j, ifail, npard, nparx, id, multpy;; 3999 Bool_t ldebug;; 4000 ; 4001 ldebug = fIdbg[3] >= 1;; 4002 if (fAmin == fUndefi) {; 4003 mnamin();; 4004 }; 4005 if (fIstrat <= 0) {; 4006 ncyc = 3;; 4007 tlrstp = .5;; 4008 tlrg2 = .1;; 4009 } else if (fIstrat == 1) {; 4010 ncyc = 5;; 4011 tlrstp = .3;; 4012 tlrg2 = .05;; 4013 } else {; 4014 ncyc = 7;; 4015 tlrstp = .1;; 4016 tlrg2 = .02;; 4017 }; 4018 if (fISW[4] >= 2 || ldebug) {; 4019 Printf("" START COVARIANCE MATRIX CALCULATION."");; 4020 }; 4021 fCfrom = ""HESSE "";; 4022 fNfcnfr = fNfcn;; 4023 fCstatu = ""OK "";; 4024 npard = fNpar;; 4025// make sure starting at the right place; 4026 mninex(fX);; 4027 nparx = fNpar;; 4028 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 4029 if (fs1 != fAmin) {; 4030 df = fAmin - fs1;; 4031 mnwarn(""D"", ""MNHESS"", TString::Format(""function value differs from AMIN by %g"",df));; 4032 }; 4033 fAmin = fs1;; 4034 if (ldebug) {; 4035 Printf("" PAR D GSTEP D G2 GRD SAG "");; 4036 }; 4037// diago",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:136187,Modifiability,variab,variable,136187,"ug) {; 4019 Printf("" START COVARIANCE MATRIX CALCULATION."");; 4020 }; 4021 fCfrom = ""HESSE "";; 4022 fNfcnfr = fNfcn;; 4023 fCstatu = ""OK "";; 4024 npard = fNpar;; 4025// make sure starting at the right place; 4026 mninex(fX);; 4027 nparx = fNpar;; 4028 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 4029 if (fs1 != fAmin) {; 4030 df = fAmin - fs1;; 4031 mnwarn(""D"", ""MNHESS"", TString::Format(""function value differs from AMIN by %g"",df));; 4032 }; 4033 fAmin = fs1;; 4034 if (ldebug) {; 4035 Printf("" PAR D GSTEP D G2 GRD SAG "");; 4036 }; 4037// diagonal elements .; 4038 ; 4039// fISW[1] = 1 if approx, 2 if not posdef, 3 if ok; 4040// AIMSAG is the sagitta we are aiming for in second deriv calc.; 4041 ; 4042 aimsag = TMath::Sqrt(fEpsma2)*(TMath::Abs(fAmin) + fUp);; 4043// Zero the second derivative matrix; 4044 npar2 = fNpar*(fNpar + 1) / 2;; 4045 for (i = 1; i <= npar2; ++i) { fVhmat[i-1] = 0; }; 4046 ; 4047// Loop over variable parameters for second derivatives; 4048 idrv = 2;; 4049 for (id = 1; id <= npard; ++id) {; 4050 i = id + fNpar - npard;; 4051 iext = fNexofi[i-1];; 4052 if (fG2[i-1] == 0) {; 4053 mnwarn(""W"", ""HESSE"", Form(""Second derivative enters zero, param %d"",iext));; 4054 wint = fWerr[i-1];; 4055 if (fNvarl[iext-1] > 1) {; 4056 mndxdi(fX[i-1], i-1, dxdi);; 4057 if (TMath::Abs(dxdi) < .001) wint = .01;; 4058 else wint /= TMath::Abs(dxdi);; 4059 }; 4060 fG2[i-1] = fUp / (wint*wint);; 4061 }; 4062 xtf = fX[i-1];; 4063 dmin_ = fEpsma2*8*TMath::Abs(xtf);; 4064 ; 4065// find step which gives sagitta = AIMSAG; 4066 d = TMath::Abs(fGstep[i-1]);; 4067 int skip50 = 0;; 4068 for (icyc = 1; icyc <= ncyc; ++icyc) {; 4069// loop here only if SAG=0; 4070 for (multpy = 1; multpy <= 5; ++multpy) {; 4071// take two steps; 4072 fX[i-1] = xtf + d;; 4073 mninex(fX);; 4074 nparx = fNpar;; 4075 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 4076 fX[i-1] = xtf - d;; 4077 mninex(fX);; 4078 Eval(nparx, fGin, fs2, fU, 4); ++fNfcn;; 4079 fX[i-1] = xtf;; 4080 sag = (fs1 + fs2 - fAmin*2)*.5;; 4081 i",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:141275,Modifiability,variab,variables,141275,"fISW[4] >= 1 && fISW[1] == 3 && fItaur == 0) {; 4186 Printf("" COVARIANCE MATRIX CALCULATED SUCCESSFULLY"");; 4187 }; 4188 goto L900;; 4189// failure to invert 2nd deriv matrix; 4190L390:; 4191 fISW[1] = 1;; 4192 fDcovar = 1;; 4193 fCstatu = ""FAILED "";; 4194 if (fISW[4] >= 0) {; 4195 Printf("" MNHESS FAILS AND WILL RETURN DIAGONAL MATRIX. "");; 4196 }; 4197 for (i = 1; i <= fNpar; ++i) {; 4198 ndex = i*(i-1) / 2;; 4199 for (j = 1; j <= i-1; ++j) {; 4200 ++ndex;; 4201 fVhmat[ndex-1] = 0;; 4202 }; 4203 ++ndex;; 4204 g2i = fG2[i-1];; 4205 if (g2i <= 0) g2i = 1;; 4206 fVhmat[ndex-1] = 2 / g2i;; 4207 }; 4208L900:; 4209 return;; 4210}; 4211 ; 4212////////////////////////////////////////////////////////////////////////////////; 4213/// Calculate first derivatives (GRD) and uncertainties (DGRD); 4214///; 4215/// and appropriate step sizes GSTEP; 4216/// Called from MNHESS and MNGRAD; 4217 ; 4218void TMinuit::mnhes1(); 4219{; 4220 /* Local variables */; 4221 Double_t dmin_, d, dfmin, dgmin=0, change, chgold, grdold=0, epspri;; 4222 Double_t fs1, optstp, fs2, grdnew=0, sag, xtf;; 4223 Int_t icyc, ncyc=0, idrv, i, nparx;; 4224 Bool_t ldebug;; 4225 ; 4226 ldebug = fIdbg[5] >= 1;; 4227 if (fIstrat <= 0) ncyc = 1;; 4228 if (fIstrat == 1) ncyc = 2;; 4229 if (fIstrat > 1) ncyc = 6;; 4230 idrv = 1;; 4231 nparx = fNpar;; 4232 dfmin = fEpsma2*4*(TMath::Abs(fAmin) + fUp);; 4233// main loop over parameters; 4234 for (i = 1; i <= fNpar; ++i) {; 4235 xtf = fX[i-1];; 4236 dmin_ = fEpsma2*4*TMath::Abs(xtf);; 4237 epspri = fEpsma2 + TMath::Abs(fGrd[i-1]*fEpsma2);; 4238 optstp = TMath::Sqrt(dfmin / (TMath::Abs(fG2[i-1]) + epspri));; 4239 d = TMath::Abs(fGstep[i-1])*.2;; 4240 if (d > optstp) d = optstp;; 4241 if (d < dmin_) d = dmin_;; 4242 chgold = 1e4;; 4243// iterate reducing step size; 4244 for (icyc = 1; icyc <= ncyc; ++icyc) {; 4245 fX[i-1] = xtf + d;; 4246 mninex(fX);; 4247 Eval(nparx, fGin, fs1, fU, 4); ++fNfcn;; 4248 fX[i-1] = xtf - d;; 4249 mninex(fX);; 4250 Eval(nparx, fGin, fs2, fU, 4);",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:144146,Modifiability,variab,variables,144146,"4275 }; 4276// loop satisfied = too many iter; 4277 mnwarn(""D"", ""MNHES1"", TString::Format(""Too many iterations on D1.%g%g"",grdold,grdnew));; 4278L60:; 4279 fDgrd[i-1] = TMath::Max(dgmin,TMath::Abs(grdold - grdnew));; 4280 }; 4281// end of first deriv. loop; 4282 mninex(fX);; 4283}; 4284 ; 4285////////////////////////////////////////////////////////////////////////////////; 4286/// Attempts to improve on a good local minimum; 4287///; 4288/// Attempts to improve on a good local minimum by finding a; 4289/// better one. The quadratic part of FCN is removed by MNCALF; 4290/// and this transformed function is minimised using the simplex; 4291/// method from several random starting points.; 4292///; 4293/// ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); 4294 ; 4295void TMinuit::mnimpr(); 4296{; 4297 /* Initialized data */; 4298 ; 4299 Double_t rnum = 0;; 4300 ; 4301 /* Local variables */; 4302 Double_t amax, ycalf, ystar, ystst;; 4303 Double_t pb, ep, wg, xi, sigsav, reg, sig2;; 4304 Int_t npfn, ndex, loop=0, i, j, ifail, iseed=0;; 4305 Int_t jhold, nloop, nparx, nparp1, jh, jl, iswtr;; 4306 ; 4307 if (fNpar <= 0) return;; 4308 if (fAmin == fUndefi) mnamin();; 4309 fCstatu = ""UNCHANGED "";; 4310 fItaur = 1;; 4311 fEpsi = fUp*.1;; 4312 npfn = fNfcn;; 4313 nloop = Int_t(fWord7[1]);; 4314 if (nloop <= 0) nloop = fNpar + 4;; 4315 nparx = fNpar;; 4316 nparp1 = fNpar + 1;; 4317 wg = 1 / Double_t(fNpar);; 4318 sigsav = fEDM;; 4319 fApsi = fAmin;; 4320 iswtr = fISW[4] - 2*fItaur;; 4321 for (i = 1; i <= fNpar; ++i) {; 4322 fXt[i-1] = fX[i-1];; 4323 fIMPRdsav[i-1] = fWerr[i-1];; 4324 for (j = 1; j <= i; ++j) {; 4325 ndex = i*(i-1) / 2 + j;; 4326 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[ndex-1];; 4327 fP[j + i*fMaxpar - fMaxpar-1] = fP[i + j*fMaxpar - fMaxpar-1];; 4328 }; 4329 }; 4330 mnvert(fP, fMaxint, fMaxint, fNpar, ifail);; 4331 if (ifail >= 1) goto L280;; 4332// Save inverted matrix in VT; 4333 for (i = 1; i <= fNpar; ++i) {; 4334 ndex = i*(i-1) / 2;; 4335 for (j = 1; j",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:150765,Modifiability,variab,variables,150765,"////////////////////////////////////////////////////////; 4501/// Transforms from internal coordinates (PINT) to external (U); 4502///; 4503/// The minimising routines which work in; 4504/// internal coordinates call this routine before calling FCN.; 4505 ; 4506void TMinuit::mninex(Double_t *pint); 4507{; 4508 Int_t i, j;; 4509 ; 4510 for (j = 0; j < fNpar; ++j) {; 4511 i = fNexofi[j]-1;; 4512 if (fNvarl[i] == 1) {; 4513 fU[i] = pint[j];; 4514 } else {; 4515 fU[i] = fAlim[i] + (TMath::Sin(pint[j]) + 1)*.5*(fBlim[i] - fAlim[i]);; 4516 }; 4517 }; 4518}; 4519 ; 4520////////////////////////////////////////////////////////////////////////////////; 4521/// Main initialization member function for MINUIT; 4522///; 4523/// It initializes some constants; 4524/// (including the logical I/O unit nos.),; 4525 ; 4526void TMinuit::mninit(Int_t i1, Int_t i2, Int_t i3); 4527{; 4528 /* Local variables */; 4529 volatile Double_t epsp1;; 4530 Double_t piby2, epstry, epsbak, distnn;; 4531 Int_t i, idb;; 4532 ; 4533// I/O unit numbers; 4534 fIsysrd = i1;; 4535 fIsyswr = i2;; 4536 fIstkwr[0] = fIsyswr;; 4537 fNstkwr = 1;; 4538 fIsyssa = i3;; 4539 fNstkrd = 0;; 4540// version identifier; 4541 fCvrsn = ""95.03++ "";; 4542// some CONSTANT; 4543 fMaxint = fMaxpar;; 4544 fMaxext = 2*fMaxpar;; 4545 fUndefi = -54321;; 4546 fBigedm = 123456;; 4547 fCundef = "")UNDEFINED"";; 4548 fCovmes[0] = ""NO ERROR MATRIX "";; 4549 fCovmes[1] = ""ERR MATRIX APPROXIMATE"";; 4550 fCovmes[2] = ""ERR MATRIX NOT POS-DEF"";; 4551 fCovmes[3] = ""ERROR MATRIX ACCURATE "";; 4552// some starting values; 4553 fNblock = 0;; 4554 fIcomnd = 0;; 4555 fCtitl = fCundef;; 4556 fCfrom = ""INPUT "";; 4557 fNfcn = 0;; 4558 fNfcnfr = fNfcn;; 4559 fCstatu = ""INITIALIZE"";; 4560 fISW[2] = 0;; 4561 fISW[3] = 0;; 4562 fISW[4] = 1;; 4563// fISW[5]=0 for batch jobs, =1 for interactive jobs; 4564// =-1 for originally interactive temporarily batch; 4565 ; 4566 fISW[5] = 0;; 4567// if (intrac(&dummy)) fISW[5] = 1;; 4568// DEBUG options set to default val",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:152848,Modifiability,variab,variables,152848,"ault values; 4569 for (idb = 0; idb <= 10; ++idb) { fIdbg[idb] = 0; }; 4570 fLrepor = kFALSE;; 4571 fLwarn = kTRUE;; 4572 fLimset = kFALSE;; 4573 fLnewmn = kFALSE;; 4574 fIstrat = 1;; 4575 fItaur = 0;; 4576// default page dimensions and 'new page' carriage control integer; 4577 fNpagwd = 120;; 4578 fNpagln = 56;; 4579 fNewpag = 1;; 4580 if (fISW[5] > 0) {; 4581 fNpagwd = 80;; 4582 fNpagln = 30;; 4583 fNewpag = 0;; 4584 }; 4585 fUp = 1;; 4586 fUpdflt = fUp;; 4587// determine machine accuracy epsmac; 4588 epstry = .5;; 4589 for (i = 1; i <= 100; ++i) {; 4590 epstry *= .5;; 4591 epsp1 = epstry + 1;; 4592 mntiny(epsp1, epsbak);; 4593 if (epsbak < epstry) goto L35;; 4594 }; 4595 epstry = 1e-7;; 4596 fEpsmac = epstry*4;; 4597 Printf("" MNINIT UNABLE TO DETERMINE ARITHMETIC PRECISION. WILL ASSUME:%g"",fEpsmac);; 4598L35:; 4599 fEpsmac = epstry*8;; 4600 fEpsma2 = TMath::Sqrt(fEpsmac)*2;; 4601// the vlims are a non-negligible distance from pi/2; 4602// used by MNPINT to set variables ""near"" the physical limits; 4603 piby2 = TMath::ATan(1)*2;; 4604 distnn = TMath::Sqrt(fEpsma2)*8;; 4605 fVlimhi = piby2 - distnn;; 4606 fVlimlo = -piby2 + distnn;; 4607 mncler();; 4608// Printf("" MINUIT RELEASE %s INITIALIZED. DIMENSIONS 100/50 EPSMAC=%g"",(const char*)fCvrsn,fEpsmac);; 4609}; 4610 ; 4611////////////////////////////////////////////////////////////////////////////////; 4612/// Interprets the SET LIM command, to reset the parameter limits; 4613///; 4614/// Called from MNSET; 4615 ; 4616void TMinuit::mnlims(); 4617{; 4618 /* Local variables */; 4619 Double_t dxdi, snew;; 4620 Int_t kint, i2, newcod, ifx=0, inu;; 4621 ; 4622 fCfrom = ""SET LIM "";; 4623 fNfcnfr = fNfcn;; 4624 fCstatu = ""NO CHANGE "";; 4625 i2 = Int_t(fWord7[0]);; 4626 if (i2 > fMaxext || i2 < 0) goto L900;; 4627 if (i2 > 0) goto L30;; 4628// set limits on all parameters; 4629 newcod = 4;; 4630 if (fWord7[1] == fWord7[2]) newcod = 1;; 4631 for (inu = 1; inu <= fNu; ++inu) {; 4632 if (fNvarl[inu-1] <= 0) continue;; 4633 if (",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:153408,Modifiability,variab,variables,153408,"ts; 4603 piby2 = TMath::ATan(1)*2;; 4604 distnn = TMath::Sqrt(fEpsma2)*8;; 4605 fVlimhi = piby2 - distnn;; 4606 fVlimlo = -piby2 + distnn;; 4607 mncler();; 4608// Printf("" MINUIT RELEASE %s INITIALIZED. DIMENSIONS 100/50 EPSMAC=%g"",(const char*)fCvrsn,fEpsmac);; 4609}; 4610 ; 4611////////////////////////////////////////////////////////////////////////////////; 4612/// Interprets the SET LIM command, to reset the parameter limits; 4613///; 4614/// Called from MNSET; 4615 ; 4616void TMinuit::mnlims(); 4617{; 4618 /* Local variables */; 4619 Double_t dxdi, snew;; 4620 Int_t kint, i2, newcod, ifx=0, inu;; 4621 ; 4622 fCfrom = ""SET LIM "";; 4623 fNfcnfr = fNfcn;; 4624 fCstatu = ""NO CHANGE "";; 4625 i2 = Int_t(fWord7[0]);; 4626 if (i2 > fMaxext || i2 < 0) goto L900;; 4627 if (i2 > 0) goto L30;; 4628// set limits on all parameters; 4629 newcod = 4;; 4630 if (fWord7[1] == fWord7[2]) newcod = 1;; 4631 for (inu = 1; inu <= fNu; ++inu) {; 4632 if (fNvarl[inu-1] <= 0) continue;; 4633 if (fNvarl[inu-1] == 1 && newcod == 1) continue;; 4634 kint = fNiofex[inu-1];; 4635// see if parameter has been fixed; 4636 if (kint <= 0) {; 4637 if (fISW[4] >= 0) {; 4638 Printf("" LIMITS NOT CHANGED FOR FIXED PARAMETER:%4d"",inu);; 4639 }; 4640 continue;; 4641 }; 4642 if (newcod == 1) {; 4643// remove limits from parameter; 4644 if (fISW[4] > 0) {; 4645 Printf("" LIMITS REMOVED FROM PARAMETER :%3d"",inu);; 4646 }; 4647 fCstatu = ""NEW LIMITS"";; 4648 mndxdi(fX[kint-1], kint-1, dxdi);; 4649 snew = fGstep[kint-1]*dxdi;; 4650 fGstep[kint-1] = TMath::Abs(snew);; 4651 fNvarl[inu-1] = 1;; 4652 } else {; 4653// put limits on parameter; 4654 fAlim[inu-1] = TMath::Min(fWord7[1],fWord7[2]);; 4655 fBlim[inu-1] = TMath::Max(fWord7[1],fWord7[2]);; 4656 if (fISW[4] > 0) {; 4657 Printf("" PARAMETER %3d LIMITS SET TO %15.5g%15.5g"",inu,fAlim[inu-1],fBlim[inu-1]);; 4658 }; 4659 fNvarl[inu-1] = 4;; 4660 fCstatu = ""NEW LIMITS"";; 4661 fGstep[kint-1] = -.1;; 4662 }; 4663 }; 4664 goto L900;; 4665// set limits on one parameter;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:157392,Modifiability,variab,variables,157392,"GE "") {; 4716 mnexin(fX);; 4717 mnrset(1);; 4718 }; 4719}; 4720 ; 4721////////////////////////////////////////////////////////////////////////////////; 4722/// Perform a line search from position START; 4723///; 4724/// along direction STEP, where the length of vector STEP; 4725/// gives the expected position of minimum.; 4726/// - FSTART is value of function at START; 4727/// - SLOPE (if non-zero) is df/dx along STEP at START; 4728/// - TOLER is initial tolerance of minimum in direction STEP; 4729///; 4730/// SLAMBG and ALPHA control the maximum individual steps allowed.; 4731/// The first step is always =1. The max length of second step is SLAMBG.; 4732/// The max size of subsequent steps is the maximum previous successful; 4733/// step multiplied by ALPHA + the size of most recent successful step,; 4734/// but cannot be smaller than SLAMBG.; 4735 ; 4736void TMinuit::mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler); 4737{; 4738 /* Local variables */; 4739 Double_t xpq[12], ypq[12], slam, sdev, coeff[3], denom, flast;; 4740 Double_t fvals[3], xvals[3], f1, fvmin, xvmin, ratio, f2, f3 = 0., fvmax;; 4741 Double_t toler8, toler9, overal, undral, slamin, slamax, slopem;; 4742 Int_t i, nparx=0, nvmax=0, nxypt, kk, ipt;; 4743 Bool_t ldebug;; 4744 TString cmess;; 4745 char chpq[13];; 4746 int l65, l70, l80;; 4747 ; 4748 /* Function Body */; 4749 l65 = 0; l70 = 0; l80 = 0;; 4750 ldebug = fIdbg[1] >= 1;; 4751// starting values for overall limits on total step SLAM; 4752 overal = 1e3;; 4753 undral = -100;; 4754// debug check if start is ok; 4755 if (ldebug) {; 4756 mninex(&start[0]);; 4757 Eval(nparx, fGin, f1, fU, 4); ++fNfcn;; 4758 if (f1 != fstart) {; 4759 Printf("" MNLINE start point not consistent, F values, parameters="");; 4760 for (kk = 1; kk <= fNpar; ++kk) {; 4761 Printf("" %14.5e"",fX[kk-1]);; 4762 }; 4763 }; 4764 }; 4765// set up linear search along STEP; 4766 fvmin = fstart;; 4767 xvmin = 0;; 4768 nxypt = 1;; 4769 chpq[0] = cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:164182,Modifiability,variab,variables,164182," FUNCTION CALLS "";; 4935 Printf("" MNLINE DEBUG: steps="");; 4936 for (kk = 1; kk <= fNpar; ++kk) {; 4937 Printf("" %12.4g"",step[kk-1]);; 4938 }; 4939 }; 4940// stop because within tolerance; 4941 if (l70 && ldebug) cmess = "" LINE SEARCH HAS ATTAINED TOLERANCE "";; 4942 if (l80 && ldebug) cmess = "" STEP SIZE AT ARITHMETICALLY ALLOWED MINIMUM"";; 4943 ; 4944 fAmin = fvmin;; 4945 for (i = 1; i <= fNpar; ++i) {; 4946 fDirin[i-1] = step[i-1]*xvmin;; 4947 fX[i-1] = start[i-1] + fDirin[i-1];; 4948 }; 4949 mninex(fX);; 4950 if (xvmin < 0) {; 4951 mnwarn(""D"", ""MNLINE"", "" LINE MINIMUM IN BACKWARDS DIRECTION"");; 4952 }; 4953 if (fvmin == fstart) {; 4954 mnwarn(""D"", ""MNLINE"", "" LINE SEARCH FINDS NO IMPROVEMENT "");; 4955 }; 4956 if (ldebug) {; 4957 Printf("" AFTER %3d POINTS,%s"",nxypt,(const char*)cmess);; 4958 mnplot(xpq, ypq, chpq, nxypt, fNpagwd, fNpagln);; 4959 }; 4960}; 4961 ; 4962////////////////////////////////////////////////////////////////////////////////; 4963/// Prints the covariance matrix v when KODE=1; 4964///; 4965/// always prints the global correlations, and; 4966/// calculates and prints the individual correlation coefficients; 4967 ; 4968void TMinuit::mnmatu(Int_t kode); 4969{; 4970 /* Local variables */; 4971 Int_t ndex, i, j, m, n, ncoef, nparm, id, it, ix;; 4972 Int_t nsofar, ndi, ndj, iso, isw2, isw5;; 4973 TString ctemp;; 4974 ; 4975 isw2 = fISW[1];; 4976 if (isw2 < 1) {; 4977 Printf(""%s"",(const char*)fCovmes[isw2]);; 4978 return;; 4979 }; 4980 if (fNpar == 0) {; 4981 Printf("" MNMATU: NPAR=0"");; 4982 return;; 4983 }; 4984// external error matrix; 4985 if (kode == 1) {; 4986 isw5 = fISW[4];; 4987 fISW[4] = 2;; 4988 mnemat(fP, fMaxint);; 4989 if (isw2 < 3) {; 4990 Printf(""%s"",(const char*)fCovmes[isw2]);; 4991 }; 4992 fISW[4] = isw5;; 4993 }; 4994// correlation coeffs; 4995 if (fNpar <= 1) return;; 4996 mnwerr();; 4997// NCOEF is number of coeff. that fit on one line, not to exceed 20; 4998 ncoef = (fNpagwd - 19) / 6;; 4999 ncoef = TMath::Min(ncoef,20);; 5000 n",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:166671,Modifiability,variab,variables,166671,"s"",(const char*)ctemp);; 5023 if (i <= nparm) continue;; 5024 ctemp = "" "";; 5025 for (iso = 1; iso <= 10; ++iso) {; 5026 nsofar = nparm;; 5027 nparm = TMath::Min(fNpar,nsofar + ncoef);; 5028 for (it = nsofar + 1; it <= nparm; ++it) {; 5029 ctemp = ctemp + TString::Format("" %6.3f"",fMATUvline[it-1]);; 5030 }; 5031 Printf(""%s"",(const char*)ctemp);; 5032 if (i <= nparm) break;; 5033 }; 5034 }; 5035 if (isw2 < 3) {; 5036 Printf("" %s"",(const char*)fCovmes[isw2]);; 5037 }; 5038}; 5039 ; 5040////////////////////////////////////////////////////////////////////////////////; 5041/// Performs a local function minimization; 5042///; 5043/// Performs a local function minimization using basically the; 5044/// method of Davidon-Fletcher-Powell as modified by Fletcher; 5045///; 5046/// ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""; 5047 ; 5048void TMinuit::mnmigr(); 5049{; 5050 /* Local variables */; 5051 Double_t gdel, gami, vlen, dsum, gssq, vsum, d;; 5052 Double_t fzero, fs, ri, delgam, rhotol;; 5053 Double_t gdgssq, gvg, vgi;; 5054 Int_t npfn, ndex, iext, i, j, m, n, npsdf, nparx;; 5055 Int_t iswtr, lined2, kk, nfcnmg, nrstrt,iter;; 5056 Bool_t ldebug;; 5057 Double_t toler = 0.05;; 5058 ; 5059 if (fNpar <= 0) return;; 5060 if (fAmin == fUndefi) mnamin();; 5061 ldebug = kFALSE; if ( fIdbg[4] >= 1) ldebug = kTRUE;; 5062 fCfrom = ""MIGRAD "";; 5063 fNfcnfr = fNfcn;; 5064 nfcnmg = fNfcn;; 5065 fCstatu = ""INITIATE "";; 5066 iswtr = fISW[4] - 2*fItaur;; 5067 npfn = fNfcn;; 5068 nparx = fNpar;; 5069 vlen = (Double_t) (fNpar*(fNpar + 1) / 2);; 5070 nrstrt = 0;; 5071 npsdf = 0;; 5072 lined2 = 0;; 5073 fISW[3] = -1;; 5074 rhotol = fApsi*.001;; 5075 if (iswtr >= 1) {; 5076 Printf("" START MIGRAD MINIMIZATION. STRATEGY %2d. CONVERGENCE WHEN EDM .LT.%9.2e"",fIstrat,rhotol);; 5077 }; 5078// initialization strategy; 5079 if (fIstrat < 2 || fISW[1] >= 3) goto L2;; 5080// come (back) here to restart completely; 5081L1:; 5082 if (nrstrt > fIstrat) {; 5083 fCstatu = ""FAILED "";; 5084 fISW[3]",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:176385,Modifiability,variab,variables,176385,";; 5362 }; 5363 mnhess();; 5364 mnwerr();; 5365 npsdf = 0;; 5366 if (fEDM > rhotol) goto L10;; 5367 }; 5368 }; 5369 fCstatu = ""CONVERGED "";; 5370 fISW[3] = 1;; 5371// come here in any case; 5372L400:; 5373 fCfrom = ""MIGRAD "";; 5374 fNfcnfr = nfcnmg;; 5375 mninex(fX);; 5376 mnwerr();; 5377 if (iswtr >= 0) mnprin(3, fAmin);; 5378 if (iswtr >= 1) mnmatu(1);; 5379}; 5380 ; 5381////////////////////////////////////////////////////////////////////////////////; 5382/// Performs a MINOS error analysis; 5383///; 5384/// Performs a MINOS error analysis on those parameters for; 5385/// which it is requested on the MINOS command by calling; 5386/// MNMNOT for each parameter requested.; 5387 ; 5388void TMinuit::mnmnos(); 5389{; 5390 /* Local variables */; 5391 Double_t val2mi, val2pl;; 5392 Int_t nbad, ilax, ilax2, ngood, nfcnmi, iin, knt;; 5393 ; 5394 if (fNpar <= 0) goto L700;; 5395 ngood = 0;; 5396 nbad = 0;; 5397 nfcnmi = fNfcn;; 5398// loop over parameters requested; 5399 for (knt = 1; knt <= fNpar; ++knt) {; 5400 if (Int_t(fWord7[1]) == 0) {; 5401 ilax = fNexofi[knt-1];; 5402 } else {; 5403 if (knt >= 7) break;; 5404 ilax = Int_t(fWord7[knt]);; 5405 if (ilax == 0) break;; 5406 if (ilax > 0 && ilax <= fNu) {; 5407 if (fNiofex[ilax-1] > 0) goto L565;; 5408 }; 5409 Printf("" PARAMETER NUMBER %3d NOT A VARIABLE. IGNORED."",ilax);; 5410 continue;; 5411 }; 5412L565:; 5413// calculate one pair of M E s; 5414 ilax2 = 0;; 5415 mnmnot(ilax, ilax2, val2pl, val2mi);; 5416 if (fLnewmn) goto L650;; 5417// update NGOOD and NBAD; 5418 iin = fNiofex[ilax-1];; 5419 if (fErp[iin-1] > 0) ++ngood;; 5420 else ++nbad;; 5421 if (fErn[iin-1] < 0) ++ngood;; 5422 else ++nbad;; 5423 }; 5424// end of loop; 5425// printout final values; 5426 fCfrom = ""MINOS "";; 5427 fNfcnfr = nfcnmi;; 5428 fCstatu = ""UNCHANGED "";; 5429 if (ngood == 0 && nbad == 0) goto L700;; 5430 if (ngood > 0 && nbad == 0) fCstatu = ""SUCCESSFUL"";; 5431 if (ngood == 0 && nbad > 0) fCstatu = ""FAILURE "";; 5432 if (ngood > 0 && nbad > 0) fC",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:178807,Modifiability,variab,variables,178807,". GO BACK TO MINIMIZATION STEP."");; 5443 Printf("" ================================================="");; 5444 Printf("" V"");; 5445 Printf("" V"");; 5446 Printf("" V"");; 5447 Printf("" VVVVVVV"");; 5448 Printf("" VVVVV"");; 5449 Printf("" VVV"");; 5450 Printf("" V\n"");; 5451 return;; 5452L700:; 5453 Printf("" THERE ARE NO MINOS ERRORS TO CALCULATE."");; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Performs a MINOS error analysis on one parameter; 5458///; 5459/// The parameter ILAX is varied, and the minimum of the; 5460/// function with respect to the other parameters is followed; 5461/// until it crosses the value FMIN+UP.; 5462 ; 5463void TMinuit::mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi); 5464{; 5465 /* System generated locals */; 5466 Int_t i__1;; 5467 ; 5468 /* Local variables */; 5469 Double_t delu, aopt, eros;; 5470 Double_t abest, xunit, dc, ut, sigsav, du1;; 5471 Double_t fac, sig, sav;; 5472 Int_t marc, isig, mpar, ndex, imax, indx, ierr, i, j;; 5473 Int_t iercr, it, istrav, nfmxin, nlimit, isw2, isw4;; 5474 TString csig;; 5475 ; 5476// save and prepare start vals; 5477 isw2 = fISW[1];; 5478 isw4 = fISW[3];; 5479 sigsav = fEDM;; 5480 istrav = fIstrat;; 5481 dc = fDcovar;; 5482 fLnewmn = kFALSE;; 5483 fApsi = fEpsi*.5;; 5484 abest = fAmin;; 5485 mpar = fNpar;; 5486 nfmxin = fNfcnmx;; 5487 for (i = 1; i <= mpar; ++i) { fXt[i-1] = fX[i-1]; }; 5488 i__1 = mpar*(mpar + 1) / 2;; 5489 for (j = 1; j <= i__1; ++j) { fVthmat[j-1] = fVhmat[j-1]; }; 5490 for (i = 1; i <= mpar; ++i) {; 5491 fMNOTgcc[i-1] = fGlobcc[i-1];; 5492 fMNOTw[i-1] = fWerr[i-1];; 5493 }; 5494 it = fNiofex[ilax-1];; 5495 fErp[it-1] = 0;; 5496 fErn[it-1] = 0;; 5497 mninex(fXt);; 5498 ut = fU[ilax-1];; 5499 if (fNvarl[ilax-1] == 1) {; 5500 fAlim[ilax-1] = ut - fMNOTw[it-1]*100;; 5501 fBlim[ilax-1] = ut + fMNOTw[it-1]*100;; 5502 }; 5503 ndex = it*(it + 1) / 2;; 5504 xunit = TMath::Sqrt(fUp / fVthmat[ndex-1]);; 5505 marc = 0;; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:184925,Modifiability,variab,variables,184925,"5639 mnfree(1);; 5640 fU[ilax-1] = sav;; 5641 mnexin(fX);; 5642 fEDM = fBigedm;; 5643// in any case; 5644L700:; 5645 fItaur = 0;; 5646 fNfcnmx = nfmxin;; 5647 fIstrat = istrav;; 5648}; 5649 ; 5650////////////////////////////////////////////////////////////////////////////////; 5651/// Implements one parameter definition; 5652///; 5653/// Called from MNPARS and user-callable; 5654/// Implements one parameter definition, that is:; 5655/// - K (external) parameter number; 5656/// - CNAMK parameter name; 5657/// - UK starting value; 5658/// - WK starting step size or uncertainty; 5659/// - A, B lower and upper physical parameter limits; 5660/// and sets up (updates) the parameter lists.; 5661/// Output:; 5662/// - IERFLG=0 if no problems; 5663/// - >0 if MNPARM unable to implement definition; 5664 ; 5665void TMinuit::mnparm(Int_t k1, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg); 5666{; 5667 /* Local variables */; 5668 Double_t vplu, a_small, gsmin, pinti, vminu, danger, sav, sav2;; 5669 Int_t ierr, kint, in, ix, ktofix, lastin, kinfix, nvl;; 5670 TString cnamk, chbufi;; 5671 ; 5672 Int_t k = k1+1;; 5673 cnamk = cnamj;; 5674 kint = fNpar;; 5675 if (k < 1 || k > fMaxext) {; 5676// parameter number exceeds allowed maximum value; 5677 Printf("" MINUIT USER ERROR. PARAMETER NUMBER IS %3d ALLOWED RANGE IS ONE TO %4d"",k,fMaxext);; 5678 goto L800;; 5679 }; 5680// normal parameter request; 5681 ktofix = 0;; 5682 if (fNvarl[k-1] < 0) goto L50;; 5683// previously defined parameter is being redefined; 5684// find if parameter was fixed; 5685 for (ix = 1; ix <= fNpfix; ++ix) {; 5686 if (fIpfix[ix-1] == k) ktofix = k;; 5687 }; 5688 if (ktofix > 0) {; 5689 mnwarn(""W"", ""PARAM DEF"", ""REDEFINING A FIXED PARAMETER."");; 5690 if (kint >= fMaxint) {; 5691 Printf("" CANNOT RELEASE. MAX NPAR EXCEEDED."");; 5692 goto L800;; 5693 }; 5694 mnfree(-k);; 5695 }; 5696// if redefining previously variable parameter; 5697 if (fNiofex[k-1] > 0) kint = fNpar - 1;; 5698L50:;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:185906,Modifiability,variab,variable,185906,"mall, gsmin, pinti, vminu, danger, sav, sav2;; 5669 Int_t ierr, kint, in, ix, ktofix, lastin, kinfix, nvl;; 5670 TString cnamk, chbufi;; 5671 ; 5672 Int_t k = k1+1;; 5673 cnamk = cnamj;; 5674 kint = fNpar;; 5675 if (k < 1 || k > fMaxext) {; 5676// parameter number exceeds allowed maximum value; 5677 Printf("" MINUIT USER ERROR. PARAMETER NUMBER IS %3d ALLOWED RANGE IS ONE TO %4d"",k,fMaxext);; 5678 goto L800;; 5679 }; 5680// normal parameter request; 5681 ktofix = 0;; 5682 if (fNvarl[k-1] < 0) goto L50;; 5683// previously defined parameter is being redefined; 5684// find if parameter was fixed; 5685 for (ix = 1; ix <= fNpfix; ++ix) {; 5686 if (fIpfix[ix-1] == k) ktofix = k;; 5687 }; 5688 if (ktofix > 0) {; 5689 mnwarn(""W"", ""PARAM DEF"", ""REDEFINING A FIXED PARAMETER."");; 5690 if (kint >= fMaxint) {; 5691 Printf("" CANNOT RELEASE. MAX NPAR EXCEEDED."");; 5692 goto L800;; 5693 }; 5694 mnfree(-k);; 5695 }; 5696// if redefining previously variable parameter; 5697 if (fNiofex[k-1] > 0) kint = fNpar - 1;; 5698L50:; 5699 ; 5700// print heading; 5701 if (fLphead && fISW[4] >= 0) {; 5702 Printf("" PARAMETER DEFINITIONS:"");; 5703 Printf("" NO. NAME VALUE STEP SIZE LIMITS"");; 5704 fLphead = kFALSE;; 5705 }; 5706 if (wk > 0) goto L122;; 5707// constant parameter; 5708 if (fISW[4] >= 0) {; 5709 Printf("" %5d %-10s %13.5e constant"",k,(const char*)cnamk,uk);; 5710 }; 5711 nvl = 0;; 5712 goto L200;; 5713L122:; 5714 if (a == 0 && b == 0) {; 5715// variable parameter without limits; 5716 nvl = 1;; 5717 if (fISW[4] >= 0) {; 5718 Printf("" %5d %-10s %13.5e%13.5e no limits"",k,(const char*)cnamk,uk,wk);; 5719 }; 5720 } else {; 5721// variable parameter with limits; 5722 nvl = 4;; 5723 fLnolim = kFALSE;; 5724 if (fISW[4] >= 0) {; 5725 Printf("" %5d %-10s %13.5e%13.5e %13.5e%13.5e"",k,(const char*)cnamk,uk,wk,a,b);; 5726 }; 5727 }; 5728// request for another variable parameter; 5729 ++kint;; 5730 if (kint > fMaxint) {; 5731 Printf("" MINUIT USER ERROR. TOO MANY VARIABLE PARAMETERS."");; 5732 goto L800;",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:186409,Modifiability,variab,variable,186409,"arameter request; 5681 ktofix = 0;; 5682 if (fNvarl[k-1] < 0) goto L50;; 5683// previously defined parameter is being redefined; 5684// find if parameter was fixed; 5685 for (ix = 1; ix <= fNpfix; ++ix) {; 5686 if (fIpfix[ix-1] == k) ktofix = k;; 5687 }; 5688 if (ktofix > 0) {; 5689 mnwarn(""W"", ""PARAM DEF"", ""REDEFINING A FIXED PARAMETER."");; 5690 if (kint >= fMaxint) {; 5691 Printf("" CANNOT RELEASE. MAX NPAR EXCEEDED."");; 5692 goto L800;; 5693 }; 5694 mnfree(-k);; 5695 }; 5696// if redefining previously variable parameter; 5697 if (fNiofex[k-1] > 0) kint = fNpar - 1;; 5698L50:; 5699 ; 5700// print heading; 5701 if (fLphead && fISW[4] >= 0) {; 5702 Printf("" PARAMETER DEFINITIONS:"");; 5703 Printf("" NO. NAME VALUE STEP SIZE LIMITS"");; 5704 fLphead = kFALSE;; 5705 }; 5706 if (wk > 0) goto L122;; 5707// constant parameter; 5708 if (fISW[4] >= 0) {; 5709 Printf("" %5d %-10s %13.5e constant"",k,(const char*)cnamk,uk);; 5710 }; 5711 nvl = 0;; 5712 goto L200;; 5713L122:; 5714 if (a == 0 && b == 0) {; 5715// variable parameter without limits; 5716 nvl = 1;; 5717 if (fISW[4] >= 0) {; 5718 Printf("" %5d %-10s %13.5e%13.5e no limits"",k,(const char*)cnamk,uk,wk);; 5719 }; 5720 } else {; 5721// variable parameter with limits; 5722 nvl = 4;; 5723 fLnolim = kFALSE;; 5724 if (fISW[4] >= 0) {; 5725 Printf("" %5d %-10s %13.5e%13.5e %13.5e%13.5e"",k,(const char*)cnamk,uk,wk,a,b);; 5726 }; 5727 }; 5728// request for another variable parameter; 5729 ++kint;; 5730 if (kint > fMaxint) {; 5731 Printf("" MINUIT USER ERROR. TOO MANY VARIABLE PARAMETERS."");; 5732 goto L800;; 5733 }; 5734 if (nvl == 1) goto L200;; 5735 if (a == b) {; 5736 Printf("" USER ERROR IN MINUIT PARAMETER"");; 5737 Printf("" DEFINITION"");; 5738 Printf("" UPPER AND LOWER LIMITS EQUAL."");; 5739 goto L800;; 5740 }; 5741 if (b < a) {; 5742 sav = b;; 5743 b = a;; 5744 a = sav;; 5745 mnwarn(""W"", ""PARAM DEF"", ""PARAMETER LIMITS WERE REVERSED."");; 5746 if (fLwarn) fLphead = kTRUE;; 5747 }; 5748 if (b - a > 1e7) {; 5749 mnwarn(""W"", ""PARAM DE",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:186593,Modifiability,variab,variable,186593,"[ix-1] == k) ktofix = k;; 5687 }; 5688 if (ktofix > 0) {; 5689 mnwarn(""W"", ""PARAM DEF"", ""REDEFINING A FIXED PARAMETER."");; 5690 if (kint >= fMaxint) {; 5691 Printf("" CANNOT RELEASE. MAX NPAR EXCEEDED."");; 5692 goto L800;; 5693 }; 5694 mnfree(-k);; 5695 }; 5696// if redefining previously variable parameter; 5697 if (fNiofex[k-1] > 0) kint = fNpar - 1;; 5698L50:; 5699 ; 5700// print heading; 5701 if (fLphead && fISW[4] >= 0) {; 5702 Printf("" PARAMETER DEFINITIONS:"");; 5703 Printf("" NO. NAME VALUE STEP SIZE LIMITS"");; 5704 fLphead = kFALSE;; 5705 }; 5706 if (wk > 0) goto L122;; 5707// constant parameter; 5708 if (fISW[4] >= 0) {; 5709 Printf("" %5d %-10s %13.5e constant"",k,(const char*)cnamk,uk);; 5710 }; 5711 nvl = 0;; 5712 goto L200;; 5713L122:; 5714 if (a == 0 && b == 0) {; 5715// variable parameter without limits; 5716 nvl = 1;; 5717 if (fISW[4] >= 0) {; 5718 Printf("" %5d %-10s %13.5e%13.5e no limits"",k,(const char*)cnamk,uk,wk);; 5719 }; 5720 } else {; 5721// variable parameter with limits; 5722 nvl = 4;; 5723 fLnolim = kFALSE;; 5724 if (fISW[4] >= 0) {; 5725 Printf("" %5d %-10s %13.5e%13.5e %13.5e%13.5e"",k,(const char*)cnamk,uk,wk,a,b);; 5726 }; 5727 }; 5728// request for another variable parameter; 5729 ++kint;; 5730 if (kint > fMaxint) {; 5731 Printf("" MINUIT USER ERROR. TOO MANY VARIABLE PARAMETERS."");; 5732 goto L800;; 5733 }; 5734 if (nvl == 1) goto L200;; 5735 if (a == b) {; 5736 Printf("" USER ERROR IN MINUIT PARAMETER"");; 5737 Printf("" DEFINITION"");; 5738 Printf("" UPPER AND LOWER LIMITS EQUAL."");; 5739 goto L800;; 5740 }; 5741 if (b < a) {; 5742 sav = b;; 5743 b = a;; 5744 a = sav;; 5745 mnwarn(""W"", ""PARAM DEF"", ""PARAMETER LIMITS WERE REVERSED."");; 5746 if (fLwarn) fLphead = kTRUE;; 5747 }; 5748 if (b - a > 1e7) {; 5749 mnwarn(""W"", ""PARAM DEF"", TString::Format(""LIMITS ON PARAM%d TOO FAR APART."",k));; 5750 if (fLwarn) fLphead = kTRUE;; 5751 }; 5752 danger = (b - uk)*(uk - a);; 5753 if (danger < 0) {; 5754 mnwarn(""W"", ""PARAM DEF"", ""STARTING VALUE OUTSIDE LIMITS",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:186818,Modifiability,variab,variable,186818,"692 goto L800;; 5693 }; 5694 mnfree(-k);; 5695 }; 5696// if redefining previously variable parameter; 5697 if (fNiofex[k-1] > 0) kint = fNpar - 1;; 5698L50:; 5699 ; 5700// print heading; 5701 if (fLphead && fISW[4] >= 0) {; 5702 Printf("" PARAMETER DEFINITIONS:"");; 5703 Printf("" NO. NAME VALUE STEP SIZE LIMITS"");; 5704 fLphead = kFALSE;; 5705 }; 5706 if (wk > 0) goto L122;; 5707// constant parameter; 5708 if (fISW[4] >= 0) {; 5709 Printf("" %5d %-10s %13.5e constant"",k,(const char*)cnamk,uk);; 5710 }; 5711 nvl = 0;; 5712 goto L200;; 5713L122:; 5714 if (a == 0 && b == 0) {; 5715// variable parameter without limits; 5716 nvl = 1;; 5717 if (fISW[4] >= 0) {; 5718 Printf("" %5d %-10s %13.5e%13.5e no limits"",k,(const char*)cnamk,uk,wk);; 5719 }; 5720 } else {; 5721// variable parameter with limits; 5722 nvl = 4;; 5723 fLnolim = kFALSE;; 5724 if (fISW[4] >= 0) {; 5725 Printf("" %5d %-10s %13.5e%13.5e %13.5e%13.5e"",k,(const char*)cnamk,uk,wk,a,b);; 5726 }; 5727 }; 5728// request for another variable parameter; 5729 ++kint;; 5730 if (kint > fMaxint) {; 5731 Printf("" MINUIT USER ERROR. TOO MANY VARIABLE PARAMETERS."");; 5732 goto L800;; 5733 }; 5734 if (nvl == 1) goto L200;; 5735 if (a == b) {; 5736 Printf("" USER ERROR IN MINUIT PARAMETER"");; 5737 Printf("" DEFINITION"");; 5738 Printf("" UPPER AND LOWER LIMITS EQUAL."");; 5739 goto L800;; 5740 }; 5741 if (b < a) {; 5742 sav = b;; 5743 b = a;; 5744 a = sav;; 5745 mnwarn(""W"", ""PARAM DEF"", ""PARAMETER LIMITS WERE REVERSED."");; 5746 if (fLwarn) fLphead = kTRUE;; 5747 }; 5748 if (b - a > 1e7) {; 5749 mnwarn(""W"", ""PARAM DEF"", TString::Format(""LIMITS ON PARAM%d TOO FAR APART."",k));; 5750 if (fLwarn) fLphead = kTRUE;; 5751 }; 5752 danger = (b - uk)*(uk - a);; 5753 if (danger < 0) {; 5754 mnwarn(""W"", ""PARAM DEF"", ""STARTING VALUE OUTSIDE LIMITS."");; 5755 }; 5756 if (danger == 0) {; 5757 mnwarn(""W"", ""PARAM DEF"", ""STARTING VALUE IS AT LIMIT."");; 5758 }; 5759L200:; 5760// input OK, set values, arrange lists,; 5761// calculate step sizes GSTEP, DIRIN",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:188305,Modifiability,variab,variable,188305,"5767 fU[k-1] = uk;; 5768 fAlim[k-1] = a;; 5769 fBlim[k-1] = b;; 5770 fNvarl[k-1] = nvl;; 5771 mnrset(1);; 5772// K is external number of new parameter; 5773// LASTIN is the number of var. params with ext. param. no.< K; 5774 lastin = 0;; 5775 for (ix = 1; ix <= k-1; ++ix) { if (fNiofex[ix-1] > 0) ++lastin; }; 5776// KINT is new number of variable params, NPAR is old; 5777 if (kint == fNpar) goto L280;; 5778 if (kint > fNpar) {; 5779// insert new variable parameter in list; 5780 for (in = fNpar; in >= lastin + 1; --in) {; 5781 ix = fNexofi[in-1];; 5782 fNiofex[ix-1] = in + 1;; 5783 fNexofi[in] = ix;; 5784 fX[in] = fX[in-1];; 5785 fXt[in] = fXt[in-1];; 5786 fDirin[in] = fDirin[in-1];; 5787 fG2[in] = fG2[in-1];; 5788 fGstep[in] = fGstep[in-1];; 5789 fWerr[in] = fWerr[in-1];; 5790 fGrd[in] = fGrd[in-1];; 5791 }; 5792 } else {; 5793// remove variable parameter from list; 5794 for (in = lastin + 1; in <= kint; ++in) {; 5795 ix = fNexofi[in];; 5796 fNiofex[ix-1] = in;; 5797 fNexofi[in-1] = ix;; 5798 fX[in-1] = fX[in];; 5799 fXt[in-1] = fXt[in];; 5800 fDirin[in-1] = fDirin[in];; 5801 fG2[in-1] = fG2[in];; 5802 fGstep[in-1] = fGstep[in];; 5803 fWerr[in-1] = fWerr[in];; 5804 fGrd[in-1] = fGrd[in];; 5805 }; 5806 }; 5807L280:; 5808 ix = k;; 5809 fNiofex[ix-1] = 0;; 5810 fNpar = kint;; 5811// lists are now arranged; 5812 if (nvl > 0) {; 5813 in = lastin + 1;; 5814 fNexofi[in-1] = ix;; 5815 fNiofex[ix-1] = in;; 5816 sav = fU[ix-1];; 5817 mnpint(sav, ix-1, pinti);; 5818 fX[in-1] = pinti;; 5819 fXt[in-1] = fX[in-1];; 5820 fWerr[in-1] = wk;; 5821 sav2 = sav + wk;; 5822 mnpint(sav2, ix-1, pinti);; 5823 vplu = pinti - fX[in-1];; 5824 sav2 = sav - wk;; 5825 mnpint(sav2, ix-1, pinti);; 5826 vminu = pinti - fX[in-1];; 5827 fDirin[in-1] = (TMath::Abs(vplu) + TMath::Abs(vminu))*.5;; 5828 fG2[in-1] = fUp*2 / (fDirin[in-1]*fDirin[in-1]);; 5829 gsmin = fEpsma2*8*TMath::Abs(fX[in-1]);; 5830 fGstep[in-1] = TMath::Max(gsmin,fDirin[in-1]*.1);; 5831 if (fAmin != fUndefi) {; 5832 a_small = TMath::Sq",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:188415,Modifiability,variab,variable,188415,"5767 fU[k-1] = uk;; 5768 fAlim[k-1] = a;; 5769 fBlim[k-1] = b;; 5770 fNvarl[k-1] = nvl;; 5771 mnrset(1);; 5772// K is external number of new parameter; 5773// LASTIN is the number of var. params with ext. param. no.< K; 5774 lastin = 0;; 5775 for (ix = 1; ix <= k-1; ++ix) { if (fNiofex[ix-1] > 0) ++lastin; }; 5776// KINT is new number of variable params, NPAR is old; 5777 if (kint == fNpar) goto L280;; 5778 if (kint > fNpar) {; 5779// insert new variable parameter in list; 5780 for (in = fNpar; in >= lastin + 1; --in) {; 5781 ix = fNexofi[in-1];; 5782 fNiofex[ix-1] = in + 1;; 5783 fNexofi[in] = ix;; 5784 fX[in] = fX[in-1];; 5785 fXt[in] = fXt[in-1];; 5786 fDirin[in] = fDirin[in-1];; 5787 fG2[in] = fG2[in-1];; 5788 fGstep[in] = fGstep[in-1];; 5789 fWerr[in] = fWerr[in-1];; 5790 fGrd[in] = fGrd[in-1];; 5791 }; 5792 } else {; 5793// remove variable parameter from list; 5794 for (in = lastin + 1; in <= kint; ++in) {; 5795 ix = fNexofi[in];; 5796 fNiofex[ix-1] = in;; 5797 fNexofi[in-1] = ix;; 5798 fX[in-1] = fX[in];; 5799 fXt[in-1] = fXt[in];; 5800 fDirin[in-1] = fDirin[in];; 5801 fG2[in-1] = fG2[in];; 5802 fGstep[in-1] = fGstep[in];; 5803 fWerr[in-1] = fWerr[in];; 5804 fGrd[in-1] = fGrd[in];; 5805 }; 5806 }; 5807L280:; 5808 ix = k;; 5809 fNiofex[ix-1] = 0;; 5810 fNpar = kint;; 5811// lists are now arranged; 5812 if (nvl > 0) {; 5813 in = lastin + 1;; 5814 fNexofi[in-1] = ix;; 5815 fNiofex[ix-1] = in;; 5816 sav = fU[ix-1];; 5817 mnpint(sav, ix-1, pinti);; 5818 fX[in-1] = pinti;; 5819 fXt[in-1] = fX[in-1];; 5820 fWerr[in-1] = wk;; 5821 sav2 = sav + wk;; 5822 mnpint(sav2, ix-1, pinti);; 5823 vplu = pinti - fX[in-1];; 5824 sav2 = sav - wk;; 5825 mnpint(sav2, ix-1, pinti);; 5826 vminu = pinti - fX[in-1];; 5827 fDirin[in-1] = (TMath::Abs(vplu) + TMath::Abs(vminu))*.5;; 5828 fG2[in-1] = fUp*2 / (fDirin[in-1]*fDirin[in-1]);; 5829 gsmin = fEpsma2*8*TMath::Abs(fX[in-1]);; 5830 fGstep[in-1] = TMath::Max(gsmin,fDirin[in-1]*.1);; 5831 if (fAmin != fUndefi) {; 5832 a_small = TMath::Sq",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:188814,Modifiability,variab,variable,188814,"5767 fU[k-1] = uk;; 5768 fAlim[k-1] = a;; 5769 fBlim[k-1] = b;; 5770 fNvarl[k-1] = nvl;; 5771 mnrset(1);; 5772// K is external number of new parameter; 5773// LASTIN is the number of var. params with ext. param. no.< K; 5774 lastin = 0;; 5775 for (ix = 1; ix <= k-1; ++ix) { if (fNiofex[ix-1] > 0) ++lastin; }; 5776// KINT is new number of variable params, NPAR is old; 5777 if (kint == fNpar) goto L280;; 5778 if (kint > fNpar) {; 5779// insert new variable parameter in list; 5780 for (in = fNpar; in >= lastin + 1; --in) {; 5781 ix = fNexofi[in-1];; 5782 fNiofex[ix-1] = in + 1;; 5783 fNexofi[in] = ix;; 5784 fX[in] = fX[in-1];; 5785 fXt[in] = fXt[in-1];; 5786 fDirin[in] = fDirin[in-1];; 5787 fG2[in] = fG2[in-1];; 5788 fGstep[in] = fGstep[in-1];; 5789 fWerr[in] = fWerr[in-1];; 5790 fGrd[in] = fGrd[in-1];; 5791 }; 5792 } else {; 5793// remove variable parameter from list; 5794 for (in = lastin + 1; in <= kint; ++in) {; 5795 ix = fNexofi[in];; 5796 fNiofex[ix-1] = in;; 5797 fNexofi[in-1] = ix;; 5798 fX[in-1] = fX[in];; 5799 fXt[in-1] = fXt[in];; 5800 fDirin[in-1] = fDirin[in];; 5801 fG2[in-1] = fG2[in];; 5802 fGstep[in-1] = fGstep[in];; 5803 fWerr[in-1] = fWerr[in];; 5804 fGrd[in-1] = fGrd[in];; 5805 }; 5806 }; 5807L280:; 5808 ix = k;; 5809 fNiofex[ix-1] = 0;; 5810 fNpar = kint;; 5811// lists are now arranged; 5812 if (nvl > 0) {; 5813 in = lastin + 1;; 5814 fNexofi[in-1] = ix;; 5815 fNiofex[ix-1] = in;; 5816 sav = fU[ix-1];; 5817 mnpint(sav, ix-1, pinti);; 5818 fX[in-1] = pinti;; 5819 fXt[in-1] = fX[in-1];; 5820 fWerr[in-1] = wk;; 5821 sav2 = sav + wk;; 5822 mnpint(sav2, ix-1, pinti);; 5823 vplu = pinti - fX[in-1];; 5824 sav2 = sav - wk;; 5825 mnpint(sav2, ix-1, pinti);; 5826 vminu = pinti - fX[in-1];; 5827 fDirin[in-1] = (TMath::Abs(vplu) + TMath::Abs(vminu))*.5;; 5828 fG2[in-1] = fUp*2 / (fDirin[in-1]*fDirin[in-1]);; 5829 gsmin = fEpsma2*8*TMath::Abs(fX[in-1]);; 5830 fGstep[in-1] = TMath::Max(gsmin,fDirin[in-1]*.1);; 5831 if (fAmin != fUndefi) {; 5832 a_small = TMath::Sq",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:191122,Modifiability,variab,variables,191122,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:193917,Modifiability,variab,variables,193917,"949/// - pary2p(i) y value of point i; 5950///; 5951/// - coef2p(1...3) coefficients of the fitted parabola; 5952/// - y=coef2p(1) + coef2p(2)*x + coef2p(3)*x**2; 5953/// - sdev2p= variance; 5954/// - method : chi**2 = min equation solved explicitly; 5955 ; 5956void TMinuit::mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p); 5957{; 5958 /* Local variables */; 5959 Double_t a, f, s, t, y, s2, x2, x3, x4, y2, cz[3], xm, xy, x2y;; 5960 x2 = x3 = 0;; 5961 Int_t i;; 5962 ; 5963 /* Parameter adjustments */; 5964 --coef2p;; 5965 --pary2p;; 5966 --parx2p;; 5967 ; 5968 /* Function Body */; 5969 for (i = 1; i <= 3; ++i) { cz[i-1] = 0; }; 5970 sdev2p = 0;; 5971 if (npar2p < 3) goto L10;; 5972 f = (Double_t) (npar2p);; 5973// center x values for reasons of machine precision; 5974 xm = 0;; 5975 for (i = 1; i <= npar2p; ++i) { xm += parx2p[i]; }; 5976 xm /= f;; 5977 x2 = 0;; 5978 x3 = 0;; 5979 x4 = 0;; 5980 y = 0;; 5981 y2 = 0;; 5982 xy = 0;; 5983 x2y = 0;; 5984 for (i = 1; i <= npar2p; ++i) {; 5985 s = parx2p[i] - xm;; 5986 t = pary2p[i];; 5987 s2 = s*s;; 5988 x2 += s2;; 5989 x3 += s*s2;; 5990 x4 += s2*s2;; 5991 y += t;; 5992 y2 += t*t;; 5993 xy += s*t;; 5994 x2y += s2*t;; 5995 }; 5996 a = (f*x4 - x2*x2)*x2 - f*(x3*x3);; 5997 if (a == 0) goto L10;; 5998 cz[2] = (x2*(f*x2y - x2*y) - f*x3*xy) / a;; 5999 cz[1] = (xy - x3*cz[2]) / x2;; 6000 cz[0] = (y - x2*cz[2]) / f;; 6001 if (npar2p == 3) goto L6;; 6002 sdev2p = y2 - (cz[0]*y + cz[1]*xy + cz[2]*x2y);; 6003 if (sdev2p < 0) sdev2p = 0;; 6004 sdev2p /= f - 3;; 6005L6:; 6006 cz[0] += xm*(xm*cz[2] - cz[1]);; 6007 cz[1] -= xm*2*cz[2];; 6008L10:; 6009 for (i = 1; i <= 3; ++i) { coef2p[i] = cz[i-1]; }; 6010}; 6011 ; 6012////////////////////////////////////////////////////////////////////////////////; 6013/// Calculates the internal parameter value PINTI; 6014///; 6015/// corresponding to the external value PEXTI for parameter I.; 6016 ; 6017void TMinuit::mnpint(Double_t &pexti, Int_t i1, Double_t",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:195557,Modifiability,variab,variables,195557,"s2*t;; 5995 }; 5996 a = (f*x4 - x2*x2)*x2 - f*(x3*x3);; 5997 if (a == 0) goto L10;; 5998 cz[2] = (x2*(f*x2y - x2*y) - f*x3*xy) / a;; 5999 cz[1] = (xy - x3*cz[2]) / x2;; 6000 cz[0] = (y - x2*cz[2]) / f;; 6001 if (npar2p == 3) goto L6;; 6002 sdev2p = y2 - (cz[0]*y + cz[1]*xy + cz[2]*x2y);; 6003 if (sdev2p < 0) sdev2p = 0;; 6004 sdev2p /= f - 3;; 6005L6:; 6006 cz[0] += xm*(xm*cz[2] - cz[1]);; 6007 cz[1] -= xm*2*cz[2];; 6008L10:; 6009 for (i = 1; i <= 3; ++i) { coef2p[i] = cz[i-1]; }; 6010}; 6011 ; 6012////////////////////////////////////////////////////////////////////////////////; 6013/// Calculates the internal parameter value PINTI; 6014///; 6015/// corresponding to the external value PEXTI for parameter I.; 6016 ; 6017void TMinuit::mnpint(Double_t &pexti, Int_t i1, Double_t &pinti); 6018{; 6019 /* Local variables */; 6020 Double_t a, alimi, blimi, yy, yy2;; 6021 Int_t igo;; 6022 TString chbuf2, chbufi;; 6023 ; 6024 Int_t i = i1+1;; 6025 pinti = pexti;; 6026 igo = fNvarl[i-1];; 6027 if (igo == 4) {; 6028// there are two limits; 6029 alimi = fAlim[i-1];; 6030 blimi = fBlim[i-1];; 6031 yy = (pexti - alimi)*2 / (blimi - alimi) - 1;; 6032 yy2 = yy*yy;; 6033 if (yy2 >= 1 - fEpsma2) {; 6034 if (yy < 0) {; 6035 a = fVlimlo;; 6036 chbuf2 = "" IS AT ITS LOWER ALLOWED LIMIT."";; 6037 } else {; 6038 a = fVlimhi;; 6039 chbuf2 = "" IS AT ITS UPPER ALLOWED LIMIT."";; 6040 }; 6041 pinti = a;; 6042 pexti = alimi + (blimi - alimi)*.5*(TMath::Sin(a) + 1);; 6043 fLimset = kTRUE;; 6044 if (yy2 > 1) chbuf2 = "" BROUGHT BACK INSIDE LIMITS."";; 6045 mnwarn(""W"", fCfrom, TString::Format(""VARIABLE%d%s"",i,chbuf2.Data()));; 6046 } else {; 6047 pinti = TMath::ASin(yy);; 6048 }; 6049 }; 6050}; 6051 ; 6052////////////////////////////////////////////////////////////////////////////////; 6053/// Plots points in array xypt onto one page with labelled axes; 6054///; 6055/// - NXYPT is the number of points to be plotted; 6056/// - XPT(I) = x-coord. of ith point; 6057/// - YPT(I) = y-coord. of ith point; 605",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:197558,Modifiability,variab,variables,197558,"the plot, you can do:; 6063/// ~~~ {.cpp}; 6064/// TGraph *gr = (TGraph*)gMinuit->GetPlot();; 6065/// gr->Draw(""al"");; 6066/// ~~~; 6067 ; 6068void TMinuit::mnplot(Double_t *xpt, Double_t *ypt, char *chpt, Int_t nxypt, Int_t npagwd, Int_t npagln); 6069{; 6070 ; 6071 if (fGraphicsMode) {; 6072 TPluginHandler *h;; 6073 if ((h = gROOT->GetPluginManager()->FindHandler(""TMinuitGraph""))) {; 6074 //remove the first two points; 6075 if (h->LoadPlugin() != -1); 6076 fPlot = (TObject*)h->ExecPlugin(3,nxypt-2,&xpt[2],&ypt[2]);; 6077 }; 6078 return;; 6079 }; 6080 ; 6081 /* Local variables */; 6082 Double_t xmin, ymin, xmax, ymax, savx, savy, yprt;; 6083 Double_t bwidx, bwidy, xbest, ybest, ax, ay, bx, by;; 6084 Double_t xvalus[12], any, dxx, dyy;; 6085 Int_t iten, i, j, k, maxnx, maxny, iquit, ni, linodd;; 6086 Int_t nxbest, nybest, km1, ibk, isp1, nx, ny, ks, ix;; 6087 TString chmess, ctemp;; 6088 Bool_t overpr;; 6089 char cline[144];; 6090 char chsav, chbest;; 6091 ; 6092 /* Function Body */; 6093 // Computing MIN; 6094 maxnx = TMath::Min(npagwd-20,100);; 6095 if (maxnx < 10) maxnx = 10;; 6096 maxny = npagln;; 6097 if (maxny < 10) maxny = 10;; 6098 if (nxypt <= 1) return;; 6099 xbest = xpt[0];; 6100 ybest = ypt[0];; 6101 chbest = chpt[0];; 6102 // order the points by decreasing y; 6103 km1 = nxypt - 1;; 6104 for (i = 1; i <= km1; ++i) {; 6105 iquit = 0;; 6106 ni = nxypt - i;; 6107 for (j = 1; j <= ni; ++j) {; 6108 if (ypt[j-1] > ypt[j]) continue;; 6109 savx = xpt[j-1];; 6110 xpt[j-1] = xpt[j];; 6111 xpt[j] = savx;; 6112 savy = ypt[j-1];; 6113 ypt[j-1] = ypt[j];; 6114 ypt[j] = savy;; 6115 chsav = chpt[j-1];; 6116 chpt[j-1]= chpt[j];; 6117 chpt[j] = chsav;; 6118 iquit = 1;; 6119 }; 6120 if (iquit == 0) break;; 6121 }; 6122 // find extreme values; 6123 xmax = xpt[0];; 6124 xmin = xmax;; 6125 for (i = 1; i <= nxypt; ++i) {; 6126 if (xpt[i-1] > xmax) xmax = xpt[i-1];; 6127 if (xpt[i-1] < xmin) xmin = xpt[i-1];; 6128 }; 6129 dxx = (xmax - xmin)*.001;; 6130 xmax += dxx;; 6131 xmin -=",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:202490,Modifiability,variab,variable,202490," on x-axis every ten columns; 6211 for (ibk = 1; ibk <= nx; ++ibk) {; 6212 cline[ibk-1] = ' ';; 6213 if (ibk % 10 == 1) cline[ibk-1] = '/';; 6214 }; 6215 Printf("" %s"",cline);; 6216 ; 6217 for (ibk = 1; ibk <= 12; ++ibk) {; 6218 xvalus[ibk-1] = xmin + Double_t(ibk-1)*10*bwidx;; 6219 }; 6220 iten = (nx + 9) / 10;; 6221 Printf("" "");; 6222 for (ibk = 1; ibk <= iten; ++ibk); 6223 Printf(""%# 8.3g "", xvalus[ibk-1]);; 6224 Printf(""\n"");; 6225 chmess = "" "";; 6226 if (overpr) chmess = "" Overprint character is &"";; 6227 Printf("" ONE COLUMN=%13.7g%s"",bwidx,(const char*)chmess);; 6228}; 6229 ; 6230////////////////////////////////////////////////////////////////////////////////; 6231/// Provides the user with information concerning the current status; 6232///; 6233/// of parameter number IUEXT. Namely, it returns:; 6234/// - CHNAM: the name of the parameter; 6235/// - VAL: the current (external) value of the parameter; 6236/// - ERR: the current estimate of the parameter uncertainty; 6237/// - XLOLIM: the lower bound (or zero if no limits); 6238/// - XUPLIM: the upper bound (or zero if no limits); 6239/// - IUINT: the internal parameter number (or zero if not variable,; 6240/// or negative if undefined).; 6241///; 6242/// Note also: If IUEXT is negative, then it is -internal parameter; 6243/// number, and IUINT is returned as the EXTERNAL number.; 6244/// Except for IUINT, this is exactly the inverse of MNPARM; 6245/// User-called; 6246 ; 6247void TMinuit::mnpout(Int_t iuext1, TString &chnam, Double_t &val, Double_t &err, Double_t &xlolim, Double_t &xuplim, Int_t &iuint) const; 6248{; 6249 /* Local variables */; 6250 Int_t iint, iext, nvl;; 6251 ; 6252 Int_t iuext = iuext1 + 1;; 6253 xlolim = 0;; 6254 xuplim = 0;; 6255 err = 0;; 6256 if (iuext == 0) goto L100;; 6257 if (iuext < 0) {; 6258// internal parameter number specified; 6259 iint = -(iuext);; 6260 if (iint > fNpar) goto L100;; 6261 iext = fNexofi[iint-1];; 6262 iuint = iext;; 6263 } else {; 6264// external parameter number",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:202938,Modifiability,variab,variables,202938," no limits); 6239/// - IUINT: the internal parameter number (or zero if not variable,; 6240/// or negative if undefined).; 6241///; 6242/// Note also: If IUEXT is negative, then it is -internal parameter; 6243/// number, and IUINT is returned as the EXTERNAL number.; 6244/// Except for IUINT, this is exactly the inverse of MNPARM; 6245/// User-called; 6246 ; 6247void TMinuit::mnpout(Int_t iuext1, TString &chnam, Double_t &val, Double_t &err, Double_t &xlolim, Double_t &xuplim, Int_t &iuint) const; 6248{; 6249 /* Local variables */; 6250 Int_t iint, iext, nvl;; 6251 ; 6252 Int_t iuext = iuext1 + 1;; 6253 xlolim = 0;; 6254 xuplim = 0;; 6255 err = 0;; 6256 if (iuext == 0) goto L100;; 6257 if (iuext < 0) {; 6258// internal parameter number specified; 6259 iint = -(iuext);; 6260 if (iint > fNpar) goto L100;; 6261 iext = fNexofi[iint-1];; 6262 iuint = iext;; 6263 } else {; 6264// external parameter number specified; 6265 iext = iuext;; 6266 if (iext > fNu) goto L100;; 6267 iint = fNiofex[iext-1];; 6268 iuint = iint;; 6269 }; 6270// in both cases; 6271 nvl = fNvarl[iext-1];; 6272 if (nvl < 0) goto L100;; 6273 chnam = fCpnam[iext-1];; 6274 val = fU[iext-1];; 6275 if (iint > 0) err = fWerr[iint-1];; 6276 if (nvl == 4) {; 6277 xlolim = fAlim[iext-1];; 6278 xuplim = fBlim[iext-1];; 6279 }; 6280 return;; 6281// parameter is undefined; 6282L100:; 6283 iuint = -1;; 6284 chnam = ""undefined"";; 6285 val = 0;; 6286}; 6287 ; 6288////////////////////////////////////////////////////////////////////////////////; 6289/// Prints the values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:204776,Modifiability,variab,variables,204776,"values of the parameters at the time of the call; 6290///; 6291/// also prints other relevant information such as function value,; 6292/// estimated distance to minimum, parameter errors, step sizes.; 6293///; 6294/// According to the value of IKODE, the printout is:; 6295/// IKODE=INKODE=; 6296/// - 0 only info about function value; 6297/// - 1 parameter values, errors, limits; 6298/// - 2 values, errors, step sizes, internal values; 6299/// - 3 values, errors, step sizes, first derivs.; 6300/// - 4 values, parabolic errors, MINOS errors; 6301///; 6302/// when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1]; 6303 ; 6304void TMinuit::mnprin(Int_t inkode, Double_t fval); 6305{; 6306 /* Initialized data */; 6307 ; 6308 static const TString cblank = "" "";; 6309 TString cnambf = "" "";; 6310 ; 6311 /* Local variables */; 6312 Double_t dcmax, x1, x2, x3, dc;; 6313 x2 = x3 = 0;; 6314 Int_t nadd, i, k, l, m, ikode, ic, nc, ntrail, lbl;; 6315 TString chedm;; 6316 TString colhdl[6], colhdu[6], cx2, cx3, cheval;; 6317 ; 6318 if (fNu == 0) {; 6319 Printf("" THERE ARE CURRENTLY NO PARAMETERS DEFINED"");; 6320 return;; 6321 }; 6322// get value of IKODE based in INKODE, fISW[1]; 6323 ikode = inkode;; 6324 if (inkode == 5) {; 6325 ikode = fISW[1] + 1;; 6326 if (ikode > 3) ikode = 3;; 6327 }; 6328// set 'default' column headings; 6329 for (k = 1; k <= 6; ++k) {; 6330 colhdu[k-1] = ""UNDEFINED"";; 6331 colhdl[k-1] = ""COLUMN HEAD"";; 6332 }; 6333// print title if Minos errors, and title exists.; 6334 if (ikode == 4 && fCtitl != fCundef) {; 6335 Printf("" MINUIT TASK: %s"",(const char*)fCtitl);; 6336 }; 6337// report function value and status; 6338 if (fval == fUndefi) cheval = "" unknown "";; 6339 else cheval.Form(""%g"",fval);; 6340 ; 6341 if (fEDM == fBigedm) chedm = "" unknown "";; 6342 else chedm.Form(""%g"",fEDM);; 6343 ; 6344 nc = fNfcn - fNfcnfr;; 6345 Printf("" FCN=%s FROM %8s STATUS=%10s %6d CALLS %9d TOTAL""; 6346 ,(const char*)cheval; 6347 ,(const char*)fCfrom; 6348 ,(const cha",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:208169,Modifiability,variab,variable,208169," = "" INTERNAL "";; 6387 colhdl[1] = "" STEP SIZE "";; 6388 colhdu[2] = "" INTERNAL "";; 6389 colhdl[2] = "" VALUE "";; 6390 }; 6391 if (ikode == 3) {; 6392 colhdu[0] = "" "";; 6393 colhdl[0] = "" ERROR "";; 6394 colhdu[1] = "" STEP "";; 6395 colhdl[1] = "" SIZE "";; 6396 colhdu[2] = "" FIRST "";; 6397 colhdl[2] = "" DERIVATIVE "";; 6398 }; 6399 if (ikode == 4) {; 6400 colhdu[0] = "" PARABOLIC "";; 6401 colhdl[0] = "" ERROR "";; 6402 colhdu[1] = "" MINOS "";; 6403 colhdu[2] = ""ERRORS "";; 6404 colhdl[1] = "" NEGATIVE "";; 6405 colhdl[2] = "" POSITIVE "";; 6406 }; 6407 ; 6408 if (ikode != 4) {; 6409 if (fISW[1] < 3) colhdu[0] = "" APPROXIMATE "";; 6410 if (fISW[1] < 1) colhdu[0] = "" CURRENT GUESS"";; 6411 }; 6412 Printf("" EXT PARAMETER %-14s%-14s%-14s"",(const char*)colhdu[0]; 6413 ,(const char*)colhdu[1]; 6414 ,(const char*)colhdu[2]);; 6415 Printf("" NO. NAME VALUE %-14s%-14s%-14s"",(const char*)colhdl[0]; 6416 ,(const char*)colhdl[1]; 6417 ,(const char*)colhdl[2]);; 6418// loop over parameters; 6419 for (i = 1; i <= fNu; ++i) {; 6420 if (fNvarl[i-1] < 0) continue;; 6421 l = fNiofex[i-1];; 6422 cnambf = cblank(0,nadd) + fCpnam[i-1];; 6423 if (l == 0) goto L55;; 6424// variable parameter.; 6425 x1 = fWerr[l-1];; 6426 cx2 = ""PLEASE GET X.."";; 6427 cx3 = ""PLEASE GET X.."";; 6428 if (ikode == 1) {; 6429 if (fNvarl[i-1] <= 1) {; 6430 Printf(""%4d %-11s%14.5e%14.5e"",i,(const char*)cnambf,fU[i-1],x1);; 6431 continue;; 6432 } else {; 6433 x2 = fAlim[i-1];; 6434 x3 = fBlim[i-1];; 6435 }; 6436 }; 6437 if (ikode == 2) {; 6438 x2 = fDirin[l-1];; 6439 x3 = fX[l-1];; 6440 }; 6441 if (ikode == 3) {; 6442 x2 = fDirin[l-1];; 6443 x3 = fGrd[l-1];; 6444 if (fNvarl[i-1] > 1 && TMath::Abs(TMath::Cos(fX[l-1])) < .001) {; 6445 cx3 = ""** at limit **"";; 6446 }; 6447 }; 6448 if (ikode == 4) {; 6449 x2 = fErn[l-1];; 6450 if (x2 == 0) cx2 = "" "";; 6451 if (x2 == fUndefi) cx2 = "" at limit "";; 6452 x3 = fErp[l-1];; 6453 if (x3 == 0) cx3 = "" "";; 6454 if (x3 == fUndefi) cx3 = "" at limit "";; 6455 }; 6456 if (cx2 == ""PLEASE GET X.."") cx2.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:210295,Modifiability,variab,variables,210295,"f(""%4d %-11s%14.5e%-14s%14.5e%14.5e"",i; 6475 ,(const char*)cnambf,fU[i-1]; 6476 ,(const char*)colhdu[0],fAlim[i-1],fBlim[i-1]);; 6477 } else {; 6478 Printf(""%4d %-11s%14.5e%s"",i; 6479 ,(const char*)cnambf,fU[i-1],(const char*)colhdu[0]);; 6480 }; 6481 }; 6482 ; 6483 if (fUp != fUpdflt) {; 6484 Printf("" ERR DEF= %g"",fUp);; 6485 }; 6486 return;; 6487}; 6488 ; 6489////////////////////////////////////////////////////////////////////////////////; 6490/// Calculates the eigenvalues of v to see if positive-def; 6491///; 6492/// if not, adds constant along diagonal to make positive.; 6493 ; 6494void TMinuit::mnpsdf(); 6495{; 6496 /* Local variables */; 6497 Double_t dgmin, pAdd, pmin, pmax, dg, epspdf, epsmin;; 6498 Int_t ndex, i, j, ndexd, ip, ifault;; 6499 TString chbuff, ctemp;; 6500 ; 6501 epsmin = 1e-6;; 6502 epspdf = TMath::Max(epsmin,fEpsma2);; 6503 dgmin = fVhmat[0];; 6504// Check if negative or zero on diagonal; 6505 for (i = 1; i <= fNpar; ++i) {; 6506 ndex = i*(i + 1) / 2;; 6507 if (fVhmat[ndex-1] <= 0) {; 6508 mnwarn(""W"", fCfrom, TString::Format(""Negative diagonal element %d in Error Matrix"",i));; 6509 }; 6510 if (fVhmat[ndex-1] < dgmin) dgmin = fVhmat[ndex-1];; 6511 }; 6512 if (dgmin <= 0) {; 6513 dg = epspdf + 1 - dgmin;; 6514 mnwarn(""W"", fCfrom, TString::Format(""%g added to diagonal of error matrix"",dg));; 6515 } else {; 6516 dg = 0;; 6517 }; 6518// Store VHMAT in P, make sure diagonal pos.; 6519 for (i = 1; i <= fNpar; ++i) {; 6520 ndex = i*(i-1) / 2;; 6521 ndexd = ndex + i;; 6522 fVhmat[ndexd-1] += dg;; 6523 if (fVhmat[ndexd-1]==0) {; 6524 fPSDFs[i-1] = 1 / 1e-19; // a totally arbitrary silly small value; 6525 } else {; 6526 fPSDFs[i-1] = 1 / TMath::Sqrt(fVhmat[ndexd-1]);; 6527 }; 6528 for (j = 1; j <= i; ++j) {; 6529 ++ndex;; 6530 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[ndex-1]*fPSDFs[i-1]*fPSDFs[j-1];; 6531 }; 6532 }; 6533// call eigen (p,p,maxint,npar,pstar,-npar); 6534 mneig(fP, fMaxint, fNpar, fMaxint, fPstar, epspdf, ifault);; 6535 pmin = fPstar[0];; 65",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:212906,Modifiability,variab,variables,212906,"+ 1;; 6556 }; 6557 fCstatu = ""NOT POSDEF"";; 6558 mnwarn(""W"", fCfrom, Form(""MATRIX FORCED POS-DEF BY ADDING %f TO DIAGONAL."",pAdd));; 6559 ; 6560}; 6561 ; 6562////////////////////////////////////////////////////////////////////////////////; 6563/// Called only by MNSIMP (and MNIMPR) to add a new point; 6564///; 6565/// and remove an old one from the current simplex, and get the; 6566/// estimated distance to minimum.; 6567 ; 6568void TMinuit::mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl); 6569{; 6570 /* Local variables */; 6571 Double_t pbig, plit;; 6572 Int_t i, j, nparp1;; 6573 ; 6574 /* Function Body */; 6575 for (i = 1; i <= fNpar; ++i) { fP[i + jh*fMaxpar - fMaxpar-1] = pnew[i-1]; }; 6576 y[jh-1] = ynew;; 6577 if (ynew < fAmin) {; 6578 for (i = 1; i <= fNpar; ++i) { fX[i-1] = pnew[i-1]; }; 6579 mninex(fX);; 6580 fAmin = ynew;; 6581 fCstatu = ""PROGRESS "";; 6582 jl = jh;; 6583 }; 6584 jh = 1;; 6585 nparp1 = fNpar + 1;; 6586 for (j = 2; j <= nparp1; ++j) { if (y[j-1] > y[jh-1]) jh = j; }; 6587 fEDM = y[jh-1] - y[jl-1];; 6588 if (fEDM <= 0) goto L45;; 6589 for (i = 1; i <= fNpar; ++i) {; 6590 pbig = fP[i-1];; 6591 plit = pbig;; 6592 for (j = 2; j <= nparp1; ++j) {; 6593 if (fP[i + j*fMaxpar - fMaxpar-1] > pbig) pbig = fP[i + j*fMaxpar - fMaxpar-1];; 6594 if (fP[i + j*fMaxpar - fMaxpar-1] < plit) plit = fP[i + j*fMaxpar - fMaxpar-1];; 6595 }; 6596 fDirin[i-1] = pbig - plit;; 6597 }; 6598L40:; 6599 return;; 6600L45:; 6601 if (fISW[4] >= 0) {; 6602 Printf("" FUNCTION VALUE DOES NOT SEEM TO DEPEND ON ANY OF THE %d VARIABLE PARAMETERS."",fNpar);; 6603 Printf("" VERIFY THAT STEP SIZES ARE BIG ENOUGH AND CHECK FCN LOGIC."");; 6604 Printf("" *******************************************************************************"");; 6605 Printf("" *******************************************************************************"");; 6606 }; 6607 goto L40;; 6608}; 6609 ; 6610////////////////////////////////////////////////////////////////////////////////; 6611/// Thi",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:214379,Modifiability,portab,portable,214379,"ROGRESS "";; 6582 jl = jh;; 6583 }; 6584 jh = 1;; 6585 nparp1 = fNpar + 1;; 6586 for (j = 2; j <= nparp1; ++j) { if (y[j-1] > y[jh-1]) jh = j; }; 6587 fEDM = y[jh-1] - y[jl-1];; 6588 if (fEDM <= 0) goto L45;; 6589 for (i = 1; i <= fNpar; ++i) {; 6590 pbig = fP[i-1];; 6591 plit = pbig;; 6592 for (j = 2; j <= nparp1; ++j) {; 6593 if (fP[i + j*fMaxpar - fMaxpar-1] > pbig) pbig = fP[i + j*fMaxpar - fMaxpar-1];; 6594 if (fP[i + j*fMaxpar - fMaxpar-1] < plit) plit = fP[i + j*fMaxpar - fMaxpar-1];; 6595 }; 6596 fDirin[i-1] = pbig - plit;; 6597 }; 6598L40:; 6599 return;; 6600L45:; 6601 if (fISW[4] >= 0) {; 6602 Printf("" FUNCTION VALUE DOES NOT SEEM TO DEPEND ON ANY OF THE %d VARIABLE PARAMETERS."",fNpar);; 6603 Printf("" VERIFY THAT STEP SIZES ARE BIG ENOUGH AND CHECK FCN LOGIC."");; 6604 Printf("" *******************************************************************************"");; 6605 Printf("" *******************************************************************************"");; 6606 }; 6607 goto L40;; 6608}; 6609 ; 6610////////////////////////////////////////////////////////////////////////////////; 6611/// This is a super-portable random number generator; 6612///; 6613/// It should not overflow on any 32-bit machine.; 6614/// The cycle is only ~10**9, so use with care!; 6615/// Note especially that VAL must not be undefined on input.; 6616///; 6617/// Set Default Starting Seed; 6618 ; 6619void TMinuit::mnrn15(Double_t &val, Int_t &inseed); 6620{; 6621 /* Initialized data */; 6622 ; 6623 static std::atomic<Int_t> g_iseed( 12345 );; 6624 ; 6625 Int_t k;; 6626 ; 6627 if (val == 3) {; 6628 // ""entry"" to set seed, flag is VAL=3; 6629 g_iseed.store(inseed, std::memory_order_release);; 6630 } else {; 6631 // Grab the local value. Two threads might comes here at the same; 6632 // time and will end up with the same results.; 6633 int starting_seed = g_iseed.load( std::memory_order_acquire );; 6634 int next_seed;; 6635 ; 6636 do {; 6637 next_seed = inseed = starting_seed;; 6638 ; 6639 // D",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:217519,Modifiability,variab,variables,217519,"1;; 6685 fDcovar = TMath::Max(fDcovar,.5);; 6686 }; 6687}; 6688 ; 6689////////////////////////////////////////////////////////////////////////////////; 6690/// Writes current parameter values and step sizes onto file ISYSSA; 6691///; 6692/// in format which can be reread by Minuit for restarting.; 6693/// The covariance matrix is also output if it exists.; 6694 ; 6695void TMinuit::mnsave(); 6696{; 6697 Printf(""mnsave is dummy in TMinuit"");; 6698 ; 6699}; 6700 ; 6701////////////////////////////////////////////////////////////////////////////////; 6702/// Scans the values of FCN as a function of one parameter; 6703///; 6704/// and plots the resulting values as a curve using MNPLOT.; 6705/// It may be called to scan one parameter or all parameters.; 6706/// retains the best function and parameter values found.; 6707 ; 6708void TMinuit::mnscan(); 6709{; 6710 /* Local variables */; 6711 Double_t step, uhigh, xhreq, xlreq, ubest, fnext, unext, xh, xl;; 6712 Int_t ipar, iint, icall, ncall, nbins, nparx;; 6713 Int_t nxypt, nccall, iparwd;; 6714 ; 6715 xlreq = TMath::Min(fWord7[2],fWord7[3]);; 6716 xhreq = TMath::Max(fWord7[2],fWord7[3]);; 6717 ncall = Int_t((fWord7[1] + .01));; 6718 if (ncall <= 1) ncall = 41;; 6719 if (ncall > 98) ncall = 98;; 6720 nccall = ncall;; 6721 if (fAmin == fUndefi) mnamin();; 6722 iparwd = Int_t((fWord7[0] + .1));; 6723 ipar = TMath::Max(iparwd,0);; 6724 fCstatu = ""NO CHANGE"";; 6725 if (iparwd > 0) goto L200;; 6726 ; 6727// equivalent to a loop over parameters requested; 6728L100:; 6729 ++ipar;; 6730 if (ipar > fNu) goto L900;; 6731 iint = fNiofex[ipar-1];; 6732 if (iint <= 0) goto L100;; 6733// set up range for parameter IPAR; 6734L200:; 6735 iint = fNiofex[ipar-1];; 6736 ubest = fU[ipar-1];; 6737 fXpt[0] = ubest;; 6738 fYpt[0] = fAmin;; 6739 fChpt[0] = ' ';; 6740 fXpt[1] = ubest;; 6741 fYpt[1] = fAmin;; 6742 fChpt[1] = 'X';; 6743 nxypt = 2;; 6744 if (fNvarl[ipar-1] > 1) goto L300;; 6745 ; 6746// no limits on parameter; 6747 if (xlreq == xhreq) ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:221015,Modifiability,variab,variables,221015,"] >= 0) mnprin(5, fAmin);; 6805}; 6806 ; 6807////////////////////////////////////////////////////////////////////////////////; 6808/// Performs a rough (but global) minimization by monte carlo search; 6809///; 6810/// Each time a new minimum is found, the search area is shifted; 6811/// to be centered at the best value. Random points are chosen; 6812/// uniformly over a hypercube determined by current step sizes.; 6813/// The Metropolis algorithm accepts a worse point with probability; 6814/// exp(-d/UP), where d is the degradation. Improved points; 6815/// are of course always accepted. Actual steps are random; 6816/// multiples of the nominal steps (DIRIN).; 6817 ; 6818void TMinuit::mnseek(); 6819{; 6820 /* Local variables */; 6821 Double_t dxdi, rnum, ftry, rnum1, rnum2, alpha;; 6822 Double_t flast, bar;; 6823 Int_t ipar, iext, j, ifail, iseed=0, nparx, istep, ib, mxfail, mxstep;; 6824 ; 6825 mxfail = Int_t(fWord7[0]);; 6826 if (mxfail <= 0) mxfail = fNpar*20 + 100;; 6827 mxstep = mxfail*10;; 6828 if (fAmin == fUndefi) mnamin();; 6829 alpha = fWord7[1];; 6830 if (alpha <= 0) alpha = 3;; 6831 if (fISW[4] >= 1) {; 6832 Printf("" MNSEEK: MONTE CARLO MINIMIZATION USING METROPOLIS ALGORITHM"");; 6833 Printf("" TO STOP AFTER %6d SUCCESSIVE FAILURES, OR %7d STEPS"",mxfail,mxstep);; 6834 Printf("" MAXIMUM STEP SIZE IS %9.3f ERROR BARS."",alpha);; 6835 }; 6836 fCstatu = ""INITIAL "";; 6837 if (fISW[4] >= 2) mnprin(2, fAmin);; 6838 fCstatu = ""UNCHANGED "";; 6839 ifail = 0;; 6840 rnum = 0;; 6841 rnum1 = 0;; 6842 rnum2 = 0;; 6843 nparx = fNpar;; 6844 flast = fAmin;; 6845// set up step sizes, starting values; 6846 for (ipar = 1; ipar <= fNpar; ++ipar) {; 6847 iext = fNexofi[ipar-1];; 6848 fDirin[ipar-1] = alpha*2*fWerr[ipar-1];; 6849 if (fNvarl[iext-1] > 1) {; 6850// parameter with limits; 6851 mndxdi(fX[ipar-1], ipar-1, dxdi);; 6852 if (dxdi == 0) dxdi = 1;; 6853 fDirin[ipar-1] = alpha*2*fWerr[ipar-1] / dxdi;; 6854 if (TMath::Abs(fDirin[ipar-1]) > 6.2831859999999997) {; 6855 fDirin[i",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:225892,Modifiability,variab,variables,225892,"18 ""FCN value "",; 6919 ""PARameters"",; 6920 ""LIMits "",; 6921 ""COVariance"",; 6922 ""CORrelatio"",; 6923 ""PRInt levl"",; 6924 ""NOGradient"",; 6925 ""GRAdient "",; 6926 ""ERRor def "",; 6927 ""INPut file"",; 6928 ""WIDth page"",; 6929 ""LINes page"",; 6930 ""NOWarnings"",; 6931 ""WARnings "",; 6932 ""RANdom gen"",; 6933 ""TITle "",; 6934 ""STRategy "",; 6935 ""EIGenvalue"",; 6936 ""PAGe throw"",; 6937 ""MINos errs"",; 6938 ""EPSmachine"",; 6939 ""OUTputfile"",; 6940 ""BATch "",; 6941 ""INTeractiv"",; 6942 ""VERsion "",; 6943 ""reserve "",; 6944 ""NODebug "",; 6945 ""DEBug "",; 6946 ""SHOw "",; 6947 ""SET ""};; 6948 ; 6949 static constexpr Int_t nname = 25; // Must less than sizeof(cname)/sizeof(char*); 6950 static constexpr Int_t nntot = sizeof(cname)/sizeof(char*);; 6951 static const TString cprlev[5] = {; 6952 ""-1: NO OUTPUT EXCEPT FROM SHOW "",; 6953 "" 0: REDUCED OUTPUT "",; 6954 "" 1: NORMAL OUTPUT "",; 6955 "" 2: EXTRA OUTPUT FOR PROBLEM CASES"",; 6956 "" 3: MAXIMUM OUTPUT ""};; 6957 ; 6958 static const TString cstrat[3] = {; 6959 "" 0: MINIMIZE THE NUMBER OF CALLS TO FUNCTION"",; 6960 "" 1: TRY TO BALANCE SPEED AGAINST RELIABILITY"",; 6961 "" 2: MAKE SURE MINIMUM TRUE, ERRORS CORRECT ""};; 6962 ; 6963 static const TString cdbopt[7] = {; 6964 ""REPORT ALL EXCEPTIONAL CONDITIONS "",; 6965 ""MNLINE: LINE SEARCH MINIMIZATION "",; 6966 ""MNDERI: FIRST DERIVATIVE CALCULATIONS "",; 6967 ""MNHESS: SECOND DERIVATIVE CALCULATIONS "",; 6968 ""MNMIGR: COVARIANCE MATRIX UPDATES "",; 6969 ""MNHES1: FIRST DERIVATIVE UNCERTAINTIES "",; 6970 ""MNCONT: MNCONTOUR PLOT (MNCROS SEARCH) ""};; 6971 ; 6972 /* System generated locals */; 6973 //Int_t f_inqu();; 6974 ; 6975 /* Local variables */; 6976 Double_t val;; 6977 Int_t iset, iprm, i, jseed, kname, iseed, iunit, id, ii, kk;; 6978 Int_t ikseed, idbopt, igrain=0, iswsav, isw2;; 6979 TString cfname, cmode, ckind, cwarn, copt, ctemp, ctemp2;; 6980 Bool_t lname=kFALSE;; 6981 ; 6982 for (i = 1; i <= nntot; ++i) {; 6983 ctemp = cname[i-1];; 6984 ckind = ctemp(0,3);; 6985 ctemp2 = fCword(4,6);; 6986 if (strstr(ctemp2.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:238115,Modifiability,variab,variables,238115,"-----------------------------------------------------; 7419// ILLEGAL COMMAND; 7420L3000:; 7421 Printf("" ABOVE COMMAND IS ILLEGAL. IGNORED"");; 7422 ; 7423}; 7424 ; 7425////////////////////////////////////////////////////////////////////////////////; 7426/// Minimization using the simplex method of Nelder and Mead; 7427///; 7428/// Performs a minimization using the simplex method of Nelder; 7429/// and Mead (ref. -- Comp. J. 7,308 (1965)).; 7430 ; 7431void TMinuit::mnsimp(); 7432{; 7433 /* Initialized data */; 7434 ; 7435 static constexpr Double_t alpha = 1;; 7436 static constexpr Double_t beta = .5;; 7437 static constexpr Double_t gamma = 2;; 7438 static constexpr Double_t rhomin = 4;; 7439 static constexpr Double_t rhomax = 8;; 7440 ; 7441 /* Local variables */; 7442 Double_t dmin_, dxdi, yrho, f, ynpp1, aming, ypbar;; 7443 Double_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2 = rho1 + alpha*gamma;; 7458 wg = 1 / Double_t(fNpar);; 7459 if (fISW[4] >= 0) {; 7460 Printf("" START SIMPLEX MINIMIZATION. CONVERGENCE WHEN EDM .LT. %g"",fEpsi);; 7461 }; 7462 for (i = 1; i <= fNpar; ++i) {; 7463 fDirin[i-1] = fWerr[i-1];; 7464 mndxdi(fX[i-1], i-1, dxdi);; 7465 if (dxdi != 0) fDirin[i-1] = fWerr[i-1] / dxdi;; 7466 dmin_ = fEpsma2*TMath::Abs(fX[i-1]);; 7467 if (fDirin[i-1] < dmin_) fDirin[i-1] = dmin_;; 7468 }; 7469// choose the initial simplex using single-parameter searches; 7470L1:; 7471 ynpp1 = fAmin;; 7472 jl = nparp1;; 7473 fSIMPy[nparp1-1] = fAmin;; 7474 absmin = fAmin;; 7475 for (i = 1; i <= fNpar; ++i) {; 7476 aming = fAmin;; 7477 fPbar[i-1] = fX[i-1];; 7478 bestx = fX[i-1];; 7479 kg = 0;; 748",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:244132,Modifiability,variab,variable,244132,"RGENCE."");; 7601 }; 7602 fCstatu = ""CALL LIMIT"";; 7603 fISW[3] = -1;; 7604 fISW[0] = 1;; 7605L80:; 7606 for (i = 1; i <= fNpar; ++i) {; 7607 pb = 0;; 7608 for (j = 1; j <= nparp1; ++j) { pb += wg*fP[i + j*fMaxpar - fMaxpar-1]; }; 7609 fPbar[i-1] = pb - wg*fP[i + jh*fMaxpar - fMaxpar-1];; 7610 }; 7611 mninex(fPbar);; 7612 Eval(nparx, fGin, ypbar, fU, 4); ++fNfcn;; 7613 if (ypbar < fAmin) mnrazz(ypbar, fPbar, fSIMPy, jh, jl);; 7614 mninex(fX);; 7615 if (fNfcnmx + npfn - fNfcn < fNpar*3) goto L90;; 7616 if (fEDM > fEpsi*2) goto L1;; 7617L90:; 7618 if (fISW[4] >= 0) mnprin(5, fAmin);; 7619}; 7620 ; 7621////////////////////////////////////////////////////////////////////////////////; 7622/// Returns concerning the current status of the minimization; 7623///; 7624/// User-called; 7625/// Namely, it returns:; 7626/// - FMIN: the best function value found so far; 7627/// - FEDM: the estimated vertical distance remaining to minimum; 7628/// - ERRDEF: the value of UP defining parameter uncertainties; 7629/// - NPARI: the number of currently variable parameters; 7630/// - NPARX: the highest (external) parameter number defined by user; 7631/// - ISTAT: a status integer indicating how good is the covariance; 7632/// matrix:; 7633/// - 0= not calculated at all; 7634/// - 1= approximation only, not accurate; 7635/// - 2= full matrix, but forced positive-definite; 7636/// - 3= full accurate covariance matrix; 7637 ; 7638void TMinuit::mnstat(Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat); 7639{; 7640 fmin = fAmin;; 7641 fedm = fEDM;; 7642 errdef = fUp;; 7643 npari = fNpar;; 7644 nparx = fNu;; 7645 istat = fISW[1];; 7646 if (fEDM == fBigedm) fedm = fUp;; 7647 if (fAmin == fUndefi) {; 7648 fmin = 0;; 7649 fedm = fUp;; 7650 istat = 0;; 7651 }; 7652}; 7653 ; 7654////////////////////////////////////////////////////////////////////////////////; 7655/// To find the machine precision; 7656///; 7657/// Compares its argument with the value 1.0, and ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:246481,Modifiability,variab,variables,246481,,MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:268897,Modifiability,portab,portable,268897,"60; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPb",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:274578,Modifiability,variab,variable,274578,"tual void mnwarn(const char *copt, const char *corg, const char *cmes)Prints Warning messages.Definition TMinuit.cxx:7784; TMinuit::fSEEKxmidDouble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s) to variable status.Definition TMinuit.cxx:3256; TMinuit::mncntrvirtual void mncntr(Int_t ke1, Int_t ke2, Int_t &ierrf)Print function contours in two variables, on line printer.Definition TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clon",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:274724,Modifiability,variab,variables,274724,"uble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s) to variable status.Definition TMinuit.cxx:3256; TMinuit::mncntrvirtual void mncntr(Int_t ke1, Int_t ke2, Int_t &ierrf)Print function contours in two variables, on line printer.Definition TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warni",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:5522,Performance,perform,perform,5522,"e user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; 131 ; 132If MIGRAD converges normally to a point where no parameter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from f",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:5536,Performance,perform,perform,5536,"e user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parabolic'' parameter errors) when there are parameter limits.; 102Users should however realize that the transformation is only a linear; 103approximation, and that it cannot give a meaningful result if one or more; 104parameters is very close to a limit, where; 105\f$\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\f$.; 106Therefore, it is recommended that:; 107 ; 108 1. Limits on variable parameters should be used only when needed in order; 109to prevent the parameter from taking on unphysical values.; 110 ; 111 2. When a satisfactory minimum has been found using limits, the limits; 112should then be removed if possible, in order to perform or re-perform the; 113error analysis without limits.; 114 ; 115 ; 116### How to get the right answer from MINUIT.; 117 ; 118MINUIT offers the user a choice of several minimization algorithms. The; 119MIGRAD algorithm is in general the best minimizer for; 120nearly all functions. It is a variable-metric method with inexact line; 121search, a stable metric updating scheme, and checks for; 122positive-definiteness. Its main weakness is that it depends heavily on; 123knowledge of the first derivatives, and fails miserably if they are very; 124inaccurate.; 125 ; 126If parameter limits are needed, in spite of the side effects, then the; 127user should be aware of the following techniques to alleviate problems; 128caused by limits:; 129 ; 130#### Getting the right minimum with limits.; 131 ; 132If MIGRAD converges normally to a point where no parameter is near one of; 133its limits, then the existence of limits has probably not prevented MINUIT; 134from f",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:29996,Performance,perform,performs,29996," fSEEKxbest;; 768 delete [] fSIMPy;; 769 delete [] fVERTq;; 770 delete [] fVERTs;; 771 delete [] fVERTpp;; 772 delete [] fCOMDplist;; 773 delete [] fPARSplist;; 774 ; 775 fEmpty = 1;; 776}; 777 ; 778////////////////////////////////////////////////////////////////////////////////; 779/// Evaluate the minimisation function; 780/// Input parameters:; 781/// - npar: number of currently variable parameters; 782/// - par: array of (constant and variable) parameters; 783/// - flag: Indicates what is to be calculated (see example below); 784/// - grad: array of gradients; 785/// Output parameters:; 786/// - fval: The calculated function value.; 787/// - grad: The (optional) vector of first derivatives).; 788///; 789/// The meaning of the parameters par is of course defined by the user,; 790/// who uses the values of those parameters to calculate their function value.; 791/// The starting values must be specified by the user.; 792/// Later values are determined by Minuit as it searches for the minimum; 793/// or performs whatever analysis is requested by the user.; 794///; 795/// Note that this virtual function may be redefined in a class derived from TMinuit.; 796/// The default function calls the function specified in SetFCN; 797///; 798/// Example of Minimisation function:; 799 ; 800Int_t TMinuit::Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 801{; 802/*; 803 if (flag == 1) {; 804 read input data,; 805 calculate any necessary constants, etc.; 806 }; 807 if (flag == 2) {; 808 calculate GRAD, the first derivatives of FVAL; 809 (this is optional); 810 }; 811 Always calculate the value of the function, FVAL,; 812 which is usually a chisquare or log likelihood.; 813 if (iflag == 3) {; 814 will come here only after the fit is finished.; 815 Perform any final calculations, output fitted data, etc.; 816 }; 817*/; 818// See concrete examples in TH1::H1FitChisquare, H1FitLikelihood; 819 ; 820 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 821 return 0;; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:112003,Performance,perform,perform,112003,"8 Printf("" function will be evaluated. [See also MNContour.]"");; 3499 goto L99;; 3500 }; 3501//______________________________________________________________________________; 3502//; 3503// Command END; 3504//; 3505 if( !strncmp(comd.Data(),""END"",3) ) {; 3506 Printf("" ***>END"");; 3507 Printf("" Signals the end of a data block (i.e., the end of a fit),"");; 3508 Printf("" and implies that execution should continue, because another"");; 3509 Printf("" Data Block follows. A Data Block is a set of Minuit data"");; 3510 Printf("" consisting of"");; 3511 Printf("" (1) A Title,"");; 3512 Printf("" (2) One or more Parameter Definitions,"");; 3513 Printf("" (3) A blank line, and"");; 3514 Printf("" (4) A set of Minuit Commands."");; 3515 Printf("" The END command is used when more than one Data Block is to"");; 3516 Printf("" be used with the same FCN function. It first causes Minuit"");; 3517 Printf("" to issue a CALL FCN with IFLAG=3, in order to allow FCN to"");; 3518 Printf("" perform any calculations associated with the final fitted"");; 3519 Printf("" parameter values, unless a CALL FCN 3 command has already"");; 3520 Printf("" been executed at the current FCN value."");; 3521 goto L99;; 3522 }; 3523//______________________________________________________________________________; 3524//; 3525// Command EXIT; 3526//; 3527 if( !strncmp(comd.Data(),""EXI"",3) ) {; 3528 Printf("" ***>EXIT"");; 3529 Printf("" Signals the end of execution."");; 3530 Printf("" The EXIT command first causes Minuit to issue a CALL FCN"");; 3531 Printf("" with IFLAG=3, to allow FCN to perform any calculations"");; 3532 Printf("" associated with the final fitted parameter values, unless a"");; 3533 Printf("" CALL FCN 3 command has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parn",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:112584,Performance,perform,perform,112584,"e,"");; 3512 Printf("" (2) One or more Parameter Definitions,"");; 3513 Printf("" (3) A blank line, and"");; 3514 Printf("" (4) A set of Minuit Commands."");; 3515 Printf("" The END command is used when more than one Data Block is to"");; 3516 Printf("" be used with the same FCN function. It first causes Minuit"");; 3517 Printf("" to issue a CALL FCN with IFLAG=3, in order to allow FCN to"");; 3518 Printf("" perform any calculations associated with the final fitted"");; 3519 Printf("" parameter values, unless a CALL FCN 3 command has already"");; 3520 Printf("" been executed at the current FCN value."");; 3521 goto L99;; 3522 }; 3523//______________________________________________________________________________; 3524//; 3525// Command EXIT; 3526//; 3527 if( !strncmp(comd.Data(),""EXI"",3) ) {; 3528 Printf("" ***>EXIT"");; 3529 Printf("" Signals the end of execution."");; 3530 Printf("" The EXIT command first causes Minuit to issue a CALL FCN"");; 3531 Printf("" with IFLAG=3, to allow FCN to perform any calculations"");; 3532 Printf("" associated with the final fitted parameter values, unless a"");; 3533 Printf("" CALL FCN 3 command has already been executed."");; 3534 goto L99;; 3535 }; 3536//______________________________________________________________________________; 3537//; 3538// Command FIX; 3539//; 3540 if( !strncmp(comd.Data(),""FIX"",3) ) {; 3541 Printf("" ***>FIX} <parno> [parno] ... [parno]"");; 3542 Printf("" Causes parameter(s) <parno> to be removed from the list of"");; 3543 Printf("" variable parameters, and their value(s) will remain constant"");; 3544 Printf("" during subsequent minimizations, etc., until another command"");; 3545 Printf("" changes their value(s) or status."");; 3546 goto L99;; 3547 }; 3548//______________________________________________________________________________; 3549//; 3550// Command HESSE; 3551//; 3552 if( !strncmp(comd.Data(),""HES"",3) ) {; 3553 Printf("" ***>HESse [maxcalls]"");; 3554 Printf("" Calculate, by finite differences, the Hessian or error matrix."");; 3555 P",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:116857,Performance,perform,performed,116857,"d vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");; 3625 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3626 Printf("" maximum number of function calls per parameter requested,"");; 3627 Printf("" after which the calculation will stop for that parameter."");; 3628 goto L99;; 3629 }; 3630//______________________________________________________________________________; 3631//; 3632// Command MNCONTOUR; 3633//; 3634 if( !strncmp(comd.Data(),""MNC"",3) ) {; 3635 Printf("" ***>MNContour <par1> <par2> [npts]"");; 3636 Printf("" Calculates one function contour of FCN with respect to"");; 3637 Printf("" ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:120829,Performance,perform,perform,120829,"___________________________________________________________; 3677//; 3678// Command RESTORE; 3679//; 3680 if( !strncmp(comd.Data(),""RES"",3) ) {; 3681 Printf("" ***>REStore [code]"");; 3682 Printf("" If no [code] is specified, this command restores all previously"");; 3683 Printf("" FIXed parameters to variable status. If [code]=1, then only"");; 3684 Printf("" the last parameter FIXed is restored to variable status."");; 3685 Printf("" If code is neither zero nor one, the command is ignored."");; 3686 goto L99;; 3687 }; 3688//______________________________________________________________________________; 3689//; 3690// Command RETURN; 3691//; 3692 if( !strncmp(comd.Data(),""RET"",3) ) {; 3693 Printf("" ***>RETURN"");; 3694 Printf("" Signals the end of a data block, and instructs Minuit to return"");; 3695 Printf("" to the program which called it. The RETurn command first"");; 3696 Printf("" causes Minuit to CALL FCN with IFLAG=3, in order to allow FCN"");; 3697 Printf("" to perform any calculations associated with the final fitted"");; 3698 Printf("" parameter values, unless a CALL FCN 3 command has already been"");; 3699 Printf("" executed at the current FCN value."");; 3700 goto L99;; 3701 }; 3702//______________________________________________________________________________; 3703//; 3704// Command SAVE; 3705//; 3706 if( !strncmp(comd.Data(),""SAV"",3) ) {; 3707 Printf("" ***>SAVe"");; 3708 Printf("" Causes the current parameter values to be saved on a file in"");; 3709 Printf("" such a format that they can be read in again as Minuit"");; 3710 Printf("" parameter definitions. If the covariance matrix exists, it is"");; 3711 Printf("" also output in such a format. The unit number is by default 7,"");; 3712 Printf("" or that specified by the user in their call to MINTIO or"");; 3713 Printf("" MNINIT. The user is responsible for opening the file previous"");; 3714 Printf("" to issuing the [SAVe] command (except where this can be done"");; 3715 Printf("" interactively)."");; 3716 goto L99;; 3717 }; 3718//_______",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:215120,Performance,load,load,215120,"****************************"");; 6606 }; 6607 goto L40;; 6608}; 6609 ; 6610////////////////////////////////////////////////////////////////////////////////; 6611/// This is a super-portable random number generator; 6612///; 6613/// It should not overflow on any 32-bit machine.; 6614/// The cycle is only ~10**9, so use with care!; 6615/// Note especially that VAL must not be undefined on input.; 6616///; 6617/// Set Default Starting Seed; 6618 ; 6619void TMinuit::mnrn15(Double_t &val, Int_t &inseed); 6620{; 6621 /* Initialized data */; 6622 ; 6623 static std::atomic<Int_t> g_iseed( 12345 );; 6624 ; 6625 Int_t k;; 6626 ; 6627 if (val == 3) {; 6628 // ""entry"" to set seed, flag is VAL=3; 6629 g_iseed.store(inseed, std::memory_order_release);; 6630 } else {; 6631 // Grab the local value. Two threads might comes here at the same; 6632 // time and will end up with the same results.; 6633 int starting_seed = g_iseed.load( std::memory_order_acquire );; 6634 int next_seed;; 6635 ; 6636 do {; 6637 next_seed = inseed = starting_seed;; 6638 ; 6639 // Determine the next seed.; 6640 k = next_seed / 53668;; 6641 next_seed = (next_seed - k*53668)*40014 - k*12211;; 6642 if (next_seed < 0) next_seed += 2147483563;; 6643 ; 6644 val = Double_t(next_seed*4.656613e-10);; 6645 ; 6646 // If more than one thread gets here, one will manage the update; 6647 // of g_iseed the other we go for at least one more round.; 6648 // This is not reproduceable; 6649 } while (! g_iseed.compare_exchange_strong(starting_seed, next_seed) );; 6650 }; 6651}; 6652 ; 6653////////////////////////////////////////////////////////////////////////////////; 6654/// Resets function value and errors to UNDEFINED; 6655///; 6656/// - If IOPT=1,; 6657/// - If IOPT=0, sets only MINOS errors to undefined; 6658/// Called from MNCLER and whenever problem changes, for example; 6659/// after SET LIMITS, SET PARAM, CALL FCN 6; 6660 ; 6661void TMinuit::mnrset(Int_t iopt); 6662{; 6663 Int_t iext, i;; 6664 ; 6665 fCstatu = ""RESET "";",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:3943,Safety,avoid,avoided,3943,"ihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformation is necessarily non-linear, it would transform a; 85nice linear problem into a nasty non-linear one, which is the reason why; 86limits should be avoided if not necessary.; 87In addition, the transformation; 88does require some computer time, so it slows down the computation a little; 89bit, and more importantly, it introduces additional numerical inaccuracy into; 90the problem in addition to what is introduced in the numerical calculation; 91of the FCN value.; 92The effects of non-linearity and numerical roundoff both; 93become more important as the external value gets closer to one of the limits; 94(expressed as the distance to nearest limit divided by distance between limits).; 95The user must therefore be aware of the fact that, for example,; 96if he puts limits of \f$(0,10^{10})\f$ on a parameter, then the values \f$0.0\f$; 97and \f$1.0\f$ will be indistinguishable to the accuracy of most machines.; 98 ; 99The transformation also affects the parameter error matrix, of course,; 100so Minuit does a transformation of the error matrix (and the; 101``parab",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:11622,Safety,recover,recovers,11622," has been; 217 badly parameterised so that individual errors are not very meaningful; 218 because they are so highly correlated.; 219 ; 220 6. Parameter at limit. This condition, signalled by a MINUIT warning; 221 message, may make both the function minimum and parameter errors; 222 unreliable. See the discussion above ``Getting the right parameter errors; 223 with limits''.; 224 ; 225 ; 226The best way to be absolutely sure of the errors, is to use; 227``independent'' calculations and compare them, or compare the calculated; 228errors with a picture of the function. Theoretically, the covariance; 229matrix for a ``physical'' function must be positive-definite at the; 230minimum, although it may not be so for all points far away from the; 231minimum, even for a well-determined physical problem. Therefore, if MIGRAD; 232reports that it has found a non-positive-definite covariance matrix, this; 233may be a sign of one or more of the following:; 234 ; 235##### A non-physical region:; 236 ; 237On its way to the minimum, MIGRAD may have traversed a region which has; 238unphysical behaviour, which is of course not a serious problem as long as; 239it recovers and leaves such a region.; 240 ; 241##### An underdetermined problem:; 242 ; 243If the matrix is not positive-definite even at the minimum, this may mean; 244that the solution is not well-defined, for example that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:61347,Safety,predict,prediction,61347,"anf(celmnt[ifld-1],""%lf"",&plist[llist-1]);; 1779 }; 1780 }; 1781// end loop over numeric fields; 1782L900:; 1783 if (lnc <= 0) lnc = 1;; 1784 comand = command;; 1785}; 1786 ; 1787////////////////////////////////////////////////////////////////////////////////; 1788/// Find point where MNEVAL=AMIN+UP; 1789///; 1790/// Find point where MNEVAL=AMIN+UP, along the line through; 1791/// XMIDCR,YMIDCR with direction XDIRCR,YDIRCR, where X and Y; 1792/// are parameters KE1CR and KE2CR. If KE2CR=0 (from MINOS),; 1793/// only KE1CR is varied. From MNCONT, both are varied.; 1794/// Crossing point is at; 1795///; 1796/// (U(KE1),U(KE2)) = (XMID,YMID) + AOPT*(XDIR,YDIR); 1797 ; 1798void TMinuit::mncros(Double_t &aopt, Int_t &iercr); 1799{; 1800 /* Local variables */; 1801 Double_t alsb[3], flsb[3], bmin, bmax, zmid, sdev, zdir, zlim;; 1802 Double_t coeff[3], aleft, aulim, fdist, adist, aminsv;; 1803 Double_t anext, fnext, slope, s1, s2, x1, x2, ecarmn, ecarmx;; 1804 Double_t determ, rt, smalla, aright, aim, tla, tlf, dfda,ecart;; 1805 Int_t iout=0, i, ileft, ierev, maxlk, ibest, ik, it;; 1806 Int_t noless, iworst=0, iright, itoohi, kex, ipt;; 1807 Bool_t ldebug;; 1808 const char *chsign;; 1809 x2 = 0;; 1810 ; 1811 ldebug = fIdbg[6] >= 1;; 1812 aminsv = fAmin;; 1813// convergence when F is within TLF of AIM and next prediction; 1814// of AOPT is within TLA of previous value of AOPT; 1815 aim = fAmin + fUp;; 1816 tlf = fUp*.01;; 1817 tla = .01;; 1818 fXpt[0] = 0;; 1819 fYpt[0] = aim;; 1820 fChpt[0] = ' ';; 1821 ipt = 1;; 1822 if (fKe2cr == 0) {; 1823 fXpt[1] = -1;; 1824 fYpt[1] = fAmin;; 1825 fChpt[1] = '.';; 1826 ipt = 2;; 1827 }; 1828// find the largest allowed A; 1829 aulim = 100;; 1830 for (ik = 1; ik <= 2; ++ik) {; 1831 if (ik == 1) {; 1832 kex = fKe1cr;; 1833 zmid = fXmidcr;; 1834 zdir = fXdircr;; 1835 } else {; 1836 if (fKe2cr == 0) continue;; 1837 kex = fKe2cr;; 1838 zmid = fYmidcr;; 1839 zdir = fYdircr;; 1840 }; 1841 if (fNvarl[kex-1] <= 1) continue;; 1842 if (zdir == 0) c",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:68401,Safety,avoid,avoid,68401,"994// Find which root is the right one; 1995 rt = TMath::Sqrt(determ);; 1996 x1 = (-coeff[1] + rt) / (coeff[2]*2);; 1997 x2 = (-coeff[1] - rt) / (coeff[2]*2);; 1998 s1 = coeff[1] + x1*2*coeff[2];; 1999 s2 = coeff[1] + x2*2*coeff[2];; 2000 if (s1*s2 > 0) {; 2001 Printf("" MNCONTour problem 1"");; 2002 }; 2003 aopt = x1;; 2004 slope = s1;; 2005 if (s2 > 0) {; 2006 aopt = x2;; 2007 slope = s2;; 2008 }; 2009// ask if converged; 2010 tla = .01;; 2011 if (TMath::Abs(aopt) > 1) tla = TMath::Abs(aopt)*.01;; 2012 if (TMath::Abs(aopt - alsb[ibest-1]) < tla && TMath::Abs(flsb[ibest-1] - aim) < tlf) {; 2013 goto L800;; 2014 }; 2015 if (ipt >= 15) goto L950;; 2016 ; 2017// see if proposed point is in acceptable zone between L and R; 2018// first find ILEFT, IRIGHT, IOUT and IBEST; 2019 ileft = 0;; 2020 iright = 0;; 2021 ibest = 1;; 2022 ecarmx = 0;; 2023 ecarmn = TMath::Abs(aim - flsb[0]);; 2024 for (i = 1; i <= 3; ++i) {; 2025 ecart = TMath::Abs(flsb[i-1] - aim);; 2026 if (ecart < ecarmn) { ecarmn = ecart; ibest = i; }; 2027 if (ecart > ecarmx) { ecarmx = ecart; }; 2028 if (flsb[i-1] > aim) {; 2029 if (iright == 0) iright = i;; 2030 else if (flsb[i-1] > flsb[iright-1]) iout = i;; 2031 else { iout = iright; iright = i; }; 2032 }; 2033 else if (ileft == 0) ileft = i;; 2034 else if (flsb[i-1] < flsb[ileft-1]) iout = i;; 2035 else { iout = ileft; ileft = i; }; 2036 }; 2037// avoid keeping a very bad point next time around; 2038 if (ecarmx > TMath::Abs(flsb[iout-1] - aim)*10) {; 2039 aopt = aopt*.5 + (alsb[iright-1] + alsb[ileft-1])*.25;; 2040 }; 2041// knowing ILEFT and IRIGHT, get acceptable window; 2042 smalla = tla*.1;; 2043 if (slope*smalla > tlf) smalla = tlf / slope;; 2044 aleft = alsb[ileft-1] + smalla;; 2045 aright = alsb[iright-1] - smalla;; 2046// move proposed point AOPT into window if necessary; 2047 if (aopt < aleft) aopt = aleft;; 2048 if (aopt > aright) aopt = aright;; 2049 if (aleft > aright) aopt = (aleft + aright)*.5;; 2050 ; 2051// see if proposed point outside limi",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:200131,Safety,avoid,avoid,200131,")*.001;; 6137 ymax += dyy;; 6138 ymin -= dyy;; 6139 mnbins(ymin, ymax, maxny, ymin, ymax, ny, bwidy);; 6140 any = (Double_t) ny;; 6141 // if first point is blank, it is an 'origin'; 6142 if (chbest == ' ') goto L50;; 6143 xbest = (xmax + xmin)*.5;; 6144 ybest = (ymax + ymin)*.5;; 6145L50:; 6146 // find scale constants; 6147 ax = 1 / bwidx;; 6148 ay = 1 / bwidy;; 6149 bx = -ax*xmin + 2;; 6150 by = -ay*ymin - 2;; 6151 // convert points to grid positions; 6152 for (i = 1; i <= nxypt; ++i) {; 6153 xpt[i-1] = ax*xpt[i-1] + bx;; 6154 ypt[i-1] = any - ay*ypt[i-1] - by;; 6155 }; 6156 nxbest = Int_t((ax*xbest + bx));; 6157 nybest = Int_t((any - ay*ybest - by));; 6158 // print the points; 6159 ny += 2;; 6160 nx += 2;; 6161 isp1 = 1;; 6162 linodd = 1;; 6163 overpr = kFALSE;; 6164 for (i = 1; i <= ny; ++i) {; 6165 for (ibk = 1; ibk <= nx; ++ibk) { cline[ibk-1] = ' '; }; 6166 cline[nx] = '\0';; 6167 cline[nx+1] = '\0';; 6168 cline[0] = '.';; 6169 // not needed - but to avoid a wrongly reported compiler warning (see ROOT-6496); 6170 if (nx>0) cline[nx-1] = '.';; 6171 cline[nxbest-1] = '.';; 6172 if (i != 1 && i != nybest && i != ny) goto L320;; 6173 for (j = 1; j <= nx; ++j) { cline[j-1] = '.'; }; 6174L320:; 6175 yprt = ymax - Double_t(i-1)*bwidy;; 6176 if (isp1 > nxypt) goto L350;; 6177 // find the points to be plotted on this line; 6178 for (k = isp1; k <= nxypt; ++k) {; 6179 ks = Int_t(ypt[k-1]);; 6180 if (ks > i) goto L345;; 6181 ix = Int_t(xpt[k-1]);; 6182 if (cline[ix-1] == '.') goto L340;; 6183 if (cline[ix-1] == ' ') goto L340;; 6184 if (cline[ix-1] == chpt[k-1]) continue;; 6185 overpr = kTRUE;; 6186 // OVERPR is true if one or more positions contains more than; 6187 // one point; 6188 cline[ix-1] = '&';; 6189 continue;; 6190L340:; 6191 cline[ix-1] = chpt[k-1];; 6192 }; 6193 isp1 = nxypt + 1;; 6194 goto L350;; 6195L345:; 6196 isp1 = k;; 6197L350:; 6198 if (linodd == 1 || i == ny) goto L380;; 6199 linodd = 1;; 6200 ctemp = cline;; 6201 Printf("" %s"",(const char*)ctemp);; 62",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:245163,Safety,safe,safely,245163,"d is the covariance; 7632/// matrix:; 7633/// - 0= not calculated at all; 7634/// - 1= approximation only, not accurate; 7635/// - 2= full matrix, but forced positive-definite; 7636/// - 3= full accurate covariance matrix; 7637 ; 7638void TMinuit::mnstat(Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat); 7639{; 7640 fmin = fAmin;; 7641 fedm = fEDM;; 7642 errdef = fUp;; 7643 npari = fNpar;; 7644 nparx = fNu;; 7645 istat = fISW[1];; 7646 if (fEDM == fBigedm) fedm = fUp;; 7647 if (fAmin == fUndefi) {; 7648 fmin = 0;; 7649 fedm = fUp;; 7650 istat = 0;; 7651 }; 7652}; 7653 ; 7654////////////////////////////////////////////////////////////////////////////////; 7655/// To find the machine precision; 7656///; 7657/// Compares its argument with the value 1.0, and returns; 7658/// the value .TRUE. if they are equal. To find EPSMAC; 7659/// safely by foiling the Fortran optimiser; 7660 ; 7661void TMinuit::mntiny(Double_t epsp1, Double_t &epsbak); 7662{; 7663 epsbak = epsp1 - 1;; 7664}; 7665 ; 7666////////////////////////////////////////////////////////////////////////////////; 7667/// Returns .TRUE. if CFNAME contains unprintable characters; 7668///; 7669 ; 7670Bool_t TMinuit::mnunpt(TString &cfname); 7671{; 7672 Int_t i, l, ic;; 7673 Bool_t ret_val;; 7674 static const TString cpt = "" ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890./;:[]$%*_!@#&+()"";; 7675 ; 7676 ret_val = kFALSE;; 7677 l = strlen((const char*)cfname);; 7678 for (i = 1; i <= l; ++i) {; 7679 for (ic = 1; ic <= 80; ++ic) {; 7680 if (cfname[i-1] == cpt[ic-1]) goto L100;; 7681 }; 7682 return kTRUE;; 7683L100:; 7684 ;; 7685 }; 7686 return ret_val;; 7687}; 7688 ; 7689////////////////////////////////////////////////////////////////////////////////; 7690/// Inverts a symmetric matrix; 7691///; 7692/// inverts a symmetric matrix. matrix is first scaled to; 7693/// have all ones on the diagonal (equivalent to change of units); 7694/// but no pivoting is done since ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:30671,Testability,log,log,30671,"86/// - fval: The calculated function value.; 787/// - grad: The (optional) vector of first derivatives).; 788///; 789/// The meaning of the parameters par is of course defined by the user,; 790/// who uses the values of those parameters to calculate their function value.; 791/// The starting values must be specified by the user.; 792/// Later values are determined by Minuit as it searches for the minimum; 793/// or performs whatever analysis is requested by the user.; 794///; 795/// Note that this virtual function may be redefined in a class derived from TMinuit.; 796/// The default function calls the function specified in SetFCN; 797///; 798/// Example of Minimisation function:; 799 ; 800Int_t TMinuit::Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag); 801{; 802/*; 803 if (flag == 1) {; 804 read input data,; 805 calculate any necessary constants, etc.; 806 }; 807 if (flag == 2) {; 808 calculate GRAD, the first derivatives of FVAL; 809 (this is optional); 810 }; 811 Always calculate the value of the function, FVAL,; 812 which is usually a chisquare or log likelihood.; 813 if (iflag == 3) {; 814 will come here only after the fit is finished.; 815 Perform any final calculations, output fitted data, etc.; 816 }; 817*/; 818// See concrete examples in TH1::H1FitChisquare, H1FitLikelihood; 819 ; 820 if (fFCN) (*fFCN)(npar,grad,fval,par,flag);; 821 return 0;; 822}; 823 ; 824////////////////////////////////////////////////////////////////////////////////; 825/// fix a parameter; 826 ; 827Int_t TMinuit::FixParameter( Int_t parNo); 828{; 829 Int_t err;; 830 Double_t tmp[1];; 831 tmp[0] = parNo+1; //set internal Minuit numbering; 832 ; 833 mnexcm( ""FIX"", tmp, 1, err );; 834 ; 835 return err;; 836}; 837 ; 838////////////////////////////////////////////////////////////////////////////////; 839/// return parameter value and error; 840 ; 841Int_t TMinuit::GetParameter( Int_t parNo, Double_t &currentValue, Double_t &currentError ) const; 842{; 843 Int_t er",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:125091,Testability,log,log,125091,"BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; 3770 Printf("" knows that the FCN function value is not calculated to"");; 3771 Printf("" the nominal machine accuracy. Typical values of <accuracy>"");; 3772 Printf("" are between 10**-5 and 10**-14."");; 3773 ; 3774 Printf("" "");; 3775 Printf("" SET ERRordef <up>"");; 3776 Printf("" Sets the value of UP (default value= 1.), defining parameter"");; 3777 Printf("" errors. Minuit defines parameter errors as the change"");; 3778 Printf("" in parameter value required to change the function value"");; 3779 Printf("" by UP. Normally, for chisquared fits UP=1, and for negative"");; 3780 Printf("" log likelihood, UP=0.5."");; 3781 ; 3782 Printf("" "");; 3783 Printf("" SET GRAdient [force]"");; 3784 Printf("" Informs Minuit that the user function is prepared to"");; 3785 Printf("" calculate its own first derivatives and return their values"");; 3786 Printf("" in the array GRAD when IFLAG=2 (see specs of FCN)."");; 3787 Printf("" If [force] is not specified, Minuit will calculate"");; 3788 Printf("" the FCN derivatives by finite differences at the current"");; 3789 Printf("" point and compare with the user calculation at that point,"");; 3790 Printf("" accepting the user values only if they agree."");; 3791 Printf("" If [force]=1, Minuit does not do its own derivative"");; 3792 Printf("" calculation, and uses the derivatives calculated in FCN."");; 3793 ; 3794 Printf("" "");; 3795 Printf("" SET INPut [unitno] [filename]"");; 3796 Printf("" Causes Minuit, in data-driven mode only, to read subsequent"");; 3797 Printf("" commands (or parameter definitions) from a different input"");; 3798 ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:150656,Testability,log,logical,150656,";; 4488 if (fISW[4] > 0) {; 4489 Printf("" IMPROVE HAS RETURNED TO REGION OF ORIGINAL MINIMUM"");; 4490 }; 4491 fCstatu = ""UNCHANGED "";; 4492 mnrset(0);; 4493 if (fISW[1] < 2) goto L380;; 4494 if (loop < nloop && fISW[0] < 1) goto L20;; 4495L380:; 4496 if (iswtr >= 0) mnprin(5, fAmin);; 4497 fItaur = 0;; 4498}; 4499 ; 4500////////////////////////////////////////////////////////////////////////////////; 4501/// Transforms from internal coordinates (PINT) to external (U); 4502///; 4503/// The minimising routines which work in; 4504/// internal coordinates call this routine before calling FCN.; 4505 ; 4506void TMinuit::mninex(Double_t *pint); 4507{; 4508 Int_t i, j;; 4509 ; 4510 for (j = 0; j < fNpar; ++j) {; 4511 i = fNexofi[j]-1;; 4512 if (fNvarl[i] == 1) {; 4513 fU[i] = pint[j];; 4514 } else {; 4515 fU[i] = fAlim[i] + (TMath::Sin(pint[j]) + 1)*.5*(fBlim[i] - fAlim[i]);; 4516 }; 4517 }; 4518}; 4519 ; 4520////////////////////////////////////////////////////////////////////////////////; 4521/// Main initialization member function for MINUIT; 4522///; 4523/// It initializes some constants; 4524/// (including the logical I/O unit nos.),; 4525 ; 4526void TMinuit::mninit(Int_t i1, Int_t i2, Int_t i3); 4527{; 4528 /* Local variables */; 4529 volatile Double_t epsp1;; 4530 Double_t piby2, epstry, epsbak, distnn;; 4531 Int_t i, idb;; 4532 ; 4533// I/O unit numbers; 4534 fIsysrd = i1;; 4535 fIsyswr = i2;; 4536 fIstkwr[0] = fIsyswr;; 4537 fNstkwr = 1;; 4538 fIsyssa = i3;; 4539 fNstkrd = 0;; 4540// version identifier; 4541 fCvrsn = ""95.03++ "";; 4542// some CONSTANT; 4543 fMaxint = fMaxpar;; 4544 fMaxext = 2*fMaxpar;; 4545 fUndefi = -54321;; 4546 fBigedm = 123456;; 4547 fCundef = "")UNDEFINED"";; 4548 fCovmes[0] = ""NO ERROR MATRIX "";; 4549 fCovmes[1] = ""ERR MATRIX APPROXIMATE"";; 4550 fCovmes[2] = ""ERR MATRIX NOT POS-DEF"";; 4551 fCovmes[3] = ""ERROR MATRIX ACCURATE "";; 4552// some starting values; 4553 fNblock = 0;; 4554 fIcomnd = 0;; 4555 fCtitl = fCundef;; 4556 fCfrom = ""INPUT "";; 45",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:277676,Testability,log,logarithm,277676,"using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ahDefinition civetweb.c:8348; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. mathminuitsrcTMinuit.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:43 (GVA Time) using Doxy",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:278290,Testability,log,logarithm,278290,"tyle format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; ptTPaveText * ptDefinition entrylist_figure1.C:7; lineTLine * lineDefinition entrylistblock_figure1.C:235; yDouble_t y[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; f1TF1 * f1Definition legend1.C:11; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ASinDouble_t ASin(Double_t)Returns the principal value of the arc sine of x, expressed in radians.Definition TMath.h:624; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::CosDouble_t Cos(Double_t)Returns the cosine of an angle of x radians.Definition TMath.h:594; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ahDefinition civetweb.c:8348; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. mathminuitsrcTMinuit.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:43 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:1254,Usability,simpl,simply,1254,"oot/minuit:$Id$; 2// Author: Rene Brun, Frederick James 12/08/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12 ; 13/*! \class TMinuit; 14\see Minuit2 for a newer version of this package; 15\ingroup MinuitOld; 16 ; 17Implementation in C++ of the Minuit package written by Fred James.; 18This is a straightforward conversion of the original Fortran version.; 19 ; 20The main changes are:; 21 ; 22 - The variables in the various Minuit labelled common blocks; 23 have been changed to the TMinuit class data members.; 24 ; 25 - The internal arrays with a maximum dimension depending on the; 26 maximum number of parameters are now data members arrays with; 27 a dynamic dimension such that one can fit very large problems; 28 by simply initialising the TMinuit constructor with the maximum; 29 number of parameters.; 30 ; 31 - The include file Minuit.h has been commented as much as possible; 32 using existing comments in the code or the printed documentation; 33 ; 34 - The original Minuit subroutines are now member functions.; 35 ; 36 - Constructors and destructor have been added.; 37 ; 38 - Instead of passing the FCN function in the argument; 39 list, the addresses of this function is stored as pointer; 40 in the data members of the class. This is by far more elegant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:2700,Usability,simpl,simple,2700,"legant; 41 and flexible in an interactive environment.; 42 The member function SetFCN can be used to define this pointer.; 43 ; 44 - The ROOT static function Printf is provided to replace all; 45 format statements and to print on currently defined output file.; 46 - The functions SetObjectFit(TObject * obj)/GetObjectFit() can be; 47 used inside the FCN function to set/get a referenced object; 48 instead of using global variables.; 49 ; 50 ; 51## Basic concepts of MINUIT; 52 ; 53The [MINUIT](https://root.cern/download/minuit.pdf); 54package acts on a multiparameter Fortran function to which one; 55must give the generic name <TT>FCN</TT>. In the ROOT implementation,; 56the function <TT>FCN</TT> is defined via the MINUIT SetFCN member function; 57when an Histogram.Fit command is invoked.; 58The value of <TT>FCN</TT> will in general depend on one; 59or more variable parameters.; 60 ; 61To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); 62the Fit function defines the Minuit fitting function as being H1FitChisquare; 63or H1FitLikelihood depending on the options selected.; 64H1FitChisquare; 65calculates the chisquare between the user fitting function (gaussian, polynomial,; 66user defined,etc) and the data for given values of the parameters.; 67It is the task of MINUIT to find those values of the parameters; 68which give the lowest value of chisquare.; 69 ; 70### Basic concepts - The transformation for parameters with limits.; 71 ; 72For variable parameters with limits, MINUIT uses the following; 73transformation:; 74 ; 75\f[; 76P_{\mathrm{int}} = \arcsin; 77 \left( 2\: \frac{P_{\mathrm{ext}}-a}{b-a} - 1 \right); 78P_{\mathrm{ext}} = a + \frac{b - a}{2} \left( \sin P_{\mathrm{int}} + 1 \right); 79\f]; 80 ; 81so that the internal value \f$P_{\mathrm{int}}\f$ can take on any value, while; 82the external value \f$P_{\mathrm{ext}}\f$ can take on values only between the lower; 83limit \f$a\f$ and the upper limit \f$b\f$.; 84Since the transformat",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:91645,Usability,simpl,simplex,91645," if (fCword(0,4) == ""MINO"") i = 5;; 2789 if (i != 6 && i != 7 && i != 8 && i != 23) {; 2790 fCfrom = cname[i-1];; 2791 fNfcnfr = fNfcn;; 2792 }; 2793// 1 2 3 4 5 6 7 8 9 10; 2794 switch (i) {; 2795 case 1: goto L400;; 2796 case 2: goto L200;; 2797 case 3: goto L300;; 2798 case 4: goto L400;; 2799 case 5: goto L500;; 2800 case 6: goto L700;; 2801 case 7: goto L700;; 2802 case 8: goto L800;; 2803 case 9: goto L900;; 2804 case 10: goto L1000;; 2805 case 11: goto L1100;; 2806 case 12: goto L1200;; 2807 case 13: goto L1300;; 2808 case 14: goto L1400;; 2809 case 15: goto L1500;; 2810 case 16: goto L1600;; 2811 case 17: goto L1700;; 2812 case 18: goto L1800;; 2813 case 19: goto L1900;; 2814 case 20: goto L1900;; 2815 case 21: goto L1900;; 2816 case 22: goto L2200;; 2817 case 23: goto L2300;; 2818 case 24: goto L2400;; 2819 case 25: goto L1900;; 2820 case 26: goto L2600;; 2821 case 27: goto L3300;; 2822 case 28: goto L3300;; 2823 case 29: goto L3300;; 2824 case 30: goto L3300;; 2825 case 31: goto L3300;; 2826 case 32: goto L3300;; 2827 case 33: goto L3300;; 2828 case 34: goto L3400;; 2829 case 35: goto L3500;; 2830 case 36: goto L3600;; 2831 case 37: goto L3700;; 2832 case 38: goto L3800;; 2833 case 39: goto L3900;; 2834 case 40: goto L4000;; 2835 }; 2836// seek; 2837L200:; 2838 mnseek();; 2839 return;; 2840// simplex; 2841L300:; 2842 mnsimp();; 2843 if (fISW[3] < 1) ierflg = 4;; 2844 return;; 2845// migrad, minimize; 2846L400:; 2847 nf = fNfcn;; 2848 fApsi = fEpsi;; 2849 mnmigr();; 2850 mnwerr();; 2851 if (fISW[3] >= 1) return;; 2852 ierflg = 4;; 2853 if (fISW[0] == 1) return;; 2854 if (fCword(0,3) == ""MIG"") return;; 2855 ; 2856 fNfcnmx = fNfcnmx + nf - fNfcn;; 2857 nf = fNfcn;; 2858 mnsimp();; 2859 if (fISW[0] == 1) return;; 2860 fNfcnmx = fNfcnmx + nf - fNfcn;; 2861 mnmigr();; 2862 if (fISW[3] >= 1) ierflg = 0;; 2863 mnwerr();; 2864 return;; 2865// minos; 2866L500:; 2867 nsuper = fNfcn + ((fNpar + 1) << 1)*fNfcnmx;; 2868// possible loop over new minima; 2869 fEpsi = fUp*.",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:96482,Usability,clear,clear,96482,"();; 2969 return;; 2970L1250:; 2971 Printf("" PARAMETER %4d NOT VARIABLE."",iext);; 2972 ierflg = 3;; 2973 return;; 2974// contour; 2975L1300:; 2976 ke1 = Int_t(fWord7[0]);; 2977 ke2 = Int_t(fWord7[1]);; 2978 if (ke1 == 0) {; 2979 if (fNpar == 2) {; 2980 ke1 = fNexofi[0];; 2981 ke2 = fNexofi[1];; 2982 } else {; 2983 Printf(""%s: NO PARAMETERS REQUESTED "",(const char*)fCword);; 2984 ierflg = 3;; 2985 return;; 2986 }; 2987 }; 2988 fNfcnmx = 1000;; 2989 mncntr(ke1-1, ke2-1, ierrf);; 2990 if (ierrf > 0) ierflg = 3;; 2991 return;; 2992// hesse; 2993L1400:; 2994 mnhess();; 2995 mnwerr();; 2996 if (fISW[4] >= 0) mnprin(2, fAmin);; 2997 if (fISW[4] >= 1) mnmatu(1);; 2998 return;; 2999// save; 3000L1500:; 3001 mnsave();; 3002 return;; 3003// improve; 3004L1600:; 3005 mncuve();; 3006 mnimpr();; 3007 if (fLnewmn) goto L400;; 3008 ierflg = 4;; 3009 return;; 3010// call fcn; 3011L1700:; 3012 iflag = Int_t(fWord7[0]);; 3013 nparx = fNpar;; 3014 f = fUndefi;; 3015 Eval(nparx, fGin, f, fU, iflag); ++fNfcn;; 3016 nowprt = 0;; 3017 if (f != fUndefi) {; 3018 if (fAmin == fUndefi) {; 3019 fAmin = f;; 3020 nowprt = 1;; 3021 } else if (f < fAmin) {; 3022 fAmin = f;; 3023 nowprt = 1;; 3024 }; 3025 if (fISW[4] >= 0 && iflag <= 5 && nowprt == 1) {; 3026 mnprin(5, fAmin);; 3027 }; 3028 if (iflag == 3) fFval3 = f;; 3029 }; 3030 if (iflag > 5) mnrset(1);; 3031 return;; 3032// standard; 3033L1800:; 3034// stand();; 3035 return;; 3036// return, stop, end, exit; 3037L1900:; 3038 it = Int_t(fWord7[0]);; 3039 if (fFval3 != fAmin && it == 0) {; 3040 iflag = 3;; 3041 if (fISW[4] >= 0) Printf("" CALL TO USER FUNCTION WITH IFLAG = 3"");; 3042 nparx = fNpar;; 3043 Eval(nparx, fGin, f, fU, iflag); ++fNfcn;; 3044 }; 3045 ierflg = 11;; 3046 if (fCword(0,3) == ""END"") ierflg = 10;; 3047 if (fCword(0,3) == ""RET"") ierflg = 12;; 3048 return;; 3049// clear; 3050L2200:; 3051 mncler();; 3052 if (fISW[4] >= 1) {; 3053 Printf("" MINUIT MEMORY CLEARED. NO PARAMETERS NOW DEFINED."");; 3054 }; 3055 return;; 3056// help; 3057L",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:132489,Usability,simpl,simplex,132489,"ng SHOw XXXX command."");; 3912 Printf("" In addition, the SHOw commands listed starting here have no"");; 3913 Printf("" corresponding SET command for obvious reasons."");; 3914 ; 3915 Printf("" "");; 3916 Printf("" SHOw CORrelations"");; 3917 Printf("" Calculates and prints the parameter correlations from the"");; 3918 Printf("" error matrix."");; 3919 ; 3920 Printf("" "");; 3921 Printf("" SHOw COVariance"");; 3922 Printf("" Prints the (external) covariance (error) matrix."");; 3923 ; 3924 Printf("" "");; 3925 Printf("" SHOw EIGenvalues"");; 3926 Printf("" Calculates and prints the eigenvalues of the covariance"");; 3927 Printf("" matrix."");; 3928 ; 3929 Printf("" "");; 3930 Printf("" SHOw FCNvalue"");; 3931 Printf("" Prints the current value of FCN."");; 3932 goto L99;; 3933 }; 3934//______________________________________________________________________________; 3935//; 3936// Command SIMPLEX; 3937//; 3938 if( !strncmp(comd.Data(),""SIM"",3) ) {; 3939 Printf("" ***>SIMplex [maxcalls] [tolerance]"");; 3940 Printf("" Performs a function minimization using the simplex method of"");; 3941 Printf("" Nelder and Mead. Minimization terminates either when the"");; 3942 Printf("" function has been called (approximately) [maxcalls] times,"");; 3943 Printf("" or when the estimated vertical distance to minimum (EDM) is"");; 3944 Printf("" less than [tolerance]."");; 3945 Printf("" The default value of [tolerance] is 0.1*UP(see SET ERRordef)."");; 3946 goto L99;; 3947 }; 3948//______________________________________________________________________________; 3949//; 3950// Command STANDARD; 3951//; 3952 if( !strncmp(comd.Data(),""STA"",3) ) {; 3953 Printf("" ***>STAndard"");; 3954 goto L99;; 3955 }; 3956//______________________________________________________________________________; 3957//; 3958// Command STOP; 3959//; 3960 if( !strncmp(comd.Data(),""STO"",3) ) {; 3961 Printf("" ***>STOP"");; 3962 Printf("" Same as EXIT."");; 3963 goto L99;; 3964 }; 3965//______________________________________________________________________________; 39",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:143887,Usability,simpl,simplex,143887,"[i-1] = grdnew;; 4265 if (fGstep[i-1] > 0) fGstep[i-1] = TMath::Abs(d);; 4266 else fGstep[i-1] = -TMath::Abs(d);; 4267// decrease step until first derivative changes by <5%; 4268 if (change < .05) goto L60;; 4269 if (TMath::Abs(grdold - grdnew) < dgmin) goto L60;; 4270 if (d < dmin_) {; 4271 mnwarn(""D"", ""MNHES1"", ""Step size too small for 1st drv."");; 4272 goto L60;; 4273 }; 4274 d *= .2;; 4275 }; 4276// loop satisfied = too many iter; 4277 mnwarn(""D"", ""MNHES1"", TString::Format(""Too many iterations on D1.%g%g"",grdold,grdnew));; 4278L60:; 4279 fDgrd[i-1] = TMath::Max(dgmin,TMath::Abs(grdold - grdnew));; 4280 }; 4281// end of first deriv. loop; 4282 mninex(fX);; 4283}; 4284 ; 4285////////////////////////////////////////////////////////////////////////////////; 4286/// Attempts to improve on a good local minimum; 4287///; 4288/// Attempts to improve on a good local minimum by finding a; 4289/// better one. The quadratic part of FCN is removed by MNCALF; 4290/// and this transformed function is minimised using the simplex; 4291/// method from several random starting points.; 4292///; 4293/// ref. -- Goldstein and Price, Math.Comp. 25, 569 (1971); 4294 ; 4295void TMinuit::mnimpr(); 4296{; 4297 /* Initialized data */; 4298 ; 4299 Double_t rnum = 0;; 4300 ; 4301 /* Local variables */; 4302 Double_t amax, ycalf, ystar, ystst;; 4303 Double_t pb, ep, wg, xi, sigsav, reg, sig2;; 4304 Int_t npfn, ndex, loop=0, i, j, ifail, iseed=0;; 4305 Int_t jhold, nloop, nparx, nparp1, jh, jl, iswtr;; 4306 ; 4307 if (fNpar <= 0) return;; 4308 if (fAmin == fUndefi) mnamin();; 4309 fCstatu = ""UNCHANGED "";; 4310 fItaur = 1;; 4311 fEpsi = fUp*.1;; 4312 npfn = fNfcn;; 4313 nloop = Int_t(fWord7[1]);; 4314 if (nloop <= 0) nloop = fNpar + 4;; 4315 nparx = fNpar;; 4316 nparp1 = fNpar + 1;; 4317 wg = 1 / Double_t(fNpar);; 4318 sigsav = fEDM;; 4319 fApsi = fAmin;; 4320 iswtr = fISW[4] - 2*fItaur;; 4321 for (i = 1; i <= fNpar; ++i) {; 4322 fXt[i-1] = fX[i-1];; 4323 fIMPRdsav[i-1] = fWerr[i-1];; 4324 for ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:145754,Usability,simpl,simplex,145754," fX[i-1];; 4323 fIMPRdsav[i-1] = fWerr[i-1];; 4324 for (j = 1; j <= i; ++j) {; 4325 ndex = i*(i-1) / 2 + j;; 4326 fP[i + j*fMaxpar - fMaxpar-1] = fVhmat[ndex-1];; 4327 fP[j + i*fMaxpar - fMaxpar-1] = fP[i + j*fMaxpar - fMaxpar-1];; 4328 }; 4329 }; 4330 mnvert(fP, fMaxint, fMaxint, fNpar, ifail);; 4331 if (ifail >= 1) goto L280;; 4332// Save inverted matrix in VT; 4333 for (i = 1; i <= fNpar; ++i) {; 4334 ndex = i*(i-1) / 2;; 4335 for (j = 1; j <= i; ++j) {; 4336 ++ndex;; 4337 fVthmat[ndex-1] = fP[i + j*fMaxpar - fMaxpar-1];; 4338 }; 4339 }; 4340 loop = 0;; 4341 ; 4342L20:; 4343 for (i = 1; i <= fNpar; ++i) {; 4344 fDirin[i-1] = fIMPRdsav[i-1]*2;; 4345 mnrn15(rnum, iseed);; 4346 fX[i-1] = fXt[i-1] + fDirin[i-1]*2*(rnum - .5);; 4347 }; 4348 ++loop;; 4349 reg = 2;; 4350 if (fISW[4] >= 0) {; 4351 Printf(""START ATTEMPT NO.%2d TO FIND NEW MINIMUM"",loop);; 4352 }; 4353L30:; 4354 mncalf(fX, ycalf);; 4355 fAmin = ycalf;; 4356// set up random simplex; 4357 jl = nparp1;; 4358 jh = nparp1;; 4359 fIMPRy[nparp1-1] = fAmin;; 4360 amax = fAmin;; 4361 for (i = 1; i <= fNpar; ++i) {; 4362 xi = fX[i-1];; 4363 mnrn15(rnum, iseed);; 4364 fX[i-1] = xi - fDirin[i-1]*(rnum - .5);; 4365 mncalf(fX, ycalf);; 4366 fIMPRy[i-1] = ycalf;; 4367 if (fIMPRy[i-1] < fAmin) {; 4368 fAmin = fIMPRy[i-1];; 4369 jl = i;; 4370 } else if (fIMPRy[i-1] > amax) {; 4371 amax = fIMPRy[i-1];; 4372 jh = i;; 4373 }; 4374 for (j = 1; j <= fNpar; ++j) { fP[j + i*fMaxpar - fMaxpar-1] = fX[j-1]; }; 4375 fP[i + nparp1*fMaxpar - fMaxpar-1] = xi;; 4376 fX[i-1] = xi;; 4377 }; 4378 ; 4379 fEDM = fAmin;; 4380 sig2 = fEDM;; 4381// start main loop; 4382L50:; 4383 if (fAmin < 0) goto L95;; 4384 if (fISW[1] <= 2) goto L280;; 4385 ep = fAmin*.1;; 4386 if (sig2 < ep && fEDM < ep) goto L100;; 4387 sig2 = fEDM;; 4388 if (fNfcn - npfn > fNfcnmx) goto L300;; 4389// calculate new point * by reflection; 4390 for (i = 1; i <= fNpar; ++i) {; 4391 pb = 0;; 4392 for (j = 1; j <= nparp1; ++j) { pb += wg*fP[i + j*fMaxpar - fMaxpar-1]; }; 4393 ",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:212724,Usability,simpl,simplex,212724," pmin = fPstar[0];; 6536 pmax = fPstar[0];; 6537 for (ip = 2; ip <= fNpar; ++ip) {; 6538 if (fPstar[ip-1] < pmin) pmin = fPstar[ip-1];; 6539 if (fPstar[ip-1] > pmax) pmax = fPstar[ip-1];; 6540 }; 6541 pmax = TMath::Max(TMath::Abs(pmax),Double_t(1));; 6542 if ((pmin <= 0 && fLwarn) || fISW[4] >= 2) {; 6543 Printf("" EIGENVALUES OF SECOND-DERIVATIVE MATRIX:"");; 6544 ctemp = "" "";; 6545 for (ip = 1; ip <= fNpar; ++ip) {; 6546 ctemp += TString::Format("" %11.4e"",fPstar[ip-1]);; 6547 }; 6548 Printf(""%s"", ctemp.Data());; 6549 }; 6550 if (pmin > epspdf*pmax) return;; 6551 if (fISW[1] == 3) fISW[1] = 2;; 6552 pAdd = pmax*.001 - pmin;; 6553 for (ip = 1; ip <= fNpar; ++ip) {; 6554 ndex = ip*(ip + 1) / 2;; 6555 fVhmat[ndex-1] *= pAdd + 1;; 6556 }; 6557 fCstatu = ""NOT POSDEF"";; 6558 mnwarn(""W"", fCfrom, Form(""MATRIX FORCED POS-DEF BY ADDING %f TO DIAGONAL."",pAdd));; 6559 ; 6560}; 6561 ; 6562////////////////////////////////////////////////////////////////////////////////; 6563/// Called only by MNSIMP (and MNIMPR) to add a new point; 6564///; 6565/// and remove an old one from the current simplex, and get the; 6566/// estimated distance to minimum.; 6567 ; 6568void TMinuit::mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl); 6569{; 6570 /* Local variables */; 6571 Double_t pbig, plit;; 6572 Int_t i, j, nparp1;; 6573 ; 6574 /* Function Body */; 6575 for (i = 1; i <= fNpar; ++i) { fP[i + jh*fMaxpar - fMaxpar-1] = pnew[i-1]; }; 6576 y[jh-1] = ynew;; 6577 if (ynew < fAmin) {; 6578 for (i = 1; i <= fNpar; ++i) { fX[i-1] = pnew[i-1]; }; 6579 mninex(fX);; 6580 fAmin = ynew;; 6581 fCstatu = ""PROGRESS "";; 6582 jl = jh;; 6583 }; 6584 jh = 1;; 6585 nparp1 = fNpar + 1;; 6586 for (j = 2; j <= nparp1; ++j) { if (y[j-1] > y[jh-1]) jh = j; }; 6587 fEDM = y[jh-1] - y[jl-1];; 6588 if (fEDM <= 0) goto L45;; 6589 for (i = 1; i <= fNpar; ++i) {; 6590 pbig = fP[i-1];; 6591 plit = pbig;; 6592 for (j = 2; j <= nparp1; ++j) {; 6593 if (fP[i + j*fMaxpar - fMaxpar-1] > pbig) pbig = fP[i +",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:237636,Usability,simpl,simplex,237636,"99// -----------------------------------------------------; 7400// UNKNOWN COMMAND; 7401L1900:; 7402 Printf("" THE COMMAND:%10s IS UNKNOWN."",(const char*)fCword);; 7403 goto L2100;; 7404// -----------------------------------------------------; 7405// HELP SHOW, HELP SET, SHOW SET, or SHOW SHOW; 7406L2000:; 7407 ckind = ""SET "";; 7408 ctemp2 = fCword(3,7);; 7409 if (strcmp(ctemp2.Data(), ""SHO"")) ckind = ""SHOW"";; 7410L2100:; 7411 Printf("" THE FORMAT OF THE %4s COMMAND IS:"",(const char*)ckind);; 7412 Printf("" %s xxx [numerical arguments if any]"",(const char*)ckind);; 7413 Printf("" WHERE xxx MAY BE ONE OF THE FOLLOWING:"");; 7414 for (kk = 1; kk <= nname; ++kk) {; 7415 Printf("" %s"",cname[kk-1]);; 7416 }; 7417 return;; 7418// -----------------------------------------------------; 7419// ILLEGAL COMMAND; 7420L3000:; 7421 Printf("" ABOVE COMMAND IS ILLEGAL. IGNORED"");; 7422 ; 7423}; 7424 ; 7425////////////////////////////////////////////////////////////////////////////////; 7426/// Minimization using the simplex method of Nelder and Mead; 7427///; 7428/// Performs a minimization using the simplex method of Nelder; 7429/// and Mead (ref. -- Comp. J. 7,308 (1965)).; 7430 ; 7431void TMinuit::mnsimp(); 7432{; 7433 /* Initialized data */; 7434 ; 7435 static constexpr Double_t alpha = 1;; 7436 static constexpr Double_t beta = .5;; 7437 static constexpr Double_t gamma = 2;; 7438 static constexpr Double_t rhomin = 4;; 7439 static constexpr Double_t rhomax = 8;; 7440 ; 7441 /* Local variables */; 7442 Double_t dmin_, dxdi, yrho, f, ynpp1, aming, ypbar;; 7443 Double_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:237722,Usability,simpl,simplex,237722,"99// -----------------------------------------------------; 7400// UNKNOWN COMMAND; 7401L1900:; 7402 Printf("" THE COMMAND:%10s IS UNKNOWN."",(const char*)fCword);; 7403 goto L2100;; 7404// -----------------------------------------------------; 7405// HELP SHOW, HELP SET, SHOW SET, or SHOW SHOW; 7406L2000:; 7407 ckind = ""SET "";; 7408 ctemp2 = fCword(3,7);; 7409 if (strcmp(ctemp2.Data(), ""SHO"")) ckind = ""SHOW"";; 7410L2100:; 7411 Printf("" THE FORMAT OF THE %4s COMMAND IS:"",(const char*)ckind);; 7412 Printf("" %s xxx [numerical arguments if any]"",(const char*)ckind);; 7413 Printf("" WHERE xxx MAY BE ONE OF THE FOLLOWING:"");; 7414 for (kk = 1; kk <= nname; ++kk) {; 7415 Printf("" %s"",cname[kk-1]);; 7416 }; 7417 return;; 7418// -----------------------------------------------------; 7419// ILLEGAL COMMAND; 7420L3000:; 7421 Printf("" ABOVE COMMAND IS ILLEGAL. IGNORED"");; 7422 ; 7423}; 7424 ; 7425////////////////////////////////////////////////////////////////////////////////; 7426/// Minimization using the simplex method of Nelder and Mead; 7427///; 7428/// Performs a minimization using the simplex method of Nelder; 7429/// and Mead (ref. -- Comp. J. 7,308 (1965)).; 7430 ; 7431void TMinuit::mnsimp(); 7432{; 7433 /* Initialized data */; 7434 ; 7435 static constexpr Double_t alpha = 1;; 7436 static constexpr Double_t beta = .5;; 7437 static constexpr Double_t gamma = 2;; 7438 static constexpr Double_t rhomin = 4;; 7439 static constexpr Double_t rhomax = 8;; 7440 ; 7441 /* Local variables */; 7442 Double_t dmin_, dxdi, yrho, f, ynpp1, aming, ypbar;; 7443 Double_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:239085,Usability,simpl,simplex,239085,"uble_t bestx, ystar, y1, y2, ystst, pb, wg;; 7444 Double_t absmin, rho, sig2, rho1, rho2;; 7445 Int_t npfn, i, j, k, jhold, ncycl, nparx;; 7446 Int_t nparp1, kg, jh, nf, jl, ns;; 7447 ; 7448 if (fNpar <= 0) return;; 7449 if (fAmin == fUndefi) mnamin();; 7450 fCfrom = ""SIMPLEX "";; 7451 fNfcnfr = fNfcn;; 7452 fCstatu = ""UNCHANGED "";; 7453 npfn = fNfcn;; 7454 nparp1 = fNpar + 1;; 7455 nparx = fNpar;; 7456 rho1 = alpha + 1;; 7457 rho2 = rho1 + alpha*gamma;; 7458 wg = 1 / Double_t(fNpar);; 7459 if (fISW[4] >= 0) {; 7460 Printf("" START SIMPLEX MINIMIZATION. CONVERGENCE WHEN EDM .LT. %g"",fEpsi);; 7461 }; 7462 for (i = 1; i <= fNpar; ++i) {; 7463 fDirin[i-1] = fWerr[i-1];; 7464 mndxdi(fX[i-1], i-1, dxdi);; 7465 if (dxdi != 0) fDirin[i-1] = fWerr[i-1] / dxdi;; 7466 dmin_ = fEpsma2*TMath::Abs(fX[i-1]);; 7467 if (fDirin[i-1] < dmin_) fDirin[i-1] = dmin_;; 7468 }; 7469// choose the initial simplex using single-parameter searches; 7470L1:; 7471 ynpp1 = fAmin;; 7472 jl = nparp1;; 7473 fSIMPy[nparp1-1] = fAmin;; 7474 absmin = fAmin;; 7475 for (i = 1; i <= fNpar; ++i) {; 7476 aming = fAmin;; 7477 fPbar[i-1] = fX[i-1];; 7478 bestx = fX[i-1];; 7479 kg = 0;; 7480 ns = 0;; 7481 nf = 0;; 7482L4:; 7483 fX[i-1] = bestx + fDirin[i-1];; 7484 mninex(fX);; 7485 Eval(nparx, fGin, f, fU, 4); ++fNfcn;; 7486 if (f <= aming) goto L6;; 7487// failure; 7488 if (kg == 1) goto L8;; 7489 kg = -1;; 7490 ++nf;; 7491 fDirin[i-1] *= -.4;; 7492 if (nf < 3) goto L4;; 7493 ns = 6;; 7494// success; 7495L6:; 7496 bestx = fX[i-1];; 7497 fDirin[i-1] *= 3;; 7498 aming = f;; 7499 fCstatu = ""PROGRESS "";; 7500 kg = 1;; 7501 ++ns;; 7502 if (ns < 6) goto L4;; 7503// local minimum found in ith direction; 7504L8:; 7505 fSIMPy[i-1] = aming;; 7506 if (aming < absmin) jl = i;; 7507 if (aming < absmin) absmin = aming;; 7508 fX[i-1] = bestx;; 7509 for (k = 1; k <= fNpar; ++k) { fP[k + i*fMaxpar - fMaxpar-1] = fX[k-1]; }; 7510 }; 7511 jh = nparp1;; 7512 fAmin = fSIMPy[jl-1];; 7513 mnrazz(ynpp1, fPbar, fSIMPy, jh, jl);; 7514 for",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8cxx_source.html:259761,Usability,simpl,simplex,259761,"uit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::fPDouble_t * fPDefinition TMinuit.h:91; TMinuit::fNblockInt_t fNblockDefinition TMin",MatchSource.WIKI,doc/master/TMinuit_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html
https://root.cern/doc/master/TMinuit_8h.html:235,Integrability,depend,dependency,235,". ROOT: math/minuit/inc/TMinuit.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Variables ; TMinuit.h File Reference. #include ""TNamed.h""; #include ""TMethodCall.h"". Include dependency graph for TMinuit.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TMinuit;  . Variables; R__EXTERN TMinuit * gMinuit;  . Variable Documentation. ◆ gMinuit. R__EXTERN TMinuit* gMinuit. Definition at line 271 of file TMinuit.h. mathminuitincTMinuit.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMinuit_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h.html
https://root.cern/doc/master/TMinuit_8h_source.html:1884,Availability,error,errors,1884,"Minuit; 21#define ROOT_TMinuit; 22 ; 23#include ""TNamed.h""; 24 ; 25#include ""TMethodCall.h""; 26 ; 27class TMinuit : public TNamed {; 28 ; 29private:; 30 TMinuit(const TMinuit &m);; 31 TMinuit& operator=(const TMinuit &m); // Not implemented; 32 ; 33// should become private....; 34public:; 35 enum{kMAXWARN=100};; 36 ; 37 Int_t fNpfix; //Number of fixed parameters; 38 Int_t fEmpty; //Initialization flag (1 = Minuit initialized); 39 Int_t fMaxpar; //Maximum number of parameters; 40 Int_t fMaxint; //Maximum number of internal parameters; 41 Int_t fNpar; //Number of free parameters (total number of pars = fNpar + fNfix); 42 Int_t fMaxext; //Maximum number of external parameters; 43 Int_t fMaxIterations; //Maximum number of iterations; 44 Int_t fMaxpar5; // fMaxpar*(fMaxpar+1)/2; 45 Int_t fMaxcpt;; 46 Int_t fMaxpar2; // fMaxpar*fMaxpar; 47 Int_t fMaxpar1; // fMaxpar*(fMaxpar+1); 48 ; 49 Double_t fAmin; //Minimum value found for FCN; 50 Double_t fUp; //FCN+-UP defines errors (for chisquare fits UP=1); 51 Double_t fEDM; //Estimated vertical distance to the minimum; 52 Double_t fFval3; //; 53 Double_t fEpsi; //; 54 Double_t fApsi; //; 55 Double_t fDcovar; //Relative change in covariance matrix; 56 Double_t fEpsmac; //machine precision for floating points:; 57 Double_t fEpsma2; //sqrt(fEpsmac); 58 Double_t fVlimlo; //; 59 Double_t fVlimhi; //; 60 Double_t fUndefi; //Undefined number = -54321; 61 Double_t fBigedm; //Big EDM = 123456; 62 Double_t fUpdflt; //; 63 Double_t fXmidcr; //; 64 Double_t fYmidcr; //; 65 Double_t fXdircr; //; 66 Double_t fYdircr; //; 67 ; 68 Double_t *fU; //[fMaxpar2] External (visible to user in FCN) value of parameters; 69 Double_t *fAlim; //[fMaxpar2] Lower limits for parameters. If zero no limits; 70 Double_t *fBlim; //[fMaxpar2] Upper limits for parameters; 71 Double_t *fErp; //[fMaxpar] Positive Minos errors if calculated; 72 Double_t *fErn; //[fMaxpar] Negative Minos errors if calculated; 73 Double_t *fWerr; //[fMaxpar] External parameters error (",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:2759,Availability,error,errors,2759,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:2827,Availability,error,errors,2827,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:2901,Availability,error,error,2901,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:3826,Availability,error,error,3826,"rors if calculated; 73 Double_t *fWerr; //[fMaxpar] External parameters error (standard deviation, defined by UP); 74 Double_t *fGlobcc; //[fMaxpar] Global Correlation Coefficients; 75 Double_t *fX; //[fMaxpar] Internal parameters values; 76 Double_t *fXt; //[fMaxpar] Internal parameters values X saved as Xt; 77 Double_t *fDirin; //[fMaxpar] (Internal) step sizes for current step; 78 Double_t *fXs; //[fMaxpar] Internal parameters values saved for fixed params; 79 Double_t *fXts; //[fMaxpar] Internal parameters values X saved as Xt for fixed params; 80 Double_t *fDirins; //[fMaxpar] (Internal) step sizes for current step for fixed params; 81 Double_t *fGrd; //[fMaxpar] First derivatives; 82 Double_t *fG2; //[fMaxpar]; 83 Double_t *fGstep; //[fMaxpar] Step sizes; 84 Double_t *fGin; //[fMaxpar2]; 85 Double_t *fDgrd; //[fMaxpar] Uncertainties; 86 Double_t *fGrds; //[fMaxpar]; 87 Double_t *fG2s; //[fMaxpar]; 88 Double_t *fGsteps; //[fMaxpar]; 89 Double_t *fVhmat; //[fMaxpar5] (Internal) error matrix stored as Half MATrix, since it is symmetric; 90 Double_t *fVthmat; //[fMaxpar5] VHMAT is sometimes saved in VTHMAT, especially in MNMNOT; 91 Double_t *fP; //[fMaxpar1]; 92 Double_t *fPstar; //[fMaxpar2]; 93 Double_t *fPstst; //[fMaxpar]; 94 Double_t *fPbar; //[fMaxpar]; 95 Double_t *fPrho; //[fMaxpar] Minimum point of parabola; 96 Double_t *fWord7; //[fMaxpar]; 97 Double_t *fXpt; //[fMaxcpt] X array of points for contours; 98 Double_t *fYpt; //[fMaxcpt] Y array of points for contours; 99 ; 100 Double_t *fCONTgcc; //[fMaxpar] array used in mncont; 101 Double_t *fCONTw; //[fMaxpar] array used in mncont; 102 Double_t *fFIXPyy; //[fMaxpar] array used in mnfixp; 103 Double_t *fGRADgf; //[fMaxpar] array used in mngrad; 104 Double_t *fHESSyy; //[fMaxpar] array used in mnhess; 105 Double_t *fIMPRdsav; //[fMaxpar] array used in mnimpr; 106 Double_t *fIMPRy; //[fMaxpar] array used in mnimpr; 107 Double_t *fMATUvline; //[fMaxpar] array used in mnmatu; 108 Double_t *fMIGRflnu; //[fMaxpa",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:11325,Availability,toler,toler,11325,"irtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault);; 217 virtual void mnemat(Double_t *emat, Int_t ndim);; 218 virtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc);; 219 virtual void mneval(Double_t anext, Double_t &fnext, Int_t &ierev);; 220 virtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg) ;; 221 virtual void mnexin(Double_t *pint);; 222 virtual void mnfixp(Int_t iint, Int_t &ierr);; 223 virtual void mnfree(Int_t k);; 224 virtual void mngrad();; 225 virtual void mnhelp(TString comd);; 226 virtual void mnhelp(const char *command="""");; 227 virtual void mnhess();; 228 virtual void mnhes1();; 229 virtual void mnimpr();; 230 virtual void mninex(Double_t *pint);; 231 virtual void mninit(Int_t i1, Int_t i2, Int_t i3);; 232 virtual void mnlims();; 233 virtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler);; 234 virtual void mnmatu(Int_t kode);; 235 virtual void mnmigr();; 236 virtual void mnmnos();; 237 virtual void mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi);; 238 virtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg);; 239 virtual void mnpars(TString &crdbuf, Int_t &icondn);; 240 virtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p);; 241 virtual void mnpint(Double_t &pexti, Int_t i, Double_t &pinti);; 242 virtual void mnplot(Double_t *xpt, Double_t *ypt, char *chpt, Int_t nxypt, Int_t npagwd, Int_t npagln);; 243 virtual void mnpout(Int_t iuext, TString &chnam, Double_t &val, Double_t &err, Double_t &xlolim, Double_t &xuplim, Int_t &iuint) const;; 244 virtual void mnprin(Int_t inkode, Double_t fval);; 245 virtual void mnpsdf();; 246 virtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl);; 247 virtual void mnrn15(Double_t &",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:14697,Availability,error,errorDefinition,14697," f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TMethodCall.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TNamed.h; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:16679,Availability,error,errors,16679,"it.cxx:855; TMinuit::fUDouble_t * fUDefinition TMinuit.h:68; TMinuit::mnpfitvirtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefi",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:16894,Availability,error,errors,16894,"on TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2c",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:18130,Availability,error,error,18130,"rtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::operator=TMinuit & operator=(const TMinuit &m); TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::GetStatusInt_t GetStatus() constDefinition TMinuit.h:201; TMinuit::fPDouble_t * fPDefinition TMinuit.h:91; TMinuit::fNblockInt_t fNblockDefinition TMinuit.h:143; TMinuit::fCvrsnTString fCvrsnDefinition TMinuit.h:171; TMinuit::fGlobccDouble_t * fGlobccDefinition TMinuit.h:74; TMinuit::mnclervirtual void mncler()Resets the parameter list to UNDEFINED.Definition TMinuit.cxx:1103; TMinuit::mnplotvirtual void mnplot(Double_t *xpt, Double_t *ypt, char *chpt, Int_t nxypt, Int_t npagwd, Int_t npagln)Plots points in array xypt onto one page with labelled axes.Definition TMinuit.cxx:6068; TMinuit::Migradvirtual Int_t Migrad()invokes the MIGRAD minimizerDefinition TMinuit.cxx:880; TMinuit::fUpDouble_t fUpDefinition TMinuit.h:50; TMinuit::fGRADgfDouble_t * fGRADgfDefinition TMinuit.h:103; TMinuit::fDirinsDouble_t * fD",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:20940,Availability,error,error,20940,"; TMinuit::fApsiDouble_t fApsiDefinition TMinuit.h:54; TMinuit::fBigedmDouble_t fBigedmDefinition TMinuit.h:61; TMinuit::~TMinuit~TMinuit() overrideMinuit default destructor.Definition TMinuit.cxx:497; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::GetPlotvirtual TObject * GetPlot() constDefinition TMinuit.h:200; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::SetGraphicsModevirtual void SetGraphicsMode(Bool_t mode=kTRUE)Definition TMinuit.h:263; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::GetObjectFitTObject * GetObjectFit() constDefinition TMinuit.h:194; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinu",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:21151,Availability,toler,toler,21151,"; TMinuit::fCstatuTString fCstatuDefinition TMinuit.h:167; TMinuit::fNwrmesInt_t fNwrmes[2]Definition TMinuit.h:151; TMinuit::fVlimloDouble_t fVlimloDefinition TMinuit.h:58; TMinuit::GetPlotvirtual TObject * GetPlot() constDefinition TMinuit.h:200; TMinuit::mnrazzvirtual void mnrazz(Double_t ynew, Double_t *pnew, Double_t *y, Int_t &jh, Int_t &jl)Called only by MNSIMP (and MNIMPR) to add a new point.Definition TMinuit.cxx:6568; TMinuit::fChptchar * fChptDefinition TMinuit.h:164; TMinuit::SetGraphicsModevirtual void SetGraphicsMode(Bool_t mode=kTRUE)Definition TMinuit.h:263; TMinuit::fIsysrdInt_t fIsysrdDefinition TMinuit.h:131; TMinuit::fXdircrDouble_t fXdircrDefinition TMinuit.h:65; TMinuit::GetObjectFitTObject * GetObjectFit() constDefinition TMinuit.h:194; TMinuit::mnmnosvirtual void mnmnos()Performs a MINOS error analysis.Definition TMinuit.cxx:5388; TMinuit::fUpdfltDouble_t fUpdfltDefinition TMinuit.h:62; TMinuit::mnlinevirtual void mnline(Double_t *start, Double_t fstart, Double_t *step, Double_t slope, Double_t toler)Perform a line search from position START.Definition TMinuit.cxx:4736; TMinuit::fNpfixInt_t fNpfixDefinition TMinuit.h:37; TMinuit::fMaxextInt_t fMaxextDefinition TMinuit.h:42; TMinuit::fNvarlInt_t * fNvarlDefinition TMinuit.h:126; TMinuit::mncuvevirtual void mncuve()Makes sure that the current point is a local minimum.Definition TMinuit.cxx:2130; TMinuit::fMATUvlineDouble_t * fMATUvlineDefinition TMinuit.h:107; TMinuit::fBlimDouble_t * fBlimDefinition TMinuit.h:70; TMinuit::fVthmatDouble_t * fVthmatDefinition TMinuit.h:90; TMinuit::mnscanvirtual void mnscan()Scans the values of FCN as a function of one parameter.Definition TMinuit.cxx:6708; TMinuit::fCundefTString fCundefDefinition TMinuit.h:170; TMinuit::fMIGRflnuDouble_t * fMIGRflnuDefinition TMinuit.h:108; TMinuit::fNfcnlcInt_t fNfcnlcDefinition TMinuit.h:147; TMinuit::fISWInt_t fISW[7]Definition TMinuit.h:141; TMinuit::fHESSyyDouble_t * fHESSyyDefinition TMinuit.h:104; TMinuit::fGraphicsMode",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:26898,Availability,error,error,26898,"ar5Definition TMinuit.h:44; TMinuit::fCOMDplistDouble_t * fCOMDplistDefinition TMinuit.h:123; TMinuit::fLnolimBool_t fLnolimDefinition TMinuit.h:160; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:27252,Availability,error,errors,27252,"nition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::SetPrintLevelvirtual Int_t SetPrintLevel(I",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:30459,Availability,error,error,30459," mntiny(Double_t epsp1, Double_t &epsbak)To find the machine precision.Definition TMinuit.cxx:7661; TMinuit::mninexvirtual void mninex(Double_t *pint)Transforms from internal coordinates (PINT) to external (U)Definition TMinuit.cxx:4506; TMinuit::fCtitlTString fCtitlDefinition TMinuit.h:168; TMinuit::mnpintvirtual void mnpint(Double_t &pexti, Int_t i, Double_t &pinti)Calculates the internal parameter value PINTI.Definition TMinuit.cxx:6017; TMinuit::fCONTwDouble_t * fCONTwDefinition TMinuit.h:101; TMinuit::fNfcwarInt_t fNfcwar[20]Definition TMinuit.h:152; TMinuit::fMIGRvgDouble_t * fMIGRvgDefinition TMinuit.h:111; TMinuit::mnfixpvirtual void mnfixp(Int_t iint, Int_t &ierr)Removes parameter IINT from the internal parameter list.Definition TMinuit.cxx:3169; TMinuit::fIstkrdInt_t fIstkrd[10]Definition TMinuit.h:137; TMinuit::fIsyswrInt_t fIsyswrDefinition TMinuit.h:132; TMinuit::fG2Double_t * fG2Definition TMinuit.h:82; TMinuit::mnmnotvirtual void mnmnot(Int_t ilax, Int_t ilax2, Double_t &val2pl, Double_t &val2mi)Performs a MINOS error analysis on one parameter.Definition TMinuit.cxx:5463; TMinuit::fNpaglnInt_t fNpaglnDefinition TMinuit.h:135; TMinuit::fMNOTxdevDouble_t * fMNOTxdevDefinition TMinuit.h:113; TMinuit::mncrckvirtual void mncrck(TString crdbuf, Int_t maxcwd, TString &comand, Int_t &lnc, Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t isyswr)Cracks the free-format input.Definition TMinuit.cxx:1677; TMinuit::fMNOTgccDouble_t * fMNOTgccDefinition TMinuit.h:115; TMinuit::DefineParametervirtual Int_t DefineParameter(Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit)Define a parameter.Definition TMinuit.cxx:695; TMinuit::fMaxpar2Int_t fMaxpar2Definition TMinuit.h:46; TMinuit::fFval3Double_t fFval3Definition TMinuit.h:52; TMinuit::fVhmatDouble_t * fVhmatDefinition TMinuit.h:89; TMinuit::fNstkrdInt_t fNstkrdDefinition TMinuit.h:138; TMinuit::mnstatvirtual void mnstat(Double_t &fmin, Double_t &fe",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:15990,Deployability,release,release,15990,"a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t GetNumPars() constreturns the total number of parameters that have been defined as fixed or free.Definition TMinuit.cxx:872; TMinuit::fXtsDouble_t * fXtsDefinition TMinuit.h:79; TMinuit::mnpsdfvirtual void mnpsdf()Calculates the eigenvalues of v to see if positive-def.Definition TMinuit.cxx:6494; TMinuit::GetNumFixedParsvirtual Int_t GetNumFixedPars() constreturns the number of currently fixed parametersDefinition TMinuit.cxx:855; TMinuit::fUDouble_t * fUDefinition TMinuit.h:68; TMinuit::mnpfitvirtual void mnpfit(Double_t *parx2p, Double_t *pary2p, Int_t npar2p, Double_t *coef2p, Double_t &sdev2p)To fit a parabola to npar2p points.Definition TMinuit.cxx:5956; TMinuit::fGrdsDouble_t * fGrdsDefinition TMinuit.h:86; TMinuit::Releasevirtual Int_t Release(Int_t parNo)release a parameterDefinition TMinuit.cxx:894; TMinuit::mnparsvirtual void mnpars(TString &crdbuf, Int_t &icondn)Implements one parameter definition.Definition TMinuit.cxx:5867; TMinuit::fGstepsDouble_t * fGstepsDefinition TMinuit.h:88; TMinuit::mnimprvirtual void mnimpr()Attempts to improve on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefini",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:7043,Integrability,message,messages,7043,"ers; 129 Int_t *fIpfix; //[fMaxpar] List of fixed parameters; 130 Int_t fNu; //; 131 Int_t fIsysrd; //standardInput unit; 132 Int_t fIsyswr; //standard output unit; 133 Int_t fIsyssa; //; 134 Int_t fNpagwd; //Page width; 135 Int_t fNpagln; //Number of lines per page; 136 Int_t fNewpag; //; 137 Int_t fIstkrd[10]; //; 138 Int_t fNstkrd; //; 139 Int_t fIstkwr[10]; //; 140 Int_t fNstkwr; //; 141 Int_t fISW[7]; //Array of switches; 142 Int_t fIdbg[11]; //Array of internal debug switches; 143 Int_t fNblock; //Number of Minuit data blocks; 144 Int_t fIcomnd; //Number of commands; 145 Int_t fNfcn; //Number of calls to FCN; 146 Int_t fNfcnmx; //Maximum number of calls to FCN; 147 Int_t fNfcnlc; //; 148 Int_t fNfcnfr; //; 149 Int_t fItaur; //; 150 Int_t fIstrat; //; 151 Int_t fNwrmes[2]; //; 152 Int_t fNfcwar[20]; //; 153 Int_t fIcirc[2]; //; 154 Int_t fStatus; //Status flag for the last called Minuit function; 155 Int_t fKe1cr; //; 156 Int_t fKe2cr; //; 157 Bool_t fLwarn; //true if warning messages are to be put out (default=true); 158 Bool_t fLrepor; //true if exceptional conditions are put out (default=false); 159 Bool_t fLimset; //true if a parameter is up against limits (for MINOS); 160 Bool_t fLnolim; //true if there are no limits on any parameters (not yet used); 161 Bool_t fLnewmn; //true if the previous process has unexpectedly improved FCN; 162 Bool_t fLphead; //true if a heading should be put out for the next parameter definition; 163 Bool_t fGraphicsMode; //true if graphics mode on (default); 164 char *fChpt; //!Character to be plotted at the X,Y contour positions; 165 TString *fCpnam; //[fMaxpar2] Array of parameters names; 166 TString fCfrom; //; 167 TString fCstatu; //; 168 TString fCtitl; //; 169 TString fCword; //; 170 TString fCundef; //; 171 TString fCvrsn; //; 172 TString fCovmes[4]; //; 173 TString fOrigin[kMAXWARN]; //; 174 TString fWarmes[kMAXWARN]; //; 175 TObject *fObjectFit; //Pointer to object being fitted; 176 TObject *fPlot; //Pointer to TGraph obj",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:14231,Integrability,interface,interface,14231,"rations(Int_t maxiter=500) {fMaxIterations = maxiter;}; 265 virtual void SetObjectFit(TObject *obj) {fObjectFit=obj;}; 266 virtual Int_t SetPrintLevel( Int_t printLevel=0 );; 267 ; 268 ClassDefOverride(TMinuit,1) //The MINUIT minimisation package; 269};; 270 ; 271R__EXTERN TMinuit *gMinuit;; 272 ; 273#endif; 274 ; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TMethodCall.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TNamed.h; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMinuitDefinition TMinuit.h:27; TMinuit::mnderivirtual void mnderi()Calculates the first derivatives of FCN (GRD)Definition TMinuit.cxx:2178; TMinuit::mnvertvirtual void mnvert(Double_t *a, Int_t l, Int_t m, Int_t n, Int_t &ifail)Inverts a symmetric matrix.Definition TMinuit.cxx:7696; TMinuit::GetParametervirtual Int_t GetParameter(Int_t parNo, Double_t &currentValue, Double_t &currentError) constreturn parameter value and errorDefinition TMinuit.cxx:841; TMinuit::fXDouble_t * fXDefinition TMinuit.h:75; TMinuit::fPrhoDouble_t * fPrhoDefinition TMinuit.h:95; TMinuit::FixParametervirtual Int_t FixParameter(Int_t parNo)fix a parameterDefinition TMinuit.cxx:827; TMinuit::mnbinsvirtual void mnbins(Double_t a1, Double_t a2, Int_t naa, Double_t &bl, Double_t &bh, Int_t &nb, Double_t &bwid)Compute reasonable histogram intervals.Definition TMinuit.cxx:997; TMinuit::fMaxcptInt_t fMaxcptDefinition TMinuit.h:45; TMinuit::GetNumParsvirtual Int_t",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:27231,Integrability,rout,routine,27231,"nition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::SetPrintLevelvirtual Int_t SetPrintLevel(I",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:28058,Integrability,rout,routine,28058,"table random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnhelpvirtual void mnhelp(TString comd)HELP routine for MINUIT interactive commands.Definition TMinuit.cxx:3439; TMinuit::SetPrintLevelvirtual Int_t SetPrintLevel(Int_t printLevel=0)set Minuit print level.Definition TMinuit.cxx:952; TMinuit::fMaxparInt_t fMaxparDefinition TMinuit.h:39; TMinuit::mnunptBool_t mnunpt(TString &cfname)Returns .TRUE.Definition TMinuit.cxx:7670; TMinuit::mnhessvirtual void mnhess()Calculates the full second-derivative matrix of FCN.Definition TMinuit.cxx:3993; TMinuit::fAlimDouble_t * fAlimDefinition TMinuit.h:69; TMinuit::fNiofexInt_t * fNiofexDefinition TMinuit.h:127; TMinuit::fIdbgInt_t fIdbg[11]Definition TMinuit.h:142; TMinuit::mnevalvirtual void mneval(Double_t anext, Double_t &fnext, Int_t &ierev)Evaluates the function being analysed by MNCROS.Definition TMinuit.cxx:2620; TMinuit::fEpsmacDouble_t fEpsmacDefinition TMinuit.h:56; TMinuit::fNewpagInt_t fNewpagDefinition TMinuit.h:136; TMinuit::mnsetvirtual void mnset()Interprets the commands that start with SET and SHOW.Definition TMinuit.",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:31792,Integrability,message,messages,31792,"p, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t isyswr)Cracks the free-format input.Definition TMinuit.cxx:1677; TMinuit::fMNOTgccDouble_t * fMNOTgccDefinition TMinuit.h:115; TMinuit::DefineParametervirtual Int_t DefineParameter(Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit)Define a parameter.Definition TMinuit.cxx:695; TMinuit::fMaxpar2Int_t fMaxpar2Definition TMinuit.h:46; TMinuit::fFval3Double_t fFval3Definition TMinuit.h:52; TMinuit::fVhmatDouble_t * fVhmatDefinition TMinuit.h:89; TMinuit::fNstkrdInt_t fNstkrdDefinition TMinuit.h:138; TMinuit::mnstatvirtual void mnstat(Double_t &fmin, Double_t &fedm, Double_t &errdef, Int_t &npari, Int_t &nparx, Int_t &istat)Returns concerning the current status of the minimization.Definition TMinuit.cxx:7638; TMinuit::fNexofiInt_t * fNexofiDefinition TMinuit.h:128; TMinuit::fSEEKxbestDouble_t * fSEEKxbestDefinition TMinuit.h:118; TMinuit::mnwarnvirtual void mnwarn(const char *copt, const char *corg, const char *cmes)Prints Warning messages.Definition TMinuit.cxx:7784; TMinuit::fSEEKxmidDouble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s)",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:5948,Modifiability,variab,variable,5948,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:6031,Modifiability,variab,variable,6031,,MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:27045,Modifiability,portab,portable,27045,"60; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)Interprets a command and takes appropriate action.Definition TMinuit.cxx:2664; TMinuit::fPbarDouble_t * fPbarDefinition TMinuit.h:94; TMinuit::mnh",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:32746,Modifiability,variab,variable,32746,"tual void mnwarn(const char *copt, const char *corg, const char *cmes)Prints Warning messages.Definition TMinuit.cxx:7784; TMinuit::fSEEKxmidDouble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s) to variable status.Definition TMinuit.cxx:3256; TMinuit::mncntrvirtual void mncntr(Int_t ke1, Int_t ke2, Int_t &ierrf)Print function contours in two variables, on line printer.Definition TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:32892,Modifiability,variab,variables,32892,"uble_t * fSEEKxmidDefinition TMinuit.h:117; TMinuit::fErpDouble_t * fErpDefinition TMinuit.h:71; TMinuit::mnprinvirtual void mnprin(Int_t inkode, Double_t fval)Prints the values of the parameters at the time of the call.Definition TMinuit.cxx:6304; TMinuit::fOriginTString fOrigin[kMAXWARN]Definition TMinuit.h:173; TMinuit::mncrosvirtual void mncros(Double_t &aopt, Int_t &iercr)Find point where MNEVAL=AMIN+UP.Definition TMinuit.cxx:1798; TMinuit::fLnewmnBool_t fLnewmnDefinition TMinuit.h:161; TMinuit::GetNumFreeParsvirtual Int_t GetNumFreePars() constreturns the number of currently free parametersDefinition TMinuit.cxx:863; TMinuit::mnhes1virtual void mnhes1()Calculate first derivatives (GRD) and uncertainties (DGRD)Definition TMinuit.cxx:4218; TMinuit::fIcircInt_t fIcirc[2]Definition TMinuit.h:153; TMinuit::mnfreevirtual void mnfree(Int_t k)Restores one or more fixed parameter(s) to variable status.Definition TMinuit.cxx:3256; TMinuit::mncntrvirtual void mncntr(Int_t ke1, Int_t ke2, Int_t &ierrf)Print function contours in two variables, on line printer.Definition TMinuit.cxx:1132; TMinuit::fAminDouble_t fAminDefinition TMinuit.h:49; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TMinuit::fEDMDouble_t fEDMDefinition TMinuit.h:51; TMinuit::fDgrdDouble_t * fDgrdDefinition TMinuit.h:85; TMinuit::mnparmvirtual void mnparm(Int_t k, TString cnamj, Double_t uk, Double_t wk, Double_t a, Double_t b, Int_t &ierflg)Implements one parameter definition.Definition TMinuit.cxx:5665; TMinuit::fMNOTwDouble_t * fMNOTwDefinition TMinuit.h:114; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; bool; double; int; yDouble_t y[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; mTMarker mDe",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:8267,Performance,perform,performed,8267,"f there are no limits on any parameters (not yet used); 161 Bool_t fLnewmn; //true if the previous process has unexpectedly improved FCN; 162 Bool_t fLphead; //true if a heading should be put out for the next parameter definition; 163 Bool_t fGraphicsMode; //true if graphics mode on (default); 164 char *fChpt; //!Character to be plotted at the X,Y contour positions; 165 TString *fCpnam; //[fMaxpar2] Array of parameters names; 166 TString fCfrom; //; 167 TString fCstatu; //; 168 TString fCtitl; //; 169 TString fCword; //; 170 TString fCundef; //; 171 TString fCvrsn; //; 172 TString fCovmes[4]; //; 173 TString fOrigin[kMAXWARN]; //; 174 TString fWarmes[kMAXWARN]; //; 175 TObject *fObjectFit; //Pointer to object being fitted; 176 TObject *fPlot; //Pointer to TGraph object created by mncont; 177 TMethodCall *fMethodCall; //Pointer to MethodCall in case of interpreted function; 178 void (*fFCN)(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); //!; 179 ; 180// methods performed on TMinuit class; 181public:; 182 TMinuit();; 183 TMinuit(Int_t maxpar);; 184 ~TMinuit() override;; 185 virtual void BuildArrays(Int_t maxpar=15);; 186 TObject *Clone(const char *newname="""") const override; //Clone-Method to copy the function-pointer fFCN; 187 virtual Int_t Command(const char *command);; 188 virtual TObject *Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1);; 189 virtual Int_t DefineParameter( Int_t parNo, const char *name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit );; 190 virtual void DeleteArrays();; 191 virtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag);; 192 virtual Int_t FixParameter( Int_t parNo );; 193 TMethodCall *GetMethodCall() const {return fMethodCall;}; 194 TObject *GetObjectFit() const {return fObjectFit;}; 195 Int_t GetMaxIterations() const {return fMaxIterations;}; 196 virtual Int_t GetNumFixedPars() const;; 197 virtual Int_t GetNumFreePars() const;; 198 virtual Int_t GetNu",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMinuit_8h_source.html:17301,Usability,simpl,simplex,17301,"on a good local minimum.Definition TMinuit.cxx:4295; TMinuit::fPstarDouble_t * fPstarDefinition TMinuit.h:92; TMinuit::fObjectFitTObject * fObjectFitDefinition TMinuit.h:175; TMinuit::BuildArraysvirtual void BuildArrays(Int_t maxpar=15)Create internal Minuit arrays for the maxpar parameters.Definition TMinuit.cxx:512; TMinuit::mnwerrvirtual void mnwerr()Calculates the WERR, external parameter errors.Definition TMinuit.cxx:7861; TMinuit::kMAXWARN@ kMAXWARNDefinition TMinuit.h:35; TMinuit::fNfcnfrInt_t fNfcnfrDefinition TMinuit.h:148; TMinuit::mnrsetvirtual void mnrset(Int_t iopt)Resets function value and errors to UNDEFINED.Definition TMinuit.cxx:6661; TMinuit::fIMPRyDouble_t * fIMPRyDefinition TMinuit.h:106; TMinuit::fVlimhiDouble_t fVlimhiDefinition TMinuit.h:59; TMinuit::mneigvirtual void mneig(Double_t *a, Int_t ndima, Int_t n, Int_t mits, Double_t *work, Double_t precis, Int_t &ifault)Compute matrix eigen values.Definition TMinuit.cxx:2305; TMinuit::mnsimpvirtual void mnsimp()Minimization using the simplex method of Nelder and Mead.Definition TMinuit.cxx:7431; TMinuit::fLwarnBool_t fLwarnDefinition TMinuit.h:157; TMinuit::fXptDouble_t * fXptDefinition TMinuit.h:97; TMinuit::fGinDouble_t * fGinDefinition TMinuit.h:84; TMinuit::GetMethodCallTMethodCall * GetMethodCall() constDefinition TMinuit.h:193; TMinuit::fNfcnmxInt_t fNfcnmxDefinition TMinuit.h:146; TMinuit::fItaurInt_t fItaurDefinition TMinuit.h:149; TMinuit::TMinuitTMinuit()Minuit normal constructor.Definition TMinuit.cxx:347; TMinuit::fUndefiDouble_t fUndefiDefinition TMinuit.h:60; TMinuit::fKe2crInt_t fKe2crDefinition TMinuit.h:156; TMinuit::mnaminvirtual void mnamin()Initialize AMIN.Definition TMinuit.cxx:972; TMinuit::operator=TMinuit & operator=(const TMinuit &m); TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::fNuInt_t fNuDefinition TMinuit.h:130; TMinuit::GetStatusInt_t GetStatus() ",MatchSource.WIKI,doc/master/TMinuit_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:6460,Availability,avail,available,6460,"ph. The following example demonstrate this.; 163 ; 164Begin_Macro(source); 165{; 166 auto c3 = new TCanvas(""c3"",""c3"",600, 400);; 167 ; 168 auto mg = new TMultiGraph(""mg"",""mg"");; 169 ; 170 const Int_t size = 10;; 171 ; 172 double px[size];; 173 double py1[size];; 174 double py2[size];; 175 double py3[size];; 176 ; 177 for ( int i = 0; i < size ; ++i ) {; 178 px[i] = i;; 179 py1[i] = size - i;; 180 py2[i] = size - 0.5 * i;; 181 py3[i] = size - 0.6 * i;; 182 }; 183 ; 184 auto gr1 = new TGraph( size, px, py1 );; 185 gr1->SetName(""gr1"");; 186 gr1->SetTitle(""graph 1"");; 187 gr1->SetMarkerStyle(21);; 188 gr1->SetDrawOption(""AP"");; 189 gr1->SetLineColor(2);; 190 gr1->SetLineWidth(4);; 191 gr1->SetFillStyle(0);; 192 ; 193 auto gr2 = new TGraph( size, px, py2 );; 194 gr2->SetName(""gr2"");; 195 gr2->SetTitle(""graph 2"");; 196 gr2->SetMarkerStyle(22);; 197 gr2->SetMarkerColor(2);; 198 gr2->SetDrawOption(""P"");; 199 gr2->SetLineColor(3);; 200 gr2->SetLineWidth(4);; 201 gr2->SetFillStyle(0);; 202 ; 203 auto gr3 = new TGraph( size, px, py3 );; 204 gr3->SetName(""gr3"");; 205 gr3->SetTitle(""graph 3"");; 206 gr3->SetMarkerStyle(23);; 207 gr3->SetLineColor(4);; 208 gr3->SetLineWidth(4);; 209 gr3->SetFillStyle(0);; 210 ; 211 mg->Add( gr1 );; 212 mg->Add( gr2 );; 213 ; 214 gr3->Draw(""ALP"");; 215 mg->Draw(""LP"");; 216 c3->BuildLegend();; 217}; 218End_Macro; 219 ; 220\anchor MG01e; 221#### Automatic coloring; 222 ; 223Automatic coloring according to the current palette is available as shown in the; 224following example:; 225 ; 226Begin_Macro(source); 227../../../tutorials/graphs/multigraphpalettecolor.C; 228End_Macro; 229 ; 230\anchor MG01f; 231#### Reverse axis; 232 ; 233\since **ROOT version 6.19/02**; 234 ; 235When a TMultiGraph is drawn, the X-axis is drawn with increasing values from left to; 236right and the Y-axis from bottom to top. The two options RX and RY allow to change; 237this order. The option RX allows to draw the X-axis with increasing values from; 238right to left and the RY o",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:16210,Availability,error,errors,16210,"_t *, Axis_t xmin, Axis_t xmax); 527{; 528 char *linear = (char*)strstr(fname, ""++"");; 529 if (linear) {; 530 TF1 f1(fname, fname, xmin, xmax);; 531 return Fit(&f1,option,"""",xmin,xmax);; 532 }; 533 TF1 * f1 = (TF1*)gROOT->GetFunction(fname);; 534 if (!f1) { Printf(""Unknown function: %s"",fname); return -1; }; 535 ; 536 return Fit(f1,option,"""",xmin,xmax);; 537}; 538 ; 539 ; 540////////////////////////////////////////////////////////////////////////////////; 541/// Fit this multigraph with function f1.; 542///; 543/// In this function all graphs of the multigraph are fitted simultaneously; 544///; 545/// f1 is an already predefined function created by TF1.; 546/// Predefined functions such as gaus, expo and poln are automatically; 547/// created by ROOT.; 548///; 549/// The list of fit options is given in parameter `option`which may takes the; 550/// following values:; 551///; 552/// - ""W"" Ignore all the point errors; 553/// - ""U"" Use a User specified fitting algorithm (via SetFCN); 554/// - ""Q"" Quiet mode (minimum printing); 555/// - ""V"" Verbose mode (default is between Q and V); 556/// - ""B"" Use this option when you want to fix one or more parameters; 557/// and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; 558/// - ""R"" Use the Range specified in the function range; 559/// - ""N"" Do not store the graphics function, do not draw; 560/// - ""0"" Do not plot the result of the fit. By default the fitted function; 561/// is drawn unless the option""N"" above is specified.; 562/// - ""+"" Add this new fitted function to the list of fitted functions; 563/// (by default, any previous function is deleted); 564/// - ""C"" In case of linear fitting, not calculate the chisquare (saves time); 565/// - ""F"" If fitting a polN, switch to minuit fitter; 566/// - ""ROB"" In case of linear fitting, compute the LTS regression; 567/// coefficients (robust(resistant) regression), using; 568/// the default fraction of good points; 569/// - ""ROB=0.x"" - compute the LTS regression coefficie",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:17150,Availability,robust,robust,17150,"tically; 547/// created by ROOT.; 548///; 549/// The list of fit options is given in parameter `option`which may takes the; 550/// following values:; 551///; 552/// - ""W"" Ignore all the point errors; 553/// - ""U"" Use a User specified fitting algorithm (via SetFCN); 554/// - ""Q"" Quiet mode (minimum printing); 555/// - ""V"" Verbose mode (default is between Q and V); 556/// - ""B"" Use this option when you want to fix one or more parameters; 557/// and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; 558/// - ""R"" Use the Range specified in the function range; 559/// - ""N"" Do not store the graphics function, do not draw; 560/// - ""0"" Do not plot the result of the fit. By default the fitted function; 561/// is drawn unless the option""N"" above is specified.; 562/// - ""+"" Add this new fitted function to the list of fitted functions; 563/// (by default, any previous function is deleted); 564/// - ""C"" In case of linear fitting, not calculate the chisquare (saves time); 565/// - ""F"" If fitting a polN, switch to minuit fitter; 566/// - ""ROB"" In case of linear fitting, compute the LTS regression; 567/// coefficients (robust(resistant) regression), using; 568/// the default fraction of good points; 569/// - ""ROB=0.x"" - compute the LTS regression coefficients, using; 570/// 0.x as a fraction of good points; 571///; 572/// When the fit is drawn (by default), the parameter goption may be used; 573/// to specify a list of graphics options. See TGraph::Paint for a complete; 574/// list of these options.; 575///; 576/// In order to use the Range option, one must first create a function; 577/// with the expression to be fitted. For example, if your graph; 578/// has a defined range between -4 and 4 and you want to fit a gaussian; 579/// only in the interval 1 to 3, you can do:; 580/// ~~~ {.cpp}; 581/// TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; 582/// graph->Fit(""f1"",""R"");; 583/// ~~~; 584///; 585/// ### Who is calling this function ?; 586///; 587/// Note that this function is call",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:18151,Availability,error,errors,18151,"); 565/// - ""F"" If fitting a polN, switch to minuit fitter; 566/// - ""ROB"" In case of linear fitting, compute the LTS regression; 567/// coefficients (robust(resistant) regression), using; 568/// the default fraction of good points; 569/// - ""ROB=0.x"" - compute the LTS regression coefficients, using; 570/// 0.x as a fraction of good points; 571///; 572/// When the fit is drawn (by default), the parameter goption may be used; 573/// to specify a list of graphics options. See TGraph::Paint for a complete; 574/// list of these options.; 575///; 576/// In order to use the Range option, one must first create a function; 577/// with the expression to be fitted. For example, if your graph; 578/// has a defined range between -4 and 4 and you want to fit a gaussian; 579/// only in the interval 1 to 3, you can do:; 580/// ~~~ {.cpp}; 581/// TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; 582/// graph->Fit(""f1"",""R"");; 583/// ~~~; 584///; 585/// ### Who is calling this function ?; 586///; 587/// Note that this function is called when calling TGraphErrors::Fit; 588/// or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; 589/// see the discussion below on the errors calculation.; 590///; 591/// ### Setting initial conditions; 592///; 593/// Parameters must be initialized before invoking the Fit function.; 594/// The setting of the parameter initial values is automatic for the; 595/// predefined functions : poln, expo, gaus, landau. One can however disable; 596/// this automatic computation by specifying the option ""B"".; 597/// You can specify boundary limits for some or all parameters via; 598/// ~~~ {.cpp}; 599/// f1->SetParLimits(p_number, parmin, parmax);; 600/// ~~~; 601/// if `parmin>=parmax`, the parameter is fixed; 602/// Note that you are not forced to fix the limits for all parameters.; 603/// For example, if you fit a function with 6 parameters, you can do:; 604/// ~~~ {.cpp}; 605/// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; 606/// func->SetParLimits(4,-10,-4);; 607/// func->Set",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:20934,Availability,error,error,20934,"30/// ~~~ {.cpp}; 631/// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); 632/// ~~~; 633/// where MyFittingFunction is of type:; 634/// ~~~ {.cpp}; 635/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 636/// ~~~; 637///; 638/// ### Access to the fit result; 639///; 640/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 641/// By default the TFitResultPtr contains only the status of the fit and it converts; 642/// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; 643/// the TFitResult and behaves as a smart pointer to it. For example one can do:; 644/// ~~~ {.cpp}; 645/// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; 646/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 647/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 648/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 649/// r->Print(""V""); // print full information of fit including covariance matrix; 650/// r->Write(); // store the result in a file; 651/// ~~~; 652///; 653/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Doubl",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:21142,Availability,error,error,21142,"30/// ~~~ {.cpp}; 631/// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); 632/// ~~~; 633/// where MyFittingFunction is of type:; 634/// ~~~ {.cpp}; 635/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 636/// ~~~; 637///; 638/// ### Access to the fit result; 639///; 640/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 641/// By default the TFitResultPtr contains only the status of the fit and it converts; 642/// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; 643/// the TFitResult and behaves as a smart pointer to it. For example one can do:; 644/// ~~~ {.cpp}; 645/// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; 646/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 647/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 648/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 649/// r->Print(""V""); // print full information of fit including covariance matrix; 650/// r->Write(); // store the result in a file; 651/// ~~~; 652///; 653/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Doubl",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:22105,Availability,error,error,22105,"53/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Double_t chi2 = myfunc->GetChisquare();; 673/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 674/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 675/// ~~~; 676///; 677/// ### Fit Statistics; 678///; 679/// You can change the statistics box to display the fit parameters with; 680/// the TStyle::SetOptFit(mode) method. This mode has four digits.; 681/// mode = pcev (default = 0111); 682///; 683/// - v = 1; print name/values of parameters; 684/// - e = 1; print errors (if e=1, v must be 1); 685/// - c = 1; print Chisquare/Number of degrees of freedom; 686/// - p = 1; print Probability; 687///; 688/// For example: `gStyle->SetOptFit(1011);`; 689/// prints the fit probability, parameter names/values, and errors.; 690/// You can change the position of the statistics box with these lines; 691/// (where g is a pointer to the TGraph):; 692///; 693/// ~~~ {.cpp}; 694/// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); 695/// Root > st->SetX1NDC(newx1); //new x start position; 696/// Root > st->SetX2NDC(newx2); //new x end position; 697/// ~~~; 698 ; 699TFitResultPtr TMultiGraph::Fit(TF1 *f",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:22450,Availability,error,errors,22450,"graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Double_t chi2 = myfunc->GetChisquare();; 673/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 674/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 675/// ~~~; 676///; 677/// ### Fit Statistics; 678///; 679/// You can change the statistics box to display the fit parameters with; 680/// the TStyle::SetOptFit(mode) method. This mode has four digits.; 681/// mode = pcev (default = 0111); 682///; 683/// - v = 1; print name/values of parameters; 684/// - e = 1; print errors (if e=1, v must be 1); 685/// - c = 1; print Chisquare/Number of degrees of freedom; 686/// - p = 1; print Probability; 687///; 688/// For example: `gStyle->SetOptFit(1011);`; 689/// prints the fit probability, parameter names/values, and errors.; 690/// You can change the position of the statistics box with these lines; 691/// (where g is a pointer to the TGraph):; 692///; 693/// ~~~ {.cpp}; 694/// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); 695/// Root > st->SetX1NDC(newx1); //new x start position; 696/// Root > st->SetX2NDC(newx2); //new x end position; 697/// ~~~; 698 ; 699TFitResultPtr TMultiGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 700{; 701 // internal multigraph fitting methods; 702 Foption_t fitOption;; 703 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph,option,fitOption);; 704 ; 705 // create range and minimizer options with default values; 706 ROOT::Fit::DataRange range(rxmin,rxmax);; 707 ROOT::Math::MinimizerOptions minOption;; 708 return R",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:22696,Availability,error,errors,22696,"graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Double_t chi2 = myfunc->GetChisquare();; 673/// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; 674/// Double_t err0 = myfunc->GetParError(0); //error on first parameter; 675/// ~~~; 676///; 677/// ### Fit Statistics; 678///; 679/// You can change the statistics box to display the fit parameters with; 680/// the TStyle::SetOptFit(mode) method. This mode has four digits.; 681/// mode = pcev (default = 0111); 682///; 683/// - v = 1; print name/values of parameters; 684/// - e = 1; print errors (if e=1, v must be 1); 685/// - c = 1; print Chisquare/Number of degrees of freedom; 686/// - p = 1; print Probability; 687///; 688/// For example: `gStyle->SetOptFit(1011);`; 689/// prints the fit probability, parameter names/values, and errors.; 690/// You can change the position of the statistics box with these lines; 691/// (where g is a pointer to the TGraph):; 692///; 693/// ~~~ {.cpp}; 694/// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); 695/// Root > st->SetX1NDC(newx1); //new x start position; 696/// Root > st->SetX2NDC(newx2); //new x end position; 697/// ~~~; 698 ; 699TFitResultPtr TMultiGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 700{; 701 // internal multigraph fitting methods; 702 Foption_t fitOption;; 703 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph,option,fitOption);; 704 ; 705 // create range and minimizer options with default values; 706 ROOT::Fit::DataRange range(rxmin,rxmax);; 707 ROOT::Math::MinimizerOptions minOption;; 708 return R",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:67857,Availability,error,error,67857,"efinition TMultiGraph.cxx:1107; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPickerStackGuardDefinition TVirtualPad.h:297; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAll",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:32042,Deployability,update,updated,32042,"973 ifail = -1;; 974 if (det <= 0) {; 975 if (fn > 0) a0 = ybar/fn;; 976 else a0 = 0;; 977 a1 = 0;; 978 return;; 979 }; 980 ifail = 0;; 981 a0 = (x2bar*ybar - xbar*xybar) / det;; 982 a1 = (fn*xybar - xbar*ybar) / det;; 983}; 984 ; 985 ; 986////////////////////////////////////////////////////////////////////////////////; 987/// Return 1 if the point (x,y) is inside one of the graphs 0 otherwise.; 988 ; 989Int_t TMultiGraph::IsInside(Double_t x, Double_t y) const; 990{; 991 Int_t in = 0;; 992 if (!fGraphs) return in;; 993 TGraph *g;; 994 TIter next(fGraphs);; 995 while ((g = (TGraph*) next())) {; 996 in = g->IsInside(x, y);; 997 if (in) return in;; 998 }; 999 return in;; 1000}; 1001 ; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Returns a pointer to the histogram used to draw the axis.; 1005/// Takes into account following cases.; 1006///; 1007/// 1. if `fHistogram` exists it is returned; 1008/// 2. if `fHistogram` doesn't exists and `gPad` exists `gPad` is updated. That; 1009/// may trigger the creation of `fHistogram`. If `fHistogram` still does not; 1010/// exit but `hframe` does (if user called `TPad::DrawFrame`) the pointer to; 1011/// `hframe` histogram is returned; 1012/// 3. after the two previous steps, if `fHistogram` still doesn't exist, then; 1013/// it is created.; 1014 ; 1015TH1F *TMultiGraph::GetHistogram(); 1016{; 1017 if (fHistogram) return fHistogram;; 1018 ; 1019 if (gPad) {; 1020 gPad->Modified();; 1021 gPad->Update();; 1022 if (fHistogram) return fHistogram;; 1023 TH1F *h1 = (TH1F*)gPad->FindObject(""hframe"");; 1024 if (h1) return h1;; 1025 }; 1026 ; 1027 Bool_t initialrangeset = kFALSE;; 1028 Double_t rwxmin = 0.,rwxmax = 0.,rwymin = 0.,rwymax = 0.;; 1029 TGraph *g;; 1030 Int_t npt = 100 ;; 1031 TIter next(fGraphs);; 1032 while ((g = (TGraph*) next())) {; 1033 if (g->GetN() <= 0) continue;; 1034 if (initialrangeset) {; 1035 Double_t rx1,ry1,rx2,ry2;; 1036 g->ComputeRange(rx1, ry1, rx2, ry2);;",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:28019,Energy Efficiency,power,power,28019,"ar[i]);; 828}; 829 ; 830 ; 831////////////////////////////////////////////////////////////////////////////////; 832/// Least squares lpolynomial fitting without weights.; 833///; 834/// - m number of parameters; 835/// - a array of parameters; 836/// - first 1st point number to fit (default =0); 837/// - last last point number to fit (default=fNpoints-1); 838///; 839/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 840 ; 841void TMultiGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 842{; 843 const Double_t zero = 0.;; 844 const Double_t one = 1.;; 845 const Int_t idim = 20;; 846 ; 847 Double_t b[400] /* was [20][20] */;; 848 Int_t i, k, l, ifail, bin;; 849 Double_t power;; 850 Double_t da[20], xk, yk;; 851 ; 852 ; 853 //count the total number of points to fit; 854 TGraph *g;; 855 TIter next(fGraphs);; 856 Double_t *px, *py;; 857 Int_t n=0;; 858 Int_t npp;; 859 while ((g = (TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 2",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:28947,Energy Efficiency,power,power,28947,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:29015,Energy Efficiency,power,power,29015,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:29043,Energy Efficiency,power,power,29043,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:29066,Energy Efficiency,power,power,29066,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:29120,Energy Efficiency,power,power,29120,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:29158,Energy Efficiency,power,power,29158,"(TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 878 }; 879 Int_t np = 0;; 880 ; 881 next.Reset();; 882 while ((g = (TGraph*) next())) {; 883 px=g->GetX();; 884 py=g->GetY();; 885 npp=g->GetN();; 886 ; 887 for (k = 0; k <= npp; ++k) {; 888 xk = px[k];; 889 if (xk < xmin || xk > xmax) continue;; 890 np++;; 891 yk = py[k];; 892 power = one;; 893 da[0] += yk;; 894 for (l = 2; l <= m; ++l) {; 895 power *= xk;; 896 b[l-1] += power;; 897 da[l-1] += power*yk;; 898 }; 899 for (l = 2; l <= m; ++l) {; 900 power *= xk;; 901 b[m + l*20 - 21] += power;; 902 }; 903 }; 904 }; 905 b[0] = Double_t(np);; 906 for (i = 3; i <= m; ++i) {; 907 for (k = i; k <= m; ++k) {; 908 b[k - 1 + (i-1)*20 - 21] = b[k + (i-2)*20 - 21];; 909 }; 910 }; 911 H1LeastSquareSeqnd(m, b, idim, ifail, 1, da);; 912 ; 913 if (ifail < 0) {; 914 //a[0] = fY[0];; 915 py=((TGraph *)fGraphs->First())->GetY();; 916 a[0]=py[0];; 917 for (i=1; i<m; ++i) a[i] = 0;; 918 return;; 919 }; 920 for (i=0; i<m; ++i) a[i] = da[i];; 921}; 922 ; 923 ; 924////////////////////////////////////////////////////////////////////////////////; 925/// Least square linear fit without weights.; 926///; 927/// Fit a straight line (a0 + a1*x) to the data in this graph.; 928///; 929/// - ndata: number of points to fit; 930/// - first: first point number to fit; 931/// - last: last point to fit O(ndata should be last-first; 932/// - ifail: return parameter indicating the status of the fit (ifail=0, fit is OK); 933///; 934/// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun; 935 ; 936void TMultiGraph::LeastSquareLinearFit(Int_t ndata, Double_t &a0, Double_t",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:15172,Integrability,interface,interface,15172,"tigraph with its current attributes.; 496///; 497/// Options to draw a graph are described in TGraphPainter.; 498///; 499/// The drawing option for each TGraph may be specified as an optional; 500/// second argument of the Add function. You can use GetGraphDrawOption; 501/// to return this option.; 502///; 503/// If a draw option is specified, it will be used to draw the graph,; 504/// otherwise the graph will be drawn with the option specified in; 505/// TMultiGraph::Draw. Use GetDrawOption to return the option specified; 506/// when drawing the TMultiGraph.; 507 ; 508void TMultiGraph::Draw(Option_t *option); 509{; 510 TString opt = option;; 511 opt.ToLower();; 512 ; 513 if (gPad) {; 514 if (!gPad->IsEditable()) gROOT->MakeDefCanvas();; 515 if (opt.Contains(""a"")) gPad->Clear();; 516 }; 517 AppendPad(option);; 518}; 519 ; 520 ; 521////////////////////////////////////////////////////////////////////////////////; 522/// Fit this graph with function with name fname.; 523///; 524/// interface to TF1::Fit(TF1 *f1...; 525 ; 526TFitResultPtr TMultiGraph::Fit(const char *fname, Option_t *option, Option_t *, Axis_t xmin, Axis_t xmax); 527{; 528 char *linear = (char*)strstr(fname, ""++"");; 529 if (linear) {; 530 TF1 f1(fname, fname, xmin, xmax);; 531 return Fit(&f1,option,"""",xmin,xmax);; 532 }; 533 TF1 * f1 = (TF1*)gROOT->GetFunction(fname);; 534 if (!f1) { Printf(""Unknown function: %s"",fname); return -1; }; 535 ; 536 return Fit(f1,option,"""",xmin,xmax);; 537}; 538 ; 539 ; 540////////////////////////////////////////////////////////////////////////////////; 541/// Fit this multigraph with function f1.; 542///; 543/// In this function all graphs of the multigraph are fitted simultaneously; 544///; 545/// f1 is an already predefined function created by TF1.; 546/// Predefined functions such as gaus, expo and poln are automatically; 547/// created by ROOT.; 548///; 549/// The list of fit options is given in parameter `option`which may takes the; 550/// following values:; 551///; 552",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:27692,Integrability,rout,routine,27692,"TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 809 f1->SetParameter(0,constant);; 810 f1->SetParameter(1,slope);; 811}; 812 ; 813 ; 814////////////////////////////////////////////////////////////////////////////////; 815/// Compute Initial values of parameters for a polynom.; 816 ; 817void TMultiGraph::InitPolynom(Double_t xmin, Double_t xmax); 818{; 819 Double_t fitpar[25];; 820 ; 821 TVirtualFitter *grFitter = TVirtualFitter::GetFitter();; 822 TF1 *f1 = (TF1*)grFitter->GetUserFunc();; 823 Int_t npar = f1->GetNpar();; 824 ; 825 LeastSquareFit(npar, fitpar, xmin, xmax);; 826 ; 827 for (Int_t i=0;i<npar;i++) f1->SetParameter(i, fitpar[i]);; 828}; 829 ; 830 ; 831////////////////////////////////////////////////////////////////////////////////; 832/// Least squares lpolynomial fitting without weights.; 833///; 834/// - m number of parameters; 835/// - a array of parameters; 836/// - first 1st point number to fit (default =0); 837/// - last last point number to fit (default=fNpoints-1); 838///; 839/// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; 840 ; 841void TMultiGraph::LeastSquareFit(Int_t m, Double_t *a, Double_t xmin, Double_t xmax); 842{; 843 const Double_t zero = 0.;; 844 const Double_t one = 1.;; 845 const Int_t idim = 20;; 846 ; 847 Double_t b[400] /* was [20][20] */;; 848 Int_t i, k, l, ifail, bin;; 849 Double_t power;; 850 Double_t da[20], xk, yk;; 851 ; 852 ; 853 //count the total number of points to fit; 854 TGraph *g;; 855 TIter next(fGraphs);; 856 Double_t *px, *py;; 857 Int_t n=0;; 858 Int_t npp;; 859 while ((g = (TGraph*) next())) {; 860 px=g->GetX();; 861 npp=g->GetN();; 862 for (bin=0; bin<npp; bin++) {; 863 xk=px[bin];; 864 if (xk < xmin || xk > xmax) continue;; 865 n++;; 866 }; 867 }; 868 if (m <= 2) {; 869 LeastSquareLinearFit(n, a[0], a[1], ifail, xmin, xmax);; 870 return;; 871 }; 872 if (m > idim || m > n) return;; 873 da[0] = zero;; 874 for (l = 2; l <= m; ++l) {; 875 b[l-1] = zero;; 876 b[m + l*20 - 21] = zero;; 877 da[l-1] = zero;; 8",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:54457,Integrability,rout,routine,54457,"170; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TGraph.h; TH1.h; TH2.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TMultiGraph.h; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TVirtualFitter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Boo",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:54764,Integrability,rout,routine,54764,"nt_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TGraph.h; TH1.h; TH2.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; H1LeastSquareSeqndvoid H1LeastSquareSeqnd(Int_t n, Double_t *a, Int_t idim, Int_t &ifail, Int_t k, Double_t *b)Extracted from CERN Program library routine DSEQN.Definition TH1.cxx:4872; TMultiGraph.h; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; Printfvoid Printf(const char *fmt,...)Formats a string in a circular formatting buffer and prints the string.Definition TString.cxx:2503; TVirtualFitter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; TAttAxis::SetNdivisionsvirtual void SetNdivisions(Int_t n=510, Bool_t optim=kTRUE)Set the number of divisions for this axis.Definition TAttAxis.cxx:233; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::SetBinLabelvirtual void SetBinLabel(Int_t bin, const char *label)Set label for bin.Definition TAxis.cxx:886; TAxis::GetTimeDisplayvirtual Bool_t GetTimeDispl",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:60115,Integrability,rout,routine,60115,")Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::kNoStats@ kNoStatsDon't draw stats box.Definition TH1.h:165; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::FindObjectTObject * FindObject(const char *name) const overrideSearch object named name in the list of functions.Definition TH1.cxx:3857; TH1::GetMaximumvirtual Double_t GetMaximum(Double_t maxval=FLT_MAX) constReturn maximum value smaller than maxval of bins in the range, unless the value has been overridden b...Definition TH1.cxx:8545; TH1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Definition TH1.h:404; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; TH1::Paintvoid Paint(Option_t *option="""") overrideControl routine to paint any kind of histograms.Definition TH1.cxx:6206; TH1::GetMinimumvirtual Double_t GetMinimum(Double_t minval=-FLT_MAX) constReturn minimum value larger than minval of bins in the range, unless the value has been overridden by...Definition TH1.cxx:8635; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TIterDefinition TCollection.h:235; TIter::GetOptionOption_t * GetOption() constDefinition TCollection.h:253; TIter::Resetvoid Reset()Definition TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::GetOptionOption_t * GetOption() const overrideReturns the object option stored in the list.Definition TList.cxx:1140; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TL",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:67863,Integrability,message,message,67863,"efinition TMultiGraph.cxx:1107; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjLink::GetObjectTObject * GetObject() constDefinition TList.h:145; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPickerStackGuardDefinition TVirtualPad.h:297; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAll",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:24001,Modifiability,plugin,plugin,24001,"n_t *goption, Axis_t rxmin, Axis_t rxmax); 700{; 701 // internal multigraph fitting methods; 702 Foption_t fitOption;; 703 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph,option,fitOption);; 704 ; 705 // create range and minimizer options with default values; 706 ROOT::Fit::DataRange range(rxmin,rxmax);; 707 ROOT::Math::MinimizerOptions minOption;; 708 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 709 ; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Display a panel with all histogram fit options.; 714/// See class TFitPanel for example; 715 ; 716void TMultiGraph::FitPanel(); 717{; 718 if (!gPad); 719 gROOT->MakeDefCanvas();; 720 ; 721 if (!gPad) {; 722 Error(""FitPanel"", ""Unable to create a default canvas"");; 723 return;; 724 }; 725 ; 726 // use plugin manager to create instance of TFitEditor; 727 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 728 if (handler && handler->LoadPlugin() != -1) {; 729 if (handler->ExecPlugin(2, gPad, this) == 0); 730 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 731 }; 732 else; 733 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Return the draw option for the TGraph `gr` in this TMultiGraph.; 738/// The return option is the one specified when calling TMultiGraph::Add(gr,option).; 739 ; 740Option_t *TMultiGraph::GetGraphDrawOption(const TGraph *gr) const; 741{; 742 if (!fGraphs || !gr) return """";; 743 TListIter next(fGraphs);; 744 TObject *obj;; 745 while ((obj = next())) {; 746 if (obj == (TObject*)gr) return next.GetOption();; 747 }; 748 return """";; 749}; 750 ; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Compute Initial values of parameters for a gaussian.; 754 ; 755void TMultiGraph::InitGaus(Double_t xmin, Double_t xmax); 756{; ",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:24360,Modifiability,plug-in,plug-in,24360,"n_t *goption, Axis_t rxmin, Axis_t rxmax); 700{; 701 // internal multigraph fitting methods; 702 Foption_t fitOption;; 703 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph,option,fitOption);; 704 ; 705 // create range and minimizer options with default values; 706 ROOT::Fit::DataRange range(rxmin,rxmax);; 707 ROOT::Math::MinimizerOptions minOption;; 708 return ROOT::Fit::FitObject(this, f1 , fitOption , minOption, goption, range);; 709 ; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Display a panel with all histogram fit options.; 714/// See class TFitPanel for example; 715 ; 716void TMultiGraph::FitPanel(); 717{; 718 if (!gPad); 719 gROOT->MakeDefCanvas();; 720 ; 721 if (!gPad) {; 722 Error(""FitPanel"", ""Unable to create a default canvas"");; 723 return;; 724 }; 725 ; 726 // use plugin manager to create instance of TFitEditor; 727 TPluginHandler *handler = gROOT->GetPluginManager()->FindHandler(""TFitEditor"");; 728 if (handler && handler->LoadPlugin() != -1) {; 729 if (handler->ExecPlugin(2, gPad, this) == 0); 730 Error(""FitPanel"", ""Unable to crate the FitPanel"");; 731 }; 732 else; 733 Error(""FitPanel"", ""Unable to find the FitPanel plug-in"");; 734}; 735 ; 736////////////////////////////////////////////////////////////////////////////////; 737/// Return the draw option for the TGraph `gr` in this TMultiGraph.; 738/// The return option is the one specified when calling TMultiGraph::Add(gr,option).; 739 ; 740Option_t *TMultiGraph::GetGraphDrawOption(const TGraph *gr) const; 741{; 742 if (!fGraphs || !gr) return """";; 743 TListIter next(fGraphs);; 744 TObject *obj;; 745 while ((obj = next())) {; 746 if (obj == (TObject*)gr) return next.GetOption();; 747 }; 748 return """";; 749}; 750 ; 751 ; 752////////////////////////////////////////////////////////////////////////////////; 753/// Compute Initial values of parameters for a gaussian.; 754 ; 755void TMultiGraph::InitGaus(Double_t xmin, Double_t xmax); 756{; ",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:68507,Modifiability,plugin,plugin,68507,"ition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::kInvalidObject@ kInvalidObjectif object ctor succeeded but object should not be usedDefinition TObject.h:72; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TPickerStackGuardDefinition TVirtualPad.h:297; TPluginHandlerDefinition TPluginManager.h:103; TPluginHandler::ExecPluginLongptr_t ExecPlugin(int nargs)Definition TPluginManager.h:231; TPluginHandler::LoadPluginInt_t LoadPlugin()Load the plugin library for this handler.Definition TPluginManager.cxx:293; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::IsWhitespaceBool_t IsWhitespace() constDefinition TString.h:415; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFitterAbstract Base Class for Fitting.Definit",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:2533,Performance,perform,performed,2533,"ref MG01); 47 - [Setting drawing options](\ref MG01a); 48 - [Titles setting](\ref MG01b); 49 - [The option \""3D\""](\ref MG01c); 50 - [Legend drawing](\ref MG01d); 51 - [Automatic coloring](\ref MG01e); 52 - [Reverse axis](\ref MG01f); 53- [MultiGraphs' fitting](\ref MG02); 54 - [Fit box position](\ref MG02a); 55- [Axis' limits setting](\ref MG03); 56 ; 57 ; 58\anchor MG00; 59### Introduction; 60 ; 61A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular,; 62when drawn, the X and Y axis ranges are automatically computed such as all the graphs; 63will be visible.; 64 ; 65`TMultiGraph::Add` should be used to add a new graph to the list.; 66 ; 67The TMultiGraph owns the objects in the list.; 68 ; 69The number of graphs in a multigraph can be retrieve with:; 70~~~ {.cpp}; 71mg->GetListOfGraphs()->GetEntries();; 72~~~; 73 ; 74\anchor MG01; 75### MultiGraphs' Drawing; 76 ; 77The drawing options are the same as for TGraph.; 78Like for TGraph, the painting is performed thanks to the TGraphPainter; 79class. All details about the various painting options are given in this class.; 80 ; 81Example:; 82~~~ {.cpp}; 83 TGraph *gr1 = new TGraph(...; 84 TGraphErrors *gr2 = new TGraphErrors(...; 85 TMultiGraph *mg = new TMultiGraph();; 86 mg->Add(gr1,""lp"");; 87 mg->Add(gr2,""cp"");; 88 mg->Draw(""a"");; 89~~~; 90 ; 91\anchor MG01a; 92#### Setting drawing options; 93 ; 94The drawing option for each TGraph may be specified as an optional; 95second argument of the `Add` function.; 96 ; 97If a draw option is specified, it will be used to draw the graph,; 98otherwise the graph will be drawn with the option specified in; 99`TMultiGraph::Draw`; 100 ; 101\anchor MG01b; 102#### Titles setting; 103 ; 104The global title and the axis titles can be modified the following way:; 105 ; 106~~~ {.cpp}; 107 [...]; 108 auto mg = new TMultiGraph;; 109 mg->SetTitle(""title;xaxis title; yaxis title"");; 110 mg->Add(g1);; 111 mg->Add(g2);; 112 mg->Draw(""apl"");; 113~~~; 114 ; 115\ancho",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:20766,Security,access,access,20766,"30/// ~~~ {.cpp}; 631/// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); 632/// ~~~; 633/// where MyFittingFunction is of type:; 634/// ~~~ {.cpp}; 635/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 636/// ~~~; 637///; 638/// ### Access to the fit result; 639///; 640/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 641/// By default the TFitResultPtr contains only the status of the fit and it converts; 642/// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; 643/// the TFitResult and behaves as a smart pointer to it. For example one can do:; 644/// ~~~ {.cpp}; 645/// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; 646/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 647/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 648/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 649/// r->Print(""V""); // print full information of fit including covariance matrix; 650/// r->Write(); // store the result in a file; 651/// ~~~; 652///; 653/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Doubl",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:11112,Testability,log,logic,11112,"tYaxis()->SetTitle(""Coefficients"");; 355 ; 356 // Change the axis limits; 357 gPad->Modified();; 358 mg->GetXaxis()->SetLimits(1.5,7.5);; 359 mg->SetMinimum(0.);; 360 mg->SetMaximum(10.);; 361}; 362End_Macro; 363*/; 364 ; 365 ; 366////////////////////////////////////////////////////////////////////////////////; 367/// TMultiGraph default constructor.; 368 ; 369TMultiGraph::TMultiGraph() {}; 370 ; 371 ; 372////////////////////////////////////////////////////////////////////////////////; 373/// Constructor with name and title.; 374 ; 375TMultiGraph::TMultiGraph(const char *name, const char *title); 376 : TNamed(name,title); 377{; 378}; 379 ; 380////////////////////////////////////////////////////////////////////////////////; 381/// TMultiGraph destructor.; 382 ; 383TMultiGraph::~TMultiGraph(); 384{; 385 if (!fGraphs) return;; 386 TObject *g;; 387 TIter next(fGraphs);; 388 while ((g = next())) {; 389 g->ResetBit(kMustCleanup);; 390 }; 391 fGraphs->Delete();; 392 delete fGraphs;; 393 fGraphs = nullptr;; 394 delete fHistogram;; 395 fHistogram = nullptr;; 396 if (fFunctions) {; 397 fFunctions->SetBit(kInvalidObject);; 398 //special logic to support the case where the same object is; 399 //added multiple times in fFunctions.; 400 //This case happens when the same object is added with different; 401 //drawing modes; 402 TObject *obj;; 403 while ((obj = fFunctions->First())) {; 404 while (fFunctions->Remove(obj)) { }; 405 delete obj;; 406 }; 407 delete fFunctions;; 408 fFunctions = nullptr;; 409 }; 410}; 411 ; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Add a new graph to the list of graphs.; 415/// Note that the graph is now owned by the TMultigraph.; 416/// Deleting the TMultiGraph object will automatically delete the graphs.; 417/// You should not delete the graphs when the TMultigraph is still active.; 418 ; 419void TMultiGraph::Add(TGraph *graph, Option_t *chopt); 420{; 421 if (!fGraphs) fGraphs = new TList();; 422 g",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:71000,Testability,log,logarithm,71000,"irtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::GetListOfPrimitivesvirtual TList * GetListOfPrimitives() const =0; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::Dividevirtual void Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)=0; TVirtualPad::Classstatic TClass * Class(); TVirtualPad::Clearvoid Clear(Option_t *option="""") override=0; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; ROOT::Fit::FitObjectTFitResultPtr FitObject(TH1 *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)fitting function for a TH1 (called from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; graphDefinition graph.py:1; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. histhistsrcTMultiGraph.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/TMultiGraph_8cxx_source.html:71195,Testability,log,logarithm,71195,"irtualFitter.cxx:209; TVirtualFitter::GetUserFuncvirtual TObject * GetUserFunc() constDefinition TVirtualFitter.h:84; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::GetListOfPrimitivesvirtual TList * GetListOfPrimitives() const =0; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; TVirtualPad::Dividevirtual void Divide(Int_t nx=1, Int_t ny=1, Float_t xmargin=0.01, Float_t ymargin=0.01, Int_t color=0)=0; TVirtualPad::Classstatic TClass * Class(); TVirtualPad::Clearvoid Clear(Option_t *option="""") override=0; bool; double; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; h1TH1F * h1Definition legend1.C:5; f1TF1 * f1Definition legend1.C:11; ROOT::Fit::FitObjectTFitResultPtr FitObject(TH1 *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)fitting function for a TH1 (called from TH1::Fit)Definition HFitImpl.cxx:972; ROOT::Fit::FitOptionsMakevoid FitOptionsMake(EFitObjectType type, const char *option, Foption_t &fitOption)Decode list of options into fitOption.Definition HFitImpl.cxx:685; ROOT::Fit::EFitObjectType::kGraph@ kGraph; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; graphDefinition graph.py:1; Foption_tDefinition Foption.h:24; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. histhistsrcTMultiGraph.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMultiGraph_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html
https://root.cern/doc/master/tmva001__RTensor_8C.html:387,Integrability,interface,interface,387,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,doc/master/tmva001__RTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html
https://root.cern/doc/master/tmva001__RTensor_8C.html:496,Integrability,interface,interface,496,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,doc/master/tmva001__RTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html
https://root.cern/doc/master/tmva001__RTensor_8C.html:472,Usability,learn,learning,472,". ROOT: tutorials/tmva/tmva001_RTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva001_RTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; The class serves as an interface in C++ between multi-dimensional data and the algorithm such as in machine learning workflows. The interface is similar to Numpy arrays and provides a subset of the functionality.; ; using namespace TMVA::Experimental;; ; void tmva001_RTensor(); {; // Create RTensor from scratch; RTensor<float> x({2, 2});; cout << x << endl;; ; // Assign some data; x(0, 0) = 1;; x(0, 1) = 2;; x(1, 0) = 3;; x(1, 1) = 4;; ; // Apply transformations; auto x2 = x.Reshape({1, 4}).Squeeze();; cout << x2 << endl;; ; // Slice; auto x3 = x.Reshape({2, 2}).Slice({{0, 2}, {0, 1}});; cout << x3 << endl;; ; // Create tensor as view on data without ownership; float data[] = {5, 6, 7, 8};; RTensor<float> y(data, {2, 2});; cout << y << endl;; ; // Create tensor as view on data with ownership; auto data2 = std::make_shared<std::vector<float>>(4);; float c = 9;; for (auto &v : *data2) {; v = c;; c++;; }; ; RTensor<float> z(data2, {2, 2});; cout << z << endl;; }; c#define c(i)Definition RSha256.hxx:101; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TMVA::Experimental::RTensor::ReshapeRTensor< Value_t, Container_t > Reshape(const Shape_t &shape) constReshape tensor.Definition RTensor.hxx:480; RooFit::SliceRooCmdArg Slice(const RooArgSet &sliceSet)Defi",MatchSource.WIKI,doc/master/tmva001__RTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva001__RTensor_8C.html
https://root.cern/doc/master/tmva002__RDataFrameAsTensor_8C.html:1151,Integrability,interface,interface,1151,". ROOT: tutorials/tmva/tmva002_RDataFrameAsTensor.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva002_RDataFrameAsTensor.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; using namespace TMVA::Experimental;; ; void tmva002_RDataFrameAsTensor(); {; // Creation of an RDataFrame with five entries filled with ascending numbers; ROOT::RDataFrame df(5);; auto df2 = df.Define(""x"", ""1.f*rdfentry_"").Define(""y"", ""-1.f*rdfentry_"");; ; // Convert content of columns to an RTensor object; auto x = AsTensor<float>(df2);; ; std::cout << ""RTensor from an RDataFrame:\n"" << x << ""\n\n"";; ; // The utility also supports reading only a part of the RDataFrame and different; // memory layouts.; auto x2 = AsTensor<float>(df2, {""x""}, MemoryLayout::ColumnMajor);; ; std::cout << ""RTensor from a single column of the RDataFrame:\n"" << x2 << ""\n\n"";; }; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; RTensor from an RDataFrame:; { { 0, -0 } { 1, -1 } { 2, -2 } { 3, -3 } { 4, -4 } }; ; RTensor from a single column of the RDataFrame:; { { 0 } { 1 } { 2 } { 3 } { 4 } }; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva002_RDataFrameAsTensor.C. tutorialstmvatmva002_RDataFrameAsTensor.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva002__RDataFrameAsTensor_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva002__RDataFrameAsTensor_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:269,Integrability,interface,interfaces,269,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:5004,Integrability,interface,interface,5004,"finition Rtypes.h:66; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::Experimental::RReaderA replacement for the TMVA::Reader legacy interface.Definition RReader.hxx:136; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDo",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:5588,Integrability,interface,interface,5588,"ionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::Experimental::RReaderA replacement for the TMVA::Reader legacy interface.Definition RReader.hxx:136; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); outputstatic void output(); ; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Background""; : Add Tree TreeB of type",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:775,Modifiability,variab,variables,775,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:916,Modifiability,variab,variables,916,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:986,Modifiability,variab,variables,986,". ROOT: tutorials/tmva/tmva003_RReader.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva003_RReader.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; using namespace TMVA::Experimental;; ; void train(const std::string &filename); {; // Create factory; auto output = TFile::Open(""TMVARR.root"", ""RECREATE"");; auto factory = new TMVA::Factory(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; /",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:1671,Modifiability,variab,variables,1671,"str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:1738,Modifiability,variab,variables,1738,"*)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:2056,Modifiability,variab,variables,2056,"es = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::c",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:2784,Modifiability,variab,variables,2784,"GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; leg",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:3314,Modifiability,variab,variables,3314,"gle-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""TreeS"", ""Signal"", ""l"");; legend.AddEntry(""TreeB"", ""Background"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetL",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:6129,Modifiability,variab,variablesvoid,6129,"TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::Experimental::RReaderA replacement for the TMVA::Reader legacy interface.Definition RReader.hxx:136; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); outputstatic void output(); ; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; : Dataset[tmva003_BDT] : Class index : 0 name : Signal; : Dataset[tmva003_BDT] : Class index : 1 name : Background; <HEADER> Factory : Booking method: BDT; : ; : Rebuilding Dataset tmva003_BDT; : Building event vectors for type 2 Signal; : Dataset[tmva003_BDT] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": ",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:6143,Modifiability,variab,variables,6143,"TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::Experimental::RReaderA replacement for the TMVA::Reader legacy interface.Definition RReader.hxx:136; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); outputstatic void output(); ; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; <HEADER> DataSetInfo : [tmva003_BDT] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; : Dataset[tmva003_BDT] : Class index : 0 name : Signal; : Dataset[tmva003_BDT] : Class index : 1 name : Background; <HEADER> Factory : Booking method: BDT; : ; : Rebuilding Dataset tmva003_BDT; : Building event vectors for type 2 Signal; : Dataset[tmva003_BDT] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": ",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:8911,Modifiability,variab,variable,8911,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:8942,Modifiability,variab,variable,8942,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:8969,Modifiability,variab,variable,8969,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9000,Modifiability,variab,variable,9000,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9027,Modifiability,variab,variable,9027,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9058,Modifiability,variab,variable,9058,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9085,Modifiability,variab,variable,9085,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9116,Modifiability,variab,variable,9116,"etInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience pl",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9512,Modifiability,variab,variables,9512,": +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:9594,Modifiability,variab,variable,9594,"-----------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, Variable selection : ; : Input : variable 'var1' <---> Output : variable 'var1'; : Input : variable 'var2' <---> Output : variable 'var2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; <HEADER> TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.017312 1.6864 [ -5.8991 4.7639 ]; : var2: 0.0068952 1.5665 [ -5.2454 4.6508 ]; : var3: 0.0094455 1.7427 [ -5.3563 4.6430 ]; : var4: 0.16960 2.1719 [ -6.9675 4.9600 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:10506,Modifiability,variab,variables,10506,"--------------------; : Ranking input variables (method unspecific)...; <HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide G",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:10573,Modifiability,variab,variable,10573,"HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:1505,Performance,load,load,1505,"y(""tmva003"",; output, ""!V:!DrawProgressBar:AnalysisType=Classification"");; ; // Open trees with signal and background events; auto data = TFile::Open(filename.c_str());; auto signal = (TTree *)data->Get(""TreeS"");; auto background = (TTree *)data->Get(""TreeB"");; ; // Add variables and register the trees with the dataloader; auto dataloader = new TMVA::DataLoader(""tmva003_BDT"");; const std::vector<std::string> variables = {""var1"", ""var2"", ""var3"", ""var4""};; for (const auto &var : variables) {; dataloader->AddVariable(var);; }; dataloader->AddSignalTree(signal, 1.0);; dataloader->AddBackgroundTree(background, 1.0);; dataloader->PrepareTrainingAndTestTree("""", """");; ; // Train a TMVA method; factory->BookMethod(dataloader, TMVA::Types::kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TM",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:2942,Performance,perform,performed,2942," inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""TreeS"", ""Signal"", ""l"");; legend.AddEntry(""TreeB"", ""Background"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ k",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:3090,Performance,perform,performs,3090," inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Events}"", 30, -0.5, 0.5}, ""y"");; };; ; auto sig = make_histo(""TreeS"");; auto bkg = make_histo(""TreeB"");; ; // Make plot; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; ; sig->SetLineColor(kRed);; bkg->SetLineColor(kBlue);; sig->SetLineWidth(2);; bkg->SetLineWidth(2);; bkg->Draw(""HIST"");; sig->Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""TreeS"", ""Signal"", ""l"");; legend.AddEntry(""TreeB"", ""Background"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ k",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:11267,Performance,perform,performed,11267,"HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:2238,Safety,predict,prediction,2238,"kBDT, ""BDT"", ""!V:!H:NTrees=300:MaxDepth=2"");; factory->TrainAllMethods();; }; ; void tmva003_RReader(); {; // First, let's train a model with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(tree",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:2333,Safety,predict,prediction,2333,"with TMVA.; const std::string filename = ""http://root.cern/files/tmva_class_example.root"";; train(filename);; ; // Next, we load the model from the TMVA XML file.; RReader model(""tmva003_BDT/weights/tmva003_BDT.weights.xml"");; ; // In case you need a reminder of the names and order of the variables during; // training, you can ask the model for it.; auto variables = model.GetVariableNames();; ; // The model can now be applied in different scenarios:; // 1) Event-by-event inference; // 2) Batch inference on data of multiple events; // 3) Inference as part of an RDataFrame graph; ; // 1) Event-by-event inference; // The event-by-event inference takes the values of the variables as a std::vector<float>.; // Note that the return value is as well a std::vector<float> since the reader; // is also capable to process models with multiple outputs.; auto prediction = model.Compute({0.5, 1.0, -0.2, 1.5});; std::cout << ""Single-event inference: "" << prediction[0] << ""\n\n"";; ; // 2) Batch inference on data of multiple events; // For batch inference, the data needs to be structured as a matrix. For this; // purpose, TMVA makes use of the RTensor class. For convenience, we use RDataFrame; // and the AsTensor utility to make the read-out from the ROOT file.; ROOT::RDataFrame df(""TreeS"", filename);; auto df2 = df.Range(3); // Read only a small subset of the dataset; auto x = AsTensor<float>(df2, variables);; auto y = model.Compute(x);; ; std::cout << ""RTensor input for inference on data of multiple events:\n"" << x << ""\n\n"";; std::cout << ""Prediction performed on multiple events: "" << y << ""\n\n"";; ; // 3) Perform inference as part of an RDataFrame graph; // We write a small lambda function that performs for us the inference on; // a dataframe to omit code duplication.; auto make_histo = [&](const std::string &treename) {; ROOT::RDataFrame df(treename, filename);; auto df2 = df.Define(""y"", Compute<4, float>(model), variables);; return df2.Histo1D({treename.c_str(), "";BDT score;N_{Ev",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:7694,Testability,test,testing,7694," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:7837,Testability,test,testing,7837," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:7885,Testability,test,testing,7885," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:7963,Testability,test,testing,7963," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:8015,Testability,test,testing,8015," TreeS; : Building event vectors for type 2 Background; : Dataset[tmva003_BDT] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [tmva003_BDT] : Number of events in input trees; : ; : ; : Dataset[tmva003_BDT] : Weight renormalisation mode: ""EqualNumEvents"": renormalises all event classes ...; : Dataset[tmva003_BDT] : such that the effective (weighted) number of events in each class is the same ; : Dataset[tmva003_BDT] : (and equals the number of events (entries) given for class=0 ); : Dataset[tmva003_BDT] : ... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ...; : Dataset[tmva003_BDT] : ... (note that N_j is the sum of TRAINING events; : Dataset[tmva003_BDT] : ..... Testing events are not renormalised nor included in the renormalisation factor!); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 3000; : Signal -- testing events : 3000; : Signal -- training and testing events: 6000; : Background -- training events : 3000; : Background -- testing events : 3000; : Background -- training and testing events: 6000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.390 +0.594 +0.819; : var2: +0.390 +1.000 +0.684 +0.724; : var3: +0.594 +0.684 +1.000 +0.848; : var4: +0.819 +0.724 +0.848 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 +0.854 +0.917 +0.965; : var2: +0.854 +1.000 +0.926 +0.934; : var3: +0.917 +0.926 +1.000 +0.972; : var4: +0.965 +0.934 +0.972 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [tmva003_BDT] : ; : ; <HEADER> Factory : Train all methods; <HEADER> Factory : [tmva003_BDT] : Create Transformation ""I"" with events from all classes.; : ; <HEADER> : Transformation, V",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva003__RReader_8C.html:10939,Testability,test,testing,10939,"HEADER> IdTransformation : Ranking result (top variable is best ranked); : -----------------------------; : Rank : Variable : Separation; : -----------------------------; : 1 : var4 : 3.564e-01; : 2 : var3 : 2.899e-01; : 3 : var1 : 2.792e-01; : 4 : var2 : 2.260e-01; : -----------------------------; <HEADER> Factory : Train method: BDT for Classification; : ; <HEADER> BDT : #events: (reweighted) sig: 3000 bkg: 3000; : #events: (unweighted) sig: 3000 bkg: 3000; : Training 300 Decision Trees ... patience please; : Elapsed time for training with 6000 events: 0.538 sec ; <HEADER> BDT : [tmva003_BDT] : Evaluation of BDT on training sample (6000 events); : Elapsed time for evaluation of 6000 events: 0.0709 sec ; : Creating xml weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; : Creating standalone class: tmva003_BDT/weights/tmva003_BDT.class.C; : TMVARR.root:/tmva003_BDT/Method_BDT/BDT; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> BDT : Ranking result (top variable is best ranked); : --------------------------------------; : Rank : Variable : Variable Importance; : --------------------------------------; : 1 : var4 : 3.940e-01; : 2 : var1 : 2.619e-01; : 3 : var2 : 1.849e-01; : 4 : var3 : 1.592e-01; : --------------------------------------; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: tmva003_BDT/weights/tmva003_BDT.weights.xml; Single-event inference: 0.233873; ; RTensor input for inference on data of multiple events:; { { -1.14361, -0.822373, -0.495426, -0.629427 } { 2.14344, -0.0189228, 0.26703, 1.26749 } { -0.443913, 0.486827, 0.139535, 0.611483 } }; ; Prediction performed on multiple events: { 0.173541, -0.0540229, 0.266502 }; ; DateJuly 2019 ; AuthorStefan Wunsch ; Definition in file tmva003_RReader.C. tutorialstmvatmva003_RReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva003__RReader_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva003__RReader_8C.html
https://root.cern/doc/master/tmva004__RStandardScaler_8C.html:1551,Integrability,interface,interface,1551,"at>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TMVA::Experimental::RStandardScalerDefinition RStandardScaler.hxx:16; TMVA::Experimental::RStandardScaler::Fitvoid Fit(const RTensor< T > &x)Definition RStandardScaler.hxx:52; TMVA::Experimental::RStandardScaler::Computestd::vector< T > Com",MatchSource.WIKI,doc/master/tmva004__RStandardScaler_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html
https://root.cern/doc/master/tmva004__RStandardScaler_8C.html:718,Modifiability,variab,variable,718,". ROOT: tutorials/tmva/tmva004_RStandardScaler.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva004_RStandardScaler.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; using namespace TMVA::Experimental;; ; void tmva004_RStandardScaler(); {; // Load data used to fit the parameters; ROOT::RDataFrame df(""TreeS"", ""http://root.cern/files/tmva_class_example.root"");; auto x = AsTensor<float>(df);; ; // Create standard scaler and fit to data; RStandardScaler<float> scaler;; scaler.Fit(x);; ; // Compute transformation; auto y = scaler.Compute(x);; ; // Plot first variable scaled and unscaled; TH1F h1(""h1"", "";x_{4};N_{Events}"", 20, -4, 4);; TH1F h2(""h2"", "";x_{4};N_{Events}"", 20, -4, 4);; for (std::size_t i = 0; i < x.GetShape()[0]; i++) {; h1.Fill(x(i, 3));; h2.Fill(y(i, 3));; }; h1.SetLineWidth(2);; h1.SetLineColor(kRed);; h2.SetLineWidth(2);; h2.SetLineColor(kBlue);; ; gStyle->SetOptStat(0);; auto c = new TCanvas("""", """", 800, 800);; h2.Draw(""HIST"");; h1.Draw(""HIST SAME"");; ; TLegend legend(0.7, 0.7, 0.89, 0.89);; legend.SetBorderSize(0);; legend.AddEntry(""h1"", ""Unscaled"", ""l"");; legend.AddEntry(""h2"", ""Scaled"", ""l"");; legend.Draw();; ; c->DrawClone();; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual",MatchSource.WIKI,doc/master/tmva004__RStandardScaler_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva004__RStandardScaler_8C.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:2887,Integrability,interface,interface,2887,"number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; At least two electrons and two muons: pass=45352 all=299973 -- eff=15.12 % cumulative eff=15.12 %; At least two electrons and two muons: pass=262776 all=1497445 -- eff=17.55 % cumulative eff=17.55 %; >>> Extract the training and testing events for signal from the SMHiggsToZZTo4L.root dataset.; >>> Extract the training and testing events for background from the ZZTo2e2mu.root dataset.; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva100_DataPreparation.py. tutorialstmvatmva100_DataPreparation.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:715,Modifiability,variab,variables,715,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:940,Modifiability,variab,variables,940,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:1319,Modifiability,variab,variables,1319,"e ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString In",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:1657,Modifiability,variab,variables,1657,"wo muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const cha",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:1178,Testability,test,testing,1178,"ataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Re",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:1612,Testability,test,testing,1612,"ilter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color c",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:3197,Testability,test,testing,3197,"number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; At least two electrons and two muons: pass=45352 all=299973 -- eff=15.12 % cumulative eff=15.12 %; At least two electrons and two muons: pass=262776 all=1497445 -- eff=17.55 % cumulative eff=17.55 %; >>> Extract the training and testing events for signal from the SMHiggsToZZTo4L.root dataset.; >>> Extract the training and testing events for background from the ZZTo2e2mu.root dataset.; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva100_DataPreparation.py. tutorialstmvatmva100_DataPreparation.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:3292,Testability,test,testing,3292,"number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; At least two electrons and two muons: pass=45352 all=299973 -- eff=15.12 % cumulative eff=15.12 %; At least two electrons and two muons: pass=262776 all=1497445 -- eff=17.55 % cumulative eff=17.55 %; >>> Extract the training and testing events for signal from the SMHiggsToZZTo4L.root dataset.; >>> Extract the training and testing events for background from the ZZTo2e2mu.root dataset.; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva100_DataPreparation.py. tutorialstmvatmva100_DataPreparation.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva100__DataPreparation_8py.html:344,Usability,learn,learning,344,". ROOT: tutorials/tmva/tmva100_DataPreparation.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva100_DataPreparation.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; This requires filtering the initial complex datasets and writing the data in a flat format.; ; import ROOT; ; ; def filter_events(df):; """"""; Reduce initial dataset to only events which shall be used for training; """"""; return df.Filter(""nElectron>=2 && nMuon>=2"", ""At least two electrons and two muons""); ; ; def define_variables(df):; """"""; Define the variables which shall be used for training; """"""; return df.Define(""Muon_pt_1"", ""Muon_pt[0]"")\; .Define(""Muon_pt_2"", ""Muon_pt[1]"")\; .Define(""Electron_pt_1"", ""Electron_pt[0]"")\; .Define(""Electron_pt_2"", ""Electron_pt[1]""); ; ; variables = [""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""]; ; ; if __name__ == ""__main__"":; for filename, label in [[""SMHiggsToZZTo4L.root"", ""signal""], [""ZZTo2e2mu.root"", ""background""]]:; print("">>> Extract the training and testing events for {} from the {} dataset."".format(; label, filename)); ; # Load dataset, filter the required events and define the training variables; filepath = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"" + filename; df = ROOT.RDataFrame(""Events"", filepath); df = filter_events(df); df = define_variables(df); ; # Book cutflow report; report = df.Report(); ; # Split dataset by event number for training and testing; columns = ROOT.std.vector[""string""](variables); df.Filter(""event % 2 == 0"", ""Select events with even event number for training"")\; .Snapshot(""Events"", ""train_"" + label + "".root"", columns); df.Filter(""event % 2 == 1"", ""Select events with odd event number for training"")\; .Snapshot(""Events"", ""test_"" + label + "".root"", columns); ; # Print cutflow report; report.Print(); formatOpti",MatchSource.WIKI,doc/master/tmva100__DataPreparation_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva100__DataPreparation_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:2065,Integrability,interface,interface,2065,"es. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva101_Training.py. tutorialstmvatmva101_Training.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:833,Modifiability,variab,variables,833,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:1174,Modifiability,variab,variables,1174,"aining.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateAugust 2019 ; ",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:1233,Modifiability,variab,variables,1233,"d Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateAugust 2019 ; AuthorStefan Wunsch ; Definition in file tmva101_Training.p",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:585,Safety,avoid,avoid,585,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:284,Usability,learn,learning,284,". ROOT: tutorials/tmva/tmva101_Training.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1])",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py.html:1114,Usability,learn,learning,1114,".  . Loading...; Searching...; No Matches. Namespaces ; tmva101_Training.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; Using XGBoost, we illustrate how you can convert an externally trained model in a format serializable and readable with the fast tree inference engine offered by TMVA.; ; # XGBoost has to be imported before ROOT to avoid crashes because of clashing; # std::regexp symbols that are exported by cppyy.; # See also: https://github.com/wlav/cppyy/issues/227; from xgboost import XGBClassifier; ; import ROOT; import numpy as np; ; from tmva100_DataPreparation import variables; ; ; def load_data(signal_filename, background_filename):; # Read data from ROOT files; data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); ; # Convert inputs to format readable by machine learning tools; x_sig = np.vstack([data_sig[var] for var in variables]).T; x_bkg = np.vstack([data_bkg[var] for var in variables]).T; x = np.vstack([x_sig, x_bkg]); ; # Create labels; num_sig = x_sig.shape[0]; num_bkg = x_bkg.shape[0]; y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); ; # Compute weights balancing both classes; num_all = num_sig + num_bkg; w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); ; return x, y, w; ; if __name__ == ""__main__"":; # Load data; x, y, w = load_data(""train_signal.root"", ""train_background.root""); ; # Fit xgboost model; bdt = XGBClassifier(max_depth=3, n_estimators=500); bdt.fit(x, y, sample_weight=w); ; # Save model in TMVA format; print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data st",MatchSource.WIKI,doc/master/tmva101__Training_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:2326,Integrability,interface,interface,2326,"erence engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n_estimators=500); 53 bdt.fit(x, y, sample_weight=w); 54 ; 55 # Save model in TMVA format; 56 print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); 57 ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. tutorialstmvatmva101_Training.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:994,Modifiability,variab,variables,994,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:1361,Modifiability,variab,variables,1361,"ing the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n_estimators=500); 53 bdt.fit(x, y, sample_weight=w); 54 ; 55 # Save model in TMVA format; 56 print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); 57 ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:1423,Modifiability,variab,variables,1423," we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n_estimators=500); 53 bdt.fit(x, y, sample_weight=w); 54 ; 55 # Save model in TMVA format; 56 print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); 57 ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41. tutori",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:728,Safety,avoid,avoid,728,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:309,Usability,learn,learning,309,". ROOT: tutorials/tmva/tmva101_Training.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva101_Training.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_tmva; 3## \notebook -nodraw; 4## This tutorial show how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva101__Training_8py_source.html:1298,Usability,learn,learning,1298," how you can train a machine learning model with any package; 5## reading the training data directly from ROOT files. Using XGBoost, we illustrate; 6## how you can convert an externally trained model in a format serializable and readable; 7## with the fast tree inference engine offered by TMVA.; 8##; 9## \macro_code; 10## \macro_output; 11##; 12## \date August 2019; 13## \author Stefan Wunsch; 14 ; 15# XGBoost has to be imported before ROOT to avoid crashes because of clashing; 16# std::regexp symbols that are exported by cppyy.; 17# See also: https://github.com/wlav/cppyy/issues/227; 18from xgboost import XGBClassifier; 19 ; 20import ROOT; 21import numpy as np; 22 ; 23from tmva100_DataPreparation import variables; 24 ; 25 ; 26def load_data(signal_filename, background_filename):; 27 # Read data from ROOT files; 28 data_sig = ROOT.RDataFrame(""Events"", signal_filename).AsNumpy(); 29 data_bkg = ROOT.RDataFrame(""Events"", background_filename).AsNumpy(); 30 ; 31 # Convert inputs to format readable by machine learning tools; 32 x_sig = np.vstack([data_sig[var] for var in variables]).T; 33 x_bkg = np.vstack([data_bkg[var] for var in variables]).T; 34 x = np.vstack([x_sig, x_bkg]); 35 ; 36 # Create labels; 37 num_sig = x_sig.shape[0]; 38 num_bkg = x_bkg.shape[0]; 39 y = np.hstack([np.ones(num_sig), np.zeros(num_bkg)]); 40 ; 41 # Compute weights balancing both classes; 42 num_all = num_sig + num_bkg; 43 w = np.hstack([np.ones(num_sig) * num_all / num_sig, np.ones(num_bkg) * num_all / num_bkg]); 44 ; 45 return x, y, w; 46 ; 47if __name__ == ""__main__"":; 48 # Load data; 49 x, y, w = load_data(""train_signal.root"", ""train_background.root""); 50 ; 51 # Fit xgboost model; 52 bdt = XGBClassifier(max_depth=3, n_estimators=500); 53 bdt.fit(x, y, sample_weight=w); 54 ; 55 # Save model in TMVA format; 56 print(""Training done on "",x.shape[0],""events. Saving model in tmva101.root""); 57 ROOT.TMVA.Experimental.SaveXGBoost(bdt, ""myBDT"", ""tmva101.root"", num_inputs=x.shape[1]); ROOT::RDataFrame",MatchSource.WIKI,doc/master/tmva101__Training_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva101__Training_8py_source.html
https://root.cern/doc/master/tmva102__Testing_8py.html:462,Modifiability,variab,variables,462,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
https://root.cern/doc/master/tmva102__Testing_8py.html:814,Safety,predict,prediction,814,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
https://root.cern/doc/master/tmva102__Testing_8py.html:273,Testability,test,test,273,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
https://root.cern/doc/master/tmva102__Testing_8py.html:385,Usability,learn,learn,385,". ROOT: tutorials/tmva/tmva102_Testing.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; tmva102_Testing.py File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; import ROOT; import pickle; ; from tmva100_DataPreparation import variables; from tmva101_Training import load_data; ; ; # Load data; x, y_true, w = load_data(""test_signal.root"", ""test_background.root""); ; # Load trained model; File = ""tmva101.root""; if (ROOT.gSystem.AccessPathName(File)) :; ROOT.Info(""tmva102_Testing.py"", File+""does not exist""); exit(); ; bdt = ROOT.TMVA.Experimental.RBDT(""myBDT"", File); ; # Make prediction; y_pred = bdt.Compute(x); ; # Compute ROC using sklearn; from sklearn.metrics import roc_curve, auc; false_positive_rate, true_positive_rate, _ = roc_curve(y_true, y_pred, sample_weight=w); score = auc(false_positive_rate, true_positive_rate); ; # Plot ROC; c = ROOT.TCanvas(""roc"", """", 600, 600); g = ROOT.TGraph(len(false_positive_rate), false_positive_rate, true_positive_rate); g.SetTitle(""AUC = {:.2f}"".format(score)); g.SetLineWidth(3); g.SetLineColor(ROOT.kRed); g.Draw(""AC""); g.GetXaxis().SetRangeUser(0, 1); g.GetYaxis().SetRangeUser(0, 1); g.GetXaxis().SetTitle(""False-positive rate""); g.GetYaxis().SetTitle(""True-positive rate""); c.Draw(); lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text con",MatchSource.WIKI,doc/master/tmva102__Testing_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva102__Testing_8py.html
https://root.cern/doc/master/tmva103__Application_8C.html:423,Deployability,pipeline,pipelines,423,". ROOT: tutorials/tmva/tmva103_Application.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. tmva103_Application.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; Supported workflows are event-by-event inference, batch inference and pipelines with RDataFrame.; ; using namespace TMVA::Experimental;; ; void tmva103_Application(); {; const char* model_filename = ""tmva101.root"";; ; if (gSystem->AccessPathName(model_filename)) {; Info(""tmva103_Application.C"", ""%s does not exist"", model_filename);; return;; }; ; // Load BDT model; RBDT bdt(""myBDT"", model_filename);; ; // Apply model on a single input; auto y1 = bdt.Compute({1.0, 2.0, 3.0, 4.0});; ; std::cout << ""Apply model on a single input vector: "" << y1[0] << std::endl;; ; // Apply model on a batch of inputs; float data[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};; RTensor<float> x(data, {2, 4});; auto y2 = bdt.Compute(x);; ; std::cout << ""Apply model on an input tensor: "" << y2 << std::endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign Ge",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
https://root.cern/doc/master/tmva103__Application_8C.html:1832,Integrability,message,messages,1832,"0, 2.0, 3.0, 4.0});; ; std::cout << ""Apply model on a single input vector: "" << y1[0] << std::endl;; ; // Apply model on a batch of inputs; float data[8] = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};; RTensor<float> x(data, {2, 4});; auto y2 = bdt.Compute(x);; ; std::cout << ""Apply model on an input tensor: "" << y2 << std::endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:12",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
https://root.cern/doc/master/tmva103__Application_8C.html:2370,Integrability,interface,interface,2370,"endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva103_Application.C. tutorialstmvatmva103_Application.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
https://root.cern/doc/master/tmva103__Application_8C.html:2747,Security,access,access,2747,"endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva103_Application.C. tutorialstmvatmva103_Application.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
https://root.cern/doc/master/tmva103__Application_8C.html:2781,Security,access,access,2781,"endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva103_Application.C. tutorialstmvatmva103_Application.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/tmva103__Application_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:13840,Availability,error,error,13840,""", nbin, 0.0, 1.0 );; if (Use[""SVM_Poly""]) histSVMP = new TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; ; // PDEFoam also returns per-event error, fill in histogram, and also fill significance; if (Use[""PDEFoam""]) {; histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; }; ; // Book example histogram for probability (the other methods are done similarly); TH1F *probHistFi(0), *rarityHistFi(0);; if (Use[""Fisher""]) {; probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event l",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:14044,Availability,error,error,14044,""", nbin, 0.0, 1.0 );; if (Use[""SVM_Poly""]) histSVMP = new TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; ; // PDEFoam also returns per-event error, fill in histogram, and also fill significance; if (Use[""PDEFoam""]) {; histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; }; ; // Book example histogram for probability (the other methods are done similarly); TH1F *probHistFi(0), *rarityHistFi(0);; if (Use[""Fisher""]) {; probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event l",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:15019,Availability,down,download,15019," nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficiency calculator for cut method; Int_t nSelCutsGA = 0;; Double_t effS = 0.7;; ; std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; var1 = userVar1 + userVar2;; var2 = userVar1 - userVar2;; ; // Return the MVA outputs and fill into histograms; ; if (Use[""CutsGA""]) {; // Cuts is a special case: give the de",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:19359,Availability,error,error,19359,"A( ""FisherG method"" ) );; if (Use[""BoostedFisher""]) histFiB ->Fill( reader->EvaluateMVA( ""BoostedFisher method"" ) );; if (Use[""LD"" ]) histLD ->Fill( reader->EvaluateMVA( ""LD method"" ) );; if (Use[""MLP"" ]) histNn ->Fill( reader->EvaluateMVA( ""MLP method"" ) );; if (Use[""MLPBFGS"" ]) histNnbfgs ->Fill( reader->EvaluateMVA( ""MLPBFGS method"" ) );; if (Use[""MLPBNN"" ]) histNnbnn ->Fill( reader->EvaluateMVA( ""MLPBNN method"" ) );; if (Use[""CFMlpANN"" ]) histNnC ->Fill( reader->EvaluateMVA( ""CFMlpANN method"" ) );; if (Use[""TMlpANN"" ]) histNnT ->Fill( reader->EvaluateMVA( ""TMlpANN method"" ) );; if (Use[""DNN_GPU""]) histDnnGpu->Fill(reader->EvaluateMVA(""DNN_GPU method""));; if (Use[""DNN_CPU""]) histDnnCpu->Fill(reader->EvaluateMVA(""DNN_CPU method""));; if (Use[""BDT"" ]) histBdt ->Fill( reader->EvaluateMVA( ""BDT method"" ) );; if (Use[""BDTG"" ]) histBdtG ->Fill( reader->EvaluateMVA( ""BDTG method"" ) );; if (Use[""BDTB"" ]) histBdtB ->Fill( reader->EvaluateMVA( ""BDTB method"" ) );; if (Use[""BDTD"" ]) histBdtD ->Fill( reader->EvaluateMVA( ""BDTD method"" ) );; if (Use[""BDTF"" ]) histBdtF ->Fill( reader->EvaluateMVA( ""BDTF method"" ) );; if (Use[""RuleFit"" ]) histRf ->Fill( reader->EvaluateMVA( ""RuleFit method"" ) );; if (Use[""SVM_Gauss"" ]) histSVMG ->Fill( reader->EvaluateMVA( ""SVM_Gauss method"" ) );; if (Use[""SVM_Poly"" ]) histSVMP ->Fill( reader->EvaluateMVA( ""SVM_Poly method"" ) );; if (Use[""SVM_Lin"" ]) histSVML ->Fill( reader->EvaluateMVA( ""SVM_Lin method"" ) );; if (Use[""FDA_MT"" ]) histFDAMT ->Fill( reader->EvaluateMVA( ""FDA_MT method"" ) );; if (Use[""FDA_GA"" ]) histFDAGA ->Fill( reader->EvaluateMVA( ""FDA_GA method"" ) );; if (Use[""Category"" ]) histCat ->Fill( reader->EvaluateMVA( ""Category method"" ) );; if (Use[""Plugin"" ]) histPBdt ->Fill( reader->EvaluateMVA( ""P_BDT method"" ) );; ; // Retrieve also per-event error; if (Use[""PDEFoam""]) {; Double_t val = reader->EvaluateMVA( ""PDEFoam method"" );; Double_t err = reader->GetMVAError();; histPDEFoam ->Fill( val );; histPDEFoamErr->Fill( err );; if (err>1.",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:22397,Availability,error,error,22397,"-----------------------"" << std::endl;; }; }; ; // Write histograms; ; TFile *target = new TFile( ""TMVApp.root"",""RECREATE"" );; if (Use[""Likelihood"" ]) histLk ->Write();; if (Use[""LikelihoodD"" ]) histLkD ->Write();; if (Use[""LikelihoodPCA""]) histLkPCA ->Write();; if (Use[""LikelihoodKDE""]) histLkKDE ->Write();; if (Use[""LikelihoodMIX""]) histLkMIX ->Write();; if (Use[""PDERS"" ]) histPD ->Write();; if (Use[""PDERSD"" ]) histPDD ->Write();; if (Use[""PDERSPCA"" ]) histPDPCA ->Write();; if (Use[""KNN"" ]) histKNN ->Write();; if (Use[""HMatrix"" ]) histHm ->Write();; if (Use[""Fisher"" ]) histFi ->Write();; if (Use[""FisherG"" ]) histFiG ->Write();; if (Use[""BoostedFisher""]) histFiB ->Write();; if (Use[""LD"" ]) histLD ->Write();; if (Use[""MLP"" ]) histNn ->Write();; if (Use[""MLPBFGS"" ]) histNnbfgs ->Write();; if (Use[""MLPBNN"" ]) histNnbnn ->Write();; if (Use[""CFMlpANN"" ]) histNnC ->Write();; if (Use[""TMlpANN"" ]) histNnT ->Write();; if (Use[""DNN_GPU""]) histDnnGpu->Write();; if (Use[""DNN_CPU""]) histDnnCpu->Write();; if (Use[""BDT"" ]) histBdt ->Write();; if (Use[""BDTG"" ]) histBdtG ->Write();; if (Use[""BDTB"" ]) histBdtB ->Write();; if (Use[""BDTD"" ]) histBdtD ->Write();; if (Use[""BDTF"" ]) histBdtF ->Write();; if (Use[""RuleFit"" ]) histRf ->Write();; if (Use[""SVM_Gauss"" ]) histSVMG ->Write();; if (Use[""SVM_Poly"" ]) histSVMP ->Write();; if (Use[""SVM_Lin"" ]) histSVML ->Write();; if (Use[""FDA_MT"" ]) histFDAMT ->Write();; if (Use[""FDA_GA"" ]) histFDAGA ->Write();; if (Use[""Category"" ]) histCat ->Write();; if (Use[""Plugin"" ]) histPBdt ->Write();; ; // Write also error and significance histos; if (Use[""PDEFoam""]) { histPDEFoam->Write(); histPDEFoamErr->Write(); histPDEFoamSig->Write(); }; ; // Write also probability hists; if (Use[""Fisher""]) { if (probHistFi != 0) probHistFi->Write(); if (rarityHistFi != 0) rarityHistFi->Write(); }; target->Close();; ; std::cout << ""--- Created root file: \""TMVApp.root\"" containing the MVA output histograms"" << std::endl;; ; delete reader;; ; std::cout << ""==> TMVAClas",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:375,Deployability,integrat,integrated,375,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:375,Integrability,integrat,integrated,375,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:1126,Modifiability,variab,variables,1126,"es. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_KNN.weights.xml; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top)",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:1450,Modifiability,variab,variables,1450,"pplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_KNN.weights.xml; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); <HEADER> ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Booked classifier ""KNN"" of type: ""KNN""; : Booking ""LD method"" of type ""LD"" from dataset/weights/TMVAClassification_LD.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:2211,Modifiability,variab,variables,2211,"/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_KNN.weights.xml; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); <HEADER> ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Booked classifier ""KNN"" of type: ""KNN""; : Booking ""LD method"" of type ""LD"" from dataset/weights/TMVAClassification_LD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_LD.weights.xml; : Booked classifier ""LD"" of type: ""LD""; : Booking ""Likelihood method"" of type ""Likelihood"" from dataset/weights/TMVAClassification_Likelihood.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Likelihood.weights.xml; : Booked classifier ""Likelihood"" of type: ""Likelihood""; : Booking ""LikelihoodPCA method"" of type ""Likelihood"" from dataset/weights/TMVAClassification_LikelihoodPCA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_LikelihoodPCA.weights.xml; : Booked classifier ""LikelihoodPCA"" of type: ""Likelihood""; : Booking ""MLPBNN method"" of type ""MLP"" from dataset/weights/TMVAClassification_MLPBNN.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5601,Modifiability,variab,variables,5601,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5714,Modifiability,variab,variables,5714,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:8582,Modifiability,variab,variables,8582,":string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod; << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; std::cout << it->first << "" "";; }; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2;; Float_t var3, var4;; reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; // Spectator variables declared in the training have to be added to the reader, too; Float_t spec1,spec2;; reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; ; Float_t Category_cat1, Category_cat2, Category_cat3;; if (Use[""Category""]){; // Add artificial spectators for distinguishing categories; reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; }; ; // Book the MVA methods; ; TString dir = ""dataset/weights/"";; TString prefix = ""TMVAClassification"";; ; // Book method(s); for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = TString(it->first) + TString("" method"");; TString weightfile = dir + prefix + TString(""_"") + TString(it->first) + TString("".weights.xml"");; reader->BookMVA( methodName, weightfile );; }; }; ; ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:8633,Modifiability,variab,variable,8633,":string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod; << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; std::cout << it->first << "" "";; }; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2;; Float_t var3, var4;; reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; // Spectator variables declared in the training have to be added to the reader, too; Float_t spec1,spec2;; reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; ; Float_t Category_cat1, Category_cat2, Category_cat3;; if (Use[""Category""]){; // Add artificial spectators for distinguishing categories; reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; }; ; // Book the MVA methods; ; TString dir = ""dataset/weights/"";; TString prefix = ""TMVAClassification"";; ; // Book method(s); for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = TString(it->first) + TString("" method"");; TString weightfile = dir + prefix + TString(""_"") + TString(it->first) + TString("".weights.xml"");; reader->BookMVA( methodName, weightfile );; }; }; ; ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:8968,Modifiability,variab,variables,8968,":string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod; << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; std::cout << it->first << "" "";; }; std::cout << std::endl;; return;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2;; Float_t var3, var4;; reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; // Spectator variables declared in the training have to be added to the reader, too; Float_t spec1,spec2;; reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; ; Float_t Category_cat1, Category_cat2, Category_cat3;; if (Use[""Category""]){; // Add artificial spectators for distinguishing categories; reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; }; ; // Book the MVA methods; ; TString dir = ""dataset/weights/"";; TString prefix = ""TMVAClassification"";; ; // Book method(s); for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = TString(it->first) + TString("" method"");; TString weightfile = dir + prefix + TString(""_"") + TString(it->first) + TString("".weights.xml"");; reader->BookMVA( methodName, weightfile );; }; }; ; ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:15296,Modifiability,variab,variable,15296," nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficiency calculator for cut method; Int_t nSelCutsGA = 0;; Double_t effS = 0.7;; ; std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; var1 = userVar1 + userVar2;; var2 = userVar1 - userVar2;; ; // Return the MVA outputs and fill into histograms; ; if (Use[""CutsGA""]) {; // Cuts is a special case: give the de",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:15371,Modifiability,variab,variables,15371," nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficiency calculator for cut method; Int_t nSelCutsGA = 0;; Double_t effS = 0.7;; ; std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; var1 = userVar1 + userVar2;; var2 = userVar1 - userVar2;; ; // Return the MVA outputs and fill into histograms; ; if (Use[""CutsGA""]) {; // Cuts is a special case: give the de",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:26681,Modifiability,variab,variablesDefinition,26681," MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::GetRarityDouble_t GetRarity(const TString &methodTag, Double_t mvaVal=-9999999)evaluates the MVA's rarityDefinition Reader.cxx:737; TMVA::Reader::FindMVAIMethod * FindMVA(const TString &methodTag)return pointer to method with tag ""methodTag""Definition Reader.cxx:695; TMVA::Reader::GetProbaDouble_t GetProba(const TString &methodTag, Double_t ap_sig=0.5, Double_t mvaVal=-9999999)evaluates probability of MVA for given set of input variablesDefinition Reader.cxx:706; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=k",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:27117,Modifiability,variab,variable,27117,"ag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::GetRarityDouble_t GetRarity(const TString &methodTag, Double_t mvaVal=-9999999)evaluates the MVA's rarityDefinition Reader.cxx:737; TMVA::Reader::FindMVAIMethod * FindMVA(const TString &methodTag)return pointer to method with tag ""methodTag""Definition Reader.cxx:695; TMVA::Reader::GetProbaDouble_t GetProba(const TString &methodTag, Double_t ap_sig=0.5, Double_t mvaVal=-9999999)evaluates probability of MVA for given set of input variablesDefinition Reader.cxx:706; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathName",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:28775,Modifiability,variab,variable,28775,"Variable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAClassificationApplication.C. tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5197,Performance,load,loads,5197,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:25175,Performance,cache,cacheDir,25175,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::MethodBase::GetInputVarconst TString & GetInputVar(Int_t i) constDefinition MethodBase.h:349; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:25290,Performance,cache,cache,25290,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::MethodBase::GetInputVarconst TString & GetInputVar(Int_t i) constDefinition MethodBase.h:349; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:28188,Security,access,access,28188,"Variable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAClassificationApplication.C. tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:28222,Security,access,access,28222,"Variable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAClassificationApplication.C. tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:5283,Testability,test,tested,5283,"nclude ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; using namespace TMVA;; ; void TMVAClassificationApplication( TString myMethodList = """" ); {; ; //---------------------------------------------------------------; // This loads the library; TMVA::Tools::Instance();; ; // Default MVA methods to be trained + tested; std::map<std::string,int> Use;; ; // Cut optimisation; Use[""Cuts""] = 1;; Use[""CutsD""] = 1;; Use[""CutsPCA""] = 0;; Use[""CutsGA""] = 0;; Use[""CutsSA""] = 0;; //; // 1-dimensional likelihood (""naive Bayes estimator""); Use[""Likelihood""] = 1;; Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); Use[""LikelihoodKDE""] = 0;; Use[""LikelihoodMIX""] = 0;; //; // Mutidimensional likelihood and Nearest-Neighbour methods; Use[""PDERS""] = 1;; Use[""PDERSD""] = 0;; Use[""PDERSPCA""] = 0;; Use[""PDEFoam""] = 1;; Use[""PDEFoamBoost""] = 0; // uses generalised MVA method boosting; Use[""KNN""] = 1; // k-nearest neighbour method; //; // Linear Discriminant Analysis; Use[""LD""] = 1; // Linear Discriminant identical to Fisher; Use[""Fisher""] = 0;; Use[""FisherG""] = 0;; Use[""BoostedFisher""] = 0; // uses generalised MVA method boosting; Use[""HMatrix""] = 0;; //; // Function Discriminant analysis; Use[""FDA_GA""] = 1; // minimisation of user-defined function using Genetics Algorithm; Use[""FDA_SA""] = 0;; Use[""FDA_MC""] = 0;; Use[""FDA_MT""] = 0;; Use[""FDA_GAMT""] = 0;; Use[""FDA_MCMT""] = 0;; //; // Neural Networks (all are feed-forward Multilayer Perceptrons); Use[""MLP""] = 0; // Recommended ANN; Use[""MLPBFGS""] = 0; // Recommended ANN with optional training method; Use[""MLPBNN""] = 1; // Recommended ANN with BFGS training method and bayesian regulator; Use[""CFMlpANN""] = 0; // Depreciated ANN from ALEPH; Use[""TMlpANN""] = 0; // ROOT's own ANN; Use[""DNN_CPU""] = 0; // CUDA-accelerated DNN training.; Use[""DNN_GPU""] = 0; // Multi-core accelerated DN",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:14676,Testability,test,test,14676,""", nbin, 0.0, 1.0 );; if (Use[""SVM_Poly""]) histSVMP = new TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; ; // PDEFoam also returns per-event error, fill in histogram, and also fill significance; if (Use[""PDEFoam""]) {; histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; }; ; // Book example histogram for probability (the other methods are done similarly); TH1F *probHistFi(0), *rarityHistFi(0);; if (Use[""Fisher""]) {; probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; }; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TFile *input(0);; TString fname = ""./tmva_class_example.root"";; if (!gSystem->AccessPathName( fname )) {; input = TFile::Open( fname ); // check if file in local directory exists; }; else {; TFile::SetCacheFileDir(""."");; input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event l",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:15975,Testability,test,tests,15975,"EREAD""); // if not: download from ROOT server; }; if (!input) {; std::cout << ""ERROR: could not open data file"" << std::endl;; exit(1);; }; std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; ; // Event loop; ; // Prepare the event tree; // - Here the variable names have to corresponds to your tree; // - You can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; std::cout << ""--- Select signal sample"" << std::endl;; TTree* theTree = (TTree*)input->Get(""TreeS"");; Float_t userVar1, userVar2;; theTree->SetBranchAddress( ""var1"", &userVar1 );; theTree->SetBranchAddress( ""var2"", &userVar2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; // Efficiency calculator for cut method; Int_t nSelCutsGA = 0;; Double_t effS = 0.7;; ; std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; var1 = userVar1 + userVar2;; var2 = userVar1 - userVar2;; ; // Return the MVA outputs and fill into histograms; ; if (Use[""CutsGA""]) {; // Cuts is a special case: give the desired signal efficiency; Bool_t passed = reader->EvaluateMVA( ""CutsGA method"", effS );; if (passed) nSelCutsGA++;; }; ; if (Use[""Likelihood"" ]) histLk ->Fill( reader->EvaluateMVA( ""Likelihood method"" ) );; if (Use[""LikelihoodD"" ]) histLkD ->Fill( reader->EvaluateMVA( ""LikelihoodD method"" ) );; if (Use[""LikelihoodPCA""]) histLkPCA ->Fill( reader->EvaluateMVA( ""LikelihoodPCA method"" ) );; if (Use[""LikelihoodKDE""]) histLkKDE ->Fill( reader->EvaluateMVA( ""LikelihoodKDE method"" ) );; if (Use[""LikelihoodMIX""]) histLkMIX ->Fill( reader->EvaluateMVA( ""Li",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:20140,Testability,test,test,20140,"r->EvaluateMVA( ""FDA_GA method"" ) );; if (Use[""Category"" ]) histCat ->Fill( reader->EvaluateMVA( ""Category method"" ) );; if (Use[""Plugin"" ]) histPBdt ->Fill( reader->EvaluateMVA( ""P_BDT method"" ) );; ; // Retrieve also per-event error; if (Use[""PDEFoam""]) {; Double_t val = reader->EvaluateMVA( ""PDEFoam method"" );; Double_t err = reader->GetMVAError();; histPDEFoam ->Fill( val );; histPDEFoamErr->Fill( err );; if (err>1.e-50) histPDEFoamSig->Fill( val/err );; }; ; // Retrieve probability instead of MVA output; if (Use[""Fisher""]) {; probHistFi ->Fill( reader->GetProba ( ""Fisher method"" ) );; rarityHistFi->Fill( reader->GetRarity( ""Fisher method"" ) );; }; }; ; // Get elapsed time; sw.Stop();; std::cout << ""--- End of event loop: ""; sw.Print();; ; // Get efficiency for cuts classifier; if (Use[""CutsGA""]) std::cout << ""--- Efficiency for CutsGA method: "" << double(nSelCutsGA)/theTree->GetEntries(); << "" (for a required signal efficiency of "" << effS << "")"" << std::endl;; ; if (Use[""CutsGA""]) {; ; // test: retrieve cuts for particular signal efficiency; TMVA::MethodCuts* mcuts = dynamic_cast<TMVA::MethodCuts*>(reader->FindMVA( ""CutsGA method"" ));; ; if (mcuts) {; std::vector<Double_t> cutsMin;; std::vector<Double_t> cutsMax;; mcuts->GetCuts( 0.7, cutsMin, cutsMax );; std::cout << ""--- -------------------------------------------------------------"" << std::endl;; std::cout << ""--- Retrieve cut values for signal efficiency of 0.7 from Reader"" << std::endl;; for (UInt_t ivar=0; ivar<cutsMin.size(); ivar++) {; std::cout << ""... Cut: ""; << cutsMin[ivar]; << "" < \""""; << mcuts->GetInputVar(ivar); << ""\"" <= ""; << cutsMax[ivar] << std::endl;; }; std::cout << ""--- -------------------------------------------------------------"" << std::endl;; }; }; ; // Write histograms; ; TFile *target = new TFile( ""TMVApp.root"",""RECREATE"" );; if (Use[""Likelihood"" ]) histLk ->Write();; if (Use[""LikelihoodD"" ]) histLkD ->Write();; if (Use[""LikelihoodPCA""]) histLkPCA ->Write();; if (Use[""LikelihoodKDE""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C.html:270,Usability,simpl,simple,270,". ROOT: tutorials/tmva/TMVAClassificationApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationApplication. ; ; ==> Start TMVAClassificationApplication; : Booking ""BDT method"" of type ""BDT"" from dataset/weights/TMVAClassification_BDT.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_BDT.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Booked classifier ""BDT"" of type: ""BDT""; : Booking ""Cuts method"" of type ""Cuts"" from dataset/weights/TMVAClassification_Cuts.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_Cuts.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""Cuts"" of type: ""Cuts""; : Booking ""CutsD method"" of type ""Cuts"" from dataset/weights/TMVAClassification_CutsD.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_CutsD.weights.xml; : Read cuts optimised using sample of MC events; : Reading 100 signal efficiency bins for 4 variables; : Booked classifier ""CutsD"" of type: ""Cuts""; : Booking ""FDA_GA method"" of type ""FDA"" from dataset/weights/TMVAClassification_FDA_GA.weights.xml.; : Reading weight file: dataset/weights/TMVAClassification_FDA_GA.weights.xml; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; : Booked classifier ""FDA_GA"" of type: ""FDA""; : Booking ""KNN method"" of type ""KNN"" from dataset/weights/TMVAClassification_KNN.weights.xml.; : Reading weight file: dataset/w",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:10600,Availability,error,error,10600,"w TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; 243 if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; 244 if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; 245 if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; 246 if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; 247 if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; 248 ; 249 // PDEFoam also returns per-event error, fill in histogram, and also fill significance; 250 if (Use[""PDEFoam""]) {; 251 histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; 252 histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; 253 histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; 254 }; 255 ; 256 // Book example histogram for probability (the other methods are done similarly); 257 TH1F *probHistFi(0), *rarityHistFi(0);; 258 if (Use[""Fisher""]) {; 259 probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; 260 rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; 261 }; 262 ; 263 // Prepare input tree (this must be replaced by your data source); 264 // in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:10816,Availability,error,error,10816,"w TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; 243 if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; 244 if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; 245 if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; 246 if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; 247 if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; 248 ; 249 // PDEFoam also returns per-event error, fill in histogram, and also fill significance; 250 if (Use[""PDEFoam""]) {; 251 histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; 252 histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; 253 histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; 254 }; 255 ; 256 // Book example histogram for probability (the other methods are done similarly); 257 TH1F *probHistFi(0), *rarityHistFi(0);; 258 if (Use[""Fisher""]) {; 259 probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; 260 rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; 261 }; 262 ; 263 // Prepare input tree (this must be replaced by your data source); 264 // in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:11879,Availability,down,download,11879," in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:16555,Availability,error,error,16555,"; 336 if (Use[""LD"" ]) histLD ->Fill( reader->EvaluateMVA( ""LD method"" ) );; 337 if (Use[""MLP"" ]) histNn ->Fill( reader->EvaluateMVA( ""MLP method"" ) );; 338 if (Use[""MLPBFGS"" ]) histNnbfgs ->Fill( reader->EvaluateMVA( ""MLPBFGS method"" ) );; 339 if (Use[""MLPBNN"" ]) histNnbnn ->Fill( reader->EvaluateMVA( ""MLPBNN method"" ) );; 340 if (Use[""CFMlpANN"" ]) histNnC ->Fill( reader->EvaluateMVA( ""CFMlpANN method"" ) );; 341 if (Use[""TMlpANN"" ]) histNnT ->Fill( reader->EvaluateMVA( ""TMlpANN method"" ) );; 342 if (Use[""DNN_GPU""]) histDnnGpu->Fill(reader->EvaluateMVA(""DNN_GPU method""));; 343 if (Use[""DNN_CPU""]) histDnnCpu->Fill(reader->EvaluateMVA(""DNN_CPU method""));; 344 if (Use[""BDT"" ]) histBdt ->Fill( reader->EvaluateMVA( ""BDT method"" ) );; 345 if (Use[""BDTG"" ]) histBdtG ->Fill( reader->EvaluateMVA( ""BDTG method"" ) );; 346 if (Use[""BDTB"" ]) histBdtB ->Fill( reader->EvaluateMVA( ""BDTB method"" ) );; 347 if (Use[""BDTD"" ]) histBdtD ->Fill( reader->EvaluateMVA( ""BDTD method"" ) );; 348 if (Use[""BDTF"" ]) histBdtF ->Fill( reader->EvaluateMVA( ""BDTF method"" ) );; 349 if (Use[""RuleFit"" ]) histRf ->Fill( reader->EvaluateMVA( ""RuleFit method"" ) );; 350 if (Use[""SVM_Gauss"" ]) histSVMG ->Fill( reader->EvaluateMVA( ""SVM_Gauss method"" ) );; 351 if (Use[""SVM_Poly"" ]) histSVMP ->Fill( reader->EvaluateMVA( ""SVM_Poly method"" ) );; 352 if (Use[""SVM_Lin"" ]) histSVML ->Fill( reader->EvaluateMVA( ""SVM_Lin method"" ) );; 353 if (Use[""FDA_MT"" ]) histFDAMT ->Fill( reader->EvaluateMVA( ""FDA_MT method"" ) );; 354 if (Use[""FDA_GA"" ]) histFDAGA ->Fill( reader->EvaluateMVA( ""FDA_GA method"" ) );; 355 if (Use[""Category"" ]) histCat ->Fill( reader->EvaluateMVA( ""Category method"" ) );; 356 if (Use[""Plugin"" ]) histPBdt ->Fill( reader->EvaluateMVA( ""P_BDT method"" ) );; 357 ; 358 // Retrieve also per-event error; 359 if (Use[""PDEFoam""]) {; 360 Double_t val = reader->EvaluateMVA( ""PDEFoam method"" );; 361 Double_t err = reader->GetMVAError();; 362 histPDEFoam ->Fill( val );; 363 histPDEFoamErr->Fill( err );; 364 if (err>1.",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:19933,Availability,error,error,19933," new TFile( ""TMVApp.root"",""RECREATE"" );; 408 if (Use[""Likelihood"" ]) histLk ->Write();; 409 if (Use[""LikelihoodD"" ]) histLkD ->Write();; 410 if (Use[""LikelihoodPCA""]) histLkPCA ->Write();; 411 if (Use[""LikelihoodKDE""]) histLkKDE ->Write();; 412 if (Use[""LikelihoodMIX""]) histLkMIX ->Write();; 413 if (Use[""PDERS"" ]) histPD ->Write();; 414 if (Use[""PDERSD"" ]) histPDD ->Write();; 415 if (Use[""PDERSPCA"" ]) histPDPCA ->Write();; 416 if (Use[""KNN"" ]) histKNN ->Write();; 417 if (Use[""HMatrix"" ]) histHm ->Write();; 418 if (Use[""Fisher"" ]) histFi ->Write();; 419 if (Use[""FisherG"" ]) histFiG ->Write();; 420 if (Use[""BoostedFisher""]) histFiB ->Write();; 421 if (Use[""LD"" ]) histLD ->Write();; 422 if (Use[""MLP"" ]) histNn ->Write();; 423 if (Use[""MLPBFGS"" ]) histNnbfgs ->Write();; 424 if (Use[""MLPBNN"" ]) histNnbnn ->Write();; 425 if (Use[""CFMlpANN"" ]) histNnC ->Write();; 426 if (Use[""TMlpANN"" ]) histNnT ->Write();; 427 if (Use[""DNN_GPU""]) histDnnGpu->Write();; 428 if (Use[""DNN_CPU""]) histDnnCpu->Write();; 429 if (Use[""BDT"" ]) histBdt ->Write();; 430 if (Use[""BDTG"" ]) histBdtG ->Write();; 431 if (Use[""BDTB"" ]) histBdtB ->Write();; 432 if (Use[""BDTD"" ]) histBdtD ->Write();; 433 if (Use[""BDTF"" ]) histBdtF ->Write();; 434 if (Use[""RuleFit"" ]) histRf ->Write();; 435 if (Use[""SVM_Gauss"" ]) histSVMG ->Write();; 436 if (Use[""SVM_Poly"" ]) histSVMP ->Write();; 437 if (Use[""SVM_Lin"" ]) histSVML ->Write();; 438 if (Use[""FDA_MT"" ]) histFDAMT ->Write();; 439 if (Use[""FDA_GA"" ]) histFDAGA ->Write();; 440 if (Use[""Category"" ]) histCat ->Write();; 441 if (Use[""Plugin"" ]) histPBdt ->Write();; 442 ; 443 // Write also error and significance histos; 444 if (Use[""PDEFoam""]) { histPDEFoam->Write(); histPDEFoamErr->Write(); histPDEFoamSig->Write(); }; 445 ; 446 // Write also probability hists; 447 if (Use[""Fisher""]) { if (probHistFi != 0) probHistFi->Write(); if (rarityHistFi != 0) rarityHistFi->Write(); }; 448 target->Close();; 449 ; 450 std::cout << ""--- Created root file: \""TMVApp.root\"" containing th",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:429,Deployability,integrat,integrated,429,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:429,Integrability,integrat,integrated,429,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:1620,Modifiability,variab,variables,1620,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:1736,Modifiability,variab,variables,1736,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:4898,Modifiability,variab,variables,4898,""" << regMethod; 121 << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; 122 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 123 std::cout << it->first << "" "";; 124 }; 125 std::cout << std::endl;; 126 return;; 127 }; 128 Use[regMethod] = 1;; 129 }; 130 }; 131 ; 132 // --------------------------------------------------------------------------------------------------; 133 ; 134 // Create the Reader object; 135 ; 136 TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; 137 ; 138 // Create a set of variables and declare them to the reader; 139 // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; 140 Float_t var1, var2;; 141 Float_t var3, var4;; 142 reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; 143 reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; 144 reader->AddVariable( ""var3"", &var3 );; 145 reader->AddVariable( ""var4"", &var4 );; 146 ; 147 // Spectator variables declared in the training have to be added to the reader, too; 148 Float_t spec1,spec2;; 149 reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; 150 reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; 151 ; 152 Float_t Category_cat1, Category_cat2, Category_cat3;; 153 if (Use[""Category""]){; 154 // Add artificial spectators for distinguishing categories; 155 reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; 156 reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; 157 reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; 158 }; 159 ; 160 // Book the MVA methods; 161 ; 162 TString dir = ""dataset/weights/"";; 163 TString prefix = ""TMVAClassification"";; 164 ; 165 // Book method(s); 166 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 167 if (it->second) {; 168 TString methodName = TString(it->first) + TString("" method"");; 169 TString weightfile = dir + prefix + TString(""_"") +",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:4953,Modifiability,variab,variable,4953,""" << regMethod; 121 << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; 122 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 123 std::cout << it->first << "" "";; 124 }; 125 std::cout << std::endl;; 126 return;; 127 }; 128 Use[regMethod] = 1;; 129 }; 130 }; 131 ; 132 // --------------------------------------------------------------------------------------------------; 133 ; 134 // Create the Reader object; 135 ; 136 TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; 137 ; 138 // Create a set of variables and declare them to the reader; 139 // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; 140 Float_t var1, var2;; 141 Float_t var3, var4;; 142 reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; 143 reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; 144 reader->AddVariable( ""var3"", &var3 );; 145 reader->AddVariable( ""var4"", &var4 );; 146 ; 147 // Spectator variables declared in the training have to be added to the reader, too; 148 Float_t spec1,spec2;; 149 reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; 150 reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; 151 ; 152 Float_t Category_cat1, Category_cat2, Category_cat3;; 153 if (Use[""Category""]){; 154 // Add artificial spectators for distinguishing categories; 155 reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; 156 reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; 157 reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; 158 }; 159 ; 160 // Book the MVA methods; 161 ; 162 TString dir = ""dataset/weights/"";; 163 TString prefix = ""TMVAClassification"";; 164 ; 165 // Book method(s); 166 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 167 if (it->second) {; 168 TString methodName = TString(it->first) + TString("" method"");; 169 TString weightfile = dir + prefix + TString(""_"") +",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:5320,Modifiability,variab,variables,5320,""" << regMethod; 121 << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; 122 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 123 std::cout << it->first << "" "";; 124 }; 125 std::cout << std::endl;; 126 return;; 127 }; 128 Use[regMethod] = 1;; 129 }; 130 }; 131 ; 132 // --------------------------------------------------------------------------------------------------; 133 ; 134 // Create the Reader object; 135 ; 136 TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; 137 ; 138 // Create a set of variables and declare them to the reader; 139 // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; 140 Float_t var1, var2;; 141 Float_t var3, var4;; 142 reader->AddVariable( ""myvar1 := var1+var2"", &var1 );; 143 reader->AddVariable( ""myvar2 := var1-var2"", &var2 );; 144 reader->AddVariable( ""var3"", &var3 );; 145 reader->AddVariable( ""var4"", &var4 );; 146 ; 147 // Spectator variables declared in the training have to be added to the reader, too; 148 Float_t spec1,spec2;; 149 reader->AddSpectator( ""spec1 := var1*2"", &spec1 );; 150 reader->AddSpectator( ""spec2 := var1*3"", &spec2 );; 151 ; 152 Float_t Category_cat1, Category_cat2, Category_cat3;; 153 if (Use[""Category""]){; 154 // Add artificial spectators for distinguishing categories; 155 reader->AddSpectator( ""Category_cat1 := var3<=0"", &Category_cat1 );; 156 reader->AddSpectator( ""Category_cat2 := (var3>0)&&(var4<0)"", &Category_cat2 );; 157 reader->AddSpectator( ""Category_cat3 := (var3>0)&&(var4>=0)"", &Category_cat3 );; 158 }; 159 ; 160 // Book the MVA methods; 161 ; 162 TString dir = ""dataset/weights/"";; 163 TString prefix = ""TMVAClassification"";; 164 ; 165 // Book method(s); 166 for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; 167 if (it->second) {; 168 TString methodName = TString(it->first) + TString("" method"");; 169 TString weightfile = dir + prefix + TString(""_"") +",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:12200,Modifiability,variab,variable,12200," in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:12279,Modifiability,variab,variables,12279," in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:24313,Modifiability,variab,variablesDefinition,24313," MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::GetRarityDouble_t GetRarity(const TString &methodTag, Double_t mvaVal=-9999999)evaluates the MVA's rarityDefinition Reader.cxx:737; TMVA::Reader::FindMVAIMethod * FindMVA(const TString &methodTag)return pointer to method with tag ""methodTag""Definition Reader.cxx:695; TMVA::Reader::GetProbaDouble_t GetProba(const TString &methodTag, Double_t ap_sig=0.5, Double_t mvaVal=-9999999)evaluates probability of MVA for given set of input variablesDefinition Reader.cxx:706; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=k",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:24749,Modifiability,variab,variable,24749,"ag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::GetRarityDouble_t GetRarity(const TString &methodTag, Double_t mvaVal=-9999999)evaluates the MVA's rarityDefinition Reader.cxx:737; TMVA::Reader::FindMVAIMethod * FindMVA(const TString &methodTag)return pointer to method with tag ""methodTag""Definition Reader.cxx:695; TMVA::Reader::GetProbaDouble_t GetProba(const TString &methodTag, Double_t ap_sig=0.5, Double_t mvaVal=-9999999)evaluates probability of MVA for given set of input variablesDefinition Reader.cxx:706; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathName",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:26407,Modifiability,variab,variable,26407,"der.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:1171,Performance,load,loads,1171,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:22807,Performance,cache,cacheDir,22807,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::MethodBase::GetInputVarconst TString & GetInputVar(Int_t i) constDefinition MethodBase.h:349; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:22922,Performance,cache,cache,22922,"nst char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; TROOT.h; TStopwatch.h; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::MethodBase::GetInputVarconst TString & GetInputVar(Int_t i) constDefinition MethodBase.h:349; TMVA::MethodCutsMultivariate optimisation of signal efficiency for given background efficiency, applying rectangular ...Definition MethodCuts.h:61; TMVA::MethodCuts::GetCutsDouble_t GetCuts(Double_t effS, std::vector< Double_t > &cutMin, std::vector< Double_t > &cutMax) constretrieve cut values for given signal efficiencyDefinition MethodCuts.cxx:551; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:25820,Security,access,access,25820,"der.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:25854,Security,access,access,25854,"der.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:1266,Testability,test,tested,1266,"h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:11500,Testability,test,test,11500,"w TH1F( ""MVA_SVM_Poly"", ""MVA_SVM_Poly"", nbin, 0.0, 1.0 );; 243 if (Use[""SVM_Lin""]) histSVML = new TH1F( ""MVA_SVM_Lin"", ""MVA_SVM_Lin"", nbin, 0.0, 1.0 );; 244 if (Use[""FDA_MT""]) histFDAMT = new TH1F( ""MVA_FDA_MT"", ""MVA_FDA_MT"", nbin, -2.0, 3.0 );; 245 if (Use[""FDA_GA""]) histFDAGA = new TH1F( ""MVA_FDA_GA"", ""MVA_FDA_GA"", nbin, -2.0, 3.0 );; 246 if (Use[""Category""]) histCat = new TH1F( ""MVA_Category"", ""MVA_Category"", nbin, -2., 2. );; 247 if (Use[""Plugin""]) histPBdt = new TH1F( ""MVA_PBDT"", ""MVA_BDT"", nbin, -0.8, 0.8 );; 248 ; 249 // PDEFoam also returns per-event error, fill in histogram, and also fill significance; 250 if (Use[""PDEFoam""]) {; 251 histPDEFoam = new TH1F( ""MVA_PDEFoam"", ""MVA_PDEFoam"", nbin, 0, 1 );; 252 histPDEFoamErr = new TH1F( ""MVA_PDEFoamErr"", ""MVA_PDEFoam error"", nbin, 0, 1 );; 253 histPDEFoamSig = new TH1F( ""MVA_PDEFoamSig"", ""MVA_PDEFoam significance"", nbin, 0, 10 );; 254 }; 255 ; 256 // Book example histogram for probability (the other methods are done similarly); 257 TH1F *probHistFi(0), *rarityHistFi(0);; 258 if (Use[""Fisher""]) {; 259 probHistFi = new TH1F( ""MVA_Fisher_Proba"", ""MVA_Fisher_Proba"", nbin, 0, 1 );; 260 rarityHistFi = new TH1F( ""MVA_Fisher_Rarity"", ""MVA_Fisher_Rarity"", nbin, 0, 1 );; 261 }; 262 ; 263 // Prepare input tree (this must be replaced by your data source); 264 // in this example, there is a toy tree with signal and one with background events; 265 // we'll later on use only the ""signal"" events for the test in this example.; 266 //; 267 TFile *input(0);; 268 TString fname = ""./tmva_class_example.root"";; 269 if (!gSystem->AccessPathName( fname )) {; 270 input = TFile::Open( fname ); // check if file in local directory exists; 271 }; 272 else {; 273 TFile::SetCacheFileDir(""."");; 274 input = TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 275 }; 276 if (!input) {; 277 std::cout << ""ERROR: could not open data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:12943,Testability,test,tests,12943," data file"" << std::endl;; 278 exit(1);; 279 }; 280 std::cout << ""--- TMVAClassificationApp : Using input file: "" << input->GetName() << std::endl;; 281 ; 282 // Event loop; 283 ; 284 // Prepare the event tree; 285 // - Here the variable names have to corresponds to your tree; 286 // - You can use the same variables as above which is slightly faster,; 287 // but of course you can use different ones and copy the values inside the event loop; 288 //; 289 std::cout << ""--- Select signal sample"" << std::endl;; 290 TTree* theTree = (TTree*)input->Get(""TreeS"");; 291 Float_t userVar1, userVar2;; 292 theTree->SetBranchAddress( ""var1"", &userVar1 );; 293 theTree->SetBranchAddress( ""var2"", &userVar2 );; 294 theTree->SetBranchAddress( ""var3"", &var3 );; 295 theTree->SetBranchAddress( ""var4"", &var4 );; 296 ; 297 // Efficiency calculator for cut method; 298 Int_t nSelCutsGA = 0;; 299 Double_t effS = 0.7;; 300 ; 301 std::vector<Float_t> vecVar(4); // vector for EvaluateMVA tests; 302 ; 303 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 304 TStopwatch sw;; 305 sw.Start();; 306 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 307 ; 308 if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 309 ; 310 theTree->GetEntry(ievt);; 311 ; 312 var1 = userVar1 + userVar2;; 313 var2 = userVar1 - userVar2;; 314 ; 315 // Return the MVA outputs and fill into histograms; 316 ; 317 if (Use[""CutsGA""]) {; 318 // Cuts is a special case: give the desired signal efficiency; 319 Bool_t passed = reader->EvaluateMVA( ""CutsGA method"", effS );; 320 if (passed) nSelCutsGA++;; 321 }; 322 ; 323 if (Use[""Likelihood"" ]) histLk ->Fill( reader->EvaluateMVA( ""Likelihood method"" ) );; 324 if (Use[""LikelihoodD"" ]) histLkD ->Fill( reader->EvaluateMVA( ""LikelihoodD method"" ) );; 325 if (Use[""LikelihoodPCA""]) histLkPCA ->Fill( reader->EvaluateMVA( ""LikelihoodPCA method"" ) );; 326 if (Use[""LikelihoodKDE""]) histLkKDE ->Fill( reader->EvaluateMVA( """,MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:17440,Testability,test,test,17440,"d"" ) );; 356 if (Use[""Plugin"" ]) histPBdt ->Fill( reader->EvaluateMVA( ""P_BDT method"" ) );; 357 ; 358 // Retrieve also per-event error; 359 if (Use[""PDEFoam""]) {; 360 Double_t val = reader->EvaluateMVA( ""PDEFoam method"" );; 361 Double_t err = reader->GetMVAError();; 362 histPDEFoam ->Fill( val );; 363 histPDEFoamErr->Fill( err );; 364 if (err>1.e-50) histPDEFoamSig->Fill( val/err );; 365 }; 366 ; 367 // Retrieve probability instead of MVA output; 368 if (Use[""Fisher""]) {; 369 probHistFi ->Fill( reader->GetProba ( ""Fisher method"" ) );; 370 rarityHistFi->Fill( reader->GetRarity( ""Fisher method"" ) );; 371 }; 372 }; 373 ; 374 // Get elapsed time; 375 sw.Stop();; 376 std::cout << ""--- End of event loop: ""; sw.Print();; 377 ; 378 // Get efficiency for cuts classifier; 379 if (Use[""CutsGA""]) std::cout << ""--- Efficiency for CutsGA method: "" << double(nSelCutsGA)/theTree->GetEntries(); 380 << "" (for a required signal efficiency of "" << effS << "")"" << std::endl;; 381 ; 382 if (Use[""CutsGA""]) {; 383 ; 384 // test: retrieve cuts for particular signal efficiency; 385 TMVA::MethodCuts* mcuts = dynamic_cast<TMVA::MethodCuts*>(reader->FindMVA( ""CutsGA method"" ));; 386 ; 387 if (mcuts) {; 388 std::vector<Double_t> cutsMin;; 389 std::vector<Double_t> cutsMax;; 390 mcuts->GetCuts( 0.7, cutsMin, cutsMax );; 391 std::cout << ""--- -------------------------------------------------------------"" << std::endl;; 392 std::cout << ""--- Retrieve cut values for signal efficiency of 0.7 from Reader"" << std::endl;; 393 for (UInt_t ivar=0; ivar<cutsMin.size(); ivar++) {; 394 std::cout << ""... Cut: ""; 395 << cutsMin[ivar]; 396 << "" < \""""; 397 << mcuts->GetInputVar(ivar); 398 << ""\"" <= ""; 399 << cutsMax[ivar] << std::endl;; 400 }; 401 std::cout << ""--- -------------------------------------------------------------"" << std::endl;; 402 }; 403 }; 404 ; 405 // Write histograms; 406 ; 407 TFile *target = new TFile( ""TMVApp.root"",""RECREATE"" );; 408 if (Use[""Likelihood"" ]) histLk ->Write();; 409 if (Use[""Lik",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:312,Usability,simpl,simple,312,". ROOT: tutorials/tmva/TMVAClassificationApplication.C Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationApplication.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_tmva; 3/// \notebook -nodraw; 4/// This macro provides a simple example on how to use the trained classifiers; 5/// within an analysis module; 6/// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; 7/// - Package : TMVA; 8/// - Executable: TMVAClassificationApplication; 9///; 10/// \macro_output; 11/// \macro_code; 12/// \author Andreas Hoecker; 13 ; 14#include <cstdlib>; 15#include <vector>; 16#include <iostream>; 17#include <map>; 18#include <string>; 19 ; 20#include ""TFile.h""; 21#include ""TTree.h""; 22#include ""TString.h""; 23#include ""TSystem.h""; 24#include ""TROOT.h""; 25#include ""TStopwatch.h""; 26 ; 27#include ""TMVA/Tools.h""; 28#include ""TMVA/Reader.h""; 29#include ""TMVA/MethodCuts.h""; 30 ; 31using namespace TMVA;; 32 ; 33void TMVAClassificationApplication( TString myMethodList = """" ); 34{; 35 ; 36 //---------------------------------------------------------------; 37 // This loads the library; 38 TMVA::Tools::Instance();; 39 ; 40 // Default MVA methods to be trained + tested; 41 std::map<std::string,int> Use;; 42 ; 43 // Cut optimisation; 44 Use[""Cuts""] = 1;; 45 Use[""CutsD""] = 1;; 46 Use[""CutsPCA""] = 0;; 47 Use[""CutsGA""] = 0;; 48 Use[""CutsSA""] = 0;; 49 //; 50 // 1-dimensional likelihood (""naive Bayes estimator""); 51 Use[""Likelihood""] = 1;; 52 Use[""LikelihoodD""] = 0; // the ""D"" extension indicates decorrelated input variables (see option strings); 53 Use[""LikelihoodPCA""] = 1; // the ""PCA"" extension indicates PCA-transformed input variables (see option strings); 54 Use[""LikelihoodKDE""] = 0;; 55 Use[""LikelihoodMIX""] = 0;; 56 //; 57 // Mutidimensional likelihood and Nearest-Neighbour methods; 58 Use[""PDERS""] = 1;; 59 Use[""PDERSD""] = 0;; 60 Use[""PDERSPCA""] = 0;; 61 Use[""PDEFoam""] = 1;; 62 Use[""",MatchSource.WIKI,doc/master/TMVAClassificationApplication_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:409,Deployability,integrat,integrated,409,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:409,Integrability,integrat,integrated,409,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:3285,Modifiability,variab,variables,3285,".070; --- Created root file: ""TMVApp.root"" containing the MVA output histograms; ==> TMVAClassificationApplication is done!; ; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TH1F.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategoryApplication(); {; // ---------------------------------------------------------------; // default MVA methods to be trained + tested; std::map<std::string,int> Use;; //; Use[""LikelihoodCat""] = 1;; Use[""FisherCat""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl; << ""==> Start TMVAClassificationCategoryApplication"" << std::endl;; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and spectators and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] =",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:3351,Modifiability,variab,variable,3351,".070; --- Created root file: ""TMVApp.root"" containing the MVA output histograms; ==> TMVAClassificationApplication is done!; ; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TH1F.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategoryApplication(); {; // ---------------------------------------------------------------; // default MVA methods to be trained + tested; std::map<std::string,int> Use;; //; Use[""LikelihoodCat""] = 1;; Use[""FisherCat""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl; << ""==> Start TMVAClassificationCategoryApplication"" << std::endl;; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and spectators and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] =",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:5135,Modifiability,variab,variable,5135,"ata source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; // if directory data not found try using tutorials dir; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"" )) {; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; std::cout << ""--- TMVAClassificationApp : Accessing "" << fname << ""!"" << std::endl;; TFile *input = TFile::Open(fname);; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; // Event loop; ; // Prepare the tree; // - here the variable names have to corresponds to your tree; // - you can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; TTree* theTree = (TTree*)input->Get(""TreeS"");; std::cout << ""--- Use signal sample for evaluation"" << std::endl;; theTree->SetBranchAddress( ""var1"", &var1 );; theTree->SetBranchAddress( ""var2"", &var2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; theTree->SetBranchAddress( ""eta"", &eta ); // spectator; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; // Return the MVA outputs and fill into histograms; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (!it->second) continue;; TString methodName = it->first + "" method"";; hist[it->first]->Fill( reader->EvaluateMVA( methodName ) );; }; ; }; sw.Stop();; std::cout << ""--- End of event loop: ""; sw.",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:5210,Modifiability,variab,variables,5210,"ata source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; // if directory data not found try using tutorials dir; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"" )) {; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; std::cout << ""--- TMVAClassificationApp : Accessing "" << fname << ""!"" << std::endl;; TFile *input = TFile::Open(fname);; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; // Event loop; ; // Prepare the tree; // - here the variable names have to corresponds to your tree; // - you can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop; //; TTree* theTree = (TTree*)input->Get(""TreeS"");; std::cout << ""--- Use signal sample for evaluation"" << std::endl;; theTree->SetBranchAddress( ""var1"", &var1 );; theTree->SetBranchAddress( ""var2"", &var2 );; theTree->SetBranchAddress( ""var3"", &var3 );; theTree->SetBranchAddress( ""var4"", &var4 );; ; theTree->SetBranchAddress( ""eta"", &eta ); // spectator; ; std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; TStopwatch sw;; sw.Start();; for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; ; if (ievt%1000 == 0) std::cout << ""--- ... Processing event: "" << ievt << std::endl;; ; theTree->GetEntry(ievt);; ; // Return the MVA outputs and fill into histograms; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (!it->second) continue;; TString methodName = it->first + "" method"";; hist[it->first]->Fill( reader->EvaluateMVA( methodName ) );; }; ; }; sw.Stop();; std::cout << ""--- End of event loop: ""; sw.",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:9613,Modifiability,variab,variable,9613,"name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMVA::ReaderThe Reader class serves to use the MVAs in a specific analysis context.Definition Reader.h:64; TMVA::Reader::EvaluateMVADouble_t EvaluateMVA(const std::vector< Float_t > &, const TString &methodTag, Double_t aux=0)Evaluate a std::vector<float> of input data for a given method The parameter aux is obligatory for th...Definition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t get",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:10244,Security,access,access,10244,"finition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategoryApplication.C. tutorialstmvaTMVAClassificationCategoryApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:10278,Security,access,access,10278,"finition Reader.cxx:468; TMVA::Reader::BookMVAIMethod * BookMVA(const TString &methodTag, const TString &weightfile)read method name from weight fileDefinition Reader.cxx:368; TMVA::Reader::AddSpectatorvoid AddSpectator(const TString &expression, Float_t *)Add a float spectator or expression to the reader.Definition Reader.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategoryApplication.C. tutorialstmvaTMVAClassificationCategoryApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:2913,Testability,test,tested,2913,".070; --- Created root file: ""TMVApp.root"" containing the MVA output histograms; ==> TMVAClassificationApplication is done!; ; ; ; #include <cstdlib>; #include <vector>; #include <iostream>; #include <map>; #include <string>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TSystem.h""; #include ""TROOT.h""; #include ""TH1F.h""; #include ""TStopwatch.h""; ; #include ""TMVA/Tools.h""; #include ""TMVA/Reader.h""; #include ""TMVA/MethodCuts.h""; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategoryApplication(); {; // ---------------------------------------------------------------; // default MVA methods to be trained + tested; std::map<std::string,int> Use;; //; Use[""LikelihoodCat""] = 1;; Use[""FisherCat""] = 1;; // ---------------------------------------------------------------; ; std::cout << std::endl; << ""==> Start TMVAClassificationCategoryApplication"" << std::endl;; ; // Create the Reader object; ; TMVA::Reader *reader = new TMVA::Reader( ""!Color:!Silent"" );; ; // Create a set of variables and spectators and declare them to the reader; // - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] =",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:4480,Testability,test,test,4480,"// - the variable names MUST corresponds in name and type to those given in the weight file(s) used; Float_t var1, var2, var3, var4, eta;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );; ; reader->AddSpectator( ""eta"", &eta );; ; // Book the MVA methods; ; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) {; if (it->second) {; TString methodName = it->first + "" method"";; TString weightfile = ""dataset/weights/TMVAClassificationCategory_"" + TString(it->first) + "".weights.xml"";; reader->BookMVA( methodName, weightfile );; }; }; ; // Book output histograms; UInt_t nbin = 100;; std::map<std::string,TH1*> hist;; hist[""LikelihoodCat""] = new TH1F( ""MVA_LikelihoodCat"", ""MVA_LikelihoodCat"", nbin, -1, 0.9999 );; hist[""FisherCat""] = new TH1F( ""MVA_FisherCat"", ""MVA_FisherCat"", nbin, -4, 4 );; ; // Prepare input tree (this must be replaced by your data source); // in this example, there is a toy tree with signal and one with background events; // we'll later on use only the ""signal"" events for the test in this example.; //; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; // if directory data not found try using tutorials dir; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"" )) {; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; std::cout << ""--- TMVAClassificationApp : Accessing "" << fname << ""!"" << std::endl;; TFile *input = TFile::Open(fname);; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; // Event loop; ; // Prepare the tree; // - here the variable names have to corresponds to your tree; // - you can use the same variables as above which is slightly faster,; // but of course you can use different ones and copy the values inside the event loop;",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html:286,Usability,simpl,simple,286,". ROOT: tutorials/tmva/TMVAClassificationCategoryApplication.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategoryApplication.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Executable: TMVAClassificationCategoryApplication. ; ; ==> Start TMVAClassificationCategoryApplication; : Booking ""FisherCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> DataSetInfo : [Default] : Added class ""Signal""; <HEADER> DataSetInfo : [Default] : Added class ""Background""; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Booked classifier ""FisherCat"" of type: ""Category""; : Booking ""LikelihoodCat method"" of type ""Category"" from dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml.; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; : Booked classifier ""LikelihoodCat"" of type: ""Category""; --- TMVAClassificationApp : Accessing /home/sftnight/build/workspace/root",MatchSource.WIKI,doc/master/TMVAClassificationCategoryApplication_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategoryApplication_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:374,Deployability,integrat,integrated,374,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:11847,Energy Efficiency,power,power,11847,0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00519 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> Factory : Traini,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:12157,Energy Efficiency,power,power,12157,Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00519 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> Factory : Training finished; : ; <HEADER> Factory : Train method: LikelihoodCat for Classification; : ; : Train all sub-classifiers for Classification ...; : Rebuilding Dataset Category_Likelihood_1_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeS; :,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:20813,Energy Efficiency,power,power,20813,Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataS,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:374,Integrability,integrat,integrated,374,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:619,Integrability,depend,dependent,619,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:589,Modifiability,variab,variables,589,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:11696,Modifiability,variab,variables,11696,021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training ,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:11759,Modifiability,variab,variable,11759,ound):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00519 sec ; : Creating xml weight,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:12069,Modifiability,variab,variable,12069,y : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : var1: +0.107; : var2: +0.148; : var3: +0.251; : var4: +0.372; : (offset): -0.751; : -----------------------; : Elapsed time for training with 4871 events: 0.0015 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00213 sec ; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Fisher_1 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.205e-01; : 2 : var3 : 1.054e-01; : 3 : var2 : 4.114e-02; : 4 : var1 : 1.987e-02; : -------------------------------; <HEADER> Category_Fisher_2 : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 2.153e-01; : 2 : var3 : 1.105e-01; : 3 : var2 : 4.289e-02; : 4 : var1 : 1.986e-02; : -------------------------------; : Elapsed time for training with 10000 events: 0.0412 sec ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00549 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00519 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; <HEADER> Factory : Training finished; : ; <HEADER> Factory : Train method: LikelihoodCat for Classification; : ; : Train all sub-classifiers for Classification ...; : Rebuilding Dataset Category_Likelihood_1_dsi; : B,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:19377,Modifiability,variab,variables,19377,; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : ; : ; : Train method: Category_Likelihood_2 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 4871 events: 0.0274 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00441 sec ; : TMVACC.root:/dataset/Method_Category/LikelihoodCat/Method_Likelihood/Category_Likelihood_2; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Likelihood_1 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.108e-01; : 2 : var3 : 2.434e-02; : 3 : var1 : 1.781e-02; : 4 : var2 : 1.380e-02; : -----------------------------------; <HEADER> Category_Likelihood_2 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Cate,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:19444,Modifiability,variab,variable,19444, Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : ; : ; : Train method: Category_Likelihood_2 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 4871 events: 0.0274 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00441 sec ; : TMVACC.root:/dataset/Method_Category/LikelihoodCat/Method_Likelihood/Category_Likelihood_2; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Likelihood_1 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.108e-01; : 2 : var3 : 2.434e-02; : 3 : var1 : 1.781e-02; : 4 : var2 : 1.380e-02; : -----------------------------------; <HEADER> Category_Likelihood_2 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 se,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:19774,Modifiability,variab,variable,19774,SetFactory : [Category_Likelihood_2_dsi] : ; : ; : Train method: Category_Likelihood_2 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 4871 events: 0.0274 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (4871 events); : Elapsed time for evaluation of 4871 events: 0.00441 sec ; : TMVACC.root:/dataset/Method_Category/LikelihoodCat/Method_Likelihood/Category_Likelihood_2; : Training finished; : Begin ranking of input variables...; <HEADER> Category_Likelihood_1 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.108e-01; : 2 : var3 : 2.434e-02; : 3 : var1 : 1.781e-02; : 4 : var2 : 1.380e-02; : -----------------------------------; <HEADER> Category_Likelihood_2 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variabl,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:20655,Modifiability,variab,variables,20655, : var1 : 1.781e-02; : 4 : var2 : 1.380e-02; : -----------------------------------; <HEADER> Category_Likelihood_2 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weig,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:20725,Modifiability,variab,variable,20725,d_2 : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.353e-01; : 2 : var3 : 6.016e-02; : 3 : var2 : 1.277e-02; : 4 : var1 : 5.885e-03; : -----------------------------------; : Elapsed time for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificatio,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:21028,Modifiability,variab,variable,21028,"me for training with 10000 events: 0.252 sec ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0108 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on training sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:21310,Modifiability,variab,variable,21310,"10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> Data",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:21367,Modifiability,variab,variable,21367,"10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> Data",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:29144,Modifiability,variab,variables,29144,"TMVA/TMVAGui.h""; ; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategory(); {; //---------------------------------------------------------------; // Example for usage of different event categories with classifiers; ; std::cout << std::endl << ""==> Start TMVAClassificationCategory"" << std::endl;; ; // This loads the library; TMVA::Tools::Instance();; ; bool batchMode = false;; ; // Create a new root output file.; TString outfileName( ""TMVACC.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {;",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:29383,Modifiability,variab,variables,29383,"TMVA/TMVAGui.h""; ; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategory(); {; //---------------------------------------------------------------; // Example for usage of different event categories with classifiers; ; std::cout << std::endl << ""==> Start TMVAClassificationCategory"" << std::endl;; ; // This loads the library; TMVA::Tools::Instance();; ; bool batchMode = false;; ; // Create a new root output file.; TString outfileName( ""TMVACC.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {;",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:29538,Modifiability,variab,variables,29538,":Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {; // first we try to find tmva_example.root in the local directory; std::cout << ""--- TMVAClassificationCategory: Accessing "" << fname << std::endl;; input = TFile::Open( fname );; }; ; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:29608,Modifiability,variab,variables,29608,":Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; dataloader->AddSpectator( ""eta"" );; ; // Load the signal and background event samples from ROOT trees; TFile *input(0);; TString fname = gSystem->GetDirName(__FILE__) + ""/data/"";; if (gSystem->AccessPathName( fname + ""toy_sigbkg_categ_offset.root"")) {; // if directory data not found try using tutorials dir; fname = gROOT->GetTutorialDir() + ""/tmva/data/"";; }; if (UseOffsetMethod) fname += ""toy_sigbkg_categ_offset.root"";; else fname += ""toy_sigbkg_categ_varoff.root"";; if (!gSystem->AccessPathName( fname )) {; // first we try to find tmva_example.root in the local directory; std::cout << ""--- TMVAClassificationCategory: Accessing "" << fname << std::endl;; input = TFile::Open( fname );; }; ; if (!input) {; std::cout << ""ERROR: could not open data file: "" << fname << std::endl;; exit(1);; }; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:31711,Modifiability,variab,variable,31711,"g event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; dataloader->AddSignalTree ( signalTree, signalWeight );; dataloader->AddBackgroundTree( background, backgroundWeight );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=0:nTrain_Background=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Book MVA methods; ; // Fisher discriminant; factory->BookMethod( dataloader, TMVA::Types::kFisher, ""Fisher"", ""!H:!V:Fisher"" );; ; // Likelihood; factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""Likelihood"",; ""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Categorised classifier; TMVA::MethodCategory* mcat = 0;; ; // The variable sets; TString theCat1Vars = ""var1:var2:var3:var4"";; TString theCat2Vars = (UseOffsetMethod ? ""var1:var2:var3:var4"" : ""var1:var2:var3"");; ; // Fisher with categories; TMVA::MethodBase* fiCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""FisherCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(fiCat);; mcat->AddMethod( ""abs(eta)<=1.3"", theCat1Vars, TMVA::Types::kFisher, ""Category_Fisher_1"",""!H:!V:Fisher"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kFisher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpo",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:33168,Modifiability,config,configured,33168,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:35998,Modifiability,variab,variable,35998,"::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategor",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22660,Performance,perform,performance,22660,"==; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Fa",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22885,Performance,perform,performance,22885,"ory_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for ev",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23117,Performance,perform,performance,23117,"onCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER>",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23563,Performance,perform,performance,23563,t method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop ,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:28504,Performance,load,loads,28504,"------------------------------------------; : ; <HEADER> Dataset:dataset : Created tree 'TestTree' with 10000 events; : ; <HEADER> Dataset:dataset : Created tree 'TrainTree' with 10000 events; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.html; ==> Wrote root file: TMVACC.root; ==> TMVAClassificationCategory is done!; ; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/MethodCategory.h""; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; ; // two types of category methods are implemented; Bool_t UseOffsetMethod = kTRUE;; ; void TMVAClassificationCategory(); {; //---------------------------------------------------------------; // Example for usage of different event categories with classifiers; ; std::cout << std::endl << ""==> Start TMVAClassificationCategory"" << std::endl;; ; // This loads the library; TMVA::Tools::Instance();; ; bool batchMode = false;; ; // Create a new root output file.; TString outfileName( ""TMVACC.root"" );; TFile* outputFile = TFile::Open( outfileName, ""RECREATE"" );; ; // Create the factory object (see TMVAClassification.C for more information); ; std::string factoryOptions( ""!V:!Silent:Transformations=I;D;P;G,D"" );; if (batchMode) factoryOptions += "":!Color:!DrawProgressBar"";; ; TMVA::Factory *factory = new TMVA::Factory( ""TMVAClassificationCategory"", outputFile, factoryOptions );; ; // Create DataLoader; TMVA::DataLoader *dataloader=new TMVA::DataLoader(""dataset"");; ; // Define the input variables used for the MVA training; dataloader->AddVariable( ""var1"", 'F' );; dataloader->AddVariable( ""var2"", 'F' );; dataloader->AddVariable( ""var3"", 'F' );; dataloader->AddVariable( ""var4"", 'F' );; ; // You can add so-called ""Spect",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:33149,Performance,perform,performance,33149,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:36325,Performance,load,loader,36325,"er.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategoryClass for categorizing the phase space.Definition MethodCategory.h:58; TMVA::MethodCategory::AddMethodTMVA::IMethod * AddMethod(const TCut &, const TString &theVariables, Types::EMVA theMethod, const TString &theTitle, const TString &theOptions)adds sub-classifier for a categoryDefinition MethodCategory.cxx:138; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinitio",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:37752,Security,access,access,37752,"ring theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategoryClass for categorizing the phase space.Definition MethodCategory.h:58; TMVA::MethodCategory::AddMethodTMVA::IMethod * AddMethod(const TCut &, const TString &theVariables, Types::EMVA theMethod, const TString &theTitle, const TString &theOptions)adds sub-classifier for a categoryDefinition MethodCategory.cxx:138; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TMVA::TMVAGuivoid TMVAGui(const char *fName=""TMVA.root"", TString dataset=""""); Factory.h; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategory.C. tutorialstmvaTMVAClassificationCategory.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:37786,Security,access,access,37786,"ring theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategoryClass for categorizing the phase space.Definition MethodCategory.h:58; TMVA::MethodCategory::AddMethodTMVA::IMethod * AddMethod(const TCut &, const TString &theVariables, Types::EMVA theMethod, const TString &theTitle, const TString &theOptions)adds sub-classifier for a categoryDefinition MethodCategory.cxx:138; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TMVA::TMVAGuivoid TMVAGui(const char *fName=""TMVA.root"", TString dataset=""""); Factory.h; AuthorAndreas Hoecker ; Definition in file TMVAClassificationCategory.C. tutorialstmvaTMVAClassificationCategory.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:292,Testability,test,testing,292,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:2800,Testability,test,testing,2800,"ADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding sub-classifier: Likelihood::Category_Likelihood_1; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; : Adding sub-classifier: Likelihood::Category_Likelihood_2; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Train all methods; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 5000; : Signal -- testing events : 5000; : Signal -- training and testing events: 10000; : Background -- training events : 5000; : Background -- testing events : 5000; : Background -- training and testing events: 10000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:2943,Testability,test,testing,2943,"ADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding sub-classifier: Likelihood::Category_Likelihood_1; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; : Adding sub-classifier: Likelihood::Category_Likelihood_2; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Train all methods; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 5000; : Signal -- testing events : 5000; : Signal -- training and testing events: 10000; : Background -- training events : 5000; : Background -- testing events : 5000; : Background -- training and testing events: 10000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:2991,Testability,test,testing,2991,"ADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding sub-classifier: Likelihood::Category_Likelihood_1; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; : Adding sub-classifier: Likelihood::Category_Likelihood_2; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Train all methods; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 5000; : Signal -- testing events : 5000; : Signal -- training and testing events: 10000; : Background -- training events : 5000; : Background -- testing events : 5000; : Background -- training and testing events: 10000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:3070,Testability,test,testing,3070,"ADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding sub-classifier: Likelihood::Category_Likelihood_1; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; : Adding sub-classifier: Likelihood::Category_Likelihood_2; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Train all methods; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 5000; : Signal -- testing events : 5000; : Signal -- training and testing events: 10000; : Background -- training events : 5000; : Background -- testing events : 5000; : Background -- training and testing events: 10000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:3122,Testability,test,testing,3122,"ADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding sub-classifier: Likelihood::Category_Likelihood_1; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; : Adding sub-classifier: Likelihood::Category_Likelihood_2; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Train all methods; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 5000; : Signal -- testing events : 5000; : Signal -- training and testing events: 10000; : Background -- training events : 5000; : Background -- testing events : 5000; : Background -- training and testing events: 10000; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6266,Testability,test,testing,6266,"cation; : ; : Train all sub-classifiers for Classification ...; : Rebuilding Dataset Category_Fisher_1_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Fisher_1_dsi] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_1_dsi] : Number of events in input trees; : Dataset[Category_Fisher_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> Data",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6465,Testability,test,testing,6465," create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_1_dsi] : Number of events in input trees; : Dataset[Category_Fisher_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6594,Testability,test,testing,6594,"eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6737,Testability,test,testing,6737,"eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:6785,Testability,test,testing,6785,"eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Fisher_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Fisher_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Fisher_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:7010,Testability,test,testing,7010,ghts: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0.004; : var3: -0.022 -0.018 +1.000 +0.004; : var4: +0.003 +0.004 +0.004 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_1_dsi] : ; : ; : Train method: Category_Fisher_1 for Classification; <HEADER> Category_Fisher_1 : Results for Fisher coefficients:; : -----------------------; : Variable: Coeffici,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:7062,Testability,test,testing,7062,ghts: 5134 ; : Dataset[Category_Fisher_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Fisher_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Fisher_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Fisher_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0.004; : var3: -0.022 -0.018 +1.000 +0.004; : var4: +0.003 +0.004 +0.004 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_1_dsi] : ; : ; : Train method: Category_Fisher_1 for Classification; <HEADER> Category_Fisher_1 : Results for Fisher coefficients:; : -----------------------; : Variable: Coeffici,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9443,Testability,test,testing,9443,"for evaluation of 5128 events: 0.00242 sec ; : Training finished; : Rebuilding Dataset Category_Fisher_2_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Fisher_2_dsi] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_2_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : Number of events in input trees; : Dataset[Category_Fisher_2_dsi] : Signal requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> Data",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9642,Testability,test,testing,9642," : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Fisher_2_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : Number of events in input trees; : Dataset[Category_Fisher_2_dsi] : Signal requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9771,Testability,test,testing,9771,"s(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9914,Testability,test,testing,9914,"s(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:9962,Testability,test,testing,9962,"s(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Fisher_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Fisher_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Fisher_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:10187,Testability,test,testing,10187,ghts: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coeffici,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:10239,Testability,test,testing,10239,ghts: 4866 ; : Dataset[Category_Fisher_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Fisher_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Fisher_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Fisher_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Fisher_2_dsi] : ; : ; : Train method: Category_Fisher_2 for Classification; <HEADER> Category_Fisher_2 : Results for Fisher coefficients:; : -----------------------; : Variable: Coeffici,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14009,Testability,test,testing,14009,"r Classification ...; : Rebuilding Dataset Category_Likelihood_1_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ;",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14212,Testability,test,testing,14212," : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_1_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_1_dsi] : Signal requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14341,Testability,test,testing,14341,"_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14484,Testability,test,testing,14484,"_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14532,Testability,test,testing,14532,"_Likelihood_1_dsi] : Signal -- number of events passed: 5123 / sum of weights: 5123 ; : Dataset[Category_Likelihood_1_dsi] : Signal -- efficiency : 0.5123; : Dataset[Category_Likelihood_1_dsi] : Background requirement: ""abs(eta)<=1.3""; : Dataset[Category_Likelihood_1_dsi] : Background -- number of events passed: 5134 / sum of weights: 5134 ; : Dataset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14761,Testability,test,testing,14761,aset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0.004; : var3: -0.022 -0.018 +1.000 +0.004; : var4: +0.003 +0.004 +0.004 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : ; : ; : Train method: Category_Likelihood_1 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for train,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:14813,Testability,test,testing,14813,aset[Category_Likelihood_1_dsi] : Background -- efficiency : 0.5134; : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5123 preselection efficiency); : Dataset[Category_Likelihood_1_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.5134 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2561; : Signal -- testing events : 2561; : Signal -- training and testing events: 5122; : Dataset[Category_Likelihood_1_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5123; : Background -- training events : 2567; : Background -- testing events : 2567; : Background -- training and testing events: 5134; : Dataset[Category_Likelihood_1_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.5134; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.017 +0.004 +0.001; : var2: -0.017 +1.000 -0.019 -0.003; : var3: +0.004 -0.019 +1.000 -0.012; : var4: +0.001 -0.003 -0.012 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.019 -0.022 +0.003; : var2: -0.019 +1.000 -0.018 +0.004; : var3: -0.022 -0.018 +1.000 +0.004; : var4: +0.003 +0.004 +0.004 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_1_dsi] : ; : ; : Train method: Category_Likelihood_1 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for train,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17176,Testability,test,testing,17176,"1; : Training finished; : Rebuilding Dataset Category_Likelihood_2_dsi; : Building event vectors for type 2 Signal; : Dataset[Category_Likelihood_2_dsi] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_2_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_2_dsi] : Signal requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Likelihood_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Likelihood_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ;",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17379,Testability,test,testing,17379,"S; : Building event vectors for type 2 Background; : Dataset[Category_Likelihood_2_dsi] : create input formulas for tree TreeB; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : Number of events in input trees; : Dataset[Category_Likelihood_2_dsi] : Signal requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Likelihood_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Likelihood_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.0",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17508,Testability,test,testing,17508,"y_Likelihood_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Likelihood_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Likelihood_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17651,Testability,test,testing,17651,"y_Likelihood_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Likelihood_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Likelihood_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17699,Testability,test,testing,17699,"y_Likelihood_2_dsi] : Signal -- number of events passed: 4877 / sum of weights: 4877 ; : Dataset[Category_Likelihood_2_dsi] : Signal -- efficiency : 0.4877; : Dataset[Category_Likelihood_2_dsi] : Background requirement: ""abs(eta)>1.3""; : Dataset[Category_Likelihood_2_dsi] : Background -- number of events passed: 4866 / sum of weights: 4866 ; : Dataset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17928,Testability,test,testing,17928,aset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : ; : ; : Train method: Category_Likelihood_2 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for train,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:17980,Testability,test,testing,17980,aset[Category_Likelihood_2_dsi] : Background -- efficiency : 0.4866; : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4877 preselection efficiency); : Dataset[Category_Likelihood_2_dsi] : you have opted for scaling the number of requested training/testing events; : to be scaled by the preselection efficiency; : ( 0 * 0.4866 preselection efficiency); : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 2438; : Signal -- testing events : 2438; : Signal -- training and testing events: 4876; : Dataset[Category_Likelihood_2_dsi] : Signal -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4877; : Background -- training events : 2433; : Background -- testing events : 2433; : Background -- training and testing events: 4866; : Dataset[Category_Likelihood_2_dsi] : Background -- due to the preselection a scaling factor has been applied to the numbers of requested events: 0.4866; : ; <HEADER> DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.005 +0.002 -0.039; : var2: -0.005 +1.000 +0.011 -0.004; : var3: +0.002 +0.011 +1.000 -0.021; : var4: -0.039 -0.004 -0.021 +1.000; : ----------------------------------------; <HEADER> DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : var1 var2 var3 var4; : var1: +1.000 -0.007 +0.009 +0.008; : var2: -0.007 +1.000 -0.020 +0.013; : var3: +0.009 -0.020 +1.000 +0.007; : var4: +0.008 +0.013 +0.007 +1.000; : ----------------------------------------; <HEADER> DataSetFactory : [Category_Likelihood_2_dsi] : ; : ; : Train method: Category_Likelihood_2 for Classification; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for train,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:21500,Testability,test,testing,21500,"10000 events); : Elapsed time for evaluation of 10000 events: 0.00971 sec ; : Creating xml weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; <HEADER> Factory : Training finished; : ; : Ranking input variables (method specific)...; <HEADER> Fisher : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Discr. power; : -------------------------------; : 1 : var4 : 1.446e-01; : 2 : var3 : 7.153e-02; : 3 : var2 : 2.447e-02; : 4 : var1 : 1.243e-02; : -------------------------------; <HEADER> Likelihood : Ranking result (top variable is best ranked); : -----------------------------------; : Rank : Variable : Delta Separation; : -----------------------------------; : 1 : var4 : 1.148e-01; : 2 : var3 : 5.071e-02; : 3 : var2 : 2.758e-02; : 4 : var1 : 1.990e-02; : -----------------------------------; : No variable ranking supplied by classifier: FisherCat; : No variable ranking supplied by classifier: LikelihoodCat; <HEADER> Factory : === Destroy and recreate all methods via weight files for testing ===; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> Data",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22731,Testability,test,testing,22731,"==; : ; : Reading weight file: dataset/weights/TMVAClassificationCategory_Fisher.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_Likelihood.weights.xml; : Reading weight file: dataset/weights/TMVAClassificationCategory_FisherCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Fa",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:22964,Testability,test,testing,22964,"ory_Fisher_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; : Reading weight file: dataset/weights/TMVAClassificationCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for ev",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23224,Testability,test,testing,23224,"onCategory_LikelihoodCat.weights.xml; : Recreating sub-classifiers from XML-file ; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_1_dsi] : Added class ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER>",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23406,Testability,test,testing,23406,"s ""Background""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Likelihood_2_dsi] : Added class ""Background""; <HEADER> Factory : Test all methods; <HEADER> Factory : Test method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23682,Testability,test,testing,23682,t method: Fisher for Classification performance; : ; <HEADER> Fisher : [dataset] : Evaluation of Fisher on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00318 sec ; <HEADER> Factory : Test method: Likelihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop ,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:23876,Testability,test,testing,23876,lihood for Classification performance; : ; <HEADER> Likelihood : [dataset] : Evaluation of Likelihood on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00959 sec ; <HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.56,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:24101,Testability,test,test,24101,HEADER> Factory : Test method: FisherCat for Classification performance; : ; <HEADER> Category_Fisher_1 : [Category_Fisher_1_dsi] : Evaluation of Category_Fisher_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00192 sec ; <HEADER> Category_Fisher_2 : [Category_Fisher_2_dsi] : Evaluation of Category_Fisher_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00196 sec ; <HEADER> Factory : Test method: LikelihoodCat for Classification performance; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : ---------------------------------------------------------,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:24629,Testability,test,test,24629,ce; : ; <HEADER> Category_Likelihood_1 : [Category_Likelihood_1_dsi] : Evaluation of Category_Likelihood_1 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00948 sec ; <HEADER> Category_Likelihood_2 : [Category_Likelihood_2_dsi] : Evaluation of Category_Likelihood_2 on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.00932 sec ; <HEADER> Factory : Evaluate all methods; <HEADER> Factory : Evaluate classifier: Fisher; : ; <HEADER> Fisher : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: FisherCat; : ; <HEADER> FisherCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_FisherCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -------------------------------------------,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:25159,Testability,test,test,25159,st events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Fisher : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: Likelihood; : ; <HEADER> Likelihood : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: FisherCat; : ; <HEADER> FisherCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_FisherCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: LikelihoodCat; : ; <HEADER> LikelihoodCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_LikelihoodCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : ---------------------------------,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:25696,Testability,test,test,25696,ents and fill histograms with classifier response...; : ; <HEADER> TFHandler_Likelihood : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: FisherCat; : ; <HEADER> FisherCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_FisherCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; <HEADER> Factory : Evaluate classifier: LikelihoodCat; : ; <HEADER> LikelihoodCat : [dataset] : Loop over test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_LikelihoodCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset FisherCat : 0.914; : dataset LikelihoodCat : 0.913; : dataset Fisher : 0.808; : dataset Likelihood : 0.769; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency comp,MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:26843,Testability,test,test,26843,"ver test events and fill histograms with classifier response...; : ; <HEADER> TFHandler_LikelihoodCat : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: -0.014081 1.2910 [ -5.3119 4.5609 ]; : var2: -0.014399 1.3299 [ -4.7537 4.6723 ]; : var3: -0.027971 1.3779 [ -5.2892 4.7007 ]; : var4: 0.12966 1.4883 [ -5.1002 4.9767 ]; : -----------------------------------------------------------; : ; : Evaluation results ranked by best signal efficiency and purity (area); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA ; : Name: Method: ROC-integ; : dataset FisherCat : 0.914; : dataset LikelihoodCat : 0.913; : dataset Fisher : 0.808; : dataset Likelihood : 0.769; : -------------------------------------------------------------------------------------------------------------------; : ; : Testing efficiency compared to training efficiency (overtraining check); : -------------------------------------------------------------------------------------------------------------------; : DataSet MVA Signal efficiency: from test sample (from training sample) ; : Name: Method: @B=0.01 @B=0.10 @B=0.30 ; : -------------------------------------------------------------------------------------------------------------------; : dataset FisherCat : 0.352 (0.360) 0.743 (0.739) 0.919 (0.916); : dataset LikelihoodCat : 0.349 (0.353) 0.739 (0.735) 0.919 (0.917); : dataset Fisher : 0.184 (0.185) 0.471 (0.486) 0.746 (0.742); : dataset Likelihood : 0.211 (0.242) 0.447 (0.454) 0.610 (0.608); : -------------------------------------------------------------------------------------------------------------------; : ; <HEADER> Dataset:dataset : Created tree 'TestTree' with 10000 events; : ; <HEADER> Dataset:dataset : Created tree 'TrainTree' with 10000 events; : ; <HEADER> Factory : Thank you for using TMVA!; : For citation information, please visit: http://tmva.sf.net/citeTMVA.h",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:31137,Testability,test,testing,31137,"g event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; dataloader->AddSignalTree ( signalTree, signalWeight );; dataloader->AddBackgroundTree( background, backgroundWeight );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=0:nTrain_Background=0:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // Book MVA methods; ; // Fisher discriminant; factory->BookMethod( dataloader, TMVA::Types::kFisher, ""Fisher"", ""!H:!V:Fisher"" );; ; // Likelihood; factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""Likelihood"",; ""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Categorised classifier; TMVA::MethodCategory* mcat = 0;; ; // The variable sets; TString theCat1Vars = ""var1:var2:var3:var4"";; TString theCat2Vars = (UseOffsetMethod ? ""var1:var2:var3:var4"" : ""var1:var2:var3"");; ; // Fisher with categories; TMVA::MethodBase* fiCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""FisherCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(fiCat);; mcat->AddMethod( ""abs(eta)<=1.3"", theCat1Vars, TMVA::Types::kFisher, ""Category_Fisher_1"",""!H:!V:Fisher"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kFisher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpo",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:32934,Testability,test,test,32934,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:33082,Testability,test,test,33082,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:35499,Testability,test,test,35499,"sually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSignalTreevoid AddSignalTree(TTree *signal, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:371; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:36551,Testability,test,testing,36551,"d backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddBackgroundTreevoid AddBackgroundTree(TTree *background, Double_t weight=1.0, Types::ETreeType treetype=Types::kMaxTreeType)number of signal events (used to compute significance)Definition DataLoader.cxx:402; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; TMVA::Factory::TrainAllMethodsvoid TrainAllMethods()Iterates through all booked methods and calls training.Definition Factory.cxx:1114; TMVA::Factory::BookMethodMethodBase * BookMethod(DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption="""")Book a classifier or regression method.Definition Factory.cxx:352; TMVA::Factory::TestAllMethodsvoid TestAllMethods()Evaluates all booked methods on the testing data and adds the output to the Results in the corresponi...Definition Factory.cxx:1271; TMVA::Factory::EvaluateAllMethodsvoid EvaluateAllMethods(void)Iterates over all MVAs that have been booked, and calls their evaluation methods.Definition Factory.cxx:1376; TMVA::MethodBaseVirtual base Class for all MVA method.Definition MethodBase.h:111; TMVA::MethodCategoryClass for categorizing the phase space.Definition MethodCategory.h:58; TMVA::MethodCategory::AddMethodTMVA::IMethod * AddMethod(const TCut &, const TString &theVariables, Types::EMVA theMethod, const TString &theTitle, const TString &theOptions)adds sub-classifier for a categoryDefinition MethodCategory.cxx:138; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kFisher@ kFisherDefinition Types.h:82; TMVA::Types::kCategory@ kCategoryDefinition Types.h:97; TMVA::Types::kLikelihood@ kLikelihoodDefinition Types.h:79; TNamed::GetNameconst char * GetName() const overrideReturns n",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassificationCategory_8C.html:824,Usability,simpl,simply,824,". ROOT: tutorials/tmva/TMVAClassificationCategory.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassificationCategory.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. . Project : TMVA - a Root-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassificationCategory. As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables with category (eta) dependent properties.; For this example, only Fisher and Likelihood are used. Run via: root -l TMVAClassificationCategory.C; The output file ""TMVACC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro.; ; ; ==> Start TMVAClassificationCategory; --- TMVAClassificationCategory: Accessing /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/tutorials/tmva/data/toy_sigbkg_categ_offset.root; <HEADER> DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 10000 events; <HEADER> DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 10000 events; <HEADER> Factory : Booking method: Fisher; : ; <HEADER> Factory : Booking method: Likelihood; : ; <HEADER> Factory : Booking method: FisherCat; : ; : Adding sub-classifier: Fisher::Category_Fisher_1; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_1_dsi] : Added class ""Background""; : Adding sub-classifier: Fisher::Category_Fisher_2; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Signal""; <HEADER> DataSetInfo : [Category_Fisher_2_dsi] : Added class ""Background""; <HEADER> Factory : Booking method: LikelihoodCat; : ; : Adding su",MatchSource.WIKI,doc/master/TMVAClassificationCategory_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:7152,Availability,error,error,7152,"arsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:43102,Availability,avail,available,43102,"rks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:43369,Availability,avail,available,43369,"educe the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this messa",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47125,Availability,error,error,47125," 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 4 ) Batch size = 100 Loss function = C; Layer 0 DENSE Layer: ( Input = 4 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47396,Availability,error,error,47396,"ction = C; Layer 0 DENSE Layer: ( Input = 4 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47505,Availability,error,error,47505,"= Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47665,Availability,error,error,47665,"ut = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47934,Availability,error,error,47934,"r testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 885",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:48042,Availability,error,error,48042,"9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 8853.03 6; : 24 | 0.38501 0.377878 0.194456 0.0147282 8902.35 7; : 25 | 0.389388 0.376148 0.201694 0.0152248 858",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:48533,Availability,error,error,48533, 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 8853.03 6; : 24 | 0.38501 0.377878 0.194456 0.0147282 8902.35 7; : 25 | 0.389388 0.376148 0.201694 0.0152248 8580.5 8; : 26 | 0.386053 0.386475 0.196336 0.0144907 8798.68 9; : 27 | 0.393538 0.3733 0.194982 0.0143137 8856 10; : 28 | 0.385176 0.39001 0.193442 0.0143164 8932.26 11; : 29 | 0.400584 0.385359 0.19387 0.0143278 8911.56 12; : 30 | 0.396539 0.381147 0.193167 0.0143041 8945.41 13; : 31 | 0.38083 0.377553 0.193127 0.014317 8948.06 14; : 32 | 0.383321 0.382886 0.193572 0.0143126 8925.64 15; : 33 | 0.38226 0.374274 0.19409 0.0143233 8900.4 16; : 34 | 0.38313 0.384605 0.193423 0.0144921 8941.,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:50815,Availability,avail,available,50815,"h 2000 events: 7.41 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; DNN_CPU : [dataset] : Evaluation of DNN_CPU on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0721 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: SVM for Classification; : ; TFHandler_SVM : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Building SVM Working Set...with 2000 event instances; : Elapsed time for Working Set build: 0.0742 sec; : Sorry, no computing time forecast available for SVM, please wait ...; : Elapsed time: 0.385 sec ; : Elapsed time for training with 2000 events: 0.464 sec ; SVM : [dataset] : Evaluation of SVM on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0678 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_SVM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_SVM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: BDT for Classification; : ; BDT : #events: (reweighted) sig: 1000 bkg: 1000; : #events: (unweighted) sig: 1000 bkg: 1000; : Training 850 Decision Trees ... patience please; : Elapsed time for training with 2000 events: 0.594 sec ; BDT : [dataset] : Evaluation of BDT on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.151 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:55279,Availability,avail,available,55279,"""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:55293,Availability,error,error,55293,"""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:56044,Availability,error,error,56044,"TING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m.; : ; : ␛[1mReached minimum early in the search␛[0m; : Minimum was found early in the fitting. This; : may indicate that the used step size ␛[1mGDStep␛[0m.; : was too large. Reduce it and rerun.; : If the results still are not OK, modify",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:56576,Availability,error,error,56576,"e. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m.; : ; : ␛[1mReached minimum early in the search␛[0m; : Minimum was found early in the fitting. This; : may indicate that the used step size ␛[1mGDStep␛[0m.; : was too large. Reduce it and rerun.; : If the results still are not OK, modify the; : model either by modifying the rule ensemble; : or add/remove linear terms; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanu",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:56737,Availability,error,error,56737,"GDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m.; : ; : ␛[1mReached minimum early in the search␛[0m; : Minimum was found early in the fitting. This; : may indicate that the used step size ␛[1mGDStep␛[0m.; : was too large. Reduce it and rerun.; : If the results still are not OK, modify the; : model either by modifying the rule ensemble; : or add/remove linear terms; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanup : 80; : Average number of cuts per rule : 3.01; : Spread in number of cuts per rules : 1.23; : ----------------------------------------------------------------; : ; : GD path scan - the scan stops when the max num. of steps is reached or",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:58118,Availability,error,error,58118,"are not OK, modify the; : model either by modifying the rule ensemble; : or add/remove linear terms; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanup : 80; : Average number of cuts per rule : 3.01; : Spread in number of cuts per rules : 1.23; : ----------------------------------------------------------------; : ; : GD path scan - the scan stops when the max num. of steps is reached or a min is found; : Estimating the cutoff parameter tau. The estimated time is a pessimistic maximum.; : Best path found with tau = 0.0000 after 2.21 sec ; : Fitting model...; <WARNING> : ; : Minimisation elapsed time : 1.23 sec ; : ----------------------------------------------------------------; : Found minimum at step 10000 with error = 0.552378; : Reason for ending loop: end of loop reached; : ----------------------------------------------------------------; : The error rate was still decreasing at the end of the path; : Increase number of steps (GDNSteps).; : Removed 28 out of a total of 80 rules with importance < 0.001; : ; : ================================================================; : M o d e l ; : ================================================================; RuleFit : Offset (a0) = 9.46803; : ------------------------------------; : Linear model (weights unnormalised); : ------------------------------------; : Variable : Weights : Importance; : ------------------------------------; : myvar1 : -6.338e-01 : 0.472; : myvar2 : -4.488e-01 : 0.209; : var3 : -2.810e-01 : 0.129; : var4 : 1.850e+00 : 1.000; : ------------------------------------; : Number of rules = 52; : Printing the first 10 rules, ordered in importance.; : Rule 1 : Importance = 0.4294",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:58257,Availability,error,error,58257," : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanup : 80; : Average number of cuts per rule : 3.01; : Spread in number of cuts per rules : 1.23; : ----------------------------------------------------------------; : ; : GD path scan - the scan stops when the max num. of steps is reached or a min is found; : Estimating the cutoff parameter tau. The estimated time is a pessimistic maximum.; : Best path found with tau = 0.0000 after 2.21 sec ; : Fitting model...; <WARNING> : ; : Minimisation elapsed time : 1.23 sec ; : ----------------------------------------------------------------; : Found minimum at step 10000 with error = 0.552378; : Reason for ending loop: end of loop reached; : ----------------------------------------------------------------; : The error rate was still decreasing at the end of the path; : Increase number of steps (GDNSteps).; : Removed 28 out of a total of 80 rules with importance < 0.001; : ; : ================================================================; : M o d e l ; : ================================================================; RuleFit : Offset (a0) = 9.46803; : ------------------------------------; : Linear model (weights unnormalised); : ------------------------------------; : Variable : Weights : Importance; : ------------------------------------; : myvar1 : -6.338e-01 : 0.472; : myvar2 : -4.488e-01 : 0.209; : var3 : -2.810e-01 : 0.129; : var4 : 1.850e+00 : 1.000; : ------------------------------------; : Number of rules = 52; : Printing the first 10 rules, ordered in importance.; : Rule 1 : Importance = 0.4294; : Cut 1 : -0.708 < var4 ; : Rule 2 : Importance = 0.3676; : Cut 1 : var3 < -0.0812; : Rule 3 : Importance = 0.3363; : Cut 1 : -0.0812 < var3 ; : Rule 4 : Importance = 0.29",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:84968,Availability,down,downloaded,84968,"st != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = TMVA::gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return 1;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Read training and test data; // (it is also possible to use ASCII format as input -> see TMVA Users Guide); // Set the cache directory for the TFile to the current directory. The input; // data file will be downloaded here if not present yet, then it will be read; // from the cache path directly.; TFile::SetCacheFileDir(""."");; std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; if (!input || input->IsZombie()) {; throw std::runtime_error(""ERROR: could not open data file"");; }; std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; ; // Register the training and test trees; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVAC.root"");; std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; if (!outputFile || outputFile->IsZombie()) {; throw std::runtime_error(""ERROR: could not open output file"");; }; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory is; // the only TMVA object you",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:86701,Availability,avail,available,86701,"TE"")};; if (!outputFile || outputFile->IsZombie()) {; throw std::runtime_error(""ERROR: could not open output file"");; }; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory is; // the only TMVA object you have to interact with; //; // The first argument is the base of the name of all the; // weightfiles in the directory weight/; //; // The second argument is the output file for the training results; // All TMVA output can be suppressed by removing the ""!"" (not) in; // front of the ""Silent"" argument in the option string; auto factory = std::make_unique<TMVA::Factory>(; ""TMVAClassification"", outputFile.get(),; ""!V:!Silent:Color:DrawProgressBar:Transformations=I;D;P;G,D:AnalysisType=Classification"");; auto dataloader_raii = std::make_unique<TMVA::DataLoader>(""dataset"");; auto *dataloader = dataloader_raii.get();; // If you wish to modify default settings; // (please check ""src/Config.h"" to see all available global options); //; // (TMVA::gConfig().GetVariablePlotting()).fTimesRMS = 8.0;; // (TMVA::gConfig().GetIONames()).fWeightFileDir = ""myWeightDirectory"";; ; // Define the input variables that shall be used for the MVA training; // note that you may also use variable expressions, such as: ""3*var1/var2*abs(var3)""; // [all types of expressions that can also be parsed by TTree::Draw( ""expression"" )]; dataloader->AddVariable( ""myvar1 := var1+var2"", 'F' );; dataloader->AddVariable( ""myvar2 := var1-var2"", ""Expression 2"", """", 'F' );; dataloader->AddVariable( ""var3"", ""Variable 3"", ""units"", 'F' );; dataloader->AddVariable( ""var4"", ""Variable 4"", ""units"", 'F' );; ; // You can add so-called ""Spectator variables"", which are not used in the MVA training,; // but will appear in the final ""TestTree"" produced by TMVA. This TestTree will contain the; // input variables, the response values of all trained MVAs, and the spectator variables; ; dataloader->AddSpectator( ""spec1 := var1*2"", ""Spectator 1"", ""units"", 'F' ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1282,Deployability,integrat,integrated,1282,"t data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables. The methods to be used can be switched on and off by means of booleans, or via the prompt command, for example: root -l ./TMVAClassification.C\‍(\""Fisher,Likelihood\""\‍); (note that the backslashes are mandatory) If no method given, a default set of classifiers is used. The output file ""TMVAC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input :",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28399,Deployability,configurat,configuration,28399,"et/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed tim",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:33112,Deployability,configurat,configuration,33112,"=====================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ KNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The k-nearest neighbor (k-NN) algorithm is a multi-dimensional classification; : and regression algorithm. Similarly to other TMVA algorithms, k-NN uses a set of; : training events for which a classification category/regression target is known. ; : The k-NN method compares a test event to all training events using a distance ; : function, which is an Euclidean distance in a space defined by the input variables. ; : The k-NN method, as implemented in TMVA, uses a kd-tree algorithm to perform a; : quick search for the k events with shortest distance to the test event. The method; : returns a fraction of signal events among the k neighbors. It is recommended; : that a histogram which stores the k-NN decision variable is binned with k+1 bins; : between 0 and 1.; : ; : ␛[1m--- Performance tuning via configuration options: ␛[0m; : ; : The k-NN method estimates a density of signal and background events in a ; : neighborhood around the test event. The method assumes that the density of the ; : signal and background events is uniform and constant within the neighborhood. ; : k is an adjustable parameter and it determines an average size of the ; : neighborhood. Small k values (less than 10) are sensitive to statistical ; : fluctuations and large (greater than 100) values might not sufficiently capture ; : local differences between events in the training set. The speed of the k-NN; : method also increases with larger values of k. ; : ; : The k-NN method assigns equal weight to all input variables. Different scales ; : among the input variables is compensated using ScaleFrac parameter: the input ; : variables are scaled so that the widths for central ScaleFrac*100% events are ; : equal among all the input variables.; : ; : ␛[1m--- Additional configuration options: ␛[0m; : ; : The method inclues an option to use a Gaussian kernel to smooth ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:34067,Deployability,configurat,configuration,34067,"figuration options: ␛[0m; : ; : The k-NN method estimates a density of signal and background events in a ; : neighborhood around the test event. The method assumes that the density of the ; : signal and background events is uniform and constant within the neighborhood. ; : k is an adjustable parameter and it determines an average size of the ; : neighborhood. Small k values (less than 10) are sensitive to statistical ; : fluctuations and large (greater than 100) values might not sufficiently capture ; : local differences between events in the training set. The speed of the k-NN; : method also increases with larger values of k. ; : ; : The k-NN method assigns equal weight to all input variables. Different scales ; : among the input variables is compensated using ScaleFrac parameter: the input ; : variables are scaled so that the widths for central ScaleFrac*100% events are ; : equal among all the input variables.; : ; : ␛[1m--- Additional configuration options: ␛[0m; : ; : The method inclues an option to use a Gaussian kernel to smooth out the k-NN; : response. The kernel re-weights events using a distance to the test event.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; KNN : <Train> start...; : Reading 2000 events; : Number of signal events 1000; : Number of background events 1000; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Elapsed time for training with 2000 events: 0.00292 sec ; KNN : [dataset] : Evaluation of KNN on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0394 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_KNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAC",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:37177,Deployability,configurat,configuration,37177,"isation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1: -0.309; : myvar2: -0.102; : var3: -0.142; : var4: +0.705; : (offset): -0.055; : -----------------------; : Elapsed time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: FDA_GA for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:38574,Deployability,configurat,configuration,38574,"d time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: FDA_GA for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The function discriminant analysis (FDA) is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynom",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:39771,Deployability,configurat,configuration,39771,"ty and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by setting the option; : ""Converger=MINUIT"". GA (MC) will then set the starting parameters; : for MINUIT such that the basic quality of GA (MC) of finding global; : minima is combined with the efficacy of MINUIT of finding local; : minima.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 0.901 sec ; FDA_GA : Results for parameter fit using ""GA"" fi",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:43708,Deployability,configurat,configuration,43708,"vergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47419,Deployability,configurat,configuration,47419,"ction = C; Layer 0 DENSE Layer: ( Input = 4 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47528,Deployability,configurat,configuration,47528,"= Tanh; Layer 1 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 2 DENSE Layer: ( Input = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47688,Deployability,configurat,configuration,47688,"ut = 128 , Width = 128 ) Output = ( 1 , 100 , 128 ) Activation Function = Tanh Dropout prob. = 0.5; Layer 3 DENSE Layer: ( Input = 128 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity Dropout prob. = 0.5; : Using 1600 events for training and 400 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:47957,Deployability,configurat,configuration,47957,"r testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 885",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:48065,Deployability,configurat,configuration,48065,"9,beta2=0.999,eps=1e-07) Learning rate = 0.01 regularization 0 minimum error = 0.699892; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.548477 0.466013 0.191275 0.014698 9061.23 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 8853.03 6; : 24 | 0.38501 0.377878 0.194456 0.0147282 8902.35 7; : 25 | 0.389388 0.376148 0.201694 0.0152248 858",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:48556,Deployability,configurat,configuration,48556, 2 | 0.431501 0.379356 0.191981 0.0145985 9020.06 0; : 3 | 0.40241 0.379482 0.19151 0.014162 9021.8 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.408996 0.379041 0.192713 0.0146534 8985.76 0; : 5 | 0.41143 0.414316 0.191728 0.014237 9014.55 1; : 6 | 0.385066 0.478603 0.19226 0.0142608 8988.82 2; : 7 | 0.404168 0.388159 0.192259 0.0142353 8987.58 3; : 8 Minimum Test error found - save the configuration ; : 8 | 0.394387 0.377539 0.19273 0.0147168 8988.1 0; : 9 Minimum Test error found - save the configuration ; : 9 | 0.386834 0.375541 0.192946 0.014741 8978.44 0; : 10 | 0.381359 0.385778 0.195351 0.0142527 8835 1; : 11 | 0.391916 0.415129 0.193961 0.0143386 8907.56 2; : 12 | 0.390755 0.379468 0.194376 0.0145555 8897.75 3; : 13 | 0.409355 0.396515 0.195082 0.0144231 8856.49 4; : 14 | 0.400917 0.375809 0.194321 0.0142902 8887.36 5; : 15 | 0.384495 0.401588 0.194138 0.0144019 8901.96 6; : 16 | 0.400658 0.401489 0.198047 0.014311 8708.13 7; : 17 Minimum Test error found - save the configuration ; : 17 | 0.386851 0.371455 0.194859 0.0148291 8887.42 0; : 18 | 0.389253 0.376491 0.196282 0.0143574 8794.87 1; : 19 | 0.378227 0.384958 0.199317 0.0143422 8649.85 2; : 20 | 0.387911 0.390858 0.193697 0.0144047 8923.97 3; : 21 | 0.391998 0.3743 0.194318 0.0146357 8904.63 4; : 22 | 0.396695 0.384671 0.194406 0.0145452 8895.77 5; : 23 | 0.38744 0.376683 0.195092 0.0143629 8853.03 6; : 24 | 0.38501 0.377878 0.194456 0.0147282 8902.35 7; : 25 | 0.389388 0.376148 0.201694 0.0152248 8580.5 8; : 26 | 0.386053 0.386475 0.196336 0.0144907 8798.68 9; : 27 | 0.393538 0.3733 0.194982 0.0143137 8856 10; : 28 | 0.385176 0.39001 0.193442 0.0143164 8932.26 11; : 29 | 0.400584 0.385359 0.19387 0.0143278 8911.56 12; : 30 | 0.396539 0.381147 0.193167 0.0143041 8945.41 13; : 31 | 0.38083 0.377553 0.193127 0.014317 8948.06 14; : 32 | 0.383321 0.382886 0.193572 0.0143126 8925.64 15; : 33 | 0.38226 0.374274 0.19409 0.0143233 8900.4 16; : 34 | 0.38313 0.384605 0.193423 0.0144921 8941.,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:54141,Deployability,configurat,configuration,54141,"ith simple rules, only capable of; : modeling simple structures.; : Several parameters exists for controlling the complexity of the; : rule ensemble.; : ; : The fitting procedure searches for a minimum using a gradient; : directed path. Apart from step size and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:91530,Deployability,configurat,configuration,91530,"--------------------------------------; // ```; // End of tree registration; ; // Set individual event weights (the variables must exist in the original TTree); // - for signal : `dataloader->SetSignalWeightExpression (""weight1*weight2"");`; // - for background: `dataloader->SetBackgroundWeightExpression(""weight1*weight2"");`; dataloader->SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the dataloader how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; //; // dataloader->PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; //; // To also specify the number of testing events, use:; //; // dataloader->PrepareTrainingAndTestTree( mycut,; // ""NSigTrain=3000:NBkgTrain=3000:NSigTest=3000:NBkgTest=3000:SplitMode=Random:!V"" );; dataloader->PrepareTrainingAndTestTree( mycuts, mycutb,; ""nTrain_Signal=1000:nTrain_Background=1000:SplitMode=Random:NormMode=NumEvents:!V"" );; ; // ### Book MVA methods; //; // Please lookup the various method configuration options in the corresponding cxx files, eg:; // src/MethoCuts.cxx, etc, or here: http://tmva.sourceforge.net/old_site/optionRef.html; // it is possible to preset ranges in the option string in which the cut optimisation should be done:; // ""...:CutRangeMin[2]=-1:CutRangeMax[2]=1""..."", where [2] is the third input variable; ; // Cut optimisation; if (Use[""Cuts""]); factory->BookMethod( dataloader, TMVA::Types::kCuts, ""Cuts"",; ""!H:!V:FitMethod=MC:EffSel:SampleSize=200000:VarProp=FSmart"" );; ; if (Use[""CutsD""]); factory->BookMethod( dataloader, TMVA::Types::kCuts, ""CutsD"",; ""!H:!V:FitMethod=MC:EffSel:SampleSize=200000:VarProp=FSmart:VarTransform=Decorrelate"" );; ; if (Us",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:103386,Deployability,configurat,configuration,103386,"TMVA::Types::kBDT, ""BDTD"",; ""!H:!V:NTrees=400:MinNodeSize=5%:MaxDepth=3:BoostType=AdaBoost:SeparationType=GiniIndex:nCuts=20:VarTransform=Decorrelate"" );; ; if (Use[""BDTF""]) // Allow Using Fisher discriminant in node splitting for (strong) linearly correlated variables; factory->BookMethod( dataloader, TMVA::Types::kBDT, ""BDTF"",; ""!H:!V:NTrees=50:MinNodeSize=2.5%:UseFisherCuts:MaxDepth=3:BoostType=AdaBoost:AdaBoostBeta=0.5:SeparationType=GiniIndex:nCuts=20"" );; ; // RuleFit -- TMVA implementation of Friedman's method; if (Use[""RuleFit""]); factory->BookMethod( dataloader, TMVA::Types::kRuleFit, ""RuleFit"",; ""H:!V:RuleFitModule=RFTMVA:Model=ModRuleLinear:MinImp=0.001:RuleMinDist=0.001:NTrees=20:fEventsMin=0.01:fEventsMax=0.5:GDTau=-1.0:GDTauPrec=0.01:GDStep=0.01:GDNSteps=10000:GDErrScale=1.02"" );; ; // For an example of the category classifier usage, see: TMVAClassificationCategory; //; // --------------------------------------------------------------------------------------------------; // Now you can optimize the setting (configuration) of the MVAs using the set of training events; // STILL EXPERIMENTAL and only implemented for BDT's !; //; // factory->OptimizeAllMethods(""SigEffAtBkg0.01"",""Scan"");; // factory->OptimizeAllMethods(""ROCIntegral"",""FitGA"");; //; // --------------------------------------------------------------------------------------------------; ; // Now you can tell the factory to train, test, and evaluate the MVAs; //; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Write();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassification is done!"" << std::endl;; ; // Launch the GUI for the root macro",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28250,Energy Efficiency,reduce,reduced,28250,"; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28845,Energy Efficiency,adapt,adaptive,28845," reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0035 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.class.C␛[0m; : TMVAC.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: LikelihoodPCA for Classification; : ; : Preparing the Principle Component (PCA) transformation...; TFHandler_Like",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28933,Energy Efficiency,adapt,adaptive,28933," reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0035 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.class.C␛[0m; : TMVAC.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: LikelihoodPCA for Classification; : ; : Preparing the Principle Component (PCA) transformation...; TFHandler_Like",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:36491,Energy Efficiency,reduce,reduces,36491,"and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : The LD implementation here is equivalent to the ""Fisher"" discriminant; : for classification, but also provides linear regression.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:36525,Energy Efficiency,power,power,36525,"and background distributions in a trans- ; : formed variable space where linear correlations are removed.; : The LD implementation here is equivalent to the ""Fisher"" discriminant; : for classification, but also provides linear regression.; : ; : (More precisely: the ""linear discriminator"" determines; : an axis in the (correlated) hyperspace of the input ; : variables such that, when projecting the output classes ; : (signal and background) upon this axis, they are pushed ; : as far as possible away from each other, while events; : of a same class are confined in a close vicinity. The ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:37092,Energy Efficiency,power,powerful,37092," ; : linearity property of this classifier is reflected in the ; : metric with which ""far apart"" and ""close vicinity"" are ; : determined: the covariance matrix of the discriminating; : variable space.); : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1: -0.309; : myvar2: -0.102; : var3: -0.142; : var4: +0.705; : (offset): -0.055; : -----------------------; : Elapsed time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:39412,Energy Efficiency,power,power,39412,") is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by setting the option; : ""Converger=MINUIT"". GA (MC) will then set the starting parameters; : for MINUIT such that the basic quality of GA (MC) ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:42336,Energy Efficiency,reduce,reduce,42336,": ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would o",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:42414,Energy Efficiency,power,power,42414,": ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would o",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:43066,Energy Efficiency,energy,energy,43066,"rks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:43358,Energy Efficiency,reduce,reduce,43358,"educe the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this messa",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:52701,Energy Efficiency,power,power,52701,"reating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_BDT.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_BDT.class.C␛[0m; : TMVAC.root:/dataset/Method_BDT/BDT; Factory : Training finished; : ; Factory : Train method: RuleFit for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ RuleFit ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : This method uses a collection of so called rules to create a; : discriminating scoring function. Each rule consists of a series; : of cuts in parameter space. The ensemble of rules are created; : from a forest of decision trees, trained using the training data.; : Each node (apart from the root) corresponds to one rule.; : The scoring function is then obtained by linearly combining; : the rules. A fitting procedure is applied to find the optimum; : set of coefficients. The goal is to find a model with few rules; : but with a strong discriminating power.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : There are two important considerations to make when optimising:; : ; : 1. Topology of the decision tree forest; : 2. Fitting of the coefficients; : ; : The maximum complexity of the rules is defined by the size of; : the trees. Large trees will yield many complex rules and capture; : higher order correlations. On the other hand, small trees will; : lead to a smaller ensemble with simple rules, only capable of; : modeling simple structures.; : Several parameters exists for controlling the complexity of the; : rule ensemble.; : ; : The fitting procedure searches for a minimum using a gradient; : directed path. Apart from step size and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:54995,Energy Efficiency,reduce,reduce,54995,"ould be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of ri",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:55630,Energy Efficiency,reduce,reduce,55630," trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:61683,Energy Efficiency,power,power,61683,3e-04; : 3 : myvar2 : -2.045e-02; : 4 : var3 : -2.655e-02; : -------------------------------------; LikelihoodPCA : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Delta Separation; : -------------------------------------; : 1 : var4 : 2.888e-01; : 2 : myvar1 : 6.310e-02; : 3 : var3 : 1.768e-02; : 4 : myvar2 : 1.165e-02; : -------------------------------------; : No variable ranking supplied by classifier: PDERS; PDEFoam : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Variable Importance; : ----------------------------------------; : 1 : var4 : 3.830e-01; : 2 : myvar1 : 2.979e-01; : 3 : var3 : 1.915e-01; : 4 : myvar2 : 1.277e-01; : ----------------------------------------; : No variable ranking supplied by classifier: KNN; LD : Ranking result (top variable is best ranked); : ---------------------------------; : Rank : Variable : Discr. power; : ---------------------------------; : 1 : var4 : 7.053e-01; : 2 : myvar1 : 3.094e-01; : 3 : var3 : 1.423e-01; : 4 : myvar2 : 1.019e-01; : ---------------------------------; : No variable ranking supplied by classifier: FDA_GA; MLPBNN : Ranking result (top variable is best ranked); : -------------------------------; : Rank : Variable : Importance; : -------------------------------; : 1 : var4 : 1.360e+00; : 2 : myvar2 : 1.009e+00; : 3 : myvar1 : 8.834e-01; : 4 : var3 : 3.562e-01; : -------------------------------; : No variable ranking supplied by classifier: DNN_CPU; : No variable ranking supplied by classifier: SVM; BDT : Ranking result (top variable is best ranked); : ----------------------------------------; : Rank : Variable : Variable Importance; : ----------------------------------------; : 1 : var4 : 2.697e-01; : 2 : myvar1 : 2.467e-01; : 3 : myvar2 : 2.460e-01; : 4 : var3 : 2.377e-01; : ----------------------------------------; RuleFit : Ranking result (top variable is best ranked); : -------------,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:95377,Energy Efficiency,adapt,adapting,95377,"imensional probability density estimator; // here are the options strings for the MinMax and RMS methods, respectively:; //; // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; if (Use[""PDERS""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600"" );; ; if (Use[""PDERSD""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSD"",; ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=Decorrelate"" );; ; if (Use[""PDERSPCA""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSPCA"",; ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=PCA"" );; ; // Multi-dimensional likelihood estimator using self-adapting phase-space binning; if (Use[""PDEFoam""]); factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoam"",; ""!H:!V:SigBgSeparate=F:TailCut=0.001:VolFrac=0.0666:nActiveCells=500:nSampl=2000:nBin=5:Nmin=100:Kernel=None:Compress=T"" );; ; if (Use[""PDEFoamBoost""]); factory->BookMethod( dataloader, TMVA::Types::kPDEFoam, ""PDEFoamBoost"",; ""!H:!V:Boost_Num=30:Boost_Transform=linear:SigBgSeparate=F:MaxDepth=4:UseYesNoCell=T:DTLogic=MisClassificationError:FillFoamWithOrigWeights=F:TailCut=0:nActiveCells=500:nBin=20:Nmin=400:Kernel=None:Compress=T"" );; ; // K-Nearest Neighbour classifier (KNN); if (Use[""KNN""]); factory->BookMethod( dataloader, TMVA::Types::kKNN, ""KNN"",; ""H:nkNN=20:ScaleFrac=0.8:SigmaFact=1.0:Kernel=Gaus:UseKernel=F:UseWeight=T:!Trim"" );; ; // H-Matrix (chi2-squared) method; if (Use[""HMatrix""]); factory->BookMethod( dataloader, TMVA::Types::kHMatrix, ""HMatrix"", ""!H:!V:VarTransform=None"" );; ; // Linear discriminant (same as Fisher discriminant); if (Use[""LD""]); factory->BookMethod( dataloade",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1282,Integrability,integrat,integrated,1282,"t data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables. The methods to be used can be switched on and off by means of booleans, or via the prompt command, for example: root -l ./TMVAClassification.C\‍(\""Fisher,Likelihood\""\‍); (note that the backslashes are mandatory) If no method given, a default set of classifiers is used. The output file ""TMVAC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input :",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:7009,Integrability,message,message,7009,"=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layo",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:29056,Integrability,message,message,29056,"PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for training with 2000 events: 0.0149 sec ; Likelihood : [dataset] : Evaluation of Likelihood on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0035 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Likelihood.class.C␛[0m; : TMVAC.root:/dataset/Method_Likelihood/Likelihood; Factory : Training finished; : ; Factory : Train method: LikelihoodPCA for Classification; : ; : Preparing the Principle Component (PCA) transformation...; TFHandler_LikelihoodPCA : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.11433 2.2714 [ -11.272 9.0916 ]; : myvar2: -0.0070834 1.0934 [ -3.9875 3.3836 ]; : var3: 0.011107 0.57824 [ -2.0171 2.1958 ]; : va",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:34279,Integrability,message,message,34279,"orm and constant within the neighborhood. ; : k is an adjustable parameter and it determines an average size of the ; : neighborhood. Small k values (less than 10) are sensitive to statistical ; : fluctuations and large (greater than 100) values might not sufficiently capture ; : local differences between events in the training set. The speed of the k-NN; : method also increases with larger values of k. ; : ; : The k-NN method assigns equal weight to all input variables. Different scales ; : among the input variables is compensated using ScaleFrac parameter: the input ; : variables are scaled so that the widths for central ScaleFrac*100% events are ; : equal among all the input variables.; : ; : ␛[1m--- Additional configuration options: ␛[0m; : ; : The method inclues an option to use a Gaussian kernel to smooth out the k-NN; : response. The kernel re-weights events using a distance to the test event.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; KNN : <Train> start...; : Reading 2000 events; : Number of signal events 1000; : Number of background events 1000; : Creating kd-tree with 2000 events; : Computing scale factor for 1d distributions: (ifrac, bottom, top) = (80%, 10%, 90%); ModulekNN : Optimizing tree for 4 variables with 2000 values; : <Fill> Class 1 has 1000 events; : <Fill> Class 2 has 1000 events; : Elapsed time for training with 2000 events: 0.00292 sec ; KNN : [dataset] : Evaluation of KNN on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0394 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_KNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_KNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: LD for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:37240,Integrability,message,message,37240,"isation:␛[0m; : ; : Optimal performance for the linear discriminant is obtained for ; : linearly correlated Gaussian-distributed variables. Any deviation; : from this ideal reduces the achievable separation power. In ; : particular, no discrimination at all is achieved for a variable; : that has the same sample mean for signal and background, even if ; : the shapes of the distributions are very different. Thus, the linear ; : discriminant often benefits from a suitable transformation of the ; : input variables. For example, if a variable x in [-1,1] has a ; : a parabolic signal distributions, and a uniform background; : distributions, their mean value is zero in both cases, leading ; : to no separation. The simple transformation x -> |x| renders this ; : variable powerful for the use in a linear discriminant.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : <None>; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; LD : Results for LD coefficients:; : -----------------------; : Variable: Coefficient:; : -----------------------; : myvar1: -0.309; : myvar2: -0.102; : var3: -0.142; : var4: +0.705; : (offset): -0.055; : -----------------------; : Elapsed time for training with 2000 events: 0.00103 sec ; LD : [dataset] : Evaluation of LD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000394 sec ; : <CreateMVAPdfs> Separation from histogram (PDF): 0.540 (0.000); : Dataset[dataset] : Evaluation of LD on training sample; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: FDA_GA for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:38984,Integrability,depend,dependent,38984,"dataset/weights/TMVAClassification_LD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_LD.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: FDA_GA for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The function discriminant analysis (FDA) is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recomme",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:39254,Integrability,depend,depends,39254," : ␛[1mH e l p f o r M V A m e t h o d [ FDA_GA ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The function discriminant analysis (FDA) is a classifier suitable ; : to solve linear or simple nonlinear discrimination problems.; : ; : The user provides the desired function with adjustable parameters; : via the configuration option string, and FDA fits the parameters to; : it, requiring the signal (background) function value to be as close; : as possible to 1 (0). Its advantage over the more involved and; : automatic nonlinear discriminators is the simplicity and transparency ; : of the discrimination expression. A shortcoming is that FDA will; : underperform for involved problems with complicated, phase space; : dependent nonlinear correlations.; : ; : Please consult the Users Guide for the format of the formula string; : and the allowed parameter ranges:; : documentation/tmva/UsersGuide/TMVAUsersGuide.pdf; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : The FDA performance depends on the complexity and fidelity of the; : user-defined discriminator function. As a general rule, it should; : be able to reproduce the discrimination power of any linear; : discriminant analysis. To reach into the nonlinear domain, it is; : useful to inspect the correlation profiles of the input variables,; : and add quadratic and higher polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by se",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:40516,Integrability,message,message,40516," polynomial terms between variables as; : necessary. Comparison with more involved nonlinear classifiers can; : be used as a guide.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : Depending on the function used, the choice of ""FitMethod"" is; : crucial for getting valuable solutions with FDA. As a guideline it; : is recommended to start with ""FitMethod=MINUIT"". When more complex; : functions are used where MINUIT does not converge to reasonable; : results, the user should switch to non-gradient FitMethods such; : as GeneticAlgorithm (GA) or Monte Carlo (MC). It might prove to be; : useful to combine GA (or MC) with MINUIT by setting the option; : ""Converger=MINUIT"". GA (MC) will then set the starting parameters; : for MINUIT such that the basic quality of GA (MC) of finding global; : minima is combined with the efficacy of MINUIT of finding local; : minima.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; FitterBase : <GeneticFitter> Optimisation, please be patient ... (inaccurate progress timing for GA); : Elapsed time: 0.901 sec ; FDA_GA : Results for parameter fit using ""GA"" fitter:; : -----------------------; : Parameter: Fit result:; : -----------------------; : Par(0): 0.525294; : Par(1): 0; : Par(2): -0.108508; : Par(3): 0; : Par(4): 0.168653; : -----------------------; : Discriminator expression: ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : Value of estimator at minimum: 0.371531; : Elapsed time for training with 2000 events: 0.936 sec ; FDA_GA : [dataset] : Evaluation of FDA_GA on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.000508 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_FDA_GA.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; :",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:42509,Integrability,interface,interfaced,42509,"actory : Training finished; : ; Factory : Train method: MLPBNN for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ MLPBNN ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The MLP artificial neural network (ANN) is a traditional feed-; : forward multilayer perceptron implementation. The MLP has a user-; : defined hidden layer architecture, while the number of input (output); : nodes is determined by the input variables (output classes, i.e., ; : signal and one background). ; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Neural networks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:44333,Integrability,message,message,44333,"ample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; TFHandler_MLPBNN : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.089214 0.20183 [ -1.0000 1.0000 ]; : myvar2: -0.090751 0.29609 [ -1.0000 1.0000 ]; : var3: 0.059878 0.21436 [ -1.0000 1.0000 ]; : var4: 0.11587 0.24261 [ -1.0000 1.0000 ]; : -----------------------------------------------------------; : Training Network; : ; : Finalizing handling of Regulator terms, trainE=0.713219 testE=0.724617; : Done with handling of Regulator terms; : Elapsed time for training with 2000 events: 2.56 sec ; MLPBNN : [dataset] : Evaluation of MLPBNN on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.0055 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_MLPBNN.class.C␛[0m; : Write special histos to file: TMVAC.root:/dataset/Method_MLP/MLPBNN; Factory : Training finished; : ; Factor",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:53520,Integrability,depend,depends,53520,"early combining; : the rules. A fitting procedure is applied to find the optimum; : set of coefficients. The goal is to find a model with few rules; : but with a strong discriminating power.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : There are two important considerations to make when optimising:; : ; : 1. Topology of the decision tree forest; : 2. Fitting of the coefficients; : ; : The maximum complexity of the rules is defined by the size of; : the trees. Large trees will yield many complex rules and capture; : higher order correlations. On the other hand, small trees will; : lead to a smaller ensemble with simple rules, only capable of; : modeling simple structures.; : Several parameters exists for controlling the complexity of the; : rule ensemble.; : ; : The fitting procedure searches for a minimum using a gradient; : directed path. Apart from step size and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees w",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:55909,Integrability,message,message,55909,"iverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter tau; : By default this value is set to -1.0.; : This means that the cut off parameter is; : automatically estimated. In most cases; : this should be fine. However, you may want; : to fix this value if you already know it; : and want to reduce on training time.; : ␛[1mGDTauPrec ␛[0m: precision of estimated tau; : Increase this precision to find a more; : optimum cut-off parameter.; : ␛[1mGDNStep ␛[0m: number of steps in path search; : If the number of steps is too small, then; : the program will give a warning message.; : ; : III. WARNING MESSAGES; : ; : ␛[1mRisk(i+1)>=Risk(i) in path␛[0m; : ␛[1mChaotic behaviour of risk evolution.␛[0m; : The error rate was still decreasing at the end; : By construction the Risk should always decrease.; : However, if the training sample is too small or; : the model is overtrained, such warnings can; : occur.; : The warnings can safely be ignored if only a; : few (<3) occur. If more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:57189,Integrability,message,message,57189,"more warnings are generated,; : the fitting fails.; : A remedy may be to increase the value; : ␛[1mGDValidEveFrac␛[0m to 1.0 (or a larger value).; : In addition, if ␛[1mGDPathEveFrac␛[0m is too high; : the same warnings may occur since the events; : used for error estimation are also used for; : path estimation.; : Another possibility is to modify the model - ; : See above on tuning the rule ensemble.; : ; : ␛[1mThe error rate was still decreasing at the end of the path␛[0m; : Too few steps in path! Increase ␛[1mGDNSteps␛[0m.; : ; : ␛[1mReached minimum early in the search␛[0m; : Minimum was found early in the fitting. This; : may indicate that the used step size ␛[1mGDStep␛[0m.; : was too large. Reduce it and rerun.; : If the results still are not OK, modify the; : model either by modifying the rule ensemble; : or add/remove linear terms; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanup : 80; : Average number of cuts per rule : 3.01; : Spread in number of cuts per rules : 1.23; : ----------------------------------------------------------------; : ; : GD path scan - the scan stops when the max num. of steps is reached or a min is found; : Estimating the cutoff parameter tau. The estimated time is a pessimistic maximum.; : Best path found with tau = 0.0000 after 2.21 sec ; : Fitting model...; <WARNING> : ; : Minimisation elapsed time : 1.23 sec ; : ----------------------------------------------------------------; : Found minimum at step 10000 with error = 0.552378; : Reason for ending loop: end of loop reached; : ----------------------------------------------------------------; : The error rate was still decreasing at the end of the path; : In",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:93932,Integrability,depend,dependent,93932,"D"",; ""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmooth=5:NAvEvtPerBin=50:VarTransform=Decorrelate"" );; ; // PCA-transformed likelihood; if (Use[""LikelihoodPCA""]); factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodPCA"",; ""!H:!V:!TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmooth=5:NAvEvtPerBin=50:VarTransform=PCA"" );; ; // Use a kernel density estimator to approximate the PDFs; if (Use[""LikelihoodKDE""]); factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodKDE"",; ""!H:!V:!TransformOutput:PDFInterpol=KDE:KDEtype=Gauss:KDEiter=Adaptive:KDEFineFactor=0.3:KDEborder=None:NAvEvtPerBin=50"" );; ; // Use a variable-dependent mix of splines and kernel density estimator; if (Use[""LikelihoodMIX""]); factory->BookMethod( dataloader, TMVA::Types::kLikelihood, ""LikelihoodMIX"",; ""!H:!V:!TransformOutput:PDFInterpolSig[0]=KDE:PDFInterpolBkg[0]=KDE:PDFInterpolSig[1]=KDE:PDFInterpolBkg[1]=KDE:PDFInterpolSig[2]=Spline2:PDFInterpolBkg[2]=Spline2:PDFInterpolSig[3]=Spline2:PDFInterpolBkg[3]=Spline2:KDEtype=Gauss:KDEiter=Nonadaptive:KDEborder=None:NAvEvtPerBin=50"" );; ; // Test the multi-dimensional probability density estimator; // here are the options strings for the MinMax and RMS methods, respectively:; //; // ""!H:!V:VolumeRangeMode=MinMax:DeltaFrac=0.2:KernelEstimator=Gauss:GaussSigma=0.3"" );; // ""!H:!V:VolumeRangeMode=RMS:DeltaFrac=3:KernelEstimator=Gauss:GaussSigma=0.3"" );; if (Use[""PDERS""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERS"",; ""!H:!V:NormTree=T:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600"" );; ; if (Use[""PDERSD""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSD"",; ""!H:!V:VolumeRangeMode=Adaptive:KernelEstimator=Gauss:GaussSigma=0.3:NEventsMin=400:NEventsMax=600:VarTransform=Decorrelate"" );; ; if (Use[""PDERSPCA""]); factory->BookMethod( dataloader, TMVA::Types::kPDERS, ""PDERSPCA"",; ""!H:!V:VolumeRangeMo",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:419,Modifiability,variab,variables,419,". ROOT: tutorials/tmva/TMVAClassification.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TMVAClassification.C File ReferenceTutorials » TMVA tutorials. Detailed Description; This macro provides examples for the training and testing of the TMVA classifiers. ; As input data is used a toy-MC sample consisting of four Gaussian-distributed and linearly correlated input variables. The methods to be used can be switched on and off by means of booleans, or via the prompt command, for example: root -l ./TMVAClassification.C\‍(\""Fisher,Likelihood\""\‍); (note that the backslashes are mandatory) If no method given, a default set of classifiers is used. The output file ""TMVAC.root"" can be analysed with the use of dedicated macros (simply say: root -l <macro.C>), which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1861,Modifiability,variab,variable,1861,"which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1905,Modifiability,variab,variable,1905,"which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1949,Modifiability,variab,variable,1949,"which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:1991,Modifiability,variab,variable,1991,"which can be conveniently invoked through a GUI that will appear at the end of the run of this macro. Launch the GUI via the command: root -l ./TMVAGui.C; You can also compile and run the example with the following commands make; ./TMVAClassification <Methods>; where: <Methods> = ""method1 method2"" are the TMVA classifier names example: ./TMVAClassification Fisher LikelihoodPCA BDT; If no method given, a default set is of classifiers is used. Project : TMVA - a ROOT-integrated toolkit for multivariate data analysis; Package : TMVA; Root Macro: TMVAClassification. ; ; ==> Start TMVAClassification; --- TMVAClassification : Using input file: ./files/tmva_class_example.root; DataSetInfo : [dataset] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2196,Modifiability,variab,variable,2196,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2229,Modifiability,variab,variable,2229,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2258,Modifiability,variab,variable,2258,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2291,Modifiability,variab,variable,2291,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2320,Modifiability,variab,variable,2320,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2351,Modifiability,variab,variable,2351,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2378,Modifiability,variab,variable,2378,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2409,Modifiability,variab,variable,2409,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2548,Modifiability,variab,variable,2548,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2592,Modifiability,variab,variable,2592,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2636,Modifiability,variab,variable,2636,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2678,Modifiability,variab,variable,2678,"et] : Added class ""Signal""; : Add Tree TreeS of type Signal with 6000 events; DataSetInfo : [dataset] : Added class ""Background""; : Add Tree TreeB of type Background with 6000 events; Factory : Booking method: ␛[1mCuts␛[0m; : ; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mCutsD␛[0m; : ; CutsD : [dataset] : Create Transformation ""Decorrelate"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Use optimization method: ""Monte Carlo""; : Use efficiency computation method: ""Event Selection""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for ty",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2941,Modifiability,variab,variable,2941,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:2974,Modifiability,variab,variable,2974,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3003,Modifiability,variab,variable,3003,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3036,Modifiability,variab,variable,3036,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3065,Modifiability,variab,variable,3065,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3096,Modifiability,variab,variable,3096,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3123,Modifiability,variab,variable,3123,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:3154,Modifiability,variab,variable,3154,"""; : Use ""FSmart"" cuts for variable: 'myvar1'; : Use ""FSmart"" cuts for variable: 'myvar2'; : Use ""FSmart"" cuts for variable: 'var3'; : Use ""FSmart"" cuts for variable: 'var4'; Factory : Booking method: ␛[1mLikelihood␛[0m; : ; Factory : Booking method: ␛[1mLikelihoodPCA␛[0m; : ; LikelihoodPCA : [dataset] : Create Transformation ""PCA"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mPDERS␛[0m; : ; Factory : Booking method: ␛[1mPDEFoam␛[0m; : ; Factory : Booking method: ␛[1mKNN␛[0m; : ; Factory : Booking method: ␛[1mLD␛[0m; : ; : Rebuilding Dataset dataset; : Building event vectors for type 2 Signal; : Dataset[dataset] : create input formulas for tree TreeS; : Building event vectors for type 2 Background; : Dataset[dataset] : create input formulas for tree TreeB; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1000; : Signal -- testing events : 5000; : Signal -- training and testing events: 6000; : Background -- training events : 1000; : Background -- testing events : 5000; : Background -- training and testing events: 6000; : ; DataSetInfo : Correlation matrix (Signal):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 +0.038 +0.748 +0.922; : myvar2: +0.038 +1.000 -0.058 +0.128; : var3: +0.748 -0.058 +1.000 +0.831; : var4: +0.922 +0.128 +0.831 +1.000; : ----------------------------------------; DataSetInfo : Correlation matrix (Background):; : ----------------------------------------; : myvar1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.00",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5338,Modifiability,variab,variable,5338,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5371,Modifiability,variab,variable,5371,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5400,Modifiability,variab,variable,5400,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5433,Modifiability,variab,variable,5433,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5462,Modifiability,variab,variable,5462,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5493,Modifiability,variab,variable,5493,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5520,Modifiability,variab,variable,5520,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:5551,Modifiability,variab,variable,5551,"var1 myvar2 var3 var4; : myvar1: +1.000 -0.021 +0.783 +0.931; : myvar2: -0.021 +1.000 -0.162 +0.057; : var3: +0.783 -0.162 +1.000 +0.841; : var4: +0.931 +0.057 +0.841 +1.000; : ----------------------------------------; DataSetFactory : [dataset] : ; : ; Factory : Booking method: ␛[1mFDA_GA␛[0m; : ; : Create parameter interval for parameter 0 : [-1,1]; : Create parameter interval for parameter 1 : [-10,10]; : Create parameter interval for parameter 2 : [-10,10]; : Create parameter interval for parameter 3 : [-10,10]; : Create parameter interval for parameter 4 : [-10,10]; : User-defined formula string : ""(0)+(1)*x0+(2)*x1+(3)*x2+(4)*x3""; : TFormula-compatible formula string: ""[0]+[1]*[5]+[2]*[6]+[3]*[7]+[4]*[8]""; Factory : Booking method: ␛[1mMLPBNN␛[0m; : ; MLPBNN : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; MLPBNN : Building Network. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=No",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:6660,Modifiability,variab,variable,6660,"ork. ; : Initializing weights; Factory : Booking method: ␛[1mDNN_CPU␛[0m; : ; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : <none>; : - Default:; : Boost_num: ""0"" [Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : Verbosit",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8393,Modifiability,variab,variable,8393,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8426,Modifiability,variab,variable,8426,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8455,Modifiability,variab,variable,8455,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8488,Modifiability,variab,variable,8488,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8517,Modifiability,variab,variable,8517,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8548,Modifiability,variab,variable,8548,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8575,Modifiability,variab,variable,8575,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8606,Modifiability,variab,variable,8606,"efault:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : vari",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8864,Modifiability,variab,variable,8864,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8897,Modifiability,variab,variable,8897,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8926,Modifiability,variab,variable,8926,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8959,Modifiability,variab,variable,8959,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:8988,Modifiability,variab,variable,8988,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9019,Modifiability,variab,variable,9019,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9046,Modifiability,variab,variable,9046,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9077,Modifiability,variab,variable,9077,"; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; DNN_CPU : [dataset] : Create Transformation ""N"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Var",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9355,Modifiability,variab,variable,9355,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9388,Modifiability,variab,variable,9388,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9417,Modifiability,variab,variable,9417,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9450,Modifiability,variab,variable,9450,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9479,Modifiability,variab,variable,9479,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9510,Modifiability,variab,variable,9510,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9537,Modifiability,variab,variable,9537,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9568,Modifiability,variab,variable,9568,"utput : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; : Will now use the CPU architecture with BLAS and IMT support !; Factory : Booking method: ␛[1mSVM␛[0m; : ; SVM : [dataset] : Create Transformation ""Norm"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9719,Modifiability,variab,variable,9719,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9752,Modifiability,variab,variable,9752,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9781,Modifiability,variab,variable,9781,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9814,Modifiability,variab,variable,9814,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9843,Modifiability,variab,variable,9843,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9874,Modifiability,variab,variable,9874,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9901,Modifiability,variab,variable,9901,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:9932,Modifiability,variab,variable,9932,"ction : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : Booking method: ␛[1mBDT␛[0m; : ; Factory : Booking method: ␛[1mRuleFit␛[0m; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10083,Modifiability,variab,variable,10083,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10116,Modifiability,variab,variable,10116,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10145,Modifiability,variab,variable,10145,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10178,Modifiability,variab,variable,10178,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10207,Modifiability,variab,variable,10207,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10238,Modifiability,variab,variable,10238,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10265,Modifiability,variab,variable,10265,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10296,Modifiability,variab,variable,10296,"methods␛[0m; Factory : [dataset] : Create Transformation ""I"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myva",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10447,Modifiability,variab,variable,10447,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10480,Modifiability,variab,variable,10480,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10509,Modifiability,variab,variable,10509,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10542,Modifiability,variab,variable,10542,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10571,Modifiability,variab,variable,10571,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10602,Modifiability,variab,variable,10602,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10629,Modifiability,variab,variable,10629,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10660,Modifiability,variab,variable,10660,"able 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10811,Modifiability,variab,variable,10811,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10844,Modifiability,variab,variable,10844,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10873,Modifiability,variab,variable,10873,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10906,Modifiability,variab,variable,10906,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10935,Modifiability,variab,variable,10935,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10966,Modifiability,variab,variable,10966,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:10993,Modifiability,variab,variable,10993,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:11024,Modifiability,variab,variable,11024,"ataset] : Create Transformation ""P"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""G"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; Factory : [dataset] : Create Transformation ""D"" with events from all classes.; : ; : Transformation, Variable selection : ; : Input : variable 'myvar1' <---> Output : variable 'myvar1'; : Input : variable 'myvar2' <---> Output : variable 'myvar2'; : Input : variable 'var3' <---> Output : variable 'var3'; : Input : variable 'var4' <---> Output : variable 'var4'; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.062775 1.7187 [ -9.3380 7.6931 ]; : myvar2: 0.056495 1.0784 [ -3.2551 4.0291 ]; : var3: -0.020366 1.0633 [ -5.2777 4.6430 ]; : var4: 0.13214 1.2464 [ -5.6007 4.6744 ]; : -----------------------------------------------------------; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:12699,Modifiability,variab,variables,12699," 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; : Preparing the Principle Component (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.11433 2.2714 [ -11.272 9.0916 ]; : myvar2: -0.0070834 1.0934 [ -3.9875 3.3836 ]; : var3: 0.011107 0.57824 [ -2.0171 2.1958 ]; : var4: -0.0094450 0.33437 [ -1.0176 1.0617 ]; : -----------------------------------------------------------; : Preparing the Gaussian transformation...; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.049483 1.0000 [ -3.0916 8.1528 ]; : myvar2: -0.0017889 1.0000 [ -4.5911 5.6465 ]; : var3: -0.0056513 1.0000 [ -3.1504 4.5978 ]; : var4: 0.070934 1.0000 [ -3.4539 5.9256 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; IdTransformation : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Separation; : -------------------------------------; : 1 : Variable 4 : 2.843e-01; : 2 : Variable 3 : 1.756e-01; : 3 : myvar1 : 1.018e-01; : 4 : Expression 2 : 3.860e-02; : -------------------------------------; Factory : Train method: Cuts for Classification; : ; FitterBase : <MCFitter> Sampling, please be patient ...; : Elapsed time: 3.53 sec ; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.1; : Corresponding background efficiency : 0.00621902; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.19223 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.126; : Cut[ 2]: -2.90978 < var3 <= 1e+30; : Cut[ 3]: 2.16207 < var4 <= 1e+30; : ------------------------------------------; : --------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:12772,Modifiability,variab,variable,12772,"mponent (PCA) transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.11433 2.2714 [ -11.272 9.0916 ]; : myvar2: -0.0070834 1.0934 [ -3.9875 3.3836 ]; : var3: 0.011107 0.57824 [ -2.0171 2.1958 ]; : var4: -0.0094450 0.33437 [ -1.0176 1.0617 ]; : -----------------------------------------------------------; : Preparing the Gaussian transformation...; : Preparing the Decorrelation transformation...; TFHandler_Factory : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.049483 1.0000 [ -3.0916 8.1528 ]; : myvar2: -0.0017889 1.0000 [ -4.5911 5.6465 ]; : var3: -0.0056513 1.0000 [ -3.1504 4.5978 ]; : var4: 0.070934 1.0000 [ -3.4539 5.9256 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; IdTransformation : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Separation; : -------------------------------------; : 1 : Variable 4 : 2.843e-01; : 2 : Variable 3 : 1.756e-01; : 3 : myvar1 : 1.018e-01; : 4 : Expression 2 : 3.860e-02; : -------------------------------------; Factory : Train method: Cuts for Classification; : ; FitterBase : <MCFitter> Sampling, please be patient ...; : Elapsed time: 3.53 sec ; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.1; : Corresponding background efficiency : 0.00621902; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.19223 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.126; : Cut[ 2]: -2.90978 < var3 <= 1e+30; : Cut[ 3]: 2.16207 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.0171253; : Transformation applied",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:13396,Modifiability,variab,variables,13396,"--------------------; : myvar1: -0.049483 1.0000 [ -3.0916 8.1528 ]; : myvar2: -0.0017889 1.0000 [ -4.5911 5.6465 ]; : var3: -0.0056513 1.0000 [ -3.1504 4.5978 ]; : var4: 0.070934 1.0000 [ -3.4539 5.9256 ]; : -----------------------------------------------------------; : Ranking input variables (method unspecific)...; IdTransformation : Ranking result (top variable is best ranked); : -------------------------------------; : Rank : Variable : Separation; : -------------------------------------; : 1 : Variable 4 : 2.843e-01; : 2 : Variable 3 : 1.756e-01; : 3 : myvar1 : 1.018e-01; : 4 : Expression 2 : 3.860e-02; : -------------------------------------; Factory : Train method: Cuts for Classification; : ; FitterBase : <MCFitter> Sampling, please be patient ...; : Elapsed time: 3.53 sec ; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.1; : Corresponding background efficiency : 0.00621902; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.19223 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.126; : Cut[ 2]: -2.90978 < var3 <= 1e+30; : Cut[ 3]: 2.16207 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.0171253; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.85714 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.21109; : Cut[ 2]: -0.759439 < var3 <= 1e+30; : Cut[ 3]: 1.66846 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.0401486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -6.09813 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 <",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:13842,Modifiability,variab,variables,13842,"Separation; : -------------------------------------; : 1 : Variable 4 : 2.843e-01; : 2 : Variable 3 : 1.756e-01; : 3 : myvar1 : 1.018e-01; : 4 : Expression 2 : 3.860e-02; : -------------------------------------; Factory : Train method: Cuts for Classification; : ; FitterBase : <MCFitter> Sampling, please be patient ...; : Elapsed time: 3.53 sec ; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.1; : Corresponding background efficiency : 0.00621902; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.19223 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.126; : Cut[ 2]: -2.90978 < var3 <= 1e+30; : Cut[ 3]: 2.16207 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.0171253; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.85714 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.21109; : Cut[ 2]: -0.759439 < var3 <= 1e+30; : Cut[ 3]: 1.66846 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.0401486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -6.09813 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.81831; : Cut[ 2]: -2.09336 < var3 <= 1e+30; : Cut[ 3]: 1.34308 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.062887; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -4.55141 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 <",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:14291,Modifiability,variab,variables,14291,; : Corresponding background efficiency : 0.00621902; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.19223 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.126; : Cut[ 2]: -2.90978 < var3 <= 1e+30; : Cut[ 3]: 2.16207 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.0171253; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.85714 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.21109; : Cut[ 2]: -0.759439 < var3 <= 1e+30; : Cut[ 3]: 1.66846 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.0401486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -6.09813 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.81831; : Cut[ 2]: -2.09336 < var3 <= 1e+30; : Cut[ 3]: 1.34308 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.062887; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -4.55141 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.94573; : Cut[ 2]: -4.68697 < var3 <= 1e+30; : Cut[ 3]: 1.07157 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.104486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.86032 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < m,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:14738,Modifiability,variab,variables,14738, : Corresponding background efficiency : 0.0171253; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.85714 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.21109; : Cut[ 2]: -0.759439 < var3 <= 1e+30; : Cut[ 3]: 1.66846 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.0401486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -6.09813 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.81831; : Cut[ 2]: -2.09336 < var3 <= 1e+30; : Cut[ 3]: 1.34308 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.062887; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -4.55141 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.94573; : Cut[ 2]: -4.68697 < var3 <= 1e+30; : Cut[ 3]: 1.07157 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.104486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.86032 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.89615; : Cut[ 2]: -0.966191 < var3 <= 1e+30; : Cut[ 3]: 0.773848 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.172806; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.52552 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 <,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:15185,Modifiability,variab,variables,15185,3; : Corresponding background efficiency : 0.0401486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -6.09813 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.81831; : Cut[ 2]: -2.09336 < var3 <= 1e+30; : Cut[ 3]: 1.34308 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.062887; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -4.55141 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.94573; : Cut[ 2]: -4.68697 < var3 <= 1e+30; : Cut[ 3]: 1.07157 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.104486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.86032 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.89615; : Cut[ 2]: -0.966191 < var3 <= 1e+30; : Cut[ 3]: 0.773848 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.172806; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.52552 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 4.08498; : Cut[ 2]: -2.61706 < var3 <= 1e+30; : Cut[ 3]: 0.469684 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.258379; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.69875 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 ,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:15634,Modifiability,variab,variables,15634,; : Corresponding background efficiency : 0.062887; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -4.55141 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.94573; : Cut[ 2]: -4.68697 < var3 <= 1e+30; : Cut[ 3]: 1.07157 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.104486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.86032 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.89615; : Cut[ 2]: -0.966191 < var3 <= 1e+30; : Cut[ 3]: 0.773848 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.172806; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.52552 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 4.08498; : Cut[ 2]: -2.61706 < var3 <= 1e+30; : Cut[ 3]: 0.469684 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.258379; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.69875 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 1.73784; : Cut[ 2]: -1.21467 < var3 <= 1e+30; : Cut[ 3]: 0.109026 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.362964; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.99372 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 <,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:16082,Modifiability,variab,variables,16082, : Corresponding background efficiency : 0.104486; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.86032 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 2.89615; : Cut[ 2]: -0.966191 < var3 <= 1e+30; : Cut[ 3]: 0.773848 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.172806; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.52552 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 4.08498; : Cut[ 2]: -2.61706 < var3 <= 1e+30; : Cut[ 3]: 0.469684 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.258379; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.69875 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 1.73784; : Cut[ 2]: -1.21467 < var3 <= 1e+30; : Cut[ 3]: 0.109026 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.362964; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.99372 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 3.93767; : Cut[ 2]: -1.56317 < var3 <= 1e+30; : Cut[ 3]: -0.124013 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.9; : Corresponding background efficiency : 0.503885; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -3.97304 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 ,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:16530,Modifiability,variab,variables,16530,; : Corresponding background efficiency : 0.172806; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.52552 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 4.08498; : Cut[ 2]: -2.61706 < var3 <= 1e+30; : Cut[ 3]: 0.469684 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.258379; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.69875 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 1.73784; : Cut[ 2]: -1.21467 < var3 <= 1e+30; : Cut[ 3]: 0.109026 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.362964; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.99372 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 3.93767; : Cut[ 2]: -1.56317 < var3 <= 1e+30; : Cut[ 3]: -0.124013 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.9; : Corresponding background efficiency : 0.503885; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -3.97304 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 3.31284; : Cut[ 2]: -2.82879 < var3 <= 1e+30; : Cut[ 3]: -0.577302 < var4 <= 1e+30; : ------------------------------------------; : Elapsed time for training with 2000 events: 3.54 sec ; Cuts : [dataset] : Evaluation of Cuts on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00192 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Cuts.weights.xml␛[0m; : Creating standalone cla,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:16979,Modifiability,variab,variables,16979, : Corresponding background efficiency : 0.258379; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -5.69875 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 1.73784; : Cut[ 2]: -1.21467 < var3 <= 1e+30; : Cut[ 3]: 0.109026 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.362964; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -1.99372 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 3.93767; : Cut[ 2]: -1.56317 < var3 <= 1e+30; : Cut[ 3]: -0.124013 < var4 <= 1e+30; : ------------------------------------------; : ------------------------------------------; Cuts : Cut values for requested signal efficiency: 0.9; : Corresponding background efficiency : 0.503885; : Transformation applied to input variables : None; : ------------------------------------------; : Cut[ 0]: -3.97304 < myvar1 <= 1e+30; : Cut[ 1]: -1e+30 < myvar2 <= 3.31284; : Cut[ 2]: -2.82879 < var3 <= 1e+30; : Cut[ 3]: -0.577302 < var4 <= 1e+30; : ------------------------------------------; : Elapsed time for training with 2000 events: 3.54 sec ; Cuts : [dataset] : Evaluation of Cuts on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00192 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_Cuts.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_Cuts.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/Cuts; Factory : Training finished; : ; Factory : Train method: CutsD for Classification; : ; : Preparing the Decorrelation transformation...; TFHandler_CutsD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var,MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:18838,Modifiability,variab,variables,18838,"----------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; TFHandler_CutsD : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: -0.17586 1.0000 [ -5.6401 4.8529 ]; : myvar2: 0.026952 1.0000 [ -2.9292 3.7065 ]; : var3: -0.11549 1.0000 [ -4.1792 3.5180 ]; : var4: 0.34819 1.0000 [ -3.3363 3.3963 ]; : -----------------------------------------------------------; FitterBase : <MCFitter> Sampling, please be patient ...; : Elapsed time: 2.77 sec ; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.1; : Corresponding background efficiency : 0; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 0.513038; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= -0.733858; : Cut[ 2]: -0.87113 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.687739 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.000493656; : Transformation applied to input variables : ""Deco""; : ----------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:19790,Modifiability,variab,variables,19790,"Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 0.513038; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= -0.733858; : Cut[ 2]: -0.87113 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.687739 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.2; : Corresponding background efficiency : 0.000493656; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 1.60056; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 1.26936; : Cut[ 2]: -1.50073 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.54845 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.00334252; : Transformation applied to input variables : ""Deco""; : ---------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:20737,Modifiability,variab,variables,20737," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 1.60056; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 1.26936; : Cut[ 2]: -1.50073 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.54845 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.3; : Corresponding background efficiency : 0.00334252; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 2.16898; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 3.25932; : Cut[ 2]: -2.08503 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.43959 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.00821453; : Transformation applied to input variables : ""Deco""; : ---------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:21684,Modifiability,variab,variables,21684," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 2.16898; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 3.25932; : Cut[ 2]: -2.08503 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.43959 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.4; : Corresponding background efficiency : 0.00821453; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 1.9086; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 1.94778; : Cut[ 2]: -2.11471 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.1885 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.0209024; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:22628,Modifiability,variab,variables,22628,"les : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 1.9086; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 1.94778; : Cut[ 2]: -2.11471 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 1.1885 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.5; : Corresponding background efficiency : 0.0209024; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 3.97301; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.87835; : Cut[ 2]: -1.68889 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.969507 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.055037; : Transformation applied to input variables : ""Deco""; : -----------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:23574,Modifiability,variab,variables,23574," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 3.97301; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.87835; : Cut[ 2]: -1.68889 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.969507 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.6; : Corresponding background efficiency : 0.055037; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 2.57624; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.20263; : Cut[ 2]: -3.86902 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.802122 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.0975699; : Transformation applied to input variables : ""Deco""; : ----------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:24521,Modifiability,variab,variables,24521," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 2.57624; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.20263; : Cut[ 2]: -3.86902 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.802122 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.7; : Corresponding background efficiency : 0.0975699; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 3.65719; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 3.19411; : Cut[ 2]: -2.87372 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.583961 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.170999; : Transformation applied to input variables : ""Deco""; : -----------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:25467,Modifiability,variab,variables,25467," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 3.65719; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 3.19411; : Cut[ 2]: -2.87372 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.583961 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.8; : Corresponding background efficiency : 0.170999; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 4.74857; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.75269; : Cut[ 2]: -3.22043 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.327788 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.9; : Corresponding background efficiency : 0.326977; : Transformation applied to input variables : ""Deco""; : -----------------------------------------------------------------------------------------------",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:26413,Modifiability,variab,variables,26413," : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 4.74857; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 2.75269; : Cut[ 2]: -3.22043 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.327788 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : ------------------------------------------------------------------------------------------------------------------------; CutsD : Cut values for requested signal efficiency: 0.9; : Corresponding background efficiency : 0.326977; : Transformation applied to input variables : ""Deco""; : ------------------------------------------------------------------------------------------------------------------------; : Cut[ 0]: -1e+30 < + 1.1476*[myvar1] + 0.027923*[myvar2] - 0.19981*[var3] - 0.82843*[var4] <= 3.56614; : Cut[ 1]: -1e+30 < + 0.027923*[myvar1] + 0.95469*[myvar2] + 0.18581*[var3] - 0.1623*[var4] <= 3.09071; : Cut[ 2]: -3.9944 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.0311777 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : Elapsed time for training with 2000 events: 2.78 sec ; CutsD : [dataset] : Evaluation of CutsD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00312 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:27948,Modifiability,variab,variables,27948,"2] + 0.18581*[var3] - 0.1623*[var4] <= 3.09071; : Cut[ 2]: -3.9944 < - 0.19981*[myvar1] + 0.18581*[myvar2] + 1.7913*[var3] - 0.77231*[var4] <= 1e+30; : Cut[ 3]: 0.0311777 < - 0.82843*[myvar1] - 0.1623*[myvar2] - 0.77231*[var3] + 2.1918*[var4] <= 1e+30; : ------------------------------------------------------------------------------------------------------------------------; : Elapsed time for training with 2000 events: 2.78 sec ; CutsD : [dataset] : Evaluation of CutsD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00312 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:27986,Modifiability,variab,variables,27986,"-------------------------------------------------------------------------------------------------------------; : Elapsed time for training with 2000 events: 2.78 sec ; CutsD : [dataset] : Evaluation of CutsD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00312 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28114,Modifiability,variab,variables,28114,"e for training with 2000 events: 2.78 sec ; CutsD : [dataset] : Evaluation of CutsD on training sample (2000 events); : Elapsed time for evaluation of 2000 events: 0.00312 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; ",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
https://root.cern/doc/master/TMVAClassification_8C.html:28303,Modifiability,variab,variables,28303,"; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_CutsD.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_CutsD.class.C␛[0m; : TMVAC.root:/dataset/Method_Cuts/CutsD; Factory : Training finished; : ; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,doc/master/TMVAClassification_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html
