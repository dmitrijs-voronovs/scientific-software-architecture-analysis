id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html602/TTree.html:79469,Modifiability,variab,variables,79469,"r AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the min",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:79530,Modifiability,variab,variable,79530,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:81439,Modifiability,variab,variable,81439,"he formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In par",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:82704,Modifiability,variab,variable,82704,"ill draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:84445,Modifiability,variab,variables,84445,"le). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one varia",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:84758,Modifiability,variab,variables,84758,"etails on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:85058,Modifiability,variab,variables,85058,"=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:85440,Modifiability,variab,variable,85440,"using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory; tree.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListA",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:95325,Modifiability,config,configuration,95325,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:108877,Modifiability,variab,variables,108877,"ated by this function.; In a ROOT session, you can do:; root > .L MyClass.C; root > MyClass* t = new MyClass;; root > t->GetEntry(12); // Fill data members of t with entry number 12.; root > t->Show(); // Show values of entry 12.; root > t->Show(16); // Read and show values of entry 16.; root > t->Loop(); // Loop on all entries. NOTE: Do not use the code generated for a single TTree which is part; of a TChain to process that entire TChain. The maximum dimensions; calculated for arrays on the basis of a single TTree from the TChain; might be (will be!) too small when processing all of the TTrees in; the TChain. You must use myChain.MakeClass() to generate the code,; not myTree.MakeClass(...). Int_t MakeCode(const char* filename = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:111633,Modifiability,variab,variables,111633,"TreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:111707,Modifiability,variab,variable,111707,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:112837,Modifiability,variab,variable,112837," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:116676,Modifiability,variab,variables,116676," Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:116764,Modifiability,variab,variables,116764," Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122759,Modifiability,variab,variable,122759,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122838,Modifiability,variab,variable,122838,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122891,Modifiability,variab,variable,122891,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122927,Modifiability,variab,variables,122927,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122975,Modifiability,variab,variables,122975,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:123477,Modifiability,variab,variables,123477," or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:123831,Modifiability,variab,variable,123831,"of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:125915,Modifiability,variab,variable,125915," Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:125989,Modifiability,variab,variables,125989,"t baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -300000",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:130620,Modifiability,variab,variables,130620," and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); Set branch status to Process or DoNotProcess. When reading a Tree, by default, all branches are read.; One can speed up considerably the analysis phase by activating; only the branches that hold variables involved in a query. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; status = 1 branch will be processed; = 0 branch will not be processed; Example:; Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..; when doing T.GetEntry(i) all branches are read for entry i.; to read only the branches c and e, one can do; T.SetBranchStatus(""*"",0); //disable all branches; T.SetBranchStatus(""c"",1);; T.setBranchStatus(""e"",1);; T.GetEntry(i);. bname is interpreted as a wildcarded TRegexp (see TRegexp::MakeWildcard).; Thus, ""a*b"" or ""a.*b"" matches branches starting with ""a"" and ending with; ""b"", but not any other branch with an ""a"" followed at some point by a; ""b"". For this second behavior, use ""*a*b*"". Note that TRegExp does not; support '|', and so you cannot select, e.g. track and shower branches; with ""track|shower"". WARNING! WARNI",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:136288,Modifiability,variab,variable,136288,"r. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); This function transfroms the given TEventList into a TEntryList; The new TEntryList is owned by the TTree and gets deleted when the tree; is deleted. This TEntryList can be returned by GetEntryList() function. void SetEstimate(Long64_t nentries = 1000000); Set number of entries to estimate variable limits.; If n is -1, the estimate is set to be the current maximum; for the tree (i.e. GetEntries() + 1); If n is less than -1, the behavior is undefined. void SetFileNumber(Int_t number = 0); Set fFileNumber to number.; fFileNumber is used by TTree::Fill to set the file name; for a new file to be created when the current file exceeds fgTreeMaxSize.; (see TTree::ChangeFile); if fFileNumber=10, the new file name will have a suffix ""_11"",; ie, fFileNumber is incremented before setting the file name. void SetMakeClass(Int_t make); Set all the branches in this TTree to be in decomposed object mode; (also known as MakeClass mode). void SetMaxTreeSize(Long64_t maxsize = 1900000000); Set the maximum size in bytes of a Tree file (static function).; The default size is 100000000000LL, ie 100 Gigabytes. In TTree::Fill, when the file has a size > fgMaxTreeSize,; the function closes the current file and starts writing into; a new file with a name of the st",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:139187,Modifiability,variab,variable,139187,"y TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:139306,Modifiability,variab,variable,139306," option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectiv",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:140415,Modifiability,variab,variable,140415,"ptions is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushB",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:9025,Performance,perform,performance,9025,"o copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:26112,Performance,cache,cachesize,26112,"ion = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = -30000000); virtual voidSetAutoSave(Long64_t autos = 300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:30959,Performance,cache,cacheSize,30959,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree&operator=(const TTree& tt); TTree(const TTree& tt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTree::(anonymous)kCircular; static TTree::ESetBr",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:32854,Performance,cache,cache,32854,:ESetBranchAddressStatuskMissingCompiledCollectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tfAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColo,MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:32984,Performance,cache,cache,32984,:ESetBranchAddressStatuskMissingCompiledCollectionProxy; static TObject::EStatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatuskNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatuskVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tfAutoSaveAutosave tree when fAutoSave bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColo,MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:35089,Performance,load,loading,35089,dex values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tfNfill! Local for EntryLoop; TObject*fNotify! Object to be notified when loading a Tree; Int_tfPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*fPlayer! Pointer to current Tree player; Long64_tfReadEntry! Number of the entry being processed; Long64_tfSavedBytesNumber of autosaved bytes; Int_tfScanFieldNumber of runs before prompting in Scan; Int_tfTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all branches before compression; Long64_tfTotalBuffers! Total number of bytes in branch buffers; TBuffer*fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*fTreeIndexPointer to the tree Index (if any); Int_tfUpdateUpdate frequency for EntryLoop; TList*fUserInfopointer to a list of user objects associated to this Tree; Double_tfWeightTree weight (see TTree::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitskFindBranch;,MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:37713,Performance,cache,cache,37713,"kRemoveFriend; static TTree::ELockStatusBitskSetBranchStatus. Class Charts. Inheritance Chart:. TObject. ; TNamed. TAttLine. TAttFill. TAttMarker. ; TTree. . TChain; . TProofChain. THbookTree. TNtuple. TNtupleD. TTreeSQL. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:37764,Performance,cache,cache,37764,"nce Chart:. TObject. ; TNamed. TAttLine. TAttFill. TAttMarker. ; TTree. . TChain; . TProofChain. THbookTree. TNtuple. TNtupleD. TTreeSQL. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filenam",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:37852,Performance,cache,cache,37852,"ee. . TChain; . TProofChain. THbookTree. TNtuple. TNtupleD. TTreeSQL. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:;",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:37953,Performance,cache,cache,37953,"; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (curren",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38041,Performance,cache,cache,38041,"urrent directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendE",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38172,Performance,cache,cache,38172," The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38227,Performance,cache,cache,38227," branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree kee",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38321,Performance,cache,cache,38321,"ion assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship m",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38434,Performance,cache,cache,38434,"chy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:38528,Performance,cache,cache,38528,"TransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFr",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:63531,Performance,optimiz,optimize,63531,"; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:63727,Performance,perform,performance,63727,"word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree fro",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:82494,Performance,load,load,82494,"Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:83247,Performance,load,loading,83247,"(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is a",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:87328,Performance,load,loaded,87328,"e.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListArray object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Using a TEventList, TEntryList or TEntryListArray as Input. Once a TEventList or a TEntryList object has been generated, it can be used as input; for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; current event list; Example1:; TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; Example2:; TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; If a TEventList object is used as input, a new TEntryList object is created; inside the SetEventList function. In case of a TChain, all tree headers are loaded; for this transformation. This new object is owned by the chain and is deleted; with it, unless the user extracts it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection criteria and TEntryListArray is not used,; all the entries that have at least one element of the array that satisfy the selection; are entered in the list.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:92485,Performance,optimiz,optimize,92485," to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In cas",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:95211,Performance,cache,cache,95211,"ave the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:95258,Performance,cache,cache,95258," Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:95287,Performance,cache,cache,95287,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:100659,Performance,perform,performs,100659,"MPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pa",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:101478,Performance,perform,performs,101478," and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); Read entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TTree* GetFriend(const char* ) const; Return a pointer to the TTree friend whose name or alias is 'friendname. const char* GetFriendAlias(TTree* ) const; If the 'tree' is a friend, this method returns its alias name. This alias is an alternate name for the tree. It can be used in conjunction with a branch or leaf ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:104912,Performance,cache,cache,104912,"ctoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; T",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:104933,Performance,cache,cache,104933,"ctoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; T",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:106035,Performance,load,loading,106035,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:110674,Performance,load,loading,110674,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:111750,Performance,cache,cache,111750,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:112785,Performance,load,loaded,112785,"fficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameo",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:112929,Performance,load,loaded,112929,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:115545,Performance,cache,cache,115545,"u can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Lon",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:115677,Performance,cache,cache,115677,"memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPri",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:115733,Performance,load,loading,115733,"tion = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipa",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:116048,Performance,optimiz,optimize,116048,"* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" a",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:118158,Performance,cache,cache,118158,"xplanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): cal",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:118234,Performance,cache,cache,118234,"ncipal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:118562,Performance,load,loaded,118562,"hes are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:119395,Performance,load,loaded,119395,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:119490,Performance,load,loaded,119490,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:119601,Performance,load,loaded,119601,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:127836,Performance,optimiz,optimize,127836,"e->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -30000000); This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:132869,Performance,cache,cachesize,132869,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buf",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:132915,Performance,cache,cache,132915,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buf",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:132927,Performance,cache,cachesize,132927,"e; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is ca",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:132954,Performance,cache,cache,132954,"e; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is ca",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:132985,Performance,cache,cachesize,132985,"nt branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; i",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133146,Performance,cache,cacheSize,133146,"arent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time enviro",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133187,Performance,cache,cache,133187,"arent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time enviro",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133278,Performance,cache,cache,133278,"call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133329,Performance,cache,cache,133329,"call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133379,Performance,cache,cacheSize,133379,"on is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133424,Performance,cache,cacheSize,133424,"ches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133454,Performance,cache,cache,133454,"ches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133466,Performance,cache,cache,133466," *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When r",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133604,Performance,cache,cache,133604,"0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:138919,Performance,cache,cache,138919,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:143755,Performance,perform,performance,143755,"urn fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return GetEntry(entry, getall); }. TEventList * GetEventList() const; { return fEventList; }. Int_t GetFileNumber() const; { return fFileNumber; }. TH1 * GetHistogram(); { return GetPlayer()->GetHistogram(); }. Int_t * GetIndex(); { return &fIndex.fArray[0]; }. Double_t * GetIndexValues(); { return &fIndexValues.fArray[0]; }. TList * GetListOfClones(); { return fClones; }. TObjArray * GetListOfBranches(); { return &fBranches; }. TObjArray * GetListOfLeaves(); { return &fLeaves; }. TList * GetListOfFriends() const; { return fFriends; }. TList * GetListOfAliases() const; { return fAliases; }. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. { return fMakeClass; }. Long64_t GetMaxEntryLoop() const; { return fMaxEntryLoop; }. Long64_t GetMaxVirtualSize() const; { return fMaxVirtualSize; }. Int_t GetNbranches(); { return fBranches.GetEntriesFast(); }. TObject * GetNotify() const; { return fNotify; }. Int_t GetPacketSize() const; { return fPacketSize; }. TVirtualPerfStats * GetPerfStats() const; { return fPerfStats; }. Long64_t GetReadEntry() const; { return fReadEntry; }. Long64_t GetReadEvent() const; { return fReadEntry; }. Int_t GetScanField() const; { return fScanField; }. TTreeFormula * GetSelect(); { return GetPlayer()->GetSelect(); }. Long64_t GetSelectedRows(); { return GetPlayer()->GetSelectedRows(); }. Int_t GetTimerInterval() const; { return fTimerInterval; }. Long64_t GetTotBytes() const; { return fTotBytes; }. TTree * GetTree() const; { return const_cast<TTree*>(this); }. TVirtualIndex * GetTreeIndex() const; { return fTreeIndex; }. Int_t GetTreeNumber() const; { return 0; }. Int_t Ge",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:8621,Safety,risk,risk,8621,"tain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:9966,Safety,detect,detector,9966,"tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //-----------",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:39408,Safety,risk,risk,39408,"subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the var",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:42565,Safety,safe,safe,42565,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE m",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:43514,Safety,recover,recovered,43514,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:43590,Safety,recover,recovered,43590,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:44177,Safety,safe,safer,44177,"g; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else nt",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:45738,Safety,detect,detection,45738," *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collecti",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:45976,Safety,detect,detection,45976,"andom,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:46211,Safety,detect,detection,46211,"raw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each elemen",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:47684,Safety,avoid,avoid,47684,"entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *lis",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:80953,Safety,avoid,avoid,80953,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:81071,Safety,avoid,avoid,81071,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:92670,Safety,recover,recoverable,92670,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:128554,Safety,recover,recover,128554," independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = 300000000); This function may be called at the start of a program to change; the default value for fAutoSave(300000000, ie 300 MBytes).; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when more than fAutoSave bytes have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the;",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:6293,Security,access,access,6293,"ee->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defi",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:39298,Security,access,access,39298,"f the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:39592,Security,access,access,39592,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:40797,Security,access,access,40797,"ically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the elements of the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.v",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:52169,Security,access,access,52169,"n; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can n",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:53570,Security,access,access,53570,"chOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:54971,Security,access,access,54971," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:56770,Security,access,access,56770,"oved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer siz",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:58049,Security,access,access,58049," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TT",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:70538,Security,authoriz,authorized,70538," number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:71996,Security,access,access,71996,"rt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:75689,Security,access,access,75689,"][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the defau",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:78006,Security,access,access,78006,"ns in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:79550,Security,access,access,79550,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:82388,Security,access,accessing,82388,"[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the b",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:88812,Security,access,access,88812," ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in case of arrays,; you can also use TEntryListArray (faster in case of a more general selection).; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; tree->SetEntryList(pyplus);; tree->Draw(""fTracks.fPy"");. will draw the fPy of only the tracks that have a positive fPy,; but without redoing the selection. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() //return the number of values accepted by the; //selection expression. In case where no selection; //was specified, returns the number of values processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetV4() //returns a pointer to the double array of V4; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3:V4"",selection);; If the expression has more than 4 component use GetVal(index). Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the e",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:106131,Security,access,access,106131,"ly created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classnam",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:106180,Security,access,access,106180," this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:109586,Security,access,access,109586,"e = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:110547,Security,access,access,110547,"enting an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are ru",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:112818,Security,access,accessible,112818," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:113015,Security,access,access,113015,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:43272,Testability,test,tests,43272," (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:44647,Testability,test,test,44647,"last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, ",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:45016,Testability,test,test,45016," new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.;",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:48664,Testability,test,test,48664,"ions to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support no",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:64269,Testability,test,test,64269,"ets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:64490,Testability,test,test,64490,"vidual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:67010,Testability,test,test,67010,"sIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; all TTreeIndex are 'ignored' and the missing piece are rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TC",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:67245,Testability,test,test,67245," rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function a",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:71488,Testability,log,log,71488,"; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:97690,Testability,test,test,97690,"have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members will not be deleted if the; characters ""->"" are specified as the first characters in the comment; field of the data member declaration. If ""->"" is specified, the pointer member is read via pointer->Str",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:1535,Usability,simpl,simple,1535," Branch buffers may be; automatically written to disk or kept in memory until the Tree attribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated b",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:7388,Usability,simpl,simple,7388,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:7452,Usability,simpl,simple,7452,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:7812,Usability,simpl,simple,7812,"ction will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:9206,Usability,simpl,simple,9206,"ong64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:10421,Usability,simpl,simple,10421,"-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 s",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:11547,Usability,simpl,simple,11547,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:14538,Usability,undo,undo,14538,">(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:48113,Usability,simpl,simply,48113,"ill be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = n",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:49741,Usability,simpl,simple,49741,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:54225,Usability,simpl,simply,54225,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each T",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:57303,Usability,simpl,simply,57303,"iour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:64560,Usability,undo,undo,64560," number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanat",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:64631,Usability,undo,undo,64631,"ad of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:69231,Usability,simpl,simplest,69231,"uple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression th",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:91383,Usability,simpl,simple,91383,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:91404,Usability,simpl,simple,91404,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:122457,Usability,simpl,simply,122457,"te(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the valu",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:124447,Usability,simpl,simply,124447,"the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and alloca",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:133725,Usability,learn,learning,133725,"known branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTree.html:138925,Usability,learn,learning,138925,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root/html602/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTree.html
https://root.cern/root/html602/TTreeCache.html:10713,Availability,error,error,10713,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual T",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:10797,Availability,error,error,10797,"t::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual TTreeCache::EPrefillTypeGetLearnPrefill() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25259,Availability,failure,failure,25259,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4019,Deployability,configurat,configurations,4019," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4467,Integrability,interface,interface,4467," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:116,Modifiability,inherit,inheritance,116,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:3934,Modifiability,variab,variable,3934," with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Proces",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4019,Modifiability,config,configurations,4019," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4195,Modifiability,layers,layers,4195,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26359,Modifiability,variab,variable,26359,"ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillTy",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:409,Performance,cache,cache,409,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:669,Performance,cache,cache,669,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:702,Performance,perform,performance,702,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:776,Performance,latency,latency,776,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:805,Performance,cache,cache,805,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:949,Performance,cache,cache,949,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1212,Performance,cache,cache,1212,"class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analy",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1378,Performance,cache,cache,1378,"ead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KByt",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1470,Performance,cache,cache,1470,"rom the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2086,Performance,cache,cached,2086,"leted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers f",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2528,Performance,perform,performance,2528,"eCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maxi",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2772,Performance,perform,performance,2772,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2852,Performance,latency,latency,2852,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2901,Performance,latency,latency,2901,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:2958,Performance,cache,cache,2958,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:3633,Performance,cache,cache,3633,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the ex",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:3772,Performance,cache,cache,3772,"g; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branche",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4512,Performance,cache,cache,4512," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4877,Performance,cache,cache,4877,"ee is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to proc",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4988,Performance,cache,cache,4988,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5032,Performance,cache,cache,5032,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5210,Performance,cache,cache,5210,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5346,Performance,cache,cachesize,5346,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5397,Performance,cache,cachesize,5397,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5478,Performance,cache,cache,5478,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5761,Performance,cache,cache,5761,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5935,Performance,cache,cachesize,5935,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:6064,Performance,cache,cachesize,6064,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:6739,Performance,cache,cachesize,6739,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:6790,Performance,cache,cachesize,6790,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:6876,Performance,cache,cache,6876,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:7833,Performance,cache,cachesize,7833,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:7884,Performance,cache,cachesize,7884,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:8323,Performance,cache,cache,8323,"(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranc",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:8891,Performance,cache,cache,8891,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); vir",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:8959,Performance,perform,performance,8959,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:17814,Performance,cache,cache,17814,,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:18418,Performance,cache,cache,18418,,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:18483,Performance,cache,cache,18483,,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:18845,Performance,cache,cache,18845,ool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains somethi,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19049,Performance,cache,cache,19049,ileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPr,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19067,Performance,cache,cached,19067,s[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks ,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19141,Performance,cache,cache,19141,BSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19185,Performance,cache,cache,19185,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19230,Performance,cache,cache,19230,ekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadN,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19281,Performance,cache,cache,19281,ng64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; ,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19627,Performance,cache,cache,19627,BufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPr,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19679,Performance,cache,cache,19679,ed size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20032,Performance,cache,cache,20032,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20184,Performance,cache,cache,20184,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20271,Performance,cache,cached,20271,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20361,Performance,cache,cached,20361,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20931,Performance,cache,cache,20931,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22097,Performance,cache,cache,22097,"k[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch)",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22273,Performance,cache,cache,22273," be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are tak",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22654,Performance,cache,cache,22654,"gLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22810,Performance,cache,cache,22810,"eeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the pr",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22990,Performance,cache,cache,22990,"ile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23370,Performance,cache,cache,23370,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23438,Performance,cache,cache,23438,"r ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23476,Performance,cache,cache,23476,"r ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23548,Performance,cache,cache,23548,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23602,Performance,cache,cache,23602,"(i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23706,Performance,cache,cache,23706,"* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cac",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23942,Performance,cache,cache,23942,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24070,Performance,cache,cache,24070," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at p",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24145,Performance,cache,cache,24145,"ook over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24250,Performance,cache,cache,24250,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Ret",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24635,Performance,cache,cache,24635,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24712,Performance,cache,cache,24712,"re; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); O",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24782,Performance,cache,cachedbranches,24782,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Stati",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:24827,Performance,cache,cached,24827,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Stati",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25148,Performance,cache,cache,25148,"*TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the p",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25286,Performance,cache,cache,25286,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25314,Performance,cache,cache,25314,"fficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25420,Performance,cache,cache,25420,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25561,Performance,optimiz,optimize,25561,"erhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned befo",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26054,Performance,cache,cache,26054,"s, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26220,Performance,cache,cache,26220,"ed branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26511,Performance,cache,cache,26511,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26994,Performance,cache,cache,26994,"TreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}.  Author: Rene Brun 04/06/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last genera",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4247,Safety,predict,predict,4247,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:5188,Safety,risk,risk,5188,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:747,Security,access,accessed,747,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:9020,Security,access,access,9020,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtu",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:549,Usability,learn,learning,549,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:570,Usability,learn,learning,570,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1389,Usability,learn,learning,1389,"rom the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1696,Usability,learn,learning,1696,"icular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1806,Usability,learn,learning,1806,"TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1948,Usability,learn,learning,1948,"bject is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:1983,Usability,learn,learning,1983,"bject is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:4436,Usability,learn,learning,4436," in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheS",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:19639,Usability,learn,learning,19639,Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:20523,Usability,learn,learning,20523,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:21679,Usability,learn,learning,21679,"adNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:22668,Usability,learn,learning,22668,"gLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. . TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:23384,Usability,learn,learning,23384,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25403,Usability,simpl,simply,25403,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25410,Usability,clear,clear,25410,"00; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:25857,Usability,learn,learning,25857,"ed is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will cr",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26001,Usability,learn,learning,26001,"s, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26544,Usability,learn,learning,26544,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLea",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:26663,Usability,learn,learning,26663,"the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCache.html:27085,Usability,learn,learning,27085,"ch type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}.  Author: Rene Brun 04/06/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html602/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCache.html
https://root.cern/root/html602/TTreeCacheUnzip.html:2692,Availability,error,error,2692,"lassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const cha",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:2776,Availability,error,error,2776,"t::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tTTreeCache::GetLearnEntries(); virtual T",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:19166,Availability,error,error,19166,"y important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nb",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:21355,Availability,failure,failure,21355," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22228,Availability,error,error,22228,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:23218,Availability,error,error,23218,"fer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMissed(); { return fNMissed; }.  Author: Rene Brun 04/06/2006  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This pa",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:17870,Deployability,update,update,17870,"onstructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20708,Energy Efficiency,adapt,adapted,20708,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:21601,Energy Efficiency,allocate,allocate,21601,"he arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all t",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22266,Energy Efficiency,allocate,allocate,22266,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22910,Energy Efficiency,allocate,allocate,22910,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:619,Integrability,synchroniz,synchronized,619,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTOb",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:121,Modifiability,inherit,inheritance,121,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTOb",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:18146,Modifiability,variab,variable,18146,"st of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:19589,Modifiability,variab,variable,19589,"ssing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical reco",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20708,Modifiability,adapt,adapted,20708,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:917,Performance,latency,latency,917,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTOb",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:1041,Performance,cache,cache,1041,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """"",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:10932,Performance,queue,queue,10932,,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:11149,Performance,cache,cache,11149,,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:11783,Performance,cache,cache,11783,,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:11860,Performance,cache,cache,11860,,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12222,Performance,cache,cache,12222,leCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache i,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12451,Performance,cache,cache,12451,; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12469,Performance,cache,cached,12469,Read::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; T,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12555,Performance,cache,cache,12555,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12611,Performance,cache,cache,12611,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12668,Performance,cache,cache,12668,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:12731,Performance,cache,cache,12731,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13154,Performance,cache,cache,13154,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13218,Performance,cache,cache,13218,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13602,Performance,cache,cache,13602,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13668,Performance,cache,cache,13668,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13835,Performance,cache,cache,13835,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:14114,Performance,cache,cache,14114,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:14201,Performance,cache,cached,14201,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:14291,Performance,cache,cached,14291,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:15036,Performance,cache,cache,15036,"ax size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:17223,Performance,cache,cache,17223,"on*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. ; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we chang",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:17399,Performance,cache,cache,17399,"tic Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. ; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to pro",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:17608,Performance,optimiz,optimize,17608,"ercentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. ; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; whe",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:17947,Performance,cache,cache,17947,"onstructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:18315,Performance,queue,queue,18315," branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits fo",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:18552,Performance,queue,queue,18552,"Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:19317,Performance,queue,queue,19317,"CacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must ",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:19821,Performance,queue,queue,19821,"ding unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void Res",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20068,Performance,cache,cache,20068," _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is co",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20839,Performance,cache,cache,20839,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20883,Performance,cache,cache,20883,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20956,Performance,cache,cache,20956,"aving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the p",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:21391,Performance,cache,cache,21391," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:21423,Performance,cache,cache,21423," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:21983,Performance,cache,cache,21983,"the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22055,Performance,cache,cache,22055,"ompletely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the tra",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22643,Performance,cache,cache,22643,"0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers ar",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22768,Performance,cache,cache,22768,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22809,Performance,cache,cache,22809,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22928,Performance,cache,cache,22928,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:22995,Performance,cache,cache,22995,"times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMisse",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:18854,Safety,detect,detection,18854,"the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the que",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20208,Testability,log,logical,20208,"therwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about ",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:20591,Testability,log,logical,20591,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:13166,Usability,learn,learning,13166,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:14532,Usability,learn,learning,14532,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCacheUnzip.html:16426,Usability,learn,learning,16426,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ; TFileCacheRead. ; TTreeCache. ; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch",MatchSource.WIKI,root/html602/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCacheUnzip.html
https://root.cern/root/html602/TTreeCloner.html:2232,Availability,error,error,2232,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance Chart:. TTreeCloner. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as ",MatchSource.WIKI,root/html602/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCloner.html
https://root.cern/root/html602/TTreeCloner.html:2238,Integrability,message,message,2238,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance Chart:. TTreeCloner. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as ",MatchSource.WIKI,root/html602/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCloner.html
https://root.cern/root/html602/TTreeCloner.html:117,Modifiability,inherit,inheritance,117,". TTreeCloner. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeCloner. class TTreeCloner. TTreeCloner. Class implementing or helping the various TTree cloning method. Function Members (Methods); public:. virtual~TTreeCloner(); static TClass*Class(); voidCloseOutWriteBaskets(); voidCollectBaskets(); UInt_tCollectBranches(); UInt_tCollectBranches(TBranch* from, TBranch* to); UInt_tCollectBranches(TObjArray* from, TObjArray* to); voidCopyMemoryBaskets(); voidCopyProcessIds(); voidCopyStreamerInfos(); Bool_tExec(); const char*GetWarning() const; virtual TClass*IsA() const; Bool_tIsValid(); Bool_tNeedConversion(); virtual voidShowMembers(TMemberInspector& insp) const; voidSortBaskets(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); voidWriteBaskets(). private:. voidImportClusterRanges(); TTreeCloner&operator=(const TTreeCloner&); TTreeCloner(const TTreeCloner&). Data Members; public:. static TTreeCloner::EClonerOptionskIgnoreMissingTopLevel; static TTreeCloner::EClonerOptionskNoWarnings; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.",MatchSource.WIKI,root/html602/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCloner.html
https://root.cern/root/html602/TTreeCloner.html:3644,Performance,optimiz,optimize,3644,"cated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TOb",MatchSource.WIKI,root/html602/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCloner.html
https://root.cern/root/html602/TTreeCloner.html:3840,Performance,perform,performance,3840,"en a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TObjArray* from, TObjArray* to); Fill the array of branches, matching the branches of the 'from' and 'to' arrays.; Returns the total number",MatchSource.WIKI,root/html602/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeCloner.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:1450,Availability,error,error,1450," virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:1534,Availability,error,error,1534," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelecti",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8971,Availability,error,error,8971,"ckets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the e",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:9239,Availability,error,error,9239,"ructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from th",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:9984,Availability,error,error,9984,"eturns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t Ge",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10460,Availability,error,error,10460,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10488,Availability,error,error,10488,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10611,Availability,error,error,10611,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }.  Author: Marek Biskup 24/01/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last g",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10627,Availability,error,error,10627,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }.  Author: Marek Biskup 24/01/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last g",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10494,Integrability,message,message,10494,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10633,Integrability,message,message,10633,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }.  Author: Marek Biskup 24/01/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last g",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:125,Modifiability,inherit,inheritance,125,". TTreeDrawArgsParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeDrawArgsParser. class TTreeDrawArgsParser: public TObject. TTreeDrawArgsParser. A class that parses all parameters for TTree::Draw().; See TTree::Draw() for the format description. Function Members (Methods); public:. virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:5852,Modifiability,variab,variables,5852,"bj); voidSetObjectName(const char* s); static voidTObject::SetObjectStat(Bool_t stat); voidSetOriginal(TObject* o); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearPrevious(); TTreeDrawArgsParser::EOutputTypeDefineType(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Bool_tParseName(TString name); Bool_tParseOption(); Bool_tParseVarExp(); Bool_tSplitVariables(TString variables). Data Members; public:. static Int_tfgMaxDimension= 4; static Int_tfgMaxParameters= 9; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTreeDrawArgsParser::EOutputTypekENTRYLIST; static TTreeDrawArgsParser::EOutputTypekEVENTLIST; static TTreeDrawArgsParser::EOutputTypekGRAPH; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM1D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM2D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM3D; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TTreeDrawArgsParser::EOutputTypekLISTOFGRAPHS; static TTreeDrawArgsParser::EOutputTypekLISTOFPOLYMARKERS3D",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:7536,Modifiability,variab,variable,7536,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8059,Modifiability,variab,variable,8059,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8256,Modifiability,variab,variables,8256,"TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kF",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8407,Modifiability,variab,variables,8407," of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for ch",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8461,Modifiability,variab,variables,8461,"prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, ",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8529,Modifiability,variab,variables,8529,"expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Dra",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8811,Modifiability,variab,variable,8811,"nal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropr",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8847,Modifiability,variab,variables,8847,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8880,Modifiability,variab,variable,8880,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:8920,Modifiability,variab,variable,8920,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:9274,Modifiability,variab,variables,9274,"er(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of ",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10245,Modifiability,variab,variable,10245,"riate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Boo",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10580,Modifiability,variab,variable,10580,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }.  Author: Marek Biskup 24/01/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last g",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeDrawArgsParser.html:10709,Modifiability,variab,variable,10709,"tring GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }.  Author: Marek Biskup 24/01/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html602/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeDrawArgsParser.html
https://root.cern/root/html602/TTreeFormula.html:721,Availability,avail,available,721,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:3816,Availability,error,error,3816,"tual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tTFormula::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tTFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidTFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*TNamed::GetName() const; virtua",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:3900,Availability,error,error,3900,"e_tTFormula::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tTFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tTFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringTFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidTFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNcodes() const; virtual Int_tGetNdata(); virtual Int_tTFormula::GetNdim() ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24833,Availability,failure,failure,24833,"thod is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:25928,Availability,failure,failure,25928," case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Nam",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:27762,Availability,redundant,redundant,27762,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:29491,Availability,avail,available,29491," the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. Int_t GetNdata(); *-*Return number of available instances in the formula; *-* ===================================================. Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member correspon",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:31576,Deployability,update,update,31576,"= 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:754,Integrability,interface,interface,754,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:25200,Integrability,message,message,25200,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:25257,Integrability,message,message,25257,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:118,Modifiability,inherit,inheritance,118,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:1022,Modifiability,variab,variability,1022,"rmula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voi",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:2465,Modifiability,variab,variable,2465," virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:14867,Modifiability,variab,variable,14867,":(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this fo",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:15653,Modifiability,variab,variable,15653,"ogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; I",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:15693,Modifiability,variab,variable,15693,"ogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; I",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:16200,Modifiability,variab,variability,16200,"utG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:17055,Modifiability,variab,variables,17055,"fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static TFormula::(anonymous)TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)kAlternateString; static TFormula::(anonymous)TFormula::kAnd; static TFormula::(anonymous)TFormula::kBinary; s",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:17668,Modifiability,variab,variable,17668,"on (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static TFormula::(anonymous)TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)kAlternateString; static TFormula::(anonymous)TFormula::kAnd; static TFormula::(anonymous)TFormula::kBinary; static TFormula::(anonymous)TFormula::kBitAnd; static TFormula::(anonymous)TFormula::kBitOr; static TFormula::(anonymous)TFormula::kBoolOptimize; static TFormula::(anonymous)TFormula::kBoolOptimizeAnd; static TFormula::(anonymous)TFormula::kBoolOptimizeOr; static TFormula::(anonymous)TFormula::kBoolSet; static TFormula::(anonymous)TFormula::kConstant; static TFormula::(anonymous)TFormula::kData; static TTreeFormula::(anonymous)kDataMember; static TFormula::(anonymous)TFormula::kDefinedString; static TFormula::(anonymous)TFormula::kDefinedVariable; static TTreeFormula::(anonymous)kDirect; static TFormula::(anonymo",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:23914,Modifiability,variab,variables,23914,"po; static TFormula::(anonymous)TFormula::kygaus; static TFormula::(anonymous)TFormula::kylandau; static TFormula::(anonymous)TFormula::kypol; static TFormula::(anonymous)TFormula::kzexpo; static TFormula::(anonymous)TFormula::kzgaus; static TFormula::(anonymous)TFormula::kzlandau; static TFormula::(anonymous)TFormula::kzpol. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TFormula. ; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failur",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24044,Modifiability,variab,variables,24044,"TFormula::(anonymous)TFormula::kzexpo; static TFormula::(anonymous)TFormula::kzgaus; static TFormula::(anonymous)TFormula::kzlandau; static TFormula::(anonymous)TFormula::kzpol. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TFormula. ; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24382,Modifiability,variab,variables,24382,"mula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24518,Modifiability,variab,variables,24518," char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& c",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24643,Modifiability,variab,variables,24643,"ar* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:26063,Modifiability,variab,variable,26063,"inting to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:26381,Modifiability,variab,variable,26381,"r* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Lo",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:26401,Modifiability,variab,variable,26401," castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* meth",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:26562,Modifiability,variab,variable,26562,"leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:30601,Modifiability,variab,variable,30601,". Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:30818,Modifiability,variab,variable,30818," const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:1560,Performance,load,loading,1560,"rmula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voi",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:14398,Performance,cache,cache,14398,"tsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TFormula::(anonymous)TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TFormula::(anonymous)TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:15021,Performance,optimiz,optimization,15021,":(anonymous)TObject::kNotDeleted; static TFormula::(anonymous)TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsTFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*TFormula::fExpr[fNoper] List of expressions; TString*TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this fo",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:16285,Performance,optimiz,optimization,16285,"utG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:16514,Performance,cache,caches,16514,"utG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayTFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TF",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:16769,Performance,load,loaded,16769,"more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayTFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tTFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tTFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tTFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tTFormula::fNoperNumber of operators; Int_tTFormula::fNparNumber of parameters; Int_tTFormula::fNstringNumber of different constants character strings; Int_tTFormula::fNumberformula number identifier; Int_tTFormula::fNvalNumber of different variables in expression; TOperOffset*TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); TFormula::TFuncGTFormula::fOptimal!pointer to optimal function; Double_t*TFormula::fParams[fNpar] Array of fNpar parameters; TFormulaPrimitive**TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable in",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:24773,Performance,load,load,24773,"========================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from exp",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:31494,Performance,load,loaded,31494,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:31798,Performance,load,loaded,31798,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TT",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:27762,Safety,redund,redundant,27762,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:26555,Usability,simpl,simple,26555,"leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:27164,Usability,usab,usable,27164,"=============. This member function redefines the function in TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the cla",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:28042,Usability,simpl,simple,28042,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable.",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormula.html:28258,Usability,simpl,simple,28258,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspon",MatchSource.WIKI,root/html602/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormula.html
https://root.cern/root/html602/TTreeFormulaManager.html:1508,Availability,error,error,1508," voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:1592,Availability,error,error,1592,"st char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classna",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:7791,Availability,avail,available,7791,"zes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }.  Author: Philippe Canal 20/03/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:8159,Deployability,update,update,8159,"en for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }.  Author: Philippe Canal 20/03/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6676,Integrability,synchroniz,synchronization,6676,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:125,Modifiability,inherit,inheritance,125,". TTreeFormulaManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeFormulaManager. class TTreeFormulaManager: public TObject. A TreeFormulaManager is used to coordinate one or more TTreeFormula objecs. In particular it makes sure that the dimensions and size of all the formulas; is properly coordinated. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6364,Modifiability,variab,variable,6364,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6447,Modifiability,variab,variable,6447,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6462,Modifiability,variab,variable,6462,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6524,Modifiability,variab,variability,6524,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:6793,Modifiability,variab,variable,6793,tatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of a,MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:7485,Modifiability,variab,variable,7485,"e dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return ",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:7703,Modifiability,variab,variable,7703,"st synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }.  Author: Philippe Canal 20/03/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *;  Last changed: root",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFormulaManager.html:8077,Performance,load,loaded,8077,"en for this formula. Class Charts. Inheritance Chart:. TObject. ; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }.  Author: Philippe Canal 20/03/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFormulaManager.html
https://root.cern/root/html602/TTreeFriendLeafIter.html:125,Modifiability,inherit,inheritance,125,". TTreeFriendLeafIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeFriendLeafIter. class TTreeFriendLeafIter: public TIterator. TTreeFriendLeafIter. Iterator on all the leaves in a TTree and its friend. Function Members (Methods); public:. virtual~TTreeFriendLeafIter(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; Bool_toperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance Chart:. TIterator. ; TTreeFriendLeafIter. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriend",MatchSource.WIKI,root/html602/TTreeFriendLeafIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeFriendLeafIter.html
https://root.cern/root/html602/TTreeIndex.html:1435,Availability,error,error,1435,"ct::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormu",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:1519,Availability,error,error,1519,"*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() con",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:10073,Availability,failure,failure,10073,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues ",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:9742,Deployability,update,update,9742,"s eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do no",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:13818,Deployability,update,update,13818,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}.  Author: Rene Brun 05/07/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:116,Modifiability,inherit,inheritance,116,". TTreeIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeIndex. class TTreeIndex: public TVirtualIndex. A Tree Index with majorname and minorname. Function Members (Methods); public:. virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long6",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:8721,Modifiability,variab,variables,8721,"n; TTreeIndex(); Default constructor for TTreeIndex. TTreeIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TTreeIndex. Build an index table using the leaves of Tree T with major & minor names; The index is built with the expressions given in ""majorname"" and ""minorname"". a Long64_t array fIndexValues is built with:; major = the value of majorname converted to an integer; minor = the value of minorname converted to an integer; fIndexValues[i] = major<<31 + minor; This array is sorted. The sorted fIndex[i] contains the serial number; in the Tree corresponding to the pair ""major,minor"" in fIndexvalues[i]. Once the index is computed, one can retrieve one entry via; T->GetEntryWithIndex(majornumber, minornumber); Example:; tree.BuildIndex(""Run"",""Event""); //creates an index using leaves Run and Event; tree.GetEntryWithIndex(1234,56789); //reads entry corresponding to; Run=1234 and Event=56789. Note that majorname and minorname may be expressions using original; Tree variables eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Wr",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:11513,Performance,perform,performs,11513,"ue, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues table, not entry# !; use lower_bound STD algorithm. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair th",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:12327,Performance,perform,performs,12327,"major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Long64_t* GetIndexValuesMinor() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeIndex.html:13736,Performance,load,loaded,13736,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}.  Author: Rene Brun 05/07/2004  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/treeplayer:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeIndex.html
https://root.cern/root/html602/TTreeInput.html:4451,Availability,error,error,4451," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:4535,Availability,error,error,4535,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:20086,Availability,mask,mask,20086,,MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:116,Modifiability,inherit,inheritance,116,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  FITPANEL;  TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:387,Modifiability,variab,variables,387,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  FITPANEL;  TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:23244,Modifiability,variab,variables,23244,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGCompositeFrame. ; TGMainFrame. ; TGTransientFrame. ; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ).  Author: David Gonzalez Maline 21/10/2008  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:23350,Modifiability,variab,variables,23350,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGCompositeFrame. ; TGMainFrame. ; TGTransientFrame. ; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ).  Author: David Gonzalez Maline 21/10/2008  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreeInput.html:23639,Usability,simpl,simple,23639,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGCompositeFrame. ; TGMainFrame. ; TGTransientFrame. ; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ).  Author: David Gonzalez Maline 21/10/2008  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gui:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeInput.html
https://root.cern/root/html602/TTreePerfStats.html:3706,Availability,error,error,3706,"r* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:3790,Availability,error,error,3790,"dBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:11323,Energy Efficiency,monitor,monitored,11323,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ; TVirtualPerfStats. ; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:120,Modifiability,inherit,inheritance,120,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:369,Performance,perform,performance,369,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:1519,Performance,cache,cache,1519,"TreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE1 : The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE2 : A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. Function Members (Methods); public:. virtual~TTreePerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrows",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:10501,Performance,cache,cache,10501,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ; TVirtualPerfStats. ; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePerfStats.html:11125,Performance,cache,cache,11125,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ; TVirtualPerfStats. ; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html602/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePerfStats.html
https://root.cern/root/html602/TTreePlayer.html:1934,Availability,error,error,1934,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; vi",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:2018,Availability,error,error,2018,"dTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:12890,Availability,error,error,12890,"olean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the n",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:13219,Availability,error,error,13219," are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEn",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:13968,Availability,error,errors,13968,"ation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; return the number of entries to be processed; this function checks that nentries is not bigger than the number; of entries in the Tree or in the associated TEventlist. const char * GetNameByIndex(TString& varexp, Int_t* index, Int_t colindex); -*-*-*Return name corresponding to colindex in varexp; *-* ===============================================. varexp is a string of names separated by :; index is an array with pointers to the start of name[i] in varexp. Int_t MakeClass(const char* classname, Option_t* option);",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:18847,Availability,avail,available,18847,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19586,Availability,avail,available,19586,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:22357,Availability,avail,available,22357,"ify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstent",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:23485,Availability,error,error,23485,"d in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically l",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:25881,Availability,error,error,25881,"ll this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Long64_t Process(TSelector* selector, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the code in the specified selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:29873,Availability,error,error,29873,"f format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better E",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:32461,Availability,error,error,32461,"unc->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t Ge",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:9696,Deployability,update,updated,9696,"tatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance Chart:. TObject. ; TVirtualTreePlayer. ; TTreePlayer. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entr",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:18993,Deployability,update,updated,18993,"tong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:32822,Deployability,update,update,32822,"effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See TSelectorDraw::GetVar. {return fSelector->GetVar(i);}. TTreeFormula * GetVar1() const; See TSelectorDraw::GetVar. {return",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19707,Energy Efficiency,efficient,efficient,19707,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19834,Energy Efficiency,efficient,efficient,19834,"). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fpri",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:1489,Integrability,wrap,wrapperPrefix,1489," virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:11527,Integrability,wrap,wrapperPrefix,11527,"0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20459,Integrability,wrap,wrapper,20459,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:22250,Integrability,interface,interface,22250,"void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for e",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:27756,Integrability,synchroniz,synchronized,27756,"inters in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:28242,Integrability,synchroniz,synchronized,28242,"hange the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will be used as the default 'precision' for the; printing format.; col=xxx; Where 'xxx' is colon (:) delimited list of printing format for; each column. The format string should follow the printf format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:117,Modifiability,inherit,inheritance,117,". TTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreePlayer. class TTreePlayer: public TVirtualTreePlayer. TTreePlayer. Implement some of the functionality of the class TTree requiring access to; extra libraries (Histogram, display, etc). Function Members (Methods); public:. virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:12001,Modifiability,variab,variables,12001,"d tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documenta",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:16691,Modifiability,variab,variables,16691,"f(""myfile.root"");); - T->MakeClass(""MyClass"");; where T is the name of the Tree in file myfile.root; and MyClass.h, MyClass.C the name of the files created by this function.; In a ROOT session, you can do:; root> .L MyClass.C; root> MyClass t; root> t.GetEntry(12); // Fill t data members with entry number 12; root> t.Show(); // Show values of entry 12; root> t.Show(16); // Read and show values of entry 16; root> t.Loop(); // Loop on all entries. NOTE: Do not use the code generated for one Tree in case of a TChain.; Maximum dimensions calculated on the basis of one TTree only; might be too small when processing all the TTrees in one TChain.; Instead of myTree.MakeClass(.., use myChain.MakeClass(.. Int_t MakeCode(const char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class ge",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19605,Modifiability,variab,variables,19605,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19679,Modifiability,variab,variable,19679,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20421,Modifiability,variab,variable,20421,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20841,Modifiability,variab,variable,20841,">10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessibl",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:21823,Modifiability,variab,variable,21823,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:22753,Modifiability,variab,variables,22753,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:22841,Modifiability,variab,variables,22841,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:30033,Modifiability,variab,variable,30033,"d by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitt",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:30474,Modifiability,variab,variable,30474,"hey are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:30650,Modifiability,variab,variable,30650,"; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the fun",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:31896,Modifiability,variab,variable,31896,"Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TT",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:18657,Performance,load,loading,18657,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19722,Performance,cache,cache,19722,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20071,Performance,load,load,20071," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:21771,Performance,load,loaded,21771,"dic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrinci",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:21915,Performance,load,loaded,21915,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:23566,Performance,load,loaded,23566,"nterface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:24399,Performance,load,loaded,24399,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:24494,Performance,load,loaded,24494,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:24605,Performance,load,loaded,24605,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:32740,Performance,load,loaded,32740,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:413,Security,access,access,413,". TTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreePlayer. class TTreePlayer: public TVirtualTreePlayer. TTreePlayer. Implement some of the functionality of the class TTree requiring access to; extra libraries (Histogram, display, etc). Function Members (Methods); public:. virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:17389,Security,access,access,17389," char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'm",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:18522,Security,access,access,18522," in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:19987,Security,access,access,19987," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20292,Security,access,access,20292,"ame name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:20447,Security,access,access,20447,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:21804,Security,access,accessible,21804,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:22001,Security,access,access,22001,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:11098,Testability,test,test,11098,"nst TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeP",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:27578,Testability,log,log,27578,"st, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the ",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreePlayer.html:27607,Testability,log,log,27607,"irstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for",MatchSource.WIKI,root/html602/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreePlayer.html
https://root.cern/root/html602/TTreeReader.html:349,Availability,robust,robust,349,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:1924,Availability,error,error,1924," #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);; ; // Read a single floa",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:2606,Availability,error,errors,2606,"ose as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);; ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;; ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;; ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;; ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;; ; // Read the taus in the tree entry:;",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:6554,Availability,error,error,6554,"l~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:6638,Availability,error,error,6638,"TObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:13075,Deployability,update,update,13075,", owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsChain); }. Bool_t Next(); { return SetEntry(GetCurrentEntry() + 1) == kEntryValid; }. EEntryStatus SetEntry(Long64_t entry); { return SetEntryBase(entry, kFALSE); }. EEntryStatus SetLocalEntry(Long64_t entry); { return SetEntryBase(entry, kTRUE); }. EEntryStatus GetEntryStatus() const; { return fEntryStatus; }. TTree* GetTree() const; { return fTree; }. Long64_t GetEntries(Bool_t force) const; { return fTree ? (force ? fTree->GetEntries() : fTree->GetEntr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:711,Energy Efficiency,power,power,711,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:365,Integrability,interface,interface,365,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:117,Modifiability,inherit,inheritance,117,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:5100,Modifiability,variab,variable,5100,") {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; }; ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;; ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;; ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;; ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Cop",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:4121,Performance,load,loaded,4121,"triggerInfo"");; if (!CheckValue(triggerInfo)) return false;; ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;; ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;; ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;; ; ; // Now iterate through the TTree entries and fill a histogram.; ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);; ; while (reader.Next()) {; ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; }; ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;; ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;; ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;; ; // Access the ",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:480,Security,access,access,480,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:1473,Security,access,access,1473,"rValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value-",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:1585,Security,access,access,1585,"Reader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:1745,Security,access,access,1745,"rams a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray obj",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:2736,Security,access,access,2736,"as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);; ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;; ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;; ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;; ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;; ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;; ; ; // Now iterate through the TTree entries and fill a histogram.; ; TH1* hist",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:4466,Security,access,access,4466," ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;; ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;; ; ; // Now iterate through the TTree entries and fill a histogram.; ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);; ; while (reader.Next()) {; ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; }; ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;; ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;; ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;; ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:341,Usability,simpl,simple,341,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:721,Usability,simpl,simpler,721,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeReader.html:859,Usability,simpl,simple,859,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.; ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html602/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeReader.html
https://root.cern/root/html602/TTreeResult.html:1552,Availability,error,error,1552," virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:1636,Availability,error,error,1636,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:349,Integrability,interface,interface,349,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:398,Integrability,interface,interface,398,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:7212,Integrability,interface,interface,7212,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ; TSQLResult. ; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}.  Author: Fons Rademakers 30/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:7378,Integrability,interface,interface,7378,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ; TSQLResult. ; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}.  Author: Fons Rademakers 30/11/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeResult.html:117,Modifiability,inherit,inheritance,117,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html602/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeResult.html
https://root.cern/root/html602/TTreeRow.html:1481,Availability,error,error,1481," virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html602/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeRow.html
https://root.cern/root/html602/TTreeRow.html:1565,Availability,error,error,1565,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html602/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeRow.html
https://root.cern/root/html602/TTreeRow.html:334,Integrability,interface,interface,334,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html602/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeRow.html
https://root.cern/root/html602/TTreeRow.html:114,Modifiability,inherit,inheritance,114,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html602/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeRow.html
https://root.cern/root/html602/TTreeSQL.html:4258,Availability,error,error,4258,"ble_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:4342,Availability,error,error,4342,"py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tTTree::GetBranchStatus(const char* branch",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:15691,Deployability,update,updateExisting,15691,"t_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:30613,Deployability,update,updated,30613," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }.  Author: Rene Brun 12/01/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:25040,Energy Efficiency,allocate,allocated,25040,lones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TStringfInsertQuery; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTr,MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:29598,Integrability,rout,routine,29598,"(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. TBranch * Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); Create a branch. void CheckBasket(TBranch* tb); Check if the basket is properly setup. Bool_t CheckBranch(TBranch* tb); Check if the table has a column corresponding the branch; and that the resultset are properly setup. Bool_t CheckTable(const TString& table) const; Check the table exist in the database. TString ConvertTypeName(const TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the T",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:114,Modifiability,inherit,inheritance,114,". TTreeSQL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TTreeSQL. class TTreeSQL: public TTree. TTreeSQL. Implement TTree for a SQL backend. Function Members (Methods); public:. virtual~TTreeSQL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tBranch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); virtual TBranch*Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtu",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:15403,Performance,cache,cachesize,15403,"l_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:21038,Performance,cache,cacheSize,21038," = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); voidCheckBasket(TBranch* tb); Bool_tCheckBranch(TBranch* tb); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); Bool_tCheckTable(const TString& table) const; TStringConvertTypeName(const TString& typeName); virtual TBasket*CreateBasket(TBranch* br); virtual voidCreateBranch(const TString& branchName, const TString& typeName); TStringCreateBranches(TSQLResult* rs); Bool_tCreateTable(const TString& table); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; vector<Int_t>*GetColumnIndice(TBranch* branch); virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInit(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidResetQuery(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). Data Members; public:. ",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:23027,Performance,cache,cache,23027,StatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; Bool_tfBranchChecked; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList,MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:23171,Performance,cache,cache,23171,StatusBitsTObject::kMustCleanup; static TTree::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave bytes produced; Bool_tfBranchChecked; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList,MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:25525,Performance,load,loading,25525,Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TStringfQuery; Long64_tTTree::fReadEntry! Number of the entry being processed; TSQLResult*fResult; TSQLRow*fRow; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TSQLServer*fServer; TStringfTable; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBr,MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:30304,Performance,load,load,30304," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }.  Author: Rene Brun 12/01/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeSQL.html:2802,Usability,undo,undo,2802,"000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") con",MatchSource.WIKI,root/html602/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeSQL.html
https://root.cern/root/html602/TTreeTableInterface.html:4183,Availability,avail,available,4183,"t nentries = 0, Long64_t firstentry = 0); TTreeTableInterface constructor. ~TTreeTableInterface(); TTreeTableInterface destructor. void SetVariablesExpression(const char* varexp); Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }.  Author: Roel Aaij 21/07/2",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeTableInterface.html:415,Integrability,interface,interface,415,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeTableInterface.html:470,Integrability,interface,interface,470,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeTableInterface.html:907,Integrability,interface,interface,907,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeTableInterface.html:125,Modifiability,inherit,inheritance,125,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEPLAYER;  TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeTableInterface.html:3354,Modifiability,variab,variables,3354,"arexp); voidSyncFormulas(). Data Members; private:. TEntryList*fEntriesCurrently active entries; Long64_tfEntryPresent entry number in fTree.; Long64_tfFirstEntryFirst entry.; Bool_tfForceDimForce dimension.; TList*fFormulasArray of TTreeFormulas to display values; TList*fInputUsed for fSelector.; TTreeFormulaManager*fManagerCoordinator for the formulas.; UInt_tfNColumnsAmount of columns in the data; Long64_tfNEntriesNumber of entries in the tree.; UInt_tfNRowsAmount of rows in the data; TTreeFormula*fSelectSelection condition; TSelectorDraw*fSelectorSelector; TTree*fTreeData in a TTree. Class Charts. Inheritance Chart:. TVirtualTableInterface. ; TTreeTableInterface. Function documentation; TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0); TTreeTableInterface constructor. ~TTreeTableInterface(); TTreeTableInterface destructor. void SetVariablesExpression(const char* varexp); Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression a",MatchSource.WIKI,root/html602/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeTableInterface.html
https://root.cern/root/html602/TTreeViewer.html:1361,Availability,echo,echoed,1361,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:11725,Availability,error,error,11725," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWin",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:11809,Availability,error,error,11809,"; voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:28726,Availability,mask,mask,28726,,MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:38729,Availability,error,error,38729,"(); Remove the current record. Bool_t HandleTimer(TTimer* timer); This function is called by the fTimer object. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other commands generated. void CloseWindow(); Close the viewer. void ExecuteCommand(const char* command, Bool_t fast = kFALSE); Execute all user commands. void MapOptions(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. ",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:1940,Deployability,toggle,toggles,1940,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:5527,Deployability,toggle,toggle,5527,"editor usage is the following :; - you can write C expressions made of leaf names by hand or you can insert; any item from the right panel by clicking on it (recommandable);; - you can click on other expressions/leaves to paste them in the editor;; - you should write the item alias by hand since it not only make the expression; meaningfull, but it also highly improve the layout for big expressions; - you may redefine an old alias - the other expressions depending on it will; be modified accordingly. An alias must not be the leading string of other aliases.; When Draw commands are issued, the name of the corresponding histogram axes; will become the aliases of the expressions. User commands can be issued directly from the textbox labeled ""Command""; from the upper-left toolbar by typing and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the left tree-type list :; The items from the left that are provided with context menus are tree and; branch items. You can directly activate the *MENU* marked methods of TTree; from this menu.; Context menu for the right panel :; A general context menu is acivated if the user right-clicks the right panel.; Commands are :; - EmptyAll : clears the content of all expressions;; - ExecuteCommand : execute a ROOT command;; - MakeSelector : equivalent of TTree::MakeSelector();; - NewExpression : add an expression item in the right panel;; - Process : equivalent of TTree::Process();; - SaveSource : save the current session as a C++ macro;; - SetScanFileName : define a name for the file where TTree::Scan command; is redirected when the <Scan> button is ",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:32479,Deployability,toggle,toggle,32479,,MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:477,Energy Efficiency,adapt,adapted,477,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:357,Integrability,interface,interface,357,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:2327,Integrability,message,message,2327,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:4986,Integrability,depend,depending,4986,"ft (where expressions are; placed) by dragging them to the left at least 10 pixels. Editing expressions. Any editable expression from the right panel has two components : a; true name (that will be used when TTree::Draw() commands are issued) and an; alias. The visible name is the alias. Aliases of user defined expressions have; a leading ~ and may be used in new expressions. Expressions containing boolean; operators have a specific icon and may be dragged to the active cut (scissors; item) position.; The expression editor can be activated by double-clicking empty expression,; using <EditExpression> from the selected expression context menu or using; <Edit/Expression> menu.; The editor will pop-up in the left part, but it can be moved.; The editor usage is the following :; - you can write C expressions made of leaf names by hand or you can insert; any item from the right panel by clicking on it (recommandable);; - you can click on other expressions/leaves to paste them in the editor;; - you should write the item alias by hand since it not only make the expression; meaningfull, but it also highly improve the layout for big expressions; - you may redefine an old alias - the other expressions depending on it will; be modified accordingly. An alias must not be the leading string of other aliases.; When Draw commands are issued, the name of the corresponding histogram axes; will become the aliases of the expressions. User commands can be issued directly from the textbox labeled ""Command""; from the upper-left toolbar by typing and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the ",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:38616,Integrability,message,message,38616," if scan is redirected. void RemoveItem(); Remove the selected item from the list. void RemoveLastRecord(); Remove the current record. Bool_t HandleTimer(TTimer* timer); This function is called by the fTimer object. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other commands generated. void CloseWindow(); Close the viewer. void ExecuteCommand(const char* command, Bool_t fast = kFALSE); Execute all user commands. void MapOptions(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Del",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:117,Modifiability,inherit,inheritance,117,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:477,Modifiability,adapt,adapted,477,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:795,Modifiability,variab,variables,795,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:7264,Performance,load,load,7264,"e file where TTree::Scan command; is redirected when the <Scan> button is checked;; - SetTreeName : open a new tree whith this name in the viewer;; A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1) From the TBrowser :; Select a tree in the TBrowser, then call the StartViewer() method from its; context menu (right-click on the tree).; 2) From the command line :; Start a ROOT session in the directory where you have your tree.; You will need first to load the library for TTreeViewer and optionally other; libraries for user defined classes (you can do this later in the session) :; root [0] gSystem->Load(\""TTreeViewer\"");; Supposing you have the tree MyTree in the file MyFile, you can do :; root [1] TFile file(\""Myfile\"");; root [2] new TTreeViewer(\""Mytree\"");; or :; root [2] TreeViewer *tv = new TTreeViewer();; root [3] tv->SetTreeName(\""Mytree\"");. /*. */. Function Members (Methods); public:. virtual~TTreeViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); voidAppendTree(TTree* tree); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackgrou",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:1416,Usability,progress bar,progress bar,1416,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:2377,Usability,clear,clear,2377,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTreeViewer.html:6111,Usability,clear,clears,6111," right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the left tree-type list :; The items from the left that are provided with context menus are tree and; branch items. You can directly activate the *MENU* marked methods of TTree; from this menu.; Context menu for the right panel :; A general context menu is acivated if the user right-clicks the right panel.; Commands are :; - EmptyAll : clears the content of all expressions;; - ExecuteCommand : execute a ROOT command;; - MakeSelector : equivalent of TTree::MakeSelector();; - NewExpression : add an expression item in the right panel;; - Process : equivalent of TTree::Process();; - SaveSource : save the current session as a C++ macro;; - SetScanFileName : define a name for the file where TTree::Scan command; is redirected when the <Scan> button is checked;; - SetTreeName : open a new tree whith this name in the viewer;; A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1) From the TBrowser :; Select a tree in the TBrowser, then call the StartViewer() method from its; context menu (right-click on the tree).; 2) From the command line :; Start a ROOT session in the directory where you have your tree.; You will need first to load the library for TTreeViewer and optionally other; libraries for user defined classes (you can do this later in ",MatchSource.WIKI,root/html602/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTreeViewer.html
https://root.cern/root/html602/TTUBE.html:1551,Availability,error,error,1551,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual In",MatchSource.WIKI,root/html602/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBE.html
https://root.cern/root/html602/TTUBE.html:1635,Availability,error,error,1635,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOf",MatchSource.WIKI,root/html602/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBE.html
https://root.cern/root/html602/TTUBE.html:111,Modifiability,inherit,inheritance,111,". TTUBE. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TTUBE. class TTUBE: public TShape. . TUBE is a tube. It has 6 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - rmin inside radius; - rmax outside radius; - dz half length in z. Function Members (Methods); public:. virtual~TTUBE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; vi",MatchSource.WIKI,root/html602/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBE.html
https://root.cern/root/html602/TTUBE.html:9654,Usability,simpl,simplified,9654,"ill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ; TNamed. TAttLine. TAttFill. TAtt3D. ; TShape. ; TTUBE. . TCONE. TELTU. THYPE. TTUBS; . TCONS. TCTUB. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root/html602/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBE.html
https://root.cern/root/html602/TTUBS.html:1740,Availability,error,error,1740,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() con",MatchSource.WIKI,root/html602/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBS.html
https://root.cern/root/html602/TTUBS.html:1824,Availability,error,error,1824,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; vir",MatchSource.WIKI,root/html602/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBS.html
https://root.cern/root/html602/TTUBS.html:111,Modifiability,inherit,inheritance,111,". TTUBS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TTUBS. class TTUBS: public TTUBE. . TUBS is a segment of a tube. It has 8 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - rmin inside radius; - rmax outside radius; - dz half length in z; - phi1 starting angle of the segment; - phi2 ending angle of the segment. NOTE: phi1 should be smaller than phi2. If this is not the case,; the system adds 360 degrees to phi2. Function Members (Methods); public:. virtual~TTUBS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::Fil",MatchSource.WIKI,root/html602/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBS.html
https://root.cern/root/html602/TTUBS.html:10129,Usability,simpl,simplified,10129,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ; TNamed. TAttLine. TAttFill. TAtt3D. ; TShape. ; TTUBE. ; TTUBS. . TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}.  Author: Nenad Buncic 18/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/g3d:$Id$  Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root/html602/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTUBS.html
https://root.cern/root/html602/TTVLVContainer.html:4990,Availability,error,error,4990,"nst char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int",MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVContainer.html:5074,Availability,error,error,5074,"am); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient",MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVContainer.html:12026,Availability,mask,mask,12026,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidTGLVContainer::LineDown(Bool_t select = kFALSE); virtual voidTGLVContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGLVContainer::LineRight(Bool_t select = kFALSE); virtual voidTGLVContainer::LineUp(Bool_t select = kFALSE); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virt",MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVContainer.html:22295,Availability,mask,mask,22295,,MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVContainer.html:23842,Integrability,message,messages,23842,ner::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*TGLVContainer::fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tTGLVContainer::fMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; EListViewModeTGLVContainer::fViewModelist view viewing mode; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0corner of rubber band box; Int_tTGContainer::fXDND; Int_tTGContainer::fXfother corner of rubber band b,MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVContainer.html:120,Modifiability,inherit,inheritance,120,". TTVLVContainer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTVLVContainer. class TTVLVContainer: public TGLVContainer. TGItemContext - empty object used as context menu support for; TGLVTreeEntries. Function Members (Methods); public:. virtual~TTVLVContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_clas",MatchSource.WIKI,root/html602/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html
https://root.cern/root/html602/TTVLVEntry.html:4016,Availability,error,error,4016,"dTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlias(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TTVLVContainer*GetContainer(); TGItemContext*GetContext(); const char*GetConvName(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() ",MatchSource.WIKI,root/html602/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVEntry.html
https://root.cern/root/html602/TTVLVEntry.html:4100,Availability,error,error,4100,"signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlias(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TTVLVContainer*GetContainer(); TGItemContext*GetContext(); const char*GetConvName(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragTy",MatchSource.WIKI,root/html602/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVEntry.html
https://root.cern/root/html602/TTVLVEntry.html:18265,Availability,mask,mask,18265,,MatchSource.WIKI,root/html602/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVEntry.html
https://root.cern/root/html602/TTVLVEntry.html:116,Modifiability,inherit,inheritance,116,". TTVLVEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTVLVEntry. class TTVLVEntry: public TGLVEntry. TGItemContext - empty object used as context menu support for; TGLVTreeEntries. Function Members (Methods); public:. virtual~TTVLVEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLVEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; const char*ConvertAliases(); virtual voidTObject::Copy(TObject& object) const; voidCopyItem(TTVLVEntry* dest); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindo",MatchSource.WIKI,root/html602/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVEntry.html
https://root.cern/root/html602/TTVLVEntry.html:21700,Usability,clear,clear,21700," TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGLVEntry. ; TTVLVEntry. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with text = 0. void SetSmallPic(const TGPicture* spic); Set small picture. TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode). const char * GetAlias(); {return fAlias.Data();}. TTVLVContainer * GetContainer(); {return fContainer;}. TGItemContext * GetContext(); {return fContext;}. const char * GetConvName(); {return fConvName;}. const char * GetTrueName(); {return fTrueName.Data();}. TGToolTip * GetTip(); {return fTip;}. Bool_t IsCut(); {return fIsCut;}. void SetAlias(const char* alias); {fAlias = alias;}. void SetTrueName(const char* name); {fTrueName = name;}.  Last changed: root/treeviewer:$Id$  Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html602/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVLVEntry.html
https://root.cern/root/html602/TTVRecord.html:1288,Availability,error,error,1288," virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html602/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVRecord.html
https://root.cern/root/html602/TTVRecord.html:1372,Availability,error,error,1372," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* me",MatchSource.WIKI,root/html602/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVRecord.html
https://root.cern/root/html602/TTVRecord.html:115,Modifiability,inherit,inheritance,115,". TTVRecord. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTVRecord. class TTVRecord: public TObject. Function Members (Methods); public:. virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html602/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVRecord.html
https://root.cern/root/html602/TTVSession.html:1339,Availability,error,error,1339," virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html602/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVSession.html
https://root.cern/root/html602/TTVSession.html:1423,Availability,error,error,1423,") const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) cons",MatchSource.WIKI,root/html602/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVSession.html
https://root.cern/root/html602/TTVSession.html:116,Modifiability,inherit,inheritance,116,". TTVSession. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREEVIEWER;  TTVSession. class TTVSession: public TObject. Function Members (Methods); public:. virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html602/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TTVSession.html
https://root.cern/root/html602/TUDPSocket.html:1529,Availability,error,error,1529," virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:1613,Availability,error,error,1613,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:3752,Availability,error,error,3752,"Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendR",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13041,Availability,down,down,13041,"y of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Sen",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13350,Availability,error,error,13350,"cket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13484,Availability,error,error,13484,"on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" fiel",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13675,Availability,avail,available,13675,"a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an ackno",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13983,Availability,error,error,13983,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:14190,Availability,error,error,14190," dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:14576,Availability,error,error,14576,"d, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EP",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:14954,Availability,error,error,14954,"has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having re",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:15255,Availability,error,error,15255," been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:15816,Availability,error,error,15816,"NG); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on th",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16189,Availability,error,error,16189,"ge object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17049,Availability,error,error,17049,"ndRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17385,Availability,error,error,17385,"ss); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17675,Availability,error,error,17675,"sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containin",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17967,Availability,error,error,17967,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18376,Availability,error,error,18376," or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t al",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:19140,Availability,error,error,19140,"e mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:19183,Availability,error,error,19183,", Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::C",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:19249,Availability,error,error,19249,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:20631,Availability,error,error,20631,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:20645,Availability,error,error,20645,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:20671,Availability,error,error,20671,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:14036,Integrability,message,message,14036,"n(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:14420,Integrability,message,message,14420,". Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, makin",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16463,Integrability,message,message,16463,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16500,Integrability,message,message,16500,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16695,Integrability,message,message,16695,"ject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16866,Integrability,message,message,16866,"en or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMe",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:16911,Integrability,message,message,16911," an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other sid",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17216,Integrability,message,message,17216,"r.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRe",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17268,Integrability,message,message,17268,"-5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length byt",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17540,Integrability,message,message,17540,"end only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:17883,Integrability,message,message,17883,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18626,Integrability,message,message,18626,"0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and al",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18673,Integrability,message,message,18673,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18729,Integrability,message,message,18729,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18833,Integrability,message,message,18833,"he user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower a",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18877,Integrability,message,message,18877,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:18930,Integrability,message,message,18930,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:19203,Integrability,depend,depends,19203,"); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build a",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:20658,Integrability,depend,depending,20658,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:116,Modifiability,inherit,inheritance,116,". TUDPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  NET;  TUDPSocket. class TUDPSocket: public TNamed. TUDPSocket. This class implements UDP client sockets. A socket is an endpoint; for communication between two machines.; The actual work is done via the TSystem class (either TUnixSystem; or TWinNTSystem). Function Members (Methods); public:. virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:5030,Safety,timeout,timeout,5030,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13545,Safety,timeout,timeout,13545,"ocket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13795,Safety,timeout,timeout,13795,"ly. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13862,Safety,timeout,timeout,13862,"reated via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13925,Safety,detect,detected,13925,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13942,Safety,timeout,timeout,13942,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:13964,Safety,timeout,timeout,13964,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:9544,Security,authenticat,authentication,9544,"TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUDPSocket::EServiceTypekPROOFD; static TUDPSocket::EServiceTypekROOTD; static TUDPSocket::EInterestkRead; static TUDPSocket::EServiceTypekSOCKD; static TObject::(anonymous)TObject::kSingleKey; static TUDPSocket::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TUDPSocket. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use ",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUDPSocket.html:11698,Security,authenticat,authentication,11698,"; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, const char* service); Create a socket. Connect to named service on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, Int_t port); Create a socket; see CreateAuthSocket for the form of url.; Connect to the specified port # on the remote host.; If user is specified in url, try authentication as user.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a s",MatchSource.WIKI,root/html602/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUDPSocket.html
https://root.cern/root/html602/TUnfold.html:701,Availability,avail,available,701,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:853,Availability,error,errors,853,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:1757,Availability,error,errors,1757,"d updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in parti",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:1892,Availability,error,error,1892,"ng the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distr",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:3104,Availability,avail,available,3104,"put data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2);",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:3331,Availability,error,errors,3331,"nimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and comp",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:4937,Availability,avail,available,4937,"ctor of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias(",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:9510,Availability,error,error,9510,,MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:9594,Availability,error,error,9594,,MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:19202,Availability,error,error,19202,"ut: scale factor for the bias; TUnfold::EConstraintfConstraintInput: type of constraint to use; TArrayIfHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*fLInput: regularisation conditions; TUnfold::ERegModefRegModeInput: type of regularisation; TArrayDfSumOverYInput: sum of all columns; Double_tfTauSquaredInput: regularisation parameter; TMatrixDSparse*fVyyInput: covariance matrix for y; TMatrixD*fX0Input: x0; TArrayIfXToHistInput: matrix indices -> histogram bins; TMatrixD*fYInput: y. private:. TMatrixDSparse*fAxResult: Ax; Double_tfChi2AResult: chi**2 contribution from (y-Ax)V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfEpsMatrixmachine accuracy for eingenvalue analysis; Int_tfIgnoredBinsnumber of input bins which are dropped because they have error=0; Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixDSparse*fVyyInvResult: inverse of covariance matrix on y; TMatrixD*fXResult: x. Class Charts. Inheritance Chart:. TObject. ; TUnfold. . TUnfoldSys; . TUnfoldDensity. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Doub",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:20842,Availability,error,error,20842,"d). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:20868,Availability,error,error,20868,"d). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:24594,Availability,error,errors,24594,"n number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); add regularisation on the difference of two bins; left_bin: 1st bin; right_bin: 2nd bin; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documen",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:25048,Availability,error,errors,25048,"s data member fL. Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfo",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:25302,Availability,error,errors,25302,"d::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for th",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:25580,Availability,error,error,25580,"of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given val",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:25908,Availability,error,errors,25908,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:25998,Availability,error,error,25998,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:26027,Availability,error,error,26027,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:26135,Availability,error,errors,26135,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:26282,Availability,error,error,26282,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:26370,Availability,error,errors,26370,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:29275,Availability,error,error,29275,"_t* binMap = 0) const; get unfolding result, folded back trough the matrix; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; retreive matrix of probabilities; histmap: on which axis to arrange the input/output vector; A: histogram to store the probability matrix. void GetInput(TH1* inputData, const Int_t* binMap = 0) const; retreive input distribution; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetInputInverseEmatrix(TH2* ematrix); calculate the inverse of the contribution to the error matrix; corresponding to the input data. void GetLsquared(TH2* lsquared) const; retreive matrix of regularisation conditions squared; out: prebooked matrix. void GetL(TH2* l) const; retreive matrix of regularisation conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:30458,Availability,error,error,30458,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:30517,Availability,error,error,30517,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:30547,Availability,error,error,30547,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:30890,Availability,error,error,30890,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:30949,Availability,error,error,30949,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:32340,Availability,error,error,32340,"t; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY;",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:32733,Availability,error,error,32733,"vEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatrixDSparse * GetVxx(void); { return fVxx; }. ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:689,Deployability,update,updates,689,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:2523,Energy Efficiency,reduce,reduce,2523,"surement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consisten",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:2067,Integrability,depend,depends,2067," transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus backgr",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:22787,Integrability,depend,depending,22787,"; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; a replacement for; (*dest) += f*(*src). TString GetOutputBinName(Int_t iBinX) const; given a bin number, return the name of the output bin; this method makes more sense for the class TUnfoldDnesity; where it gets overwritten. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fL: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t Reg",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:113,Modifiability,inherit,inheritance,113,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:3272,Modifiability,extend,extends,3272,"nimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and comp",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:3455,Modifiability,extend,extends,3455,"esult x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:7633,Modifiability,variab,variables,7633,"tive minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which often is found in; literature. The second derivative is often named curvature.; Sometimes the bias is not discussed, equivalent to a bias scale factor; of zero. The regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins; AddRegularisationCondition(); define an arbitrary regulatisation condition. Function Members (Methods); public:. virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b);",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:2363,Performance,perform,performed,2363,"ormalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:7233,Performance,tune,tuned,7233," If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; kRegModeSize minimize the size of (x-x0); kRegModeDerivative minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which often is found in; literature. The second derivative is often named curvature.; Sometimes the bias is not discussed, equivalent to a bias scale factor; of zero. The regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regu",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:2779,Safety,detect,detector,2779,"he error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. eps",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:5577,Safety,avoid,avoid,5577," difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:4952,Testability,test,tests,4952,"da/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:13507,Testability,log,logTauX,13507,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tRegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstrain",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:13530,Testability,log,logTauY,13530,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tRegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstrain",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:27020,Testability,log,logTauX,27020,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:27043,Testability,log,logTauY,27043,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:27227,Testability,log,logTauX,27227,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:27291,Testability,log,logTauY,27291,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:4895,Usability,simpl,simple,4895,"ctor of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias(",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:26493,Usability,clear,cleared,26493,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfold.html:32704,Usability,clear,clear,32704,"vEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatrixDSparse * GetVxx(void); { return fVxx; }. ",MatchSource.WIKI,root/html602/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfold.html
https://root.cern/root/html602/TUnfoldBinning.html:813,Availability,avail,available,813,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:3591,Availability,error,error,3591,"ing = 0) const; TH1*CreateHistogram(const char* histogramName, Bool_t originalAxisBinning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; static TH2D*CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); voidDecodeAxisSteering(const char* axisSteering, const char* options, Int_t* isOptionGiven) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TH1*ExtractHistogram(const char* histogramName, const TH1* globalBins, const TH2* globalBinsEmatrix = 0, Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); const TUnfoldBinning*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetBinFactor(Int_t iBin) const; const TUnfoldBinning*GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; TStringGetBinName(Int_t iBin) const; voidGetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; Double_tGetBinSize(Int_t iBin) const; voidGetBinU",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:3675,Availability,error,error,3675,"nning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; static TH2D*CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); voidDecodeAxisSteering(const char* axisSteering, const char* options, Int_t* isOptionGiven) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TH1*ExtractHistogram(const char* histogramName, const TH1* globalBins, const TH2* globalBinsEmatrix = 0, Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); const TUnfoldBinning*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetBinFactor(Int_t iBin) const; const TUnfoldBinning*GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; TStringGetBinName(Int_t iBin) const; voidGetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; Double_tGetBinSize(Int_t iBin) const; voidGetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const; const TUnf",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:801,Deployability,update,updates,801,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:12686,Deployability,update,update,12686,"isListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-empty distributions; if there is none or if there are many, return zero. Int_t GetTHxxBinsRecursive(const char* axisSteering) const; input",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:12793,Deployability,update,update,12793,"isListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-empty distributions; if there is none or if there are many, return zero. Int_t GetTHxxBinsRecursive(const char* axisSteering) const; input",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:120,Modifiability,inherit,inheritance,120,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:12615,Modifiability,variab,variables,12615,"ie. protected:. TUnfoldBinning*childNodefirst daughter node; TObjArray*fAxisLabelListfor each axis its name (TObjString); TObjArray*fAxisListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-emp",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:888,Security,access,access,888,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:17148,Security,access,access,17148,"Create THxx histograms . TH1 * CreateHistogram(const char* histogramName, Bool_t originalAxisBinning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, const Int_t* axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t ",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldBinning.html:17316,Security,access,access,17316,"har* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, const Int_t* axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. const TUnfoldBinning * GetBinLocationRecursive(Int_t& offset, const char* axisSteering, Int_t[3",MatchSource.WIKI,root/html602/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html
https://root.cern/root/html602/TUnfoldDensity.html:830,Availability,avail,available,830,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:1009,Availability,error,error,1009," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly deter",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:5996,Availability,error,error,5996,,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:6080,Availability,error,error,6080,,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:21676,Availability,error,error,21676,TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning sch,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:21731,Availability,error,error,21731,TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning sch,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:22225,Availability,error,errors,22225,s::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrix,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:22491,Availability,error,error,22491,ect::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins;,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:22558,Availability,error,error,22558,rflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:22634,Availability,error,error,22634,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. ; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:23154,Availability,error,errors,23154,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. ; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:23325,Availability,error,error,23325,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. ; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:818,Deployability,update,updates,818,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:3157,Integrability,depend,depend,3157,"lex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:120,Modifiability,inherit,inheritance,120,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:2999,Modifiability,variab,variable,2999,"with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determined with the help of auxillary; measurements. In TUnfoldDensity, such complex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area co",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:3134,Modifiability,variab,variable,3134,"lex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:3681,Modifiability,variab,variable,3681,"e ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation does not work well with; the tau-scan: the higher tau, the smaller rho, but there is no minimum.; In contrast, the tau-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative; correlations from migrations are approximately cancelled by the; positive correlations from the regularisation conditions. whichever algorithm is used, the output has to be checked:; (1) The L-curve should have approximate L-shape; and the final choice of tau should not be at the very edge of the; scanned region; (2) The scan result should have a well-defined",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:3329,Safety,predict,prediction,3329,"aves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation does not work well with; the tau-scan: the higher tau, the smaller rho, but there is no minimum.; In contrast, the tau-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:1683,Testability,test,test,1683,", please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determined with the help of auxillary; measurements. In TUnfoldDensity, such complex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" b",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:13911,Testability,log,logTauX,13911,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:13934,Testability,log,logTauY,13934,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:14166,Testability,log,logTauXPlot,14166,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:14193,Testability,log,logTauYPlot,14193,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:24715,Testability,log,logTauXPlot,24715,"ldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0). TH1 * GetOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const. TH1 * GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetDeltaSysBackgroundScale(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE). TH2 * GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const c",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:24742,Testability,log,logTauYPlot,24742,"ldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0). TH1 * GetOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const. TH1 * GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetDeltaSysBackgroundScale(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE). TH2 * GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const c",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:6590,Usability,clear,clearHist,6590,,MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:7925,Usability,clear,clearEmat,7925,"t char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysSource(const char* source, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t u",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:8261,Usability,clear,clearEmat,8261,"e = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distribu",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:8360,Usability,clear,clearEmat,8360,"stogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distributionName = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); TH2*GetL(const char* histog",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldDensity.html:17547,Usability,clear,clearEmat,17547,"uble_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidTUnfoldSys::DoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; Double_tGetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidTUnfoldSys::GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; virtual TStringGetOutputBinName(Int_t iBinX) const; Double_tTUnfold::GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; Int_tTUnfold::GetRowFromBin(int ix) const; TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixXX(); TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixYY(); const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixDSparse*TUnfold::GetVyyInv() const; const TMatrixD*TUnfold::GetX() const; TMatrixDSparse*TUnfold::InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatr",MatchSource.WIKI,root/html602/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html
https://root.cern/root/html602/TUnfoldSys.html:495,Availability,error,error,495,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:527,Availability,error,errors,527,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:577,Availability,error,errors,577,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:864,Availability,avail,available,864,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:944,Availability,error,error,944,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:997,Availability,error,errors,997,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to t",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1045,Availability,error,errors,1045,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to t",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1114,Availability,error,errors,1114,"inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCL",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1273,Availability,error,error,1273,". ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas er",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1300,Availability,error,error,1300,"Unfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; pro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1347,Availability,error,error,1347," to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error mat",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1407,Availability,error,errors,1407,"nties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These s",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1450,Availability,error,errors,1450,"nties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These s",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1509,Availability,error,errors,1509,"stematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource()",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1837,Availability,error,errors,1837,"dates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. M",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1918,Availability,error,errors,1918,"rror are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatr",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:1997,Availability,error,errors,1997,"histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d)",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2038,Availability,error,errors,2038,"histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d)",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2082,Availability,error,errors,2082,"ples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2138,Availability,error,error,2138,"ples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2242,Availability,error,errors,2242," several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argu",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2350,Availability,error,error,2350," on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogra",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2371,Availability,error,error,2371,"elated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2629,Availability,error,error,2629,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2688,Availability,error,errors,2688,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2823,Availability,error,error,2823,"ror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2843,Availability,avail,available,2843,"ror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2868,Availability,error,error,2868,"tractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2896,Availability,error,error,2896,"tractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:3253,Availability,error,error,3253,"ereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfo",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:3379,Availability,error,error,3379,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:4654,Availability,error,error,4654,,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:4738,Availability,error,error,4738,,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16138,Availability,error,error,16138,tsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSpars,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16181,Availability,error,error,16181,tsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSpars,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16505,Availability,error,errors,16505,RegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction.,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16723,Availability,error,error,16723,bject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgrou,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16778,Availability,error,error,16778,rModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + f,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:16842,Availability,error,error,16842,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:17136,Availability,error,errors,17136,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:17295,Availability,error,error,17295,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18101,Availability,error,errors,18101," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18191,Availability,error,error,18191," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18220,Availability,error,error,18220," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18266,Availability,error,error,18266,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18354,Availability,error,errors,18354,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18957,Availability,error,error,18957," 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:19278,Availability,error,error,19278,"nes 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:19553,Availability,error,error,19553,"s modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDS",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:19581,Availability,error,error,19581,"s modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDS",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:19803,Availability,error,errors,19803,"nfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMo",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:19968,Availability,error,errors,19968,"X, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:20125,Availability,error,error,20125,"X, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:852,Deployability,update,updates,852,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18865,Integrability,depend,depend,18865,"-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* b",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:116,Modifiability,inherit,inheritance,116,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:17718,Performance,perform,performs,17718,"lt: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~T",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18511,Performance,perform,performs,18511,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ; TUnfold. ; TUnfoldSys. . TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:2457,Security,access,accessed,2457,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:10067,Testability,log,logTauX,10067,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:10090,Testability,log,logTauY,10090,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:3362,Usability,clear,cleared,3362,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:3395,Usability,simpl,simply,3395,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:5127,Usability,clear,clearHist,5127,,MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:5768,Usability,clear,clearEmat,5768,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:5887,Usability,clear,clearEmat,5887,"virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:6007,Usability,clear,clearEmat,6007,"st; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:6117,Usability,clear,clearEmat,6117,"ol_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:6204,Usability,clear,clearEmat,6204," const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(T",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:6294,Usability,clear,clearEmat,6294,"hi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnf",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:13023,Usability,clear,clearEmat,13023,"s(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidGetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; virtual TStringTUnfold::GetOutputBinName(Int_t iBinX) const; Double_tTUnfold::GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; Int_tTUnfold::GetRowFromBin(int ix) const; TMatrixDSparse*GetSummedErrorMatrixXX(); TMatrixDSparse*GetSummedErrorMatrixYY(); const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixDSparse*TUnfold::GetVyyInv() const; const TMatrixD*TUnfold::GetX() const; TMatrixDSparse*TUnfold::InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixTBase<Double_",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:18836,Usability,clear,clear,18836,"-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* b",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:20687,Usability,clear,clearEmat,20687,"Sparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE).  Last changed: Tue Jun 2 14:10:12 2015  Last generated: 2015-06-02",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:21240,Usability,clear,clearEmat,21240,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE).  Last changed: Tue Jun 2 14:10:12 2015  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:21351,Usability,clear,clearEmat,21351,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE).  Last changed: Tue Jun 2 14:10:12 2015  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:21471,Usability,clear,clearEmat,21471,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE).  Last changed: Tue Jun 2 14:10:12 2015  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnfoldSys.html:21558,Usability,clear,clearEmat,21558,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE).  Last changed: Tue Jun 2 14:10:12 2015  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html
https://root.cern/root/html602/TUnixSystem.html:3449,Availability,error,error,3449,"har* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtu",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:3533,Availability,error,error,3533,"opyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtual const char*TSystem::GetBuildCompilerVersion() const; virtual const char*TSystem::",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:11984,Availability,mask,mask,11984,"nst char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:13687,Availability,mask,mask,13687,"etNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnixSystem(); TUnixSystem(const TUnixSystem&); virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:19367,Availability,mask,mask,19367,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:19414,Availability,mask,mask,19414,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:19495,Availability,mask,masks,19495,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:20944,Availability,error,error,20944,"; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TSystem. ; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignal",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:22666,Availability,mask,mask,22666,"er was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Return",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23113,Availability,error,error,23113,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23566,Availability,error,error,23566,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25248,Availability,error,error,25248," system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const c",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25823,Availability,failure,failure,25823,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25910,Availability,error,error,25910,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:26031,Availability,failure,failure,26031,"; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Sym",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:26998,Availability,failure,failure,26998,"e a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27134,Availability,failure,failure,27134,"ts to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the proces",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27257,Availability,failure,failure,27257,"char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27609,Availability,error,error,27609,"ee, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for c",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27959,Availability,error,error,27959," from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:28060,Availability,error,error,28060,"te a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effect",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:28096,Availability,mask,mask,28096,"essful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:28138,Availability,mask,mask,28138,"essful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:28332,Availability,error,error,28332,"pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:29284,Availability,error,error,29284,"ime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:29516,Availability,error,error,29516,"ed list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process i",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:29783,Availability,error,error,29783," the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30106,Availability,error,error,30106,"ile being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, c",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:31811,Availability,error,error,31811," of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32123,Availability,error,error,32123,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32520,Availability,error,error,32520,"ucture.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int p",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:34996,Availability,error,error,34996," scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:35073,Availability,avail,available,35073,"nounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:35357,Availability,error,error,35357,"to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoB",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:35511,Availability,error,error,35511,"indowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket optio",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:35873,Availability,error,error,35873,"omain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When t",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:36296,Availability,error,error,36296," size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls()",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37826,Availability,mask,masks,37826,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37964,Availability,error,error,37964,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:39622,Availability,error,error,39622,"t_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen(",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:39775,Availability,error,error,39775,"_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reu",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:39940,Availability,error,error,39940,"()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:41451,Availability,error,error,41451,"window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl a",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:41791,Availability,error,error,41791,"s; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Retu",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:42710,Availability,error,error,42710,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:42887,Availability,error,error,42887,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:43138,Availability,error,error,43138,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:43297,Availability,error,error,43297,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:350,Integrability,interface,interface,350,". TUnixSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  UNIX;  TUnixSystem. class TUnixSystem: public TSystem. TUnixSystem. Class providing an interface to the UNIX Operating System. Function Members (Methods); public:. virtual~TUnixSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* lib); virtual voidAddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:2457,Integrability,protocol,protocol,2457,", Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock, Bool_t force = kFALSE); virtual voidCloselog(); virtual intClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); v",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:9187,Integrability,protocol,protocol,9187,"TObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeNow(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intOpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidOpenlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*OpenPipe(const char* shellcmd, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnixSystem&operator=(const TUnixSystem&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(in",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:20545,Integrability,interface,interface,20545,"sion of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TSystem. ; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signa",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:26629,Integrability,depend,dependend,26629,"ists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Un",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30973,Integrability,message,message,30973,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:33530,Integrability,protocol,protocol,33530,". TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms s",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:33687,Integrability,protocol,protocol,33687," dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:38910,Integrability,depend,dependend,38910,"EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindows",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:117,Modifiability,inherit,inheritance,117,". TUnixSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  UNIX;  TUnixSystem. class TUnixSystem: public TSystem. TUnixSystem. Class providing an interface to the UNIX Operating System. Function Members (Methods); public:. virtual~TUnixSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* lib); virtual voidAddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:17742,Modifiability,config,configure,17742,t; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSystem::EAclicModeTSystem::kOpt; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EA,MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:20860,Modifiability,variab,variable,20860,"lerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TSystem. ; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified sig",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:24785,Modifiability,config,configured,24785,"ol_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when succes",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27460,Modifiability,variab,variables,27460,"; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Fi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:27810,Modifiability,variab,variables,27810,"stem; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Re",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30193,Modifiability,variab,variable,30193,"d); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redir",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30258,Modifiability,variab,variable,30258,"structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the fil",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30319,Modifiability,variab,variable,30319,"turned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:18359,Performance,optimiz,optimized,18359,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:19045,Performance,cache,cache,19045,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32031,Performance,load,loading,32031,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32067,Performance,load,loaded,32067,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32335,Performance,load,loaded,32335,"ifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetSer",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:32424,Performance,load,loaded,32424,"ed before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(in",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:42807,Performance,load,load,42807,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:42824,Performance,load,load,42824,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:42962,Performance,load,load,42962,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem().  Author: Fons Rademakers 15/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/unix:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:11161,Safety,timeout,timeout,11161,"obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:11216,Safety,timeout,timeout,11216,"ngth); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:15709,Safety,timeout,timeout,15709,"ptr = 0); virtual voidTSystem::DoBeep(Int_t = -1, Int_t = -1) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TSystem::ExpandFileName(const char* fname); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); TString&TSystem::GetLastErrorString(); const TString&TSystem::GetLastErrorString() const; virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static const char*TSystem::StripOffProto(const char* path, const char* proto); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, SigHandler_t h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:22342,Safety,timeout,timeout,22342,"was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:22955,Safety,timeout,timeout,22955,"ers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:22997,Safety,timeout,timeout,22997,"s sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and ca",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23082,Safety,timeout,timeout,23082,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23379,Safety,timeout,timeout,23379,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(voi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23451,Safety,timeout,timeout,23451,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:23536,Safety,timeout,timeout,23536,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25157,Safety,safe,safely,25157,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25191,Safety,avoid,avoids,25191,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:26162,Safety,avoid,avoid,26162,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37067,Safety,timeout,timeout,37067,"eset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37733,Safety,timeout,timeout,37733,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37839,Safety,timeout,timeout,37839,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:37933,Safety,timeout,timeout,37933,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:18468,Security,access,access,18468,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:24917,Security,secur,secure,24917,"hed. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error du",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25206,Security,secur,security,25206,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25456,Security,access,access,25456,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25490,Security,access,access,25490,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:25537,Security,access,access,25537,"ctory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:28233,Security,access,access,28233,"a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in th",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30772,Testability,log,log,30772,"ed structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included S",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:30945,Testability,log,logging,30945,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:31009,Testability,log,log,31009,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnixSystem.html:31058,Testability,log,log,31058," The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1",MatchSource.WIKI,root/html602/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnixSystem.html
https://root.cern/root/html602/TUnuran.html:4788,Availability,error,error,4788,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }.  Author: L. Moneta Tue Sep 26 16:25:09 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:3505,Deployability,continuous,continuous,3505,"opied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN ",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:1611,Integrability,wrap,wrapper,1611,"igned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance Chart:. TUnuran. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied i",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:113,Modifiability,inherit,inheritance,113,". TUnuran. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuran. class TUnuran. Function Members (Methods); public:. ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiContDist& distr, const string& method = ""hitro""); boolInit(const TUnuranDiscrDist& distr, const string& method = ""auto""); boolInit(const TUnuranEmpDist& distr, const string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance Chart:. TUnuran. Function documentation; TUnuran(TRandom* r = 0, unsigned int l",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:1153,Testability,log,log,1153,". TUnuran. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuran. class TUnuran. Function Members (Methods); public:. ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiContDist& distr, const string& method = ""hitro""); boolInit(const TUnuranDiscrDist& distr, const string& method = ""auto""); boolInit(const TUnuranEmpDist& distr, const string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance Chart:. TUnuran. Function documentation; TUnuran(TRandom* r = 0, unsigned int l",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:2000,Testability,log,log,2000,"lag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance Chart:. TUnuran. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to ma",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuran.html:4780,Testability,log,log,4780,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }.  Author: L. Moneta Tue Sep 26 16:25:09 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuran.html
https://root.cern/root/html602/TUnuranBaseDist.html:575,Availability,avail,available,575,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance Chart:. TUnuranBaseDist. . TUnuranContDist. TUnuranDiscrDist. TUnuranEmpDist. TUnuranMultiContDist. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes.  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranBaseDist.html
https://root.cern/root/html602/TUnuranBaseDist.html:110,Modifiability,inherit,inheritance,110,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance Chart:. TUnuranBaseDist. . TUnuranContDist. TUnuranDiscrDist. TUnuranEmpDist. TUnuranMultiContDist. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes.  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranBaseDist.html
https://root.cern/root/html602/TUnuranContDist.html:2401,Integrability,interface,interfaces,2401,"LogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set t",MatchSource.WIKI,root/html602/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranContDist.html
https://root.cern/root/html602/TUnuranContDist.html:2838,Integrability,interface,interface,2838,"on has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is",MatchSource.WIKI,root/html602/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranContDist.html
https://root.cern/root/html602/TUnuranContDist.html:121,Modifiability,inherit,inheritance,121,". TUnuranContDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranContDist. class TUnuranContDist: public TUnuranBaseDist. Function Members (Methods); public:. virtual~TUnuranContDist(); doubleCdf(double x) const; static TClass*Class(); virtual TUnuranContDist*Clone() const; doubleDPdf(double x) const; boolGetDomain(double& xmin, double& xmax) const; boolHasCdf() const; boolHasMode() const; boolHasPdfArea() const; virtual TClass*IsA() const; boolIsLogPdf() const; doubleMode() const; TUnuranContDist&operator=(const TUnuranContDist& rhs); doublePdf(double x) const; doublePdfArea() const; voidSetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranContDist(const TUnuranContDist&); TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; co",MatchSource.WIKI,root/html602/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranContDist.html
https://root.cern/root/html602/TUnuranContDist.html:1881,Testability,log,log,1881,"SetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranContDist(const TUnuranContDist&); TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution u",MatchSource.WIKI,root/html602/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranContDist.html
https://root.cern/root/html602/TUnuranContDist.html:4282,Testability,log,log,4282,"; Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is provided for the distribution. { return fCdf != 0; }. bool HasMode() const. check if distribution has a pre-computed mode. { return fHasMode; }. bool HasPdfArea() const. check if distribution has a pre-computed area below the Pdf. { return fHasArea; }. double Mode() const. return the mode (x location of maximum of the pdf). { return fMode; }. double PdfArea() const. return area below the pdf. { return fArea; }. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }.  Last changed: root/unuran:$Id$  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranContDist.html
https://root.cern/root/html602/TUnuranDiscrDist.html:2563,Integrability,interface,interface,2563,"olfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities; vector<double>fPVecSumVector of the sum of the probabilities; const ROOT::Math::IGenFunction*fPmfpointer to a function calculating the probability; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranDiscrDist. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false); Constructor from a generic function object. TUnuranDiscrDist(TF1* func); Constructor from a TF1 objects. TUnuranDiscrDist(const TUnuranDiscrDist& ); Implementation of copy ctor using aassignment operator. ~TUnuranDiscrDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pmf(int x) const; evaluate the distribution. double Cdf(int x) const; evaluate the cumulative distribution; otherwise evaluate from the sum of the probabilities. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xmax a domain is removed. void SetMode(int mode). set the mode of the distribution (location of maximum probability). { fMode = mode; fHasMode=true;}. void SetProbSum(double sum). set the value of the sum of the probabilities in the given domain. { fSum = sum; fHasSum=true; }. bool GetDomain(int& xmin, int& xmax) const. check if distribution has domain and return in case its domain. int Mode() const. get the mode (x location of function maximum). { return fMode; }. double ProbSum",MatchSource.WIKI,root/html602/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranDiscrDist.html
https://root.cern/root/html602/TUnuranDiscrDist.html:122,Modifiability,inherit,inheritance,122,". TUnuranDiscrDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranDiscrDist. class TUnuranDiscrDist: public TUnuranBaseDist. Function Members (Methods); public:. virtual~TUnuranDiscrDist(); doubleCdf(int x) const; static TClass*Class(); virtual TUnuranDiscrDist*Clone() const; boolGetDomain(int& xmin, int& xmax) const; boolHasCdf() const; boolHasMode() const; boolHasProbSum() const; virtual TClass*IsA() const; intMode() const; TUnuranDiscrDist&operator=(const TUnuranDiscrDist& rhs); doublePmf(int x) const; doubleProbSum() const; const vector<double>&ProbVec() const; voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetCdf(TF1* cdf); voidSetDomain(int xmin, int xmax); voidSetMode(int mode); voidSetProbSum(double sum); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranDiscrDist(TF1* func); TUnuranDiscrDist(const TUnuranDiscrDist&); TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Data Members; private:. const ROOT::Math::IGenFunction*fCdfpointer to the cumulative distribution function; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [0,INT_MAX]); boolfHasModeflag to control if distribution has a pre-computed mode; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities; vector<double>fPVecSumVector of the sum of the probabilities; const ROOT::Math::IGenFunction*fPmfpointer to a function calculating the probability; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domai",MatchSource.WIKI,root/html602/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranDiscrDist.html
https://root.cern/root/html602/TUnuranEmpDist.html:1580,Availability,avail,available,1580,"st&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranEmpDist(const TUnuranEmpDist&); TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranEmpDist. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); Constructor from a TH1 objects.; The buffer of the histo, if available, can be used for; the estimation of the parent distribution using smoothing. TUnuranEmpDist(unsigned int n, double* x); constructor for 1D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y); constructor for 2D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); constructor for 3D unbinned data. TUnuranEmpDist(const TUnuranEmpDist& ); Implementation of copy ctor using aassignment operator. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. Return reference to data vector (unbinned or binned data). { return fData; }. bool IsBinned() const. Flag to control if data are binned. { return fBinned; }. double LowerBin() const. Min value of binned data; (return 0 for unbinned data). { return fMin; }. double UpperBin() const. upper value of binned data; (return 0 for unbinned data). { return fMax; }. unsigned int NDim()",MatchSource.WIKI,root/html602/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranEmpDist.html
https://root.cern/root/html602/TUnuranEmpDist.html:120,Modifiability,inherit,inheritance,120,". TUnuranEmpDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranEmpDist. class TUnuranEmpDist: public TUnuranBaseDist. Function Members (Methods); public:. virtual~TUnuranEmpDist(); static TClass*Class(); virtual TUnuranEmpDist*Clone() const; const vector<double>&Data() const; virtual TClass*IsA() const; boolIsBinned() const; doubleLowerBin() const; unsigned intNDim() const; TUnuranEmpDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranEmpDist(const TUnuranEmpDist&); TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranEmpDist. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); Constructor from a TH1 objects.; The buffer of the histo, if available, can be used for; the estimation of the parent distribution using smoothing. TUnuranEmpDist(unsigned int n, double* x); constructor for 1D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y); constructor for 2D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); constructor for 3D unbinned data. TUnuranEmpDist(const TUnuranEmpDist& ); Implementation of copy ctor us",MatchSource.WIKI,root/html602/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranEmpDist.html
https://root.cern/root/html602/TUnuranMultiContDist.html:1977,Integrability,interface,interfaces,1977,"onst double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranMultiContDist. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array o",MatchSource.WIKI,root/html602/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranMultiContDist.html
https://root.cern/root/html602/TUnuranMultiContDist.html:126,Modifiability,inherit,inheritance,126,". TUnuranMultiContDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranMultiContDist. class TUnuranMultiContDist: public TUnuranBaseDist. Function Members (Methods); public:. virtual~TUnuranMultiContDist(); static TClass*Class(); virtual TUnuranMultiContDist*Clone() const; doubleDerivative(const double* x, int icoord) const; const double*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranMultiContDist. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMulti",MatchSource.WIKI,root/html602/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranMultiContDist.html
https://root.cern/root/html602/TUnuranMultiContDist.html:1409,Testability,log,log,1409,"uble*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ; TUnuranMultiContDist. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerica",MatchSource.WIKI,root/html602/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranMultiContDist.html
https://root.cern/root/html602/TUnuranMultiContDist.html:3809,Testability,log,log,3809," Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const double * GetUpperDomain() const. get the distribution upper domain values. Return a null pointer if domain is not defined. const double * GetMode() const. get the mode (vector of coordinate positions of the maxima of the distribution); If a mode has not defined return a NULL pointer. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }.  Last changed: root/unuran:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranMultiContDist.html
https://root.cern/root/html602/TUnuranSampler.html:1355,Availability,error,error,1355,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:1475,Availability,error,errors,1475,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:4012,Availability,error,error,4012,"ag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). {fLevel = level;}. void SetMode(double mode). set the mode. void SetArea(double area). set the area.  Author: L. Moneta Fri Sep 22 15:06:47 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:3330,Integrability,interface,interface,3330,"::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IGenFunction*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). ",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:120,Modifiability,inherit,inheritance,120,". TUnuranSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  UNURAN;  TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* ",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:772,Modifiability,extend,extend,772,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUnuranSampler.html:913,Modifiability,extend,extend,913,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html602/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html
https://root.cern/root/html602/TUploadDataSetDlg.html:464,Availability,avail,available,464,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  SESSIONVIEWER;  TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(co",MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUploadDataSetDlg.html:4603,Availability,error,error,4603," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUploadDataSetDlg.html:4687,Availability,error,error,4687,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUploadDataSetDlg.html:20374,Availability,mask,mask,20374,,MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUploadDataSetDlg.html:24621,Integrability,message,messages,24621,"ton; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance Chart:. TObject. ; TGObject. ; TGWindow. TQObject. ; TGFrame. ; TGCompositeFrame. ; TGMainFrame. ; TGTransientFrame. ; TUploadDataSetDlg. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void RemoveFile(); Remove the selected entry from the list view. void UploadDataSet(); Upload the dataset to the server. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h).  Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/sess",MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUploadDataSetDlg.html:123,Modifiability,inherit,inheritance,123,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  SESSIONVIEWER;  TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(co",MatchSource.WIKI,root/html602/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html
https://root.cern/root/html602/TUri.html:1496,Availability,error,error,1496," virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:1580,Availability,error,error,1580," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringG",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:13796,Availability,error,error,13796,"hority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. const TString PctEncode(const TString& source); Percent-encode and return the given string according to RFC 3986; in principle, this function cannot fail or produce an error. Bool_t IsHost(const TString& ); Returns kTRUE if string qualifies as valid host component:; host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t IsPath(const TString& ); Retruns kTRUE if string qualifies as valid path component:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t IsPathAbempty(const TString& ); Returns kTRUE if string qualifies as valid path-abempty component:; path-abempty = *( ""/"" segment ); segment = *pchar. Bool_t IsPathAbsolute(const TString& ); Returns kTRUE if string qualifies as valid path-absolute component; path-absolute = ""/"" [ segment-nz *( ""/"" segment ) ]; segment-nz = 1*pchar; segment = *pchar. Bool_t IsPathNoscheme(const TString& ); Returns kTRUE if s",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:9228,Integrability,rout,routine,9228,"_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A. Bool_t IsRelative() const; Returns kTRUE if instance qualifies as relative-ref; relative-ref = relative-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsUri() const; Returns kTRUE if instance qualifies as URI; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsReference() const; Returns kTRUE if instance qualifies as URI-reference; URI-reference = URI / relative-ref; cf. Appendix A. Bool_t SetScheme(const TString& scheme); Set scheme component of URI:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / ""-"" / ""."" ). Bool_t IsScheme(const TString& ); Returns kTRUE if string qualifies as URI scheme:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / """,MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:110,Modifiability,inherit,inheritance,110,". TUri. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TUri. class TUri: public TObject. TUri. This class represents a RFC 3986 compatible URI.; See http://rfc.net/rfc3986.html.; It provides member functions to set and return the different; the different parts of an URI. The functionality is that of; a validating parser. Function Members (Methods); public:. virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:12432,Modifiability,variab,variables,12432,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:512,Security,validat,validating,512,". TUri. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TUri. class TUri: public TObject. TUri. This class represents a RFC 3986 compatible URI.; See http://rfc.net/rfc3986.html.; It provides member functions to set and return the different; the different parts of an URI. The functionality is that of; a validating parser. Function Members (Methods); public:. virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:8467,Security,password,password,8467,"onst char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' a",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:12477,Security,validat,validates,12477,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUri.html:12231,Usability,simpl,simply,12231," userinfo = *( unreserved / pct-encoded / sub-delims / "":"" ); this equals to pchar without the '@' character. Bool_t SetHost(const TString& host); Set host component of URI:; RFC 3986: host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless",MatchSource.WIKI,root/html602/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUri.html
https://root.cern/root/html602/TUrl.html:1497,Availability,error,error,1497," virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:1581,Availability,error,error,1581,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:7360,Integrability,protocol,protocols,7360,"eap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t ",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:7778,Integrability,protocol,protocols,7778,"(after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:7834,Integrability,protocol,protocols,7834,"(after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:7897,Integrability,protocol,protocol,7897,"!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been a",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:8546,Integrability,protocol,protocols,8546," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:8602,Integrability,protocol,protocols,8602," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:8665,Integrability,protocol,protocol,8665,"o://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Conve",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:9416,Integrability,protocol,protocol,9416,"acter string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:9896,Integrability,protocol,protocol,9896,"94, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing a",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:10143,Integrability,protocol,protocols,10143," anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { r",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:10183,Integrability,protocol,protocols,10183,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { ",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:10213,Integrability,protocol,protocol,10213,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { ",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:110,Modifiability,inherit,inheritance,110,". TUrl. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TUrl. class TUrl: public TObject. TUrl. This class represents a WWW compatible URL.; It provides member functions to return the different parts of; an URL. The supported url format is:; [proto://][user[:passwd]@]host[:port]/file.ext[#anchor][?options]. Function Members (Methods); public:. virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUrl.html:9780,Security,access,access,9780,"""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) co",MatchSource.WIKI,root/html602/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUrl.html
https://root.cern/root/html602/TUUID.html:6146,Integrability,interface,interface,6146,"_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:111,Modifiability,inherit,inheritance,111,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:3254,Performance,perform,performance,3254," create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetUUIDNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStreamerV1(TBuffer& b); TUUID(); TUUID(const char* uuid_str); TUUID(const T",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:2014,Safety,detect,detects,2014,"id 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, a",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:2430,Safety,avoid,avoiding,2430," fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:6467,Security,hash,hash,6467," from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }.  Author: Fons Rademakers 30/9/2001  Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TUUID.html:2961,Usability,clear,cleared,2961,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetU",MatchSource.WIKI,root/html602/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TUUID.html
https://root.cern/root/html602/TVector2.html:1324,Availability,error,error,1324," virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html602/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector2.html
https://root.cern/root/html602/TVector2.html:1408,Availability,error,error,1408,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector2.html
https://root.cern/root/html602/TVector2.html:114,Modifiability,inherit,inheritance,114,". TVector2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TVector2. class TVector2: public TObject. Function Members (Methods); public:. virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html602/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector2.html
https://root.cern/root/html602/TVector3.html:5566,Availability,error,error,5566,"t char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt",MatchSource.WIKI,root/html602/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector3.html
https://root.cern/root/html602/TVector3.html:5650,Availability,error,error,5650,"al TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual B",MatchSource.WIKI,root/html602/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector3.html
https://root.cern/root/html602/TVector3.html:114,Modifiability,inherit,inheritance,114,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;  TVector3 v1; //; v1 = (0,0,0);  TVector3 v3(1,2,3); // v3 = (1,2,3);  TVector3 v4(v2); // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;  xx = v1.X(); or xx =; v1(0);;  yy = v1.Y();; yy = v1(1);;  zz = v1.Z();; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;  v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;  v1.SetXYZ(1.,2.,3.);; . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;  Double_t m = v.Ma",MatchSource.WIKI,root/html602/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector3.html
https://root.cern/root/html602/TVector3.html:979,Modifiability,variab,variables,979,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;  TVector3 v1; //; v1 = (0,0,0);  TVector3 v3(1,2,3); // v3 = (1,2,3);  TVector3 v4(v2); // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;  xx = v1.X(); or xx =; v1(0);;  yy = v1.Y();; yy = v1(1);;  zz = v1.Z();; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;  v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;  v1.SetXYZ(1.,2.,3.);; . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;  Double_t m = v.Ma",MatchSource.WIKI,root/html602/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector3.html
https://root.cern/root/html602/TVector3.html:12731,Testability,log,log,12731,"ector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vector around Z. void Rotate(Double_t , const TVector3& ); rotate vector. void RotateUz(const TVector3& ); NewUzVector must be normalized !. Double_t PseudoRapidity() const; Double_t m = Mag();; return 0.5*log( (m+fZ)/(m-fZ) );; guard against Pt=0. void SetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); set Pt, Eta and Phi. void SetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); set Pt, Theta and Phi. void SetTheta(Double_t ); Set theta keeping mag and phi constant (BaBar). void SetPhi(Double_t ); Set phi keeping mag and theta constant (BaBar). Double_t DeltaR(const TVector3& ) const; return deltaR with respect to v. void SetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); setter with mag, theta, phi. void Streamer(TBuffer& ); Stream an object of class TVector3. void Print(Option_t* option = """") const; print vector parameters. Double_t & operator[](int ); { return operator()(i); }. Double_t operator[](int ) const; { return operator()(i); }. Double_t x() const; { return fX; }. Double_t y() const; { return fY; }. Double_t z() const; { return fZ; }. Double_t X() const; { return fX; }. Double_t Y() const; { return fY; }. Double_t Z() const; { return fZ; }. Double_t Px() const; { return fX; }. ",MatchSource.WIKI,root/html602/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVector3.html
https://root.cern/root/html602/TVectorT_double_.html:573,Availability,avail,available,573,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:2336,Availability,error,error,2336,"ctorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:2420,Availability,error,error,2420,"orT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:11995,Integrability,depend,depends,11995,"ector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<double>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Elemen",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:122,Modifiability,inherit,inheritance,122,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:602,Safety,avoid,avoiding,602,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_double_.html:1030,Testability,test,test,1030,"ick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"",MatchSource.WIKI,root/html602/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html
https://root.cern/root/html602/TVectorT_float_.html:570,Availability,avail,available,570,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:2322,Availability,error,error,2322,"t TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:2406,Availability,error,error,2406,"VectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUn",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:11748,Integrability,depend,depends,11748,"is vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<float>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Element>",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:121,Modifiability,inherit,inheritance,121,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:599,Safety,avoid,avoiding,599,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TVectorT_float_.html:1027,Testability,test,test,1027,"Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATRIX;  TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; vir",MatchSource.WIKI,root/html602/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html
https://root.cern/root/html602/TView.html:468,Availability,avail,available,468,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root/html602/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView.html
https://root.cern/root/html602/TView.html:2202,Availability,error,error,2202,"tatic TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject",MatchSource.WIKI,root/html602/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView.html
https://root.cern/root/html602/TView.html:2286,Availability,error,error,2286,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDvi",MatchSource.WIKI,root/html602/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView.html
https://root.cern/root/html602/TView.html:111,Modifiability,inherit,inheritance,111,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root/html602/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView.html
https://root.cern/root/html602/TView.html:11030,Modifiability,plug-in,plug-in,11030,"TObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance Chart:. TObject. TAttLine. ; TView. . TView3D. Function documentation; TView(const TView& ); Copy constructor. TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. TView(); {}. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). Double_t GetLatitude(). Double_t GetLongitude(). Double_t GetPsi(). void GetRange(Float_t* min, Float_t* max). void GetRange(Double_t* min, Double_t* max). Double_t * GetRmax(). Double_t * G",MatchSource.WIKI,root/html602/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView.html
https://root.cern/root/html602/TView3D.html:2138,Availability,avail,available,2138," PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSize(2);; pm3d1->SetMarkerColor(4);; pm3d1->SetMarkerStyle(2);. // Draw; pl3d1->Draw();; pm3d1->Draw();; }. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefin",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:4014,Availability,error,error,4014,"View*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TO",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:4098,Availability,error,error,4098,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tG",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:17290,Availability,down,down,17290,"costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); Define view direction (in spherical coordinates). Compute transformation matrix from world coordinates; to normalised coordinates (-1 to +1). Input: S(3) - scale factors; C(3) - centre of scope; COSPHI - longitude COS; SINPHI - longitude SIN; COSTHE - latitude COS (angle between +Z and view direc.); SINTHE - latitude SIN; COSPSI - screen plane rotation angle COS; SINPSI - screen plane rotation angle SIN. void DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); Draw the outline of a cube while rotating a 3-d object in the pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void ExecuteRotateView(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a object is clicked with the locator. If Left button clicked in the object area, while the button is kept down; the cube representing the surrounding frame for the corresponding; new latitude and longitude position is drawn. void FindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); Find Z component of NORMAL in normalized coordinates. Input: X - X-component of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separato",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:18581,Availability,error,error,18581," of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separators (modified internally). Output: ITH1 - initial sector; ITH2 - final sector. void FindScope(Double_t* scale, Double_t* center, Int_t& irep); Find centre of a MIN-MAX scope and scale factors. Output: SCALE(3) - scale factors; CENTER(3) - centre; IREP - reply (-1 if error in min-max). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); Return distance to axis from point px,py. Algorithm:. A(x1,y1) P B(x2,y2); ------------------------------------------------; I; I; I; I; M(x,y). Let us call a = distance AM A=a**2; b = distance BM B=b**2; c = distance AB C=c**2; d = distance PM D=d**2; u = distance AP U=u**2; v = distance BP V=v**2 c = u + v. D = A - U; D = B - V = B -(c-u)**2; ==> u = (A -B +C)/2c. Double_t GetExtent() const; Get maximum view extent. void GetRange(Float_t* min, Float_t* max); Get Range function. void GetRange(Double_t* min, Double_t* max); Get Range function. void GetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; Get current window extent. Bool_t IsClippedNDC(Double_t* p) const; Check if point is clipped in perspective view. void NDCtoWC(const Float_t* pn, Float_t* pw); Transfer point from normalized to world coordinates. Input: PN(3) - point in world coordina",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:22003,Availability,error,error,22003,"-------+; (x,y,z) (X,y,z). void SetParallel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:22030,Availability,error,error,22030,"lel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void Adj",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:23874,Availability,down,down,23874,"(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {ret",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:22512,Deployability,update,updated,22512,"view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlon",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:442,Energy Efficiency,adapt,adapted,442,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:14157,Integrability,depend,depending,14157,"_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance Chart:. TObject. TAttLine. ; TView. ; TView3D. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd point of X-axis; IY1 - 1st point of Y-axis; IY2 - 2nd point of Y-axis; IZ1 - 1st point of Z-axis; IZ2 - 2nd point of Z-axis. 8 6; / \ /|\; 5 / \ 7 5 / | \ 7; |\ /| | | |; THETA < 90 | \6/ | THETA > 90 | /2\ |; (Top view) | | | (Bottom vie",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:113,Modifiability,inherit,inheritance,113,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:442,Modifiability,adapt,adapted,442,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:955,Usability,simpl,simple,955,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TView3D.html:981,Usability,simpl,simple,981,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html602/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TView3D.html
https://root.cern/root/html602/TViewer3DPad.html:1853,Availability,error,error,1853,"irtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html602/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewer3DPad.html
https://root.cern/root/html602/TViewer3DPad.html:1937,Availability,error,error,1937,"l Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html602/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewer3DPad.html
https://root.cern/root/html602/TViewer3DPad.html:351,Integrability,interface,interface,351,". TViewer3DPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TViewer3DPad. class TViewer3DPad: public TVirtualViewer3D. Provides 3D viewer interface (TVirtualViewer3D) support on a pad.; Will be merged with TView / TView3D eventually. Function Members (Methods); public:. virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t",MatchSource.WIKI,root/html602/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewer3DPad.html
https://root.cern/root/html602/TViewer3DPad.html:118,Modifiability,inherit,inheritance,118,". TViewer3DPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GPAD;  TViewer3DPad. class TViewer3DPad: public TVirtualViewer3D. Provides 3D viewer interface (TVirtualViewer3D) support on a pad.; Will be merged with TView / TView3D eventually. Function Members (Methods); public:. virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t",MatchSource.WIKI,root/html602/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewer3DPad.html
https://root.cern/root/html602/TViewerX3D.html:1829,Availability,error,error,1829,"ene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:1913,Availability,error,error,1913,"ass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidIconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) co",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:9511,Availability,down,down,9511,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:9549,Deployability,toggle,toggle,9549,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:9580,Deployability,toggle,toggle,9580,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:9611,Deployability,toggle,toggle,9611,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:9644,Deployability,toggle,toggle,9644,"OOT X3D viewer. void Close(); Close X3D Viewer. void CreateViewer(const char* name); Create the actual canvas. void InitX3DWindow(); Setup geometry and initialize X3D. void BeginScene(); The x3d viewer cannot rebuild a scene once created. void EndScene(); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); The x3d viewer cannot rebuild a scene once created. Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed IDs - discard. void PaintPolyMarker(const TBuffer3D& buffer) const; Paint 3D PolyMarker. Int_t ExecCommand(Int_t px, Int_t py, char command); This function may be called from a script to animate an X3D picture; px, py mouse position; command = 0 --- move to px,py; = w --- wireframe mode; = e --- hidden line mode; = r --- hidden surface mode; = u --- move object down; = i --- move object up; = o --- toggle controls style; = s --- toggle stereo display; = d --- toggle blue stereo view; = f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D vie",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:10794,Deployability,release,release,10794," f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}.  Author: Rene Brun 05/09/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/x3d:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:10827,Deployability,update,update,10827," f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}.  Author: Rene Brun 05/09/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/x3d:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:341,Integrability,interface,interface,341,". TViewerX3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  X3D;  TViewerX3D. class TViewerX3D: public TVirtualViewer3D. TViewerX3D. C++ interface to the X3D viewer. Function Members (Methods); public:. virtual~TViewerX3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual ",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:10994,Integrability,interface,interface,10994," f --- toggle double buffer; = h --- move object right; = j --- move object forward; = k --- move object backward; = l --- move object left; = x a --- rotate about x; = y b --- rotate about y; = z c --- rotate about z; = 1 2 3 --- autorotate about x; = 4 5 6 --- autorotate about y; = 7 8 9 --- autorotate about z; = [ ] { } --- adjust focus; Example:. {; gSystem->Load(""libX3d"");; TCanvas *c1 = new TCanvas(""c1"");; TFile *f = new TFile(""hsimple.root"");; TTree *ntuple = (TTree*)f->Get(""ntuple"");; ntuple->SetMarkerColor(kYellow);; ntuple->Draw(""px:py:pz"");; TViewerX3D *x3d = new TViewerX3D(c1,"""");; for (Int_t i=0;i<500;i++) {; Int_t px = i%500;; Int_t py = (2*i)%200;; x3d->ExecCommand(px,py,0); //rotate; if (i%20 >10) x3d->ExecCommand(px,py,'j'); //zoom; if (i%20 <10) x3d->ExecCommand(px,py,'k'); //unzoom; }; }. void GetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); Get position. void DeleteX3DWindow(); Close X3D window. void Update(); Update X3D viewer. Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Bool_t HandleContainerButton(Event_t* ev); After button release get current position and update associated pad. TViewerX3D(TVirtualPad* pad). void Iconify(); { }. void Show(); { fMainFrame->MapRaised(); }. Bool_t PreferLocalFrame() const; TVirtualViewer3D interface. { return kFALSE; }. Bool_t BuildingScene() const; { return fBuildingScene; }. Bool_t OpenComposite(const TBuffer3D& , Bool_t* = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of component shapes. { return kTRUE; }. void CloseComposite(); {}. void AddCompositeOp(UInt_t ); {}.  Author: Rene Brun 05/09/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/x3d:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TViewerX3D.html:116,Modifiability,inherit,inheritance,116,". TViewerX3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  X3D;  TViewerX3D. class TViewerX3D: public TVirtualViewer3D. TViewerX3D. C++ interface to the X3D viewer. Function Members (Methods); public:. virtual~TViewerX3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual ",MatchSource.WIKI,root/html602/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TViewerX3D.html
https://root.cern/root/html602/TVirtualArray.html:108,Modifiability,inherit,inheritance,108,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size); TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size). Data Members; public:. char*fArray[fSize]; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance Chart:. TVirtualArray. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved.  Author: Philippe Canal July, 2008  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualArray.html
https://root.cern/root/html602/TVirtualArray.html:340,Security,access,access,340,". TVirtualArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TVirtualArray. class TVirtualArray. TVirtualArray. Wrapper around an object and giving indirect access to its content; even if the object is not of a class in the Cint/Reflex dictionary. Function Members (Methods); public:. ~TVirtualArray(); TClass*GetClass(); char*GetObjectAt(UInt_t ind) const; TVirtualArray&operator=(const TVirtualArray&); char*operator[](UInt_t ind) const; voidSetSize(UInt_t size); TVirtualArray(const TVirtualArray&); TVirtualArray(TClass* cl, UInt_t size). Data Members; public:. char*fArray[fSize]; UInt_tfCapacity; TClassReffClass; UInt_tfSize. Class Charts. Inheritance Chart:. TVirtualArray. Function documentation; TVirtualArray(TClass* cl, UInt_t size); {}. ~TVirtualArray(); { if (fClass) fClass->DeleteArray( fArray ); }. TClass * GetClass(); { return fClass; }. char * operator[](UInt_t ind) const; { return GetObjectAt(ind); }. char * GetObjectAt(UInt_t ind) const; { return fArray+fClass->Size()*ind; }. void SetSize(UInt_t size); Set the used size of this array to 'size'. If size is greater than the existing; capacity, reallocate the array BUT no data is preserved.  Author: Philippe Canal July, 2008  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/io:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualArray.html
https://root.cern/root/html602/TVirtualAuth.html:480,Availability,avail,available,480,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. . TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name().  Author: G. Ganis 08/07/05  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: Tue Jun 30 15:32:34 2015  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html
https://root.cern/root/html602/TVirtualAuth.html:304,Integrability,interface,interface,304,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. . TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name().  Author: G. Ganis 08/07/05  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: Tue Jun 30 15:32:34 2015  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html
https://root.cern/root/html602/TVirtualAuth.html:107,Modifiability,inherit,inheritance,107,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. . TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name().  Author: G. Ganis 08/07/05  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: Tue Jun 30 15:32:34 2015  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html
https://root.cern/root/html602/TVirtualAuth.html:325,Security,authenticat,authentication,325,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. . TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name().  Author: G. Ganis 08/07/05  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: Tue Jun 30 15:32:34 2015  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:3172,Availability,error,error,3172,,MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:3256,Availability,error,error,3256,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:10283,Availability,down,down,10283,"sSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TVirtualBranchBrowsable. . TCollectionPropertyBrowsable. TMethodBrowsable; . TCollectionMethodBrowsable. TNonSplitBrowsable. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:10842,Integrability,depend,depending,10842," Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default generators. The user can remove any of them as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. void RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Adds a generator to be called when browsing branches.; Called by the Register method, which should be implemented; for all derived classes (see e.g. TMethodBrowsable::Register()). void UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Removes a generator from the list of gene",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:11241,Integrability,depend,depending,11241," branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default generators. The user can remove any of them as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. void RegisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Adds a generator to be called when browsing branches.; Called by the Register method, which should be implemented; for all derived classes (see e.g. TMethodBrowsable::Register()). void UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator); Removes a generator from the list of generators to be called when; browsing branches. The user can remove any of the generators as follows:; TMethodBrowsable::Unregister();; which will cause the browser not to show any methods. const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. Bool_t IsFolder() const; check whether we have sub-elements. const TBranch* GetBranch() const; return th",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:129,Modifiability,inherit,inheritance,129,". TVirtualBranchBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& li",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:463,Modifiability,extend,extend,463,". TVirtualBranchBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& li",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:1190,Performance,cache,cached,1190,"s. ROOT;  TREE;  TREE;  TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchB",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:1251,Performance,cache,cached,1251,"s. ROOT;  TREE;  TREE;  TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchB",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:10346,Security,access,access,10346,"sSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TVirtualBranchBrowsable. . TCollectionPropertyBrowsable. TMethodBrowsable; . TCollectionMethodBrowsable. TNonSplitBrowsable. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualBranchBrowsable.html:1438,Usability,simpl,simple,1438,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root/html602/TVirtualBranchBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:639,Availability,avail,available,639,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:6241,Energy Efficiency,allocate,allocated,6241,", Bool_t forceDelete). void Commit(void* ). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if ",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:6687,Energy Efficiency,allocate,allocated,6687,"At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena. CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE); Copy the iterator source, into dest. dest should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator is of that size or less, the iterator will be constructed in place in this location (new with placement); Otherwise the iterator will be allocated via a regular new.; The actual address of the iterator is returned in both case. Next_t GetFunctionNext(Bool_t read = kTRUE); iter and end should be pointers to respectively an iterator to be incremented and the result of collection.end(); If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if; the iterator reached the end.; If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the; incrementation ; if the collection contains pointers, 'Next' will return the value of the pointer. DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE). DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE); If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses,; Otherwise just call the iterator's destructor.  Author: Philippe Canal 20/08/2003  Copyright ",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:347,Integrability,interface,interface,347,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:118,Modifiability,inherit,inheritance,118,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:479,Security,access,access,479,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualCollectionProxy.html:4940,Usability,simpl,simple,4940,"::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass() const; Return a pointer to the TClass representing the content. EDataType GetType() const; If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). void Insert(const void* data, void* container, size_t size); Insert data into the container where data is a C-style array of the actual type contained in the collection; of the given size. For associative container (map, etc.), the data type is the pair<key,value>. char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreate",MatchSource.WIKI,root/html602/TVirtualCollectionProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html
https://root.cern/root/html602/TVirtualDragManager.html:125,Modifiability,inherit,inheritance,125,". TVirtualDragManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GUI;  TVirtualDragManager. class TVirtualDragManager. TVirtualDragManager. Virtual drag and drop manager used for the GUI builder. Function Members (Methods); public:. virtual~TVirtualDragManager(); virtual Bool_tCancel(Bool_t = kTRUE); static TClass*Class(); virtual Bool_tDrop(); virtual Bool_tEndDrag(); EDragTypeGetEDragType() const; virtual Int_tGetEndDragX() const; virtual Int_tGetEndDragY() const; TGFrame*GetFrameUnder() const; TGFrame*GetPasteFrame() const; TGFrame*GetSource() const; virtual Int_tGetStrartDragX() const; virtual Int_tGetStrartDragY() const; TGFrame*GetTarget() const; virtual Bool_tHandleEvent(Event_t*); virtual Bool_tHandleTimerEvent(Event_t*, TTimer*); virtual Bool_tIgnoreEvent(Event_t*); static TVirtualDragManager*Instance(); virtual TClass*IsA() const; Bool_tIsDragging() const; Bool_tIsDropping() const; Bool_tIsMoveWaiting() const; Bool_tIsPasting() const; TVirtualDragManager&operator=(const TVirtualDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualDragManager(); TVirtualDragManager(const TVirtualDragManager&). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged",MatchSource.WIKI,root/html602/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualDragManager.html
https://root.cern/root/html602/TVirtualDragManager.html:2208,Modifiability,plugin,plugin,2208,"lDragManager&); virtual voidSetEditable(Bool_t); virtual voidSetPasteFrame(TGFrame* f); virtual voidSetSource(TGFrame* f); virtual voidSetTarget(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual Bool_tStartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualDragManager(); TVirtualDragManager(const TVirtualDragManager&). protected:. virtual voidInit(). Data Members; protected:. EDragTypefDragTypedragging type; Bool_tfDraggingin dragging mode?; Bool_tfDroppingdrop is in progress; TGFrame*fFrameUnderframe under drag; Bool_tfMoveWaitingkTRUE if source is clicked but not moved; TGFrame*fPasteFrame; Bool_tfPastingpaste action is in progress; TGFrame*fSourceframe being dragged; TGFrame*fTargetdrop target. Class Charts. Inheritance Chart:. TVirtualDragManager. . TGuiBldDragManager. Function documentation; TVirtualDragManager(); Constructor. TVirtualDragManager * Instance(); Load plugin and create drag manager object. void Init(); Initialization. TVirtualDragManager(). virtual ~TVirtualDragManager(); {}. EDragType GetEDragType() const; { return fDragType; }. Bool_t IsMoveWaiting() const; { return fMoveWaiting; }. Bool_t IsDragging() const; { return fDragging; }. Bool_t IsDropping() const; { return fDropping; }. Bool_t IsPasting() const; { return fPasting; }. TGFrame * GetTarget() const; { return fTarget; }. TGFrame * GetSource() const; { return fSource; }. TGFrame * GetFrameUnder() const; { return fFrameUnder; }. TGFrame * GetPasteFrame() const; { return fPasteFrame; }. void SetTarget(TGFrame* f); { fTarget = f; }. void SetSource(TGFrame* f); { fSource = f; }. void SetPasteFrame(TGFrame* f); { fPasteFrame = f; }. Bool_t StartDrag(TGFrame* = 0, Int_t = 0, Int_t = 0); { return kFALSE; }. Bool_t EndDrag(); { return kFALSE; }. Bool_t Drop(); { return kFALSE; }. Bool_t Cancel(Bool_t = kTRUE); { return kFALSE; }. Bool_t HandleEvent(Event_t* ); { return kFALSE; }. Bo",MatchSource.WIKI,root/html602/TVirtualDragManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualDragManager.html
https://root.cern/root/html602/TVirtualFFT.html:1145,Availability,redundant,redundant,1145,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:1671,Availability,avail,available,1671,"utput discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- kind=7; Formulas and detailed descriptions can be found in the chapter; ""What FFTW really computes"" of the FFTW manual. NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; inverse will give the original array, multiplied by normalization constant; (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; other sine/cosine transforms). How to use it:; Call to the static function FFT returns a pointer to a fast fourier transform; with requested parameters. Call to the static function SineCosine returns a; pointer to a sine or cosine transform with requested parameters. Example:; {; Int_t N = 10; Double_t *in = new Double_t[N];; TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; fftr2c->SetPoints(in);; fftr2c->Transform();; Double_t re, im;; for (Int_t i=0; i<N; i++); fftr2c->GetPointComplex(i, r",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:3135,Availability,avail,available,3135,"the FFTW manual. NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; inverse will give the original array, multiplied by normalization constant; (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; other sine/cosine transforms). How to use it:; Call to the static function FFT returns a pointer to a fast fourier transform; with requested parameters. Call to the static function SineCosine returns a; pointer to a sine or cosine transform with requested parameters. Example:; {; Int_t N = 10; Double_t *in = new Double_t[N];; TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; fftr2c->SetPoints(in);; fftr2c->Transform();; Double_t re, im;; for (Int_t i=0; i<N; i++); fftr2c->GetPointComplex(i, re, im);. fftr2c->SetPoints(in2);. fftr2c->SetPoints(in3);. }; Different options are explained in the function comments. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualFFT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual void",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:4104,Availability,error,error,4104,,MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:4188,Availability,error,error,4188," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TVirtualFFT*FFT(Int_t ndim, Int_t* n, Option_t* option); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFFT*GetCurrentTransform(); static const char*GetDefaultFFT(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_t*GetN() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdim() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetPointComplex(Int_t ipoint, Double_t& re, Double_t& im, Bool_t fromInput = kFALSE) const; virtual voidGetPointComplex(const Int_t* ipoint, Double_t& re, Double_t& im, Bool_t fromInput =",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:12055,Availability,avail,available,12055," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:471,Deployability,install,installed,471,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:599,Deployability,install,installation,599,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:349,Integrability,interface,interface,349,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:11180,Integrability,depend,depending,11180,"us)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance Chart:. TObject. ; TVirtualFFT. . TFFTComplex. TFFTComplexReal. TFFTReal. TFFTRealComplex. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:12753,Integrability,depend,depending,12753," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:117,Modifiability,inherit,inheritance,117,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:11474,Modifiability,variab,variable,11474,"ray at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but pr",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:13046,Modifiability,variab,variable,13046,"nd cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* fft); static: set the current transfrom to parameter. const char * GetDefaultFFT(); static: return the name of the default fft. void SetDefaultFFT(const char* name = """"); static: set name of default fft. TVirtualFFT(); {}. Int_t * GetN() const. Int_t GetNdim() const. Option_t * GetType() const. Int_t GetSign() const. Option_t * GetTransformFlag() const. void Init(Option_t* flag, Int_t sign, const Int_t* kind). Bool_t IsInplace() const. void GetPoints(Double_t* data, Bool_t fromInput = kFALSE) const. Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const. Double_t GetPointReal(const Int_t* ipoint, Bool_t fromInput = kFALSE) const. void GetPointComplex(Int_t ipoint, Double",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:10904,Performance,perform,performance,10904,"us)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. static TStringfgDefaultdefault transformer; static TVirtualFFT*fgFFTcurrent transformer. Class Charts. Inheritance Chart:. TObject. ; TVirtualFFT. . TFFTComplex. TFFTComplexReal. TFFTReal. TFFTRealComplex. Function documentation; ~TVirtualFFT(); destructor. TVirtualFFT* FFT(Int_t ndim, Int_t* n, Option_t* option); Returns a pointer to the FFT of requested size and type.; Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -option : consists of 3 parts - flag option and an option to create a new TVirtualFFT; 1) transform type option:; Available transform types are:; C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; see class description for details; 2) flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transfor",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:12477,Performance,perform,performance,12477," 3) option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc. TVirtualFFT* SineCosine(Int_t ndim, Int_t* n, Int_t* r2rkind, Option_t* option); Returns a pointer to a sine or cosine transform of requested size and kind. Parameters:; -ndim : number of transform dimensions; -n : sizes of each dimension (an array at least ndim long); -r2rkind : transform kind for each dimension; 4 different kinds of sine and cosine transforms are available; DCT-I - kind=0; DCT-II - kind=1; DCT-III - kind=2; DCT-IV - kind=3; DST-I - kind=4; DST-II - kind=5; DST-III - kind=6; DST-IV - kind=7; -option : consists of 2 parts - flag option and an option to create a new TVirtualFFT; - flag option: choosing how much time should be spent in planning the transform:; Possible options:; ""ES"" (from ""estimate"") - no time in preparing the transform,; but probably sub-optimal performance; ""M"" (from ""measure"") - some time spend in finding the optimal way; to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way; to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the; same size and type are going to be done.; Planning is only done once, for the first transform of this size and type.; - option allowing to choose between the global fgFFT and a new TVirtualFFT object; """" - default, changes and returns the global fgFFT variable; ""K"" (from ""keep"")- without touching the global fgFFT,; creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; Examples of valid options: ""ES K"", ""EX"", etc. TVirtualFFT* GetCurrentTransform(); static: return current fgFFT. void SetTransform(TVirtualFFT* ff",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:1145,Safety,redund,redundant,1145,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFFT.html:1165,Testability,log,logically,1165,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in halfcomplex format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root/html602/TVirtualFFT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html
https://root.cern/root/html602/TVirtualFitter.html:497,Availability,avail,available,497,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject*",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:1526,Availability,error,error,1526,"itting. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); virtual Double_t*GetCovariance",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:1610,Availability,error,error,1610,"itting. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); virtual voidGetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); virtual Double_t*GetCovariance",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:12805,Availability,toler,tolerance,12805,"s is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vh",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:12882,Availability,toler,tolerance,12882,"s is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs). void FixParameter(Int_t ipar). Double_t * GetCovarianceMatrix() const. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const. FCNFunc_t GetFCN(); { return fFCN; }. Foption_t GetFitOption() const; {return fOption;}. TMethodCall * GetMethodCall() const; {return fMethodCall;}. Int_t GetNumberTotalParameters() const. Int_t GetNumberFreeParameters() const. TObject * GetObjectFit() const; {return fObjectFit;}. Double_t GetParError(Int_t ipar) const. Double_t GetParameter(Int_t ipar) const. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vh",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:120,Modifiability,inherit,inheritance,120,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject*",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:9335,Performance,cache,cache,9335,"Object::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_t*fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tfCacheSizeSize of the fCache array; void(*)(Int_t&,Double_t*,Double_t&,Double_t*,Int_t)fFCN; TMethodCall*fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tfNpointsNumber of points to fit; TObject*fObjectFitpointer to object being fitted; Foption_tfOptionstruct with the fit options; Int_tfPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*fUserFuncpointer to user theoretical function (a TF1*); Int_tfXfirstfirst bin on X axis; Int_tfXlastlast bin on X axis; Int_tfYfirstfirst bin on Y axis; Int_tfYlastlast bin on Y axis; Int_tfZfirstfirst bin on Z axis; Int_tfZlastlast bin on Z axis; static TStringfgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tfgErrorDefError definition (default=1); static TVirtualFitter*fgFitterCurrent fitter (default TFitter); static Int_tfgMaxiterMaximum number of iterations; static Int_tfgMaxparMaximum number of fit parameters for current fitter; static Double_tfgPrecisionmaximum precision. Class Charts. Inheritance Chart:. TObject. ; TNamed. ; TVirtualFitter. . TBackCompFitter. TFitter. TFumili. TLinearFitter. Function documentation; TVirtualFitter(); Default constructor. TVirtualFitter(const TVirtualFitter& tvf); copy constructor. TVirtualFitter& operator=(const TVirtualFitter& tvf); assignment operator. ~TVirtualFitter(); Cleanup virtual fitter. TVirtualFitter * Fitter(TObject* obj, Int_t maxpar = 25);",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:11837,Performance,cache,cache,11837,"e_t cl = 0.94999999999999996); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRA",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:11922,Performance,cache,cache,11922,"e_t cl = 0.94999999999999996); return confidence intervals in TObject obj; implemented in TFitter and TLinearFitter. const char * GetDefaultFitter(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRA",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:12017,Performance,cache,cache,12017,"r(); static: return the name of the default fitter. TVirtualFitter * GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npa",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualFitter.html:12102,Performance,cache,cache,12102,"GetFitter(); static: return the current Fitter. Int_t GetMaxIterations(); static: Return the maximum number of iterations; actually max number of function calls. Double_t GetErrorDef(); static: Return the Error Definition. Double_t GetPrecision(); static: Return the fit relative precision. void SetDefaultFitter(const char* name = """"); static: set name of default fitter. void SetFitter(TVirtualFitter* fitter, Int_t maxpar = 25); Static function to set an alternative fitter. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); To set the address of the minimization objective function; called by the native compiler (see function below when called by CINT). Double_t * SetCache(Int_t npoints, Int_t psize); Initialize the cache array; npoints is the number of points to be stored (or already stored) in the cache; psize is the number of elements per point. if (npoints*psize > fCacheSize) the existing cache is deleted; and a new array is created.; The function returns a pointer to the cache. void SetFCN(void* fcn); To set the address of the minimization objective function. this function is called by CINT instead of the function above. void SetMaxIterations(Int_t niter = 5000); static: Set the maximum number of function calls for the minimization algorithm; For example for MIGRAD this is the maxcalls value passed as first argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). void SetErrorDef(Double_t errdef = 1); static: Set the Error Definition (default=1); For Minuit this is the value passed with the ""SET ERR"" command; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html). void SetPrecision(Double_t prec = 9.9999999999999995E-7); static: Set the tolerance used in the minimization algorithm; For example for MIGRAD this is tolerance value passed as second argument; (see http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html ). Double_t Chisquare(Int_t npar, Double_t* params) const. void Clear(Option_t* option = """"). Int_t",MatchSource.WIKI,root/html602/TVirtualFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:520,Availability,avail,available,520,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:3241,Availability,error,error,3241,"Vol(TGeoVolume* vol, Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t, Double_t, Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::Get",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:3325,Availability,error,error,3325,"irtual voidDrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t, Double_t, Double_t*, Double_t*); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObj",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:6074,Deployability,update,update,6074,,MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:124,Modifiability,inherit,inheritance,124,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:8474,Modifiability,plugin,plugin,8474,"_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3); virtual voidSetCheckedNode(TGeoNode* node); virtual voidSetClippingShape(TGeoShape* shape); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetExplodedView(Int_t iopt = 0); virtual voidSetGeoManager(TGeoManager* geom); virtual voidSetIteratorPlugin(TGeoIteratorPlugin* plugin); virtual voidSetNmeshPoints(Int_t npoints); virtual voidSetNsegments(Int_t nseg = 20); static voidTObject::SetObjectStat(Bool_t stat); static voidSetPainter(const TVirtualGeoPainter* painter); virtual voidSetRaytracing(Bool_t flag = kTRUE); virtual voidSetTopVisible(Bool_t vis = kTRUE); virtual voidSetTopVolume(TGeoVolume* vol); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetVisLevel(Int_t level = 3); virtual voidSetVisOption(Int_t option = 0); virtual Int_tShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTest(Int_t npoints, Option_t* option); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTestOverlaps(const char* path); virtual Bool_tTestVoxels(TGeoVolume* vol); TVirtualGeoPainter(TGeoManager* manager); TVirtualGeoPainter(const TVirtualGeoPainter&); virtual voidUnbombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tWeight(Double_t precision, Option_t* option = ""v""); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, cons",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:16069,Modifiability,plugin,plugin,16069,"har* opname, Long64_t current, Long64_t size, TStopwatch* watch = 0, Bool_t last = kFALSE, Bool_t refresh = kFALSE, const char* msg = """"). void Paint(Option_t* option = """"). void PaintNode(TGeoNode* node, Option_t* option = """", TGeoMatrix* global = 0). void PaintShape(TGeoShape* shape, Option_t* option = """"). void PaintOverlap(void* ovlp, Option_t* option = """"). void PrintOverlaps() const. void PaintVolume(TGeoVolume* vol, Option_t* option = """", TGeoMatrix* global = 0). void RandomPoints(const TGeoVolume* vol, Int_t npoints, Option_t* option = """"). void RandomRays(Int_t nrays, Double_t startx, Double_t starty, Double_t startz, const char* target_vol, Bool_t check_norm). void Raytrace(Option_t* option = """"). TGeoNode * SamplePoints(Int_t npoints, Double_t& dist, Double_t epsil, const char* g3path). void SetBombFactors(Double_t bombx = 1.3, Double_t bomby = 1.3, Double_t bombz = 1.3, Double_t bombr = 1.3). void SetExplodedView(Int_t iopt = 0). void SetGeoManager(TGeoManager* geom). void SetIteratorPlugin(TGeoIteratorPlugin* plugin). void SetCheckedNode(TGeoNode* node). void SetNsegments(Int_t nseg = 20). void SetNmeshPoints(Int_t npoints). void SetRaytracing(Bool_t flag = kTRUE). void SetTopVisible(Bool_t vis = kTRUE). void SetTopVolume(TGeoVolume* vol). void SetVisLevel(Int_t level = 3). void SetVisOption(Int_t option = 0). Int_t ShapeDistancetoPrimitive(const TGeoShape* shape, Int_t numpoints, Int_t px, Int_t py) const. void Test(Int_t npoints, Option_t* option). void TestOverlaps(const char* path). Bool_t TestVoxels(TGeoVolume* vol). void UnbombTranslation(const Double_t* tr, Double_t* bombtr). Double_t Weight(Double_t precision, Option_t* option = ""v"").  Author: Andrei Gheata 11/01/02  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/geom:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:1672,Testability,test,testNo,1672,"10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoPainter.html:12642,Testability,test,testNo,12642,"eoPainter(TGeoManager* manager); -*-*Geometry painter default constructor; *-* ====================================. ~TVirtualGeoPainter(); -*-*Geometry painter default destructor; *-* ===================================. TVirtualGeoPainter * GeoPainter(); Static function returning a pointer to the geometry painter.; The painter will paint objects from the specified geometry.; If the geometry painter does not exist a default painter is created. void SetPainter(const TVirtualGeoPainter* painter); Static function to set an alternative histogram painter. TVirtualGeoPainter(TGeoManager* manager). void AddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys). TVirtualGeoTrack * AddTrack(Int_t id, Int_t pdgcode, TObject* particle). void AddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE). void BombTranslation(const Double_t* tr, Double_t* bombtr). void CheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"). void CheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option). void CheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.). void CheckBoundaryReference(Int_t icheck = -1). void CheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null). void CheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const. void CheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const. Int_t CountVisibleNodes(). void DefaultAngles(). void DefaultColors(). Int_t DistanceToPrimitiveVol(TGeoVolume* vol, Int_t px, Int_t py). void Draw(Option_t* option = """"). void DrawBatemanSol(TGeoBatemanSol* sol, Option_t* option = """"). void DrawShape(TGeoShape* shape, Option_t* option = """"). void DrawOnly(Option_t* option = """"). void DrawOverlap(void* ovlp, Option_t* option = """"). void DrawCurrentPoint(Int_t color). void DrawPanel(). void DrawPath(const char* path, Option_t* option = """"). voi",MatchSource.WIKI,root/html602/TVirtualGeoPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html
https://root.cern/root/html602/TVirtualGeoTrack.html:779,Availability,avail,available,779,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual vo",MatchSource.WIKI,root/html602/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html
https://root.cern/root/html602/TVirtualGeoTrack.html:2067,Availability,error,error,2067,"le_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*FindTrackWithId(Int_t id) const; TVirtualGeoTrack*GetDaughter(Int_t index) const; virtual Int_tGetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; const Double_t*GetLastPoint() const; Int_tGetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerCol",MatchSource.WIKI,root/html602/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html
https://root.cern/root/html602/TVirtualGeoTrack.html:2151,Availability,error,error,2151,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVirtualGeoTrack*FindTrackWithId(Int_t id) const; TVirtualGeoTrack*GetDaughter(Int_t index) const; virtual Int_tGetDaughterId(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const Double_t*GetFirstPoint() const; virtual const char*TObject::GetIconName() const; Int_tGetId() const; const Double_t*GetLastPoint() const; Int_tGetLastPoint(Double_t& x, Double_t& y, Double_t& z, Double_t& t) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMark",MatchSource.WIKI,root/html602/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html
https://root.cern/root/html602/TVirtualGeoTrack.html:122,Modifiability,inherit,inheritance,122,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual vo",MatchSource.WIKI,root/html602/TVirtualGeoTrack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html
https://root.cern/root/html602/TVirtualGLManip.html:520,Availability,avail,available,520,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLManip.html:947,Availability,avail,available,947,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLManip.html:394,Integrability,interface,interface,394,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLManip.html:404,Integrability,protocol,protocol,404,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLManip.html:620,Integrability,interface,interface,620,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLManip.html:121,Modifiability,inherit,inheritance,121,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. . TGLManip; . TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root/html602/TVirtualGLManip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html
https://root.cern/root/html602/TVirtualGLPainter.html:526,Availability,avail,available,526,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGLPainter.html:953,Availability,avail,available,953,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGLPainter.html:400,Integrability,interface,interface,400,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGLPainter.html:410,Integrability,protocol,protocol,410,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGLPainter.html:626,Integrability,interface,interface,626,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGLPainter.html:123,Modifiability,inherit,inheritance,123,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. . TGLPlotPainter; . TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter. [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py).  Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root/html602/TVirtualGLPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html
https://root.cern/root/html602/TVirtualGraphPainter.html:549,Availability,avail,available,549,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fin",MatchSource.WIKI,root/html602/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html
https://root.cern/root/html602/TVirtualGraphPainter.html:1652,Availability,error,error,1652,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject",MatchSource.WIKI,root/html602/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html
https://root.cern/root/html602/TVirtualGraphPainter.html:1736,Availability,error,error,1736,"bject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObj",MatchSource.WIKI,root/html602/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html
https://root.cern/root/html602/TVirtualGraphPainter.html:381,Integrability,interface,interface,381,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fin",MatchSource.WIKI,root/html602/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html
https://root.cern/root/html602/TVirtualGraphPainter.html:126,Modifiability,inherit,inheritance,126,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fin",MatchSource.WIKI,root/html602/TVirtualGraphPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html
https://root.cern/root/html602/TVirtualHistPainter.html:545,Availability,avail,available,545,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root/html602/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html
https://root.cern/root/html602/TVirtualHistPainter.html:1538,Availability,error,error,1538," virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root/html602/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html
https://root.cern/root/html602/TVirtualHistPainter.html:1622,Availability,error,error,1622,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*HistPainter(TH1* obj); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inher",MatchSource.WIKI,root/html602/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html
https://root.cern/root/html602/TVirtualHistPainter.html:377,Integrability,interface,interface,377,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root/html602/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html
https://root.cern/root/html602/TVirtualHistPainter.html:125,Modifiability,inherit,inheritance,125,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root/html602/TVirtualHistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html
https://root.cern/root/html602/TVirtualIndex.html:492,Availability,avail,available,492,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Lo",MatchSource.WIKI,root/html602/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html
https://root.cern/root/html602/TVirtualIndex.html:1534,Availability,error,error,1534,"rtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetO",MatchSource.WIKI,root/html602/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html
https://root.cern/root/html602/TVirtualIndex.html:1618,Availability,error,error,1618,"end(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree*); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual const char*GetMajorName() const; virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed:",MatchSource.WIKI,root/html602/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html
https://root.cern/root/html602/TVirtualIndex.html:332,Integrability,interface,interface,332,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Lo",MatchSource.WIKI,root/html602/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html
https://root.cern/root/html602/TVirtualIndex.html:119,Modifiability,inherit,inheritance,119,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Lo",MatchSource.WIKI,root/html602/TVirtualIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html
https://root.cern/root/html602/TVirtualIsAProxy.html:464,Availability,avail,available,464,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance Chart:. TVirtualIsAProxy. . TIsAProxy. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj).  Author: Markus Frank 20/05/2005  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIsAProxy.html
https://root.cern/root/html602/TVirtualIsAProxy.html:111,Modifiability,inherit,inheritance,111,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance Chart:. TVirtualIsAProxy. . TIsAProxy. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj).  Author: Markus Frank 20/05/2005  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id$  Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html602/TVirtualIsAProxy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualIsAProxy.html
https://root.cern/root/html602/TVirtualMagField.html:1059,Availability,avail,available,1059,"ass Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualMagField. class TVirtualMagField: public TNamed. TVirtualMagField - ABC for magnetic field. Derived classes are encouraged to; use the TVirtualMagField named constructor and must implement the method:; Field(const Double_t *x, Double_t *B). A field object can be made global via:; TGlobalMagField::Instance()->SetField(field) [1]; A field which is made global is owned by the field manager. The used is not; allowed to delete it directly anymore (otherwise a Fatal() is issued). Global; field can be deleted by calling [1] with a different argument (which can be; NULL). Otherwise the global field is deleted together with the field manager. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtu",MatchSource.WIKI,root/html602/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMagField.html
https://root.cern/root/html602/TVirtualMagField.html:2035,Availability,error,error,2035," virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* m",MatchSource.WIKI,root/html602/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMagField.html
https://root.cern/root/html602/TVirtualMagField.html:2119,Availability,error,error,2119,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* B); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cla",MatchSource.WIKI,root/html602/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMagField.html
https://root.cern/root/html602/TVirtualMagField.html:122,Modifiability,inherit,inheritance,122,". TVirtualMagField. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GEOM;  GEOM;  TVirtualMagField. class TVirtualMagField: public TNamed. TVirtualMagField - ABC for magnetic field. Derived classes are encouraged to; use the TVirtualMagField named constructor and must implement the method:; Field(const Double_t *x, Double_t *B). A field object can be made global via:; TGlobalMagField::Instance()->SetField(field) [1]; A field which is made global is owned by the field manager. The used is not; allowed to delete it directly anymore (otherwise a Fatal() is issued). Global; field can be deleted by calling [1] with a different argument (which can be; NULL). Otherwise the global field is deleted together with the field manager. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualMagField(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* m",MatchSource.WIKI,root/html602/TVirtualMagField.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMagField.html
https://root.cern/root/html602/TVirtualMC.html:973,Availability,avail,available,973,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MONTECARLO;  VMC;  TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); vi",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:3378,Availability,error,error,3378,,MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:3462,Availability,error,error,3462,,MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:27701,Availability,error,error,27701,"me identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int_t id) const; Return material number for a given volume id. Int_t NofVolDaughters(const char* volName) const; Return number of daughters of the volume specified by volName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:28456,Availability,error,error,28456,"st char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughter",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:35167,Availability,alive,alive,35167,"rn the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or because it underwent; an inelastic collision. Bool_t IsTrackStop() const; Return true if the track energy has fallen below the threshold. Bool_t IsTrackAlive() const; Return true if the current particle is alive and will continue to be; transported. Int_t NSecondaries() const. get methods - secondaries. Return the number of secondary particles generated in the current step. void GetSecondary(Int_t isec, Int_t& particleId, TLorentzVector& position, TLorentzVector& momentum); Return the parameters of the secondary track number isec produced; in the current step. Int_t StepProcesses(TArrayI& proc) const; Return the VMC code of the process that has produced the secondary; particles in the current step; Return the array of the VMC code of the processes active in the current; step. Bool_t SecondariesAreOrdered() const; Return the information about the transport order needed by the stack. void Init(). Control methods. Initialize MC. void BuildPhysics(); Initialize MC physics. void ProcessEvent(); Process one event; Deprecated. Bool_t ProcessRun(Int_t nevent); Process one run and return true if run has finished successfully,; return false in other cases (run aborted by user). void I",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:18650,Deployability,continuous,continuous,18650," given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of these; parameters for a given tracking medium.; itmed tracking medium number; param is a char",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:2372,Energy Efficiency,charge,charge,2372,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0., Double_t excitation = 0.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:2506,Energy Efficiency,charge,charge,2506,"TNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); virtual voidDefineOpSurface(const char* name, EMCOpSurfaceModel model, EMCOpSurfaceType surfaceType, EMCOpSurfaceFinish surfaceFinish, Double_t sigmaAlpha); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); virtual Bool_tDefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime, const TString& pType, Double_t width, Int_t iSpin, Int_t iParity, Int_t iConjugation, Int_t iIsospin, Int_t iIsospinZ, Int_t gParity, Int_t lepton, Int_t baryon, Bool_t stable, Bool_t shortlived = kFALSE, const TString& subType = """", Int_t antiEncoding = 0, Double_t magMoment = 0., Double_t excitation = 0.); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Double_tEdep() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEtot() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:18573,Energy Efficiency,energy,energy,18573,"ach basic material in the mixture. If nlmat < 0 then wmat contains the number of atoms; of a given kind into the molecule of the compound.; In this case, wmat in output is changed to relative; weights. void Medium(Int_t& kmed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Double_t fieldm, Double_t tmaxfd, Double_t stemax, Double_t deemax, Double_t epsil, Double_t stmin, Float_t* ubuf, Int_t nbuf); The same as previous but in double precision; Define a medium.; kmed tracking medium number assigned; name tracking medium name; nmat material number; isvol sensitive volume flag; ifield magnetic field:; - ifield = 0 if no magnetic field;; - ifield = -1 if user decision in guswim;; - ifield = 1 if tracking performed with g3rkuta;; - ifield = 2 if tracking performed with g3helix;; - ifield = 3 if tracking performed with g3helx3.; fieldm max. field value (kilogauss); tmaxfd max. angle due to field (deg/step); stemax max. step allowed; deemax max. fraction of energy lost in a step; epsil tracking precision (cm); stmin min. step due to continuous processes (cm); ubuf pointer to an array of user words; nbuf number of user words. void Matrix(Int_t& krot, Double_t thetaX, Double_t phiX, Double_t thetaY, Double_t phiY, Double_t thetaZ, Double_t phiZ); The same as previous but in double precision; Define a rotation matrix; krot rotation matrix number assigned; thetaX polar angle for axis X; phiX azimuthal angle for axis X; thetaY polar angle for axis Y; phiY azimuthal angle for axis Y; thetaZ polar angle for axis Z; phiZ azimuthal angle for axis Z. Int_t Gsvolu(const char* name, const char* shape, Int_t nmed, Float_t* upar, Int_t np); Change the value of cut or mechanism param; to a new value parval for tracking medium itmed.; In Geant3, the data structure JTMED contains the standard tracking; parameters (CUTS and flags to control the physics processes) which; are used by default for all tracking media.; It is possible to redefine individually with this function any of th",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:27573,Energy Efficiency,charge,charge,27573,"me identifier id. Int_t MediumId(const char* mediumName) const; Return the unique numeric identifier for medium name mediumName. Int_t NofVolumes() const; Return total number of volumes in the geometry. Int_t VolId2Mate(Int_t id) const; Return material number for a given volume id. Int_t NofVolDaughters(const char* volName) const; Return number of daughters of the volume specified by volName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:27808,Energy Efficiency,charge,charge,27808,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:27815,Energy Efficiency,charge,charge,27815,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:28239,Energy Efficiency,energy,energy,28239,"lName. const char* VolDaughterName(const char* volName, Int_t i) const; Return the name of i-th daughter of the volume specified by volName. Int_t VolDaughterCopyNo(const char* volName, Int_t i) const; Return the copyNo of i-th daughter of the volume specified by volName. Bool_t SetCut(const char* cutName, Double_t cutValue). methods for physics management. set methods. Set transport cuts for particles. Bool_t SetProcess(const char* flagName, Int_t flagValue); Set process control. Bool_t DefineParticle(Int_t pdg, const char* name, TMCParticleType mcType, Double_t mass, Double_t charge, Double_t lifetime); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excita",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:28563,Energy Efficiency,charge,charge,28563,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:28570,Energy Efficiency,charge,charge,28570,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:28994,Energy Efficiency,energy,energy,28994,"cle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:29082,Energy Efficiency,charge,charge,29082,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticl",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:29120,Energy Efficiency,energy,energy,29120,"; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]. Bool_t DefineIon(const char* name, Int_t Z, Int_t A, Int_t Q, Double_t excEnergy, Double_t mass = 0.); Set a user defined particle; Function is ignored if particle with specified pdg; already exists and error report is printed.; pdg PDG encoding; name particle name; mcType VMC Particle type; mass mass [GeV]; charge charge [eplus]; lifetime time of life [s]; pType particle type as in Geant4; width width [GeV]; iSpin spin; iParity parity; iConjugation conjugation; iIsospin isospin; iIsospinZ isospin - #rd component; gParity gParity; lepton lepton number; baryon baryon number; stable stability; shortlived is shorlived?; subType particle subType as in Geant4; antiEncoding anti encoding; magMoment magnetic moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticl",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:29963,Energy Efficiency,charge,charge,29963,"moment; excitation excitation energy [GeV]; Set a user defined ion.; name ion name; Z atomic number; A atomic mass; Q charge [eplus}; excitation excitation energy [GeV]; mass mass [GeV] (if not specified by user, approximative; mass is calculated). Double_t Xsec(char* , Double_t , Int_t , Int_t ); Set a user phase space decay for a particle; pdg particle PDG encoding; bratios the array with branching ratios (in %); mode[6][3] the array with daughters particles PDG codes for each; decay channel; Calculate X-sections; (Geant3 only); Deprecated. Int_t IdFromPDG(Int_t pdg) const. particle table usage. Return MC specific code from a PDG and pseudo ENDF code (pdg). Int_t PDGFromId(Int_t id) const; Return PDG code and pseudo ENDF code from MC specific code (id). TString ParticleName(Int_t pdg) const. get methods. Return name of the particle specified by pdg. Double_t ParticleMass(Int_t pdg) const; Return mass of the particle specified by pdg. Double_t ParticleCharge(Int_t pdg) const; Return charge (in e units) of the particle specified by pdg. Double_t ParticleLifeTime(Int_t pdg) const; Return life time of the particle specified by pdg. TMCParticleType ParticleMCType(Int_t pdg) const; Return VMC type of the particle specified by pdg. void StopTrack(). methods for step management. action methods. Stop the transport of the current particle and skip to the next. void StopEvent(); Stop simulation of the current event and skip to the next. void StopRun(); Stop simulation of the current event and set the abort run flag to true. void SetMaxStep(Double_t ). set methods. Set the maximum step allowed till the particle is in the current medium. void SetMaxNStep(Int_t ); Set the maximum number of steps till the particle is in the current medium. void SetUserDecay(Int_t pdg); Force the decays of particles to be done with Pythia; and not with the Geant routines. void ForceDecayTime(Float_t ); Force the decay time of the current particle. Int_t CurrentVolID(Int_t& copyNo) const. tracking ",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
https://root.cern/root/html602/TVirtualMC.html:33968,Energy Efficiency,energy,energy,33968,"d in the current medium. void TrackPosition(TLorentzVector& position) const. get methods; tracking particle; dynamic properties. Return the current position in the master reference frame of the; track being transported. void TrackPosition(Double_t& x, Double_t& y, Double_t& z) const; Return the current position in the master reference frame of the; track being transported. void TrackMomentum(TLorentzVector& momentum) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. void TrackMomentum(Double_t& px, Double_t& py, Double_t& pz, Double_t& etot) const; Return the direction and the momentum (GeV/c) of the track; currently being transported. Double_t TrackStep() const; Return the length in centimeters of the current step (in cm). Double_t TrackLength() const; Return the length of the current track from its origin (in cm). Double_t TrackTime() const; Return the current time of flight of the track being transported. Double_t Edep() const; Return the energy lost in the current step. Int_t TrackPid() const. get methods; tracking particle; static properties. Return the PDG of the particle transported. Double_t TrackCharge() const; Return the charge of the track currently transported. Double_t TrackMass() const; Return the mass of the track currently transported. Double_t Etot() const; Return the total energy of the current track. Bool_t IsNewTrack() const. get methods - track status. Return true when the track performs the first step. Bool_t IsTrackInside() const; Return true if the track is not at the boundary of the current volume. Bool_t IsTrackEntering() const; Return true if this is the first step of the track in the current volume. Bool_t IsTrackExiting() const; Return true if this is the last step of the track in the current volume. Bool_t IsTrackOut() const; Return true if the track is out of the setup. Bool_t IsTrackDisappeared() const; Return true if the current particle has disappeared; either because it decayed or becaus",MatchSource.WIKI,root/html602/TVirtualMC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html602/TVirtualMC.html
