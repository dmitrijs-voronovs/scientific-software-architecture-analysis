id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html604/TTreeCacheUnzip.html:21093,Energy Efficiency,adapt,adapted,21093,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21986,Energy Efficiency,allocate,allocate,21986,"he arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22651,Energy Efficiency,allocate,allocate,22651,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23295,Energy Efficiency,allocate,allocate,23295,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:619,Integrability,synchroniz,synchronized,619,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:121,Modifiability,inherit,inheritance,121,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:4987,Modifiability,Inherit,InheritsFrom,4987," Int_tTFileCacheRead::GetNoCacheReadCalls() const; Int_tTFileCacheRead::GetNseek() const; Int_tTFileCacheRead::GetNtot() const; Int_tGetNUnzip(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TTreeCacheUnzip::EParUnzipModeGetParallelUnzip(); Long64_tTFileCacheRead::GetPrefetchedBlocks() const; virtual TFilePrefetch*TFileCacheRead::GetPrefetchObj(); virtual Int_tTFileCacheRead::GetReadCalls() const; Int_tGetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); virtual const char*TObject::GetTitle() const; TTree*TTreeCache::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActiveThread(); virtual Bool_tTFileCacheRead::IsAsyncReading() const; Bool_tTTreeCache::IsAutoCreated() const; virtual Bool_tTTreeCache::IsEnabled() const; virtual Bool_tTFileCacheRead::IsEnablePrefetching() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTTreeCache::IsLearning() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsParallelUnzip(); Bool_tIsQueueEmpty(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTTreeCache::LearnPrefill(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVer",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:5053,Modifiability,Inherit,InheritsFrom,5053,"Read::GetNseek() const; Int_tTFileCacheRead::GetNtot() const; Int_tGetNUnzip(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TTreeCacheUnzip::EParUnzipModeGetParallelUnzip(); Long64_tTFileCacheRead::GetPrefetchedBlocks() const; virtual TFilePrefetch*TFileCacheRead::GetPrefetchObj(); virtual Int_tTFileCacheRead::GetReadCalls() const; Int_tGetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); virtual const char*TObject::GetTitle() const; TTree*TTreeCache::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActiveThread(); virtual Bool_tTFileCacheRead::IsAsyncReading() const; Bool_tTTreeCache::IsAutoCreated() const; virtual Bool_tTTreeCache::IsEnabled() const; virtual Bool_tTFileCacheRead::IsEnablePrefetching() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTTreeCache::IsLearning() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsParallelUnzip(); Bool_tIsQueueEmpty(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTTreeCache::LearnPrefill(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::op",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:16744,Modifiability,Inherit,Inheritance,16744,"(sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer c",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18531,Modifiability,variab,variable,18531,"ranch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19974,Modifiability,variab,variable,19974,"ssing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical reco",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21093,Modifiability,adapt,adapted,21093,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:917,Performance,latency,latency,917,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:1041,Performance,cache,cache,1041,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:10982,Performance,queue,queue,10982,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11199,Performance,cache,cache,11199,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11833,Performance,cache,cache,11833,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:11910,Performance,cache,cache,11910,,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12272,Performance,cache,cache,12272,leCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen[fBNb]; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache i,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12501,Performance,cache,cache,12501,; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12519,Performance,cache,cached,12519,Read::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; T,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12605,Performance,cache,cache,12605,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12661,Performance,cache,cache,12661,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12718,Performance,cache,cache,12718,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:12781,Performance,cache,cache,12781,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13204,Performance,cache,cache,13204,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13268,Performance,cache,cache,13268,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13652,Performance,cache,cache,13652,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13718,Performance,cache,cache,13718,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13885,Performance,cache,cache,13885,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14164,Performance,cache,cache,14164,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14251,Performance,cache,cached,14251,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14341,Performance,cache,cached,14341,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:15086,Performance,cache,cache,15086,"ax size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17274,Performance,cache,cache,17274,"o signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17508,Performance,cache,cache,17508,"eeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is a",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17720,Performance,cache,cache,17720,"ivate:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty()",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:17993,Performance,optimiz,optimize,17993,"it(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; whe",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18332,Performance,cache,cache,18332,"; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Bool_t FillBuffer(). Int_t SetBufferSize(Int_t buffersize); Change the underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18700,Performance,queue,queue,18700,"e underlying buffer size of the cache.; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits fo",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:18937,Performance,queue,queue,18937,"Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19702,Performance,queue,queue,19702,"CacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20206,Performance,queue,queue,20206,"ding unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void Res",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20453,Performance,cache,cache,20453," _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is co",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21224,Performance,cache,cache,21224,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21268,Performance,cache,cache,21268,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21341,Performance,cache,cache,21341,"aving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the p",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21776,Performance,cache,cache,21776," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:21808,Performance,cache,cache,21808," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22368,Performance,cache,cache,22368,"the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:22440,Performance,cache,cache,22440,"ompletely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the tra",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23028,Performance,cache,cache,23028,"0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers ar",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23153,Performance,cache,cache,23153,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23194,Performance,cache,cache,23194,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23313,Performance,cache,cache,23313,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:23380,Performance,cache,cache,23380,"times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMisse",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:19239,Safety,detect,detection,19239,"the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the que",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:4877,Security,Hash,Hash,4877,") const; Int_tGetNFound(); Int_tGetNMissed(); virtual Long64_tTFileCacheRead::GetNoCacheBytesRead() const; virtual Int_tTFileCacheRead::GetNoCacheReadCalls() const; Int_tTFileCacheRead::GetNseek() const; Int_tTFileCacheRead::GetNtot() const; Int_tGetNUnzip(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TTreeCacheUnzip::EParUnzipModeGetParallelUnzip(); Long64_tTFileCacheRead::GetPrefetchedBlocks() const; virtual TFilePrefetch*TFileCacheRead::GetPrefetchObj(); virtual Int_tTFileCacheRead::GetReadCalls() const; Int_tGetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); virtual const char*TObject::GetTitle() const; TTree*TTreeCache::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActiveThread(); virtual Bool_tTFileCacheRead::IsAsyncReading() const; Bool_tTTreeCache::IsAutoCreated() const; virtual Bool_tTTreeCache::IsEnabled() const; virtual Bool_tTFileCacheRead::IsEnablePrefetching() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTTreeCache::IsLearning() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsParallelUnzip(); Bool_tIsQueueEmpty(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTTreeCache::LearnPrefill(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual B",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:8875,Testability,Test,TestBit,8875,"t val); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBufferSize(Int_t buffersize); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFileCacheRead::SetEnablePrefetching(Bool_t setPrefetching = kFALSE); virtual voidSetEntryRange(Long64_t emin, Long64_t emax); virtual voidTTreeCache::SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); static voidTTreeCache::SetLearnEntries(Int_t n = 10); virtual voidTTreeCache::SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); static voidTObject::SetObjectStat(Bool_t stat); static Int_tSetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); virtual voidTFileCacheRead::SetSkipZip(Bool_t = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnzipBufferSize(Long64_t bufferSize); static voidSetUnzipRelBufferSize(Float_t relbufferSize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFileCacheRead::Sort(); voidTTreeCache::StartLearningPhase(); virtual voidStopLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Int_tUnzipBuffer(char** dest, char* src); Int_tUnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); static void*UnzipLoop(void* arg); virtual voidUpdateBranches(TTree* tree); virtual voidTObject::UseCurrentStyle(); virtual voidTFileCacheRead::WaitFinishPrefetch(); voidWaitUnzipStartSignal(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:8914,Testability,Test,TestBits,8914,"t val); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBufferSize(Int_t buffersize); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFileCacheRead::SetEnablePrefetching(Bool_t setPrefetching = kFALSE); virtual voidSetEntryRange(Long64_t emin, Long64_t emax); virtual voidTTreeCache::SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); static voidTTreeCache::SetLearnEntries(Int_t n = 10); virtual voidTTreeCache::SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); static voidTObject::SetObjectStat(Bool_t stat); static Int_tSetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); virtual voidTFileCacheRead::SetSkipZip(Bool_t = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUnzipBufferSize(Long64_t bufferSize); static voidSetUnzipRelBufferSize(Float_t relbufferSize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTFileCacheRead::Sort(); voidTTreeCache::StartLearningPhase(); virtual voidStopLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Int_tUnzipBuffer(char** dest, char* src); Int_tUnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); static void*UnzipLoop(void* arg); virtual voidUpdateBranches(TTree* tree); virtual voidTObject::UseCurrentStyle(); virtual voidTFileCacheRead::WaitFinishPrefetch(); voidWaitUnzipStartSignal(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20593,Testability,log,logical,20593,"therwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about ",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:20976,Testability,log,logical,20976,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:1736,Usability,Clear,Clear,1736," virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual Int_tAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidT",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:5751,Usability,Learn,LearnPrefill,5751,"buf, Long64_t pos, Int_t len, Bool_t* free); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsActiveThread(); virtual Bool_tTFileCacheRead::IsAsyncReading() const; Bool_tTTreeCache::IsAutoCreated() const; virtual Bool_tTTreeCache::IsEnabled() const; virtual Bool_tTFileCacheRead::IsEnablePrefetching() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTTreeCache::IsLearning() const; Bool_tTObject::IsOnHeap() const; static Bool_tIsParallelUnzip(); Bool_tIsQueueEmpty(); virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTTreeCache::LearnPrefill(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTFileCacheRead::Prefetch(Long64_t pos, Int_t len); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTTreeCache::ReadBuffer(char* buf, Long64_t pos, Int_t len); virtual Int_tReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); v",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:13216,Usability,learn,learning,13216,BSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:14582,Usability,learn,learning,14582,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode; Long64_t*TFileCacheRead::fSeek[fNseek] ,MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCacheUnzip.html:16476,Usability,learn,learning,16476,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←; TTreeCacheUnzip. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). Int_t AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket; Returns 0 branch added or already included; -1 on error. Int_t AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to",MatchSource.WIKI,root/html604/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCacheUnzip.html
https://root.cern/root/html604/TTreeCloner.html:2208,Availability,error,error,2208,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file i",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:2214,Integrability,message,message,2214,"ngs; static TTreeCloner::EClonerOptionskNone. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file i",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:2467,Modifiability,Inherit,Inheritance,2467,"rt entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of t",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:2480,Modifiability,Inherit,Inherited,2480,"rt entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state; static TTreeCloner::ECloneMethodkDefault; static TTreeCloner::ECloneMethodkSortBasketsByBranch; static TTreeCloner::ECloneMethodkSortBasketsByEntry; static TTreeCloner::ECloneMethodkSortBasketsByOffset. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone); Constructor. This object would transfer the data from; 'from' to 'to' using the method indicated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of t",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:3640,Performance,optimiz,optimize,3640,"cated in method. The value of the parameter 'method' determines in which; order the branches' baskets are written to the output file. When a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TOb",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeCloner.html:3836,Performance,perform,performance,3836,"en a TTree is filled the data is stored in the individual; branches' basket. Each basket is written individually to; the disk as soon as it is full. In consequence the baskets; of branches that contain 'large' data chunk are written to; the disk more often. There is currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in; the output file in the same order as in the original file; (i.e. the basket are sorted on their offset in the original; file; Usually this also means that the baskets are sorted; on the index/number of the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each; individual branches are stored contiguously. This tends to; optimize reading speed when reading a small number (1->5) of; branches, since all their baskets will be clustered together; instead of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. Bool_t Exec(); Execute the cloning. ~TTreeCloner(); TTreeCloner destructor. void CloseOutWriteBaskets(); Before we can start adding new basket, we need to flush to; disk the partially filled baskets (the WriteBasket). UInt_t CollectBranches(TBranch* from, TBranch* to); Fill the array of branches, adding the branch 'from' and 'to',; and matching the sub-branches of the 'from' and 'to' branches.; Returns the total number of baskets in all the from branch and; it sub-branches. UInt_t CollectBranches(TObjArray* from, TObjArray* to); Fill the array of branches, matching the branches of the 'from' and 'to' arrays.; Returns the total number",MatchSource.WIKI,root/html604/TTreeCloner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeCloner.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:1321,Availability,Error,Error,1321," virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:1450,Availability,error,error,1450," virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:1534,Availability,error,error,1534," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelecti",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8971,Availability,error,error,8971,"ckets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the e",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9239,Availability,error,error,9239,"ructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from th",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9984,Availability,error,error,9984,"eturns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t Ge",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10460,Availability,error,error,10460,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10488,Availability,error,error,10488,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10611,Availability,error,error,10611,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10627,Availability,error,error,10627,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10494,Integrability,message,message,10494,"rawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TOb",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10633,Integrability,message,message,10633,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:125,Modifiability,inherit,inheritance,125,". TTreeDrawArgsParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeDrawArgsParser. class TTreeDrawArgsParser: public TObject. TTreeDrawArgsParser. A class that parses all parameters for TTree::Draw().; See TTree::Draw() for the format description. Function Members (Methods); public:. virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:2914,Modifiability,Inherit,InheritsFrom,2914,"g_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelection() const; Bool_tGetShouldDraw() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TStringGetVarExp() const; TStringGetVarExp(Int_t num) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsSpecified(int num) const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); vo",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:2980,Modifiability,Inherit,InheritsFrom,2980,"ar*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelection() const; Bool_tGetShouldDraw() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TStringGetVarExp() const; TStringGetVarExp(Int_t num) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsSpecified(int num) const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeDrawArgsPars",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:5852,Modifiability,variab,variables,5852,"bj); voidSetObjectName(const char* s); static voidTObject::SetObjectStat(Bool_t stat); voidSetOriginal(TObject* o); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearPrevious(); TTreeDrawArgsParser::EOutputTypeDefineType(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); Bool_tParseName(TString name); Bool_tParseOption(); Bool_tParseVarExp(); Bool_tSplitVariables(TString variables). Data Members; public:. static Int_tfgMaxDimension= 4; static Int_tfgMaxParameters= 9; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTreeDrawArgsParser::EOutputTypekENTRYLIST; static TTreeDrawArgsParser::EOutputTypekEVENTLIST; static TTreeDrawArgsParser::EOutputTypekGRAPH; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM1D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM2D; static TTreeDrawArgsParser::EOutputTypekHISTOGRAM3D; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TTreeDrawArgsParser::EOutputTypekLISTOFGRAPHS; static TTreeDrawArgsParser::EOutputTypekLISTOFPOLYMARKERS3D",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:7536,Modifiability,variab,variable,7536,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8059,Modifiability,variab,variable,8059,"static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TTreeDrawArgsParser::EOutputTypekPOLYMARKER3D; static TTreeDrawArgsParser::EOutputTypekPROFILE; static TTreeDrawArgsParser::EOutputTypekPROFILE2D; static TObject::(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : tha",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8121,Modifiability,Inherit,Inheritance,8121,":(anonymous)TObject::kSingleKey; static TTreeDrawArgsParser::EOutputTypekUNKNOWN; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds f",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8256,Modifiability,variab,variables,8256,"TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAddvalues should be added to an existing object; Int_tfDimensiondimension of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kF",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8407,Modifiability,variab,variables,8407," of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for ch",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8461,Modifiability,variab,variables,8461,"prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, ",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8529,Modifiability,variab,variables,8529,"expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Dra",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8811,Modifiability,variab,variable,8811,"nal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropr",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8847,Modifiability,variab,variables,8847,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8880,Modifiability,variab,variable,8880,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8920,Modifiability,variab,variable,8920,"e parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9274,Modifiability,variab,variables,9274,"er(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of ",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:9561,Modifiability,Variab,Variable,9561,"ws) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10245,Modifiability,variab,variable,10245,"riate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for choosing the type of the; drawn object. Bool_t Parse(const char* varexp, const char* selection, Option_t* option); Parses parameters from TTree::Draw().; varexp - Variable expression; see TTree::Draw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Boo",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10580,Modifiability,variab,variable,10580,"aw(); selection - selection expression; see TTree::Draw(); option - Drawnig option; see TTree::Draw. TString GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last g",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:10709,Modifiability,variab,variable,10709,"tring GetProofSelectorName() const; Returns apropriate TSelector class name for proof for the object that is to be drawn; assumes that Parse() method has been called before. Double_t GetParameter(int num) const; returns *num*-th parameter from brackets in the expression; in case of an error (wrong number) returns 0.0; num - number of parameter (counted from 0). Double_t GetIfSpecified(Int_t num, Double_t def) const; num - parameter number; def - default value of the parameter; returns the value of *num*-th parameter from the brackets in the variable expression; if the parameter of that number wasn't specified returns *def*. Bool_t IsSpecified(int num) const; returns kTRUE if the *num*-th parameter was specified; otherwise returns fFALSE; in case of an error (wrong num) prints an error message and; returns kFALSE. TString GetVarExp(Int_t num) const; Returns the *num*-th variable string; in case of an error prints an error message and returns an empty string. TString GetVarExp() const; Returns the variable string, i.e. [var1[:var2[:var2[:var4]]]]. TString GetObjectTitle() const; Returns the desired plot title. TTreeDrawArgsParser::EOutputType DefineType(). TTreeDrawArgsParser(). Bool_t GetAdd() const; { return fAdd; }. Int_t GetDimension() const; { return fDimension; }. Bool_t GetShouldDraw() const; { return fShouldDraw; }. TString GetExp() const; { return fExp; }. Int_t GetNoParameters() const; { return fNoParameters; }. TString GetObjectName() const; { return fName; }. Bool_t GetOptionSame() const; { return fOptionSame; }. TObject * GetOriginal() const; { return fOriginal; }. TString GetSelection() const; { return fSelection; }. void SetObjectName(const char* s); { fName = s; }. void SetOriginal(TObject* o); { fOriginal = o; }. » Author: Marek Biskup 24/01/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions reg",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:2804,Security,Hash,Hash,2804,"onst; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::GetIconName() const; Double_tGetIfSpecified(Int_t num, Double_t def) const; static Int_tGetMaxDimension(); virtual const char*TObject::GetName() const; Int_tGetNoParameters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TStringGetObjectName() const; static Bool_tTObject::GetObjectStat(); TStringGetObjectTitle() const; virtual Option_t*TObject::GetOption() const; Bool_tGetOptionSame() const; TObject*GetOriginal() const; Double_tGetParameter(int num) const; TStringGetProofSelectorName() const; TStringGetSelection() const; Bool_tGetShouldDraw() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TStringGetVarExp() const; TStringGetVarExp(Int_t num) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsSpecified(int num) const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::ope",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:5111,Testability,Test,TestBit,5111,"const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeDrawArgsParser&operator=(const TTreeDrawArgsParser&); virtual voidTObject::Paint(Option_t* option = """"); Bool_tParse(const char* varexp, const char* selection, Option_t* option); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetObjectName(const char* s); static voidTObject::SetObjectStat(Bool_t stat); voidSetOriginal(TObject* o); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:5150,Testability,Test,TestBits,5150,"const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeDrawArgsParser&operator=(const TTreeDrawArgsParser&); virtual voidTObject::Paint(Option_t* option = """"); Bool_tParse(const char* varexp, const char* selection, Option_t* option); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetObjectName(const char* s); static voidTObject::SetObjectStat(Bool_t stat); voidSetOriginal(TObject* o); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeDrawArgsParser(); TTreeDrawArgsParser(const TTreeDrawArgsParser&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:781,Usability,Clear,Clear,781," virtual~TTreeDrawArgsParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAdd() const; Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetExp() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeDrawArgsParser.html:8375,Usability,Clear,ClearPrevious,8375," of the histogram/plot; Bool_tfDrawProfiletrue if the options contain :""prof""; Bool_tfEntryListif fill a TEntryList; TStringfExpcomplete variable expression; TStringfNamehistogram's/plot's name; Int_tfNoParametersif dimensions of the plot was specified; TStringfOptiondraw options; Bool_tfOptionSameif option contained ""same""; TObject*fOriginaloriginal plot (if it is to be reused); TTreeDrawArgsParser::EOutputTypefOutputTypetype of the output; Bool_tfParameterGiven[9]true if the parameter was given, otherwise false; Double_tfParameters[9]parameters in brackets; TStringfSelectionselection expression; Bool_tfShouldDrawif to draw the plot; TStringfVarExp[4]variable expression 0 - X, 1 - Y, 2 - Z, 3 - W. Class Charts. Inheritance Chart:. TObject. ←; TTreeDrawArgsParser. Function documentation; TTreeDrawArgsParser(); Constructor - cleans all the class variables. ~TTreeDrawArgsParser(); Destructor. Int_t GetMaxDimension(); return fgMaxDimension (cannot be inline). void ClearPrevious(); Resets all the variables of the class. Bool_t SplitVariables(TString variables); Parse expression [var1 [:var2 [:var3] ...]],; number of variables cannot be greater than fgMaxDimension.; A colon which is followed by (or that follows) another semicolon; is not regarded as a separator.; If there are more separating : than fgMaxDimension - 1 then; all characters after (fgMaxDimension - 1)th colon is put into; the last variable.; fDimension := <number of variables>; fVarExp[0] := <first variable string>; fVarExp[1] := <second variable string>; ..; Returns kFALSE in case of an error. Bool_t ParseName(TString name); Syntax:; [' '*][[\+][' '*]name[(num1 [, [num2] ] [, [num3] ] ...)]]; num's are floating point numbers; sets the fileds fNoParameters, fParameterGiven, fParameters, fAdd, fName; to apropriate values.; Returns kFALSE in case of an error. Bool_t ParseVarExp(); Split variables and parse name and parameters in brackets. Bool_t ParseOption(); Check if options contain some data important for ch",MatchSource.WIKI,root/html604/TTreeDrawArgsParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeDrawArgsParser.html
https://root.cern/root/html604/TTreeFormula.html:731,Availability,avail,available,731,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:2917,Availability,Error,Error,2917,"ect::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(const char* expression = """"); virtual voidROOT::v5::TFormula::Copy(TObject& formula) const; virtual char*ROOT::v5::TFormula::DefinedString(Int_t code); virtual Double_tROOT::v5::TFormula::DefinedValue(Int_t code); virtual Int_tDefinedVariable(TString& variable, Int_t& action); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tROOT::v5::TFormula::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tROOT::v5::TFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tROOT::v5::TFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, I",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:3926,Availability,error,error,3926,"char* method, const char* msgfmt) const; virtual Double_tROOT::v5::TFormula::Eval(Double_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tROOT::v5::TFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tROOT::v5::TFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringROOT::v5::TFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*ROOT::v5::TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidROOT::v5::TFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*T",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:4010,Availability,error,error,4010,"uble_t x, Double_t y = 0, Double_t z = 0, Double_t t = 0) const; virtual TClass*EvalClass() const; virtual Double_tEvalInstance(Int_t i = 0, const char*[] stringStack = 0); virtual Long64_tEvalInstance64(Int_t i = 0, const char*[] stringStack = 0); doubleEvalInstance<double>(Int_t i = 0, const char*[] stringStack = 0); long doubleEvalInstance<long double>(Int_t i = 0, const char*[] stringStack = 0); Long64_tEvalInstance<long long>(Int_t i = 0, const char*[] stringStack = 0); virtual LongDouble_tEvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); virtual void*EvalObject(Int_t i = 0); virtual Double_tROOT::v5::TFormula::EvalPar(const Double_t* x, const Double_t* params = 0); virtual Double_tROOT::v5::TFormula::EvalParOld(const Double_t* x, const Double_t* params = 0); virtual const char*EvalStringInstance(Int_t i = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TStringROOT::v5::TFormula::GetExpFormula(Option_t* option = """") const; virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeaf(Int_t n) const; TFormLeafInfo*GetLeafInfo(Int_t code) const; virtual const TObject*ROOT::v5::TFormula::GetLinearPart(Int_t i); TTreeFormulaManager*GetManager() const; static voidROOT::v5::TFormula::GetMaxima(Int_t& maxop, Int_t& maxpar, Int_t& maxconst); TMethodCall*GetMethodCall(Int_t code) const; virtual Int_tGetMultiplicity() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNcodes() const; virtual Int_tGetNdata(); vir",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27803,Availability,failure,failure,27803,"thod is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28134,Availability,Error,Error,28134,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28199,Availability,Error,Error,28199,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28898,Availability,failure,failure,28898," case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30742,Availability,redundant,redundant,30742,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:32471,Availability,avail,available,32471," the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. Int_t GetNdata(); *-*Return number of available instances in the formula; *-* ===================================================. Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member correspon",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:1537,Deployability,Update,Update,1537,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:10226,Deployability,Update,Update,10226," Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameters(const Double_t* params); virtual voidROOT::v5::TFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidROOT::v5::TFormula::SetParName(Int_t ipar, const char* name); virtual voidROOT::v5::TFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; voidSetQuickLoad(Bool_t quick); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const ROOT::v5::TFormula& formula); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const char* name, const char* formula); TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual voidROOT::v5::TFormula::Update(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34339,Deployability,Update,UpdateFormulaLeaves,34339,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34399,Deployability,Update,UpdateFormulaLeaves,34399,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34556,Deployability,update,update,34556,"= 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:35986,Deployability,Update,UpdateFormulaLeaves,35986,"use Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TTreeFormulaManager* GetManager() const; { return fManager; }. Int_t GetMultiplicity() const; {return fMultiplicity;}. Int_t GetNcodes() const; {return fNcodes;}. Bool_t IsQuickLoad() const; { return fQuickLoad; }. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. void SetQuickLoad(Bool_t quick); { fQuickLoad = quick; }. void SetTree(TTree* tree); {fTree = tree;}. TTree* GetTree() const; {return fTree;}. » Author: Rene Brun 19/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:764,Integrability,interface,interface,764,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28170,Integrability,message,message,28170,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:28227,Integrability,message,message,28227,"ultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:118,Modifiability,inherit,inheritance,118,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:1032,Modifiability,variab,variability,1032,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:2545,Modifiability,variab,variable,2545," virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:6004,Modifiability,Inherit,InheritsFrom,6004,"virtual Int_tROOT::v5::TFormula::GetNdim() const; virtual Int_tROOT::v5::TFormula::GetNpar() const; virtual Int_tROOT::v5::TFormula::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tROOT::v5::TFormula::GetParameter(Int_t ipar) const; Double_tROOT::v5::TFormula::GetParameter(const char* name) const; virtual Double_t*ROOT::v5::TFormula::GetParameters() const; virtual voidROOT::v5::TFormula::GetParameters(Double_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObjec",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:6070,Modifiability,Inherit,InheritsFrom,6070,"T::v5::TFormula::GetNpar() const; virtual Int_tROOT::v5::TFormula::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tROOT::v5::TFormula::GetParameter(Int_t ipar) const; Double_tROOT::v5::TFormula::GetParameter(const char* name) const; virtual Double_t*ROOT::v5::TFormula::GetParameters() const; virtual voidROOT::v5::TFormula::GetParameters(Double_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15740,Modifiability,variab,variable,15740,"tatic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfL",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:16556,Modifiability,variab,variable,16556,"tring; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNc",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:16596,Modifiability,variab,variable,16596,"tring; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNc",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17113,Modifiability,variab,variability,17113,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:18058,Modifiability,variab,variables,18058,"*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:18751,Modifiability,variab,variable,18751," entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry number changes.; TStringTNamed::fTitleobject title; TTree*fTree! pointer to Tree; TTreeFormula*fVarIndexes[500][5]Pointer to a variable index.; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAdd; static TTreeFormula::(anonymous)kAlias; static TTreeFormula::(anonymous)kAliasString; static TTreeFormula::(anonymous)kAlternate; static TTreeFormula::(anonymous)kAlternateString; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBinary; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBitAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBitOr; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimize; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimizeAnd; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolOptimizeOr; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kBoolSet; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kConstant; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kData; s",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:26164,Modifiability,Inherit,Inheritance,26164,"mula::(anonymous)ROOT::v5::TFormula::kxexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxpol; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxyexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxygaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kxylandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kyexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kygaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kylandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kypol; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance Chart:. ROOT::v5::TFormula. ←; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usa",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:26884,Modifiability,variab,variables,26884,":kylandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kypol; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzexpo; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance Chart:. ROOT::v5::TFormula. ←; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failur",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27014,Modifiability,variab,variables,27014,"OOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzgaus; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzlandau; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kzpol. Class Charts. Inheritance Chart:. ROOT::v5::TFormula. ←; TTreeFormula. Function documentation; TTreeFormula(); Tree Formula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27352,Modifiability,variab,variables,27352,"mula default constructor. TTreeFormula(const char* name, const char* formula, TTree* tree); Normal TTree Formula Constuctor. TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27488,Modifiability,variab,variables,27488," char* formula, TTree* tree, const vector<string>& aliases); Constructor used during the expansion of an alias. void Init(const char* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27613,Modifiability,variab,variables,27613,"ar* name, const char* formula); Initialiation called from the constructors. ~TTreeFormula(); Tree Formula default destructor; *-* =================================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29033,Modifiability,variab,variable,29033,"inting to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29361,Modifiability,variab,variable,29361,"ion, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Lo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29381,Modifiability,variab,variable,29381,", vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* meth",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29542,Modifiability,variab,variable,29542,"sponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:33581,Modifiability,variab,variable,33581,". Double_t GetValueFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. void* GetValuePointerFromMethod(Int_t i, TLeaf* leaf) const; Return result of a leafobject method. Bool_t IsInteger(Bool_t fast = kTRUE) const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:33798,Modifiability,variab,variable,33798," const; return TRUE if the formula corresponds to one single Tree leaf; and this leaf is short, int or unsigned short, int; When a leaf is of type integer or string, the generated histogram is forced; to have an integer bin width. Bool_t IsLeafInteger(Int_t code) const; return TRUE if the leaf corresponding to code is short, int or unsigned; short, int When a leaf is of type integer, the generated histogram is; forced to have an integer bin width. Bool_t IsString() const; return TRUE if the formula is a string. Bool_t IsString(Int_t oper) const; (fOper[i]>=105000 && fOper[i]<110000) || fOper[i] == kStrings). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:1570,Performance,load,loading,1570,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:7258,Performance,Optimiz,Optimize,7258,"le_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidROOT::v5::TFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidROOT::v5::TFormula::Print(Option_t* option = """") constMENU ; virtual char*PrintValue(Int_t mode = 0) const; virtual char*PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15261,Performance,cache,cache,15261,"UID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kLinear; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNormalized; static TObject::(anonymous)TObject::kNotDeleted; static ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:15894,Performance,optimiz,optimization,15894,"tatic ROOT::v5::TFormula::(anonymous)ROOT::v5::TFormula::kNotGlobal; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAliases! List of TTreeFormula for each alias used.; vector<string>fAliasesUsed! List of aliases used during the parsing of the expression.; TBitsROOT::v5::TFormula::fAlreadyFound! cache for information; TAxis*fAxis! pointer to histogram axis if this is a string; TObjArrayfBranches! List of branches to read. Similar to fLeaces but duplicates are zeroed out.; Int_tfCodes[500]List of leaf numbers referenced in formula; Double_t*ROOT::v5::TFormula::fConst[fNconst] Array of fNconst formula constants; LongDouble_t*fConstLDlocal version of fConsts able to store bigger numbers; Int_tfCumulSizes[500][5]Accumulated sizes of lower dimensions for each leaf after variable dimensions has been calculated; TObjArrayfDataMembers! List of leaf data members; Bool_tfDidBooleanOptimization! True if we executed one boolean optimization since the last time instance number 0 was evaluated; TList*fDimensionSetup! list of dimension setups, for delayed creation of the dimension information.; TString*ROOT::v5::TFormula::fExpr[fNoper] List of expressions; TString*ROOT::v5::TFormula::fExprOptimized![fNOperOptimized] List of expressions; TObjArrayfExternalCuts! List of TCutG and TEntryList used in the formula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfL",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17208,Performance,optimiz,optimization,17208,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17457,Performance,cache,caches,17457,"ula; Int_tfFixedSizes[500][5]Physical sizes of lower dimensions for each leaf; TObjArrayROOT::v5::TFormula::fFunctionsArray of function calls to make; Bool_tfHasCastRecord whether the formula contain a cast operation or not; UChar_tfHasMultipleVarDim[500]True if the corresponding variable is an array with more than one variable dimension.; Int_tfIndexes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation fo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:17722,Performance,load,loaded,17722,"xes[500][5]Index of array selected by user for each leaf; TObjArrayfLeafNamesList of TNamed describing leaves; TObjArrayfLeaves! List of leaf used in this formula.; TObjArrayROOT::v5::TFormula::fLinearPartsLinear parts if the formula is linear (contains '|' or ""++""); Int_t*fLookupType[fNindex] array indicating how each leaf should be looked-up; TTreeFormulaManager*fManager! The dimension coordinator.; TObjArrayfMethods! List of leaf method calls; Int_tfMultiplicityIndicator of the variability of the formula; Int_tROOT::v5::TFormula::fNOperOptimized!Number of operators after optimization; TStringTNamed::fNameobject identifier; TString*ROOT::v5::TFormula::fNames[fNpar] Array of parameter names; Int_tfNcodesNumber of leaves referenced in formula; Int_tROOT::v5::TFormula::fNconstNumber of constants; Int_tfNdata[500]! This caches the physical number of element in the leaf or datamember.; Int_tROOT::v5::TFormula::fNdimDimension of function (1=1-Dim, 2=2-Dim,etc); Int_tfNdimensions[500]Number of array dimensions in each leaf; Bool_tfNeedLoading! If true, the current entry has not been loaded yet.; Int_tfNindexSize of fIndex; Int_tROOT::v5::TFormula::fNoperNumber of operators; Int_tROOT::v5::TFormula::fNparNumber of parameters; Int_tROOT::v5::TFormula::fNstringNumber of different constants character strings; Int_tROOT::v5::TFormula::fNumberformula number identifier; Int_tROOT::v5::TFormula::fNvalNumber of different variables in expression; ROOT::v5::TOperOffset*ROOT::v5::TFormula::fOperOffset![fNOperOptimized] Offsets of operrands; Int_t*ROOT::v5::TFormula::fOperOptimized![fNOperOptimized] List of operators. (See documentation for changes made at version 7); ROOT::v5::TFormula::TFuncGROOT::v5::TFormula::fOptimal!pointer to optimal function; Double_t*ROOT::v5::TFormula::fParams[fNpar] Array of fNpar parameters; ROOT::v5::TFormulaPrimitive**ROOT::v5::TFormula::fPredefined![fNPar] predefined function; Bool_tfQuickLoad! If true, branch GetEntry is only called when the entry num",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:27743,Performance,load,load,27743,"========================. void DefineDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* info, Int_t& virt_dim); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(const char* size, Int_t code); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, Int_t size, TFormLeafInfoMultiVarDim* multidim = 0); This method stores the dimension information for later usage. Int_t RegisterDimensions(Int_t code, TFormLeafInfo* info, TFormLeafInfo* maininfo, Bool_t useCollectionObject); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TBranchElement* branch); This method is used internally to decode the dimensions of the variables. Int_t RegisterDimensions(Int_t code, TLeaf* leaf); This method is used internally to decode the dimensions of the variables. Int_t DefineAlternate(const char* expression); This method check for treat the case where expression contains $Atl and load up; both fAliases and fExpr.; We return; -1 in case of failure; 0 in case we did not find $Alt; the action number in case of success. Int_t ParseWithLeaf(TLeaf* leaf, const char* expression, Bool_t final, UInt_t paran_level, TObjArray& castqueue, Bool_t useLeafCollectionObject, const char* fullExpression); Decompose 'expression' as pointing to something inside the leaf; Returns:; -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. Int_t FindLeafForExpression(const char* expression, TLeaf*& leaf, TString& leftover, Bool_t& final, UInt_t& paran_level, TObjArray& castqueue, vector<string>& aliasUsed, Bool_t& useLeafCollectionObject, const char* fullExpression); Look for the leaf corresponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from exp",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34446,Performance,Load,LoadTree,34446,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34474,Performance,load,loaded,34474,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34720,Performance,Load,LoadBranches,34720,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TT",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34778,Performance,load,loaded,34778,"ar* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TT",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:34802,Performance,Load,LoadCurrentDim,34802," as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* formula, TTree* tree, const vector<string>& aliases). TTreeFormula& operator=(const TTreeFormula& ). Long64_t EvalInstance64(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<Long64_t>(i, stringStack); }. LongDouble_t EvalInstanceLD(Int_t i = 0, const char*[] stringStack = 0); {return EvalInstance<LongDouble_t>(i, stringStack); }. TTreeFormulaManager* GetManager() const; { return fMana",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30742,Safety,redund,redundant,30742,"Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* ======",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:5894,Security,Hash,Hash,5894,"ity() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNcodes() const; virtual Int_tGetNdata(); virtual Int_tROOT::v5::TFormula::GetNdim() const; virtual Int_tROOT::v5::TFormula::GetNpar() const; virtual Int_tROOT::v5::TFormula::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tROOT::v5::TFormula::GetParameter(Int_t ipar) const; Double_tROOT::v5::TFormula::GetParameter(const char* name) const; virtual Double_t*ROOT::v5::TFormula::GetParameters() const; virtual voidROOT::v5::TFormula::GetParameters(Double_t* params); virtual const char*ROOT::v5::TFormula::GetParName(Int_t ipar) const; virtual Int_tROOT::v5::TFormula::GetParNumber(const char* name) const; virtual const char*TNamed::GetTitle() const; virtual TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsInteger(Bool_t fast = kTRUE) const; virtual Bool_tROOT::v5::TFormula::IsLinear() const; virtual Bool_tROOT::v5::TFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; Bool_tIsQuickLoad() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsString() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(vo",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:9827,Testability,Test,TestBit,9827," Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameters(const Double_t* params); virtual voidROOT::v5::TFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidROOT::v5::TFormula::SetParName(Int_t ipar, const char* name); virtual voidROOT::v5::TFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; voidSetQuickLoad(Bool_t quick); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const ROOT::v5::TFormula& formula); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const char* name, const char* formula); TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual voidROOT::v5::TFormula::Update(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:9866,Testability,Test,TestBits,9866," Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidROOT::v5::TFormula::SetParameters(const Double_t* params); virtual voidROOT::v5::TFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidROOT::v5::TFormula::SetParName(Int_t ipar, const char* name); virtual voidROOT::v5::TFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; voidSetQuickLoad(Bool_t quick); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const ROOT::v5::TFormula& formula); ROOT::v5::TFormulaROOT::v5::TFormula::TFormula(const char* name, const char* formula); TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual voidROOT::v5::TFormula::Update(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:2103,Usability,Clear,Clear,2103," virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:10905,Usability,Clear,ClearFormula,10905,,MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:29535,Usability,simpl,simple,29535,"sponding to the start of expression.; It returns the corresponding leaf if any.; It also modify the following arguments:; leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used; Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. Int_t DefinedVariable(TString& variable, Int_t& action); -*Check if name is in the list of Tree/Branch leaves; *-* ==================================================. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of ",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:30144,Usability,usab,usable,30144,"===. This member function redefines the function in ROOT::v5::TFormula; If a leaf has a name corresponding to the argument name, then; returns a new code.; A TTreeFormula may contain more than one variable.; For each variable referenced, the pointers to the corresponding; branch and leaf is stored in the object arrays fBranches and fLeaves. name can be :; - Leaf_Name (simple variable or data member of a ClonesArray); - Branch_Name.Leaf_Name; - Branch_Name.Method_Name; - Leaf_Name[index]; - Branch_Name.Leaf_Name[index]; - Branch_Name.Leaf_Name[index1]; - Branch_Name.Leaf_Name[][index2]; - Branch_Name.Leaf_Name[index1][index2]; New additions:; - Branch_Name.Leaf_Name[OtherLeaf_Name]; - Branch_Name.Datamember_Name; - '.' can be replaced by '->'; and; - Branch_Name[index1].Leaf_Name[index2]; - Leaf_name[index].Action().OtherAction(param); - Leaf_name[index].Action()[val].OtherAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the cla",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:31022,Usability,simpl,simple,31022,"rAction(param). The expected returns values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized; >=0 : the name has been recognized, return the internal code for this name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable.",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormula.html:31238,Usability,simpl,simple,31238,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspon",MatchSource.WIKI,root/html604/TTreeFormula.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormula.html
https://root.cern/root/html604/TTreeFormulaManager.html:1379,Availability,Error,Error,1379," voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:1508,Availability,error,error,1508," voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:1592,Availability,error,error,1592,"st char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classna",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7791,Availability,avail,available,7791,"zes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7936,Deployability,Update,UpdateFormulaLeaves,7936,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8002,Deployability,Update,UpdateFormulaLeaves,8002,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8159,Deployability,update,update,8159,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8234,Deployability,Update,UpdateUsedSize,8234,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8511,Deployability,Update,UpdateFormulaLeaves,8511,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6676,Integrability,synchroniz,synchronization,6676,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7901,Integrability,Synchroniz,Synchronize,7901,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:125,Modifiability,inherit,inheritance,125,". TTreeFormulaManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormulaManager. class TTreeFormulaManager: public TObject. A TreeFormulaManager is used to coordinate one or more TTreeFormula objecs. In particular it makes sure that the dimensions and size of all the formulas; is properly coordinated. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:2563,Modifiability,Inherit,InheritsFrom,2563,"jArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void*",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:2629,Modifiability,Inherit,InheritsFrom,2629,"nt(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual v",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6364,Modifiability,variab,variable,6364,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6447,Modifiability,variab,variable,6447,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6462,Modifiability,variab,variable,6462,reeFormulaManager&operator=(const TTreeFormulaManager&); TTreeFormulaManager(const TTreeFormulaManager&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; Th,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6524,Modifiability,variab,variability,6524,k; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. vo,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6793,Modifiability,variab,variable,6793,tatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of a,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:6916,Modifiability,Inherit,Inheritance,6916, static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCumulUsedSizes[6]Accumulated size of lower dimensions as seen for this entry; TArrayI*fCumulUsedVarDimsfCumulUsedSizes(1) for multi variable dimensions case; TObjArrayfFormulas; Bool_tfMultiVarDimTrue if one of the variable has 2 variable size dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the form,MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7485,Modifiability,variab,variable,7485,"e dimensions.; Int_tfMultiplicityIndicator of the variability of the formula; Int_tfNdata! Last value calculated by GetNdata; Bool_tfNeedSyncIndicate whether a new formula has been added since the last synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:7703,Modifiability,variab,variable,7703,"st synchronization; Int_tfUsedSizes[6]Actual size of the dimensions as seen for this entry.; TArrayI*fVarDims[6]List of variable sizes dimensions.; Int_tfVirtUsedSizes[6]Virtual size of lower dimensions as seen for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8049,Performance,Load,LoadTree,8049,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:8077,Performance,load,loaded,8077,"en for this formula. Class Charts. Inheritance Chart:. TObject. ←; TTreeFormulaManager. Function documentation; TTreeFormulaManager(); -*Tree FormulaManger default constructor; *-* ======================================. ~TTreeFormulaManager(); -*Tree FormulaManager default destructor; *-* ======================================. void Remove(TTreeFormula* ); Remove a formula from this manager. void Add(TTreeFormula* ); Add a new formula to the list of formulas managed; The manager of the formula will be changed and the old one will be deleted; if it is empty. void AddVarDims(Int_t virt_dim); Add a variable dimension. void CancelDimension(Int_t virt_dim); Cancel a dimension. This is usually called when an out-of-bounds index; is used. void EnableMultiVarDims(); Set the manager as handling a formula with multiple variable dimensions. Int_t GetNdata(Bool_t forceLoadDim = kFALSE); -*-*Return number of available instances in the formulas; *-* ====================================================. Bool_t Sync(); Synchronize all the formulae. void UpdateFormulaLeaves(); this function could be called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void UpdateUsedSize(Int_t& virt_dim, Int_t vsize); Reload the array sizes. TTreeFormulaManager(const TTreeFormulaManager& ); Not implemented yet. TTreeFormulaManager& operator=(const TTreeFormulaManager& ). Int_t GetMultiplicity() const; {return fMultiplicity;}. Bool_t Notify(); { UpdateFormulaLeaves(); return kTRUE; }. » Author: Philippe Canal 20/03/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:2453,Security,Hash,Hash,2453,"ecute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNdata(Bool_t forceLoadDim = kFALSE); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operato",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:4578,Testability,Test,TestBit,4578,"ct::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TTreeFormula*); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Bool_tSync(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeFormulaManager(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:4617,Testability,Test,TestBits,4617,"ct::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tNotify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemove(TTreeFormula*); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Bool_tSync(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeFormulaManager(); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFormulaManager.html:839,Usability,Clear,Clear,839," voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TTreeFormula*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() con",MatchSource.WIKI,root/html604/TTreeFormulaManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFormulaManager.html
https://root.cern/root/html604/TTreeFriendLeafIter.html:1489,Modifiability,Inherit,Inheritance,1489,"tCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; Bool_toperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-20",MatchSource.WIKI,root/html604/TTreeFriendLeafIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFriendLeafIter.html
https://root.cern/root/html604/TTreeFriendLeafIter.html:1502,Modifiability,Inherit,Inherited,1502,"tCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual Bool_toperator!=(const TIterator&) const; Bool_toperator!=(const TTreeFriendLeafIter&) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-20",MatchSource.WIKI,root/html604/TTreeFriendLeafIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFriendLeafIter.html
https://root.cern/root/html604/TTreeFriendLeafIter.html:2307,Safety,Safe,SafeDelete,2307,"perator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-18 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFriendLeafIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFriendLeafIter.html
https://root.cern/root/html604/TTreeFriendLeafIter.html:2330,Safety,Safe,SafeDelete,2330,"perator*() const; virtual TIterator&operator=(const TIterator& rhs); TTreeFriendLeafIter&operator=(const TTreeFriendLeafIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward). protected:. TTreeFriendLeafIter(). Data Members; protected:. Bool_tfDirectioniteration direction; TIterator*fLeafItercurrent leaf sub-iterator.; TTree*fTreetree being iterated; TIterator*fTreeItercurrent tree sub-iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeFriendLeafIter(const TTree* t, Bool_t dir = kIterForward); Create a new iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. TTreeFriendLeafIter(const TTreeFriendLeafIter& iter); Copy constructor. Does NOT copy the 'cursor' location!. TIterator& operator=(const TIterator& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TTreeFriendLeafIter& operator=(const TTreeFriendLeafIter& rhs); Overridden assignment operator. Does NOT copy the 'cursor' location!. TObject* Next(); Go the next friend element. Option_t* GetOption() const; Returns the object option stored in the list. void Reset(Option_t* option = """"). TTreeFriendLeafIter(); { }. ~TTreeFriendLeafIter(); { SafeDelete(fLeafIter); SafeDelete(fTreeIter); }. const TCollection * GetCollection() const; { return 0; }. TObject * operator*() const; TODO: Implement me. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-18 17:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeFriendLeafIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeFriendLeafIter.html
https://root.cern/root/html604/TTreeIndex.html:1306,Availability,Error,Error,1306," virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long6",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:1435,Availability,error,error,1435,"ct::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormu",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:1519,Availability,error,error,1519,"*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() con",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:10073,Availability,failure,failure,10073,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:9742,Deployability,update,update,9742,"s eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do no",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13495,Deployability,Update,UpdateFormulaLeaves,13495,"() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13696,Deployability,Update,UpdateFormulaLeaves,13696,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13818,Deployability,update,update,13818,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:116,Modifiability,inherit,inheritance,116,". TTreeIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeIndex. class TTreeIndex: public TVirtualIndex. A Tree Index with majorname and minorname. Function Members (Methods); public:. virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long6",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:3212,Modifiability,Inherit,InheritsFrom,3212,"onst char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormula(); virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:3278,Modifiability,Inherit,InheritsFrom,3278,") const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormula(); virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); vi",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:7610,Modifiability,Inherit,Inheritance,7610,"TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_t*fIndex[fN] Index of sorted values; Long64_t*fIndexValues[fN] Sorted index values, higher 64bits; Long64_t*fIndexValuesMinor[fN] Sorted index values, lower 64bits; TTreeFormula*fMajorFormula! Pointer to major TreeFormula; TTreeFormula*fMajorFormulaParent! Pointer to major TreeFormula in Parent tree (if any); TStringfMajorNameIndex major name; TTreeFormula*fMinorFormula! Pointer to minor TreeFormula; TTreeFormula*fMinorFormulaParent! Pointer to minor TreeFormula in Parent tree (if any); TStringfMinorNameIndex minor name; Long64_tfNNumber of entries; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TTree*TVirtualIndex::fTree! pointer to Tree. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualIndex. ←; TTreeIndex. Function documentation; TTreeIndex(); Default constructor for TTreeIndex. TTreeIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TTreeIndex. Build an index table using the leaves of Tree T with major & minor names; The index is built with the expressions given in ""majorname"" and ""minorname"". a Long64_t array fIndexValues is built with:; major = the value of majorname converted to an integer; minor = the value of minorname converted to an integer; fIndexValues[i] = major<<31 + minor; This array is sorted. The sorted fIndex[i] contains the serial number; in the Tree corresponding to the pair ""major,minor"" in fIndexvalues[i]. Once the index is computed, one can retrieve one entry via; T->GetEntryWithIndex(majornumber, minornumber); Example:; tree.BuildIndex(""Run"",""Event""); //creates an index using leaves Run and Event; tree.GetEntryWithIndex(1234,56789); //reads entry corresponding to",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:8721,Modifiability,variab,variables,8721,"n; TTreeIndex(); Default constructor for TTreeIndex. TTreeIndex(const TTree* T, const char* majorname, const char* minorname); Normal constructor for TTreeIndex. Build an index table using the leaves of Tree T with major & minor names; The index is built with the expressions given in ""majorname"" and ""minorname"". a Long64_t array fIndexValues is built with:; major = the value of majorname converted to an integer; minor = the value of minorname converted to an integer; fIndexValues[i] = major<<31 + minor; This array is sorted. The sorted fIndex[i] contains the serial number; in the Tree corresponding to the pair ""major,minor"" in fIndexvalues[i]. Once the index is computed, one can retrieve one entry via; T->GetEntryWithIndex(majornumber, minornumber); Example:; tree.BuildIndex(""Run"",""Event""); //creates an index using leaves Run and Event; tree.GetEntryWithIndex(1234,56789); //reads entry corresponding to; Run=1234 and Event=56789. Note that majorname and minorname may be expressions using original; Tree variables eg: ""run-90000"", ""event +3*xx"". However the result; must be integer.; In case an expression is specified, the equivalent expression must be computed; when calling GetEntryWithIndex. To build an index with only majorname, specify minorname=""0"" (default). TreeIndex and Friend Trees. Assuming a parent Tree T and a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Wr",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:11513,Performance,perform,performs,11513,"ue, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues table, not entry# !; use lower_bound STD algorithm. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair th",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:12327,Performance,perform,performs,12327,"major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Double_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Long64_t* GetIndexValuesMinor() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13555,Performance,Load,LoadTree,13555,"() const. TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT su",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13670,Performance,Load,LoadTree,13670,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:13736,Performance,load,loaded,13736,". TTreeFormula * GetMajorFormula(); Return a pointer to the TreeFormula corresponding to the majorname. TTreeFormula * GetMinorFormula(); Return a pointer to the TreeFormula corresponding to the minorname. TTreeFormula * GetMajorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the majorname in parent tree. TTreeFormula * GetMinorFormulaParent(const TTree* parent); Return a pointer to the TreeFormula corresponding to the minorname in parent tree. void Print(Option_t* option = """") const; Print the table with : serial number, majorname, minorname.; if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries. void Streamer(TBuffer& ); Stream an object of class TTreeIndex.; Note that this Streamer should be changed to an automatic Streamer; once TStreamerInfo supports an index of type Long64_t. void UpdateFormulaLeaves(const TTree* parent); Called by TChain::LoadTree when the parent chain changes it's tree. void SetTree(const TTree* T); this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreeIndex. TTreeIndex(const TTreeIndex& ). TTreeIndex & operator=(const TTreeIndex& ). Long64_t * GetIndex() const; {return fIndex;}. Long64_t * GetIndexValues() const; {return fIndexValues;}. const char * GetMajorName() const; {return fMajorName.Data();}. const char * GetMinorName() const; {return fMinorName.Data();}. Long64_t GetN() const; {return fN;}. » Author: Rene Brun 05/07/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:3102,Security,Hash,Hash,3102,"r, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual Long64_t*GetIndex() const; virtual Long64_t*GetIndexValues() const; virtual Long64_t*GetIndexValuesMinor() const; virtual TTreeFormula*GetMajorFormula(); virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFormula*GetMinorFormula(); virtual TTreeFormula*GetMinorFormulaParent(const TTree* parent); virtual const char*GetMinorName() const; virtual Long64_tGetN() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual TTree*TVirtualIndex::GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:5424,Testability,Test,TestBit,5424,"delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeIndex(); TTreeIndex(const TTree* T, const char* majorname, const char* minorname); virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:5463,Testability,Test,TestBits,5463,"delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidSetTree(const TTree* T); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeIndex(); TTreeIndex(const TTree* T, const char* majorname, const char* minorname); virtual voidUpdateFormulaLeaves(const TTree* parent); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeIndex.html:740,Usability,Clear,Clear,740," virtual~TTreeIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; boolConvertOldToNew(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tFindValues(Long64_t major, Long64_t minor) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long6",MatchSource.WIKI,root/html604/TTreeIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeIndex.html
https://root.cern/root/html604/TTreeInput.html:4322,Availability,Error,Error,4322,"const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::G",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:4451,Availability,error,error,4451," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:4535,Availability,error,error,4535,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:20086,Availability,mask,mask,20086,,MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:11110,Integrability,Message,Message,11110,"TGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTGCompositeFrame::Print(Option_t* option = """") const; virtual voidTGFrame::ProcessedConfigure(Event_t* ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:116,Modifiability,inherit,inheritance,116,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:387,Modifiability,variab,variables,387,". TTreeInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » FITPANEL; » TTreeInput. class TTreeInput: public TGTransientFrame. Tree Input Widget. An dialog box that asks the user for the variables and cuts; of the selected tree in the fitpanel. Function Members (Methods); public:. virtual~TTreeInput(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, co",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:9693,Modifiability,Inherit,InheritsFrom,9693,"TGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() co",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:9759,Modifiability,Inherit,InheritsFrom,9759,"e::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow:",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23244,Modifiability,variab,variables,23244,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23350,Modifiability,variab,variables,23350,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23375,Modifiability,Inherit,Inheritance,23375,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:9403,Security,Hash,Hash,9403,"virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWi",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:15927,Testability,Test,TestBit,15927,"TGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:15966,Testability,Test,TestBits,15966,"TGMainFrame::SetIconPixmap(char** xpm_array); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:1567,Usability,Clear,Clear,1567,"dTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTGMainFrame::CloseWindow()SIGNAL ; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::D",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreeInput.html:23639,Usability,simpl,simple,23639,"ag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TGTransientFrame. ←; TTreeInput. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeInput.html
https://root.cern/root/html604/TTreePerfStats.html:3493,Availability,Error,Error,3493,,MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:3706,Availability,error,error,3706,"r* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:3790,Availability,error,error,3790,"dBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&TVirtualPerfStats::CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char*, const char*, const char*, const char*, Bool_t); virtual voidFileOpenEvent(TFile*, const char*, Double_t); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinish(); virtual Long64_tGetBytesRead() const; virtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:11323,Energy Efficiency,monitor,monitored,11323,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:120,Modifiability,inherit,inheritance,120,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:5437,Modifiability,Inherit,InheritsFrom,5437,"virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TPaveText*GetPave(); virtual Int_tGetReadaheadSize() const; virtual Int_tGetReadCalls() const; virtual Double_tGetRealTime() const; TStopwatch*GetStopwatch() const; virtual const char*TObject::GetTitle() const; virtual Int_tGetTreeCacheSize() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetUnzipTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:5503,Modifiability,Inherit,InheritsFrom,5503,"ect::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TPaveText*GetPave(); virtual Int_tGetReadaheadSize() const; virtual Int_tGetReadCalls() const; virtual Double_tGetRealTime() const; TStopwatch*GetStopwatch() const; virtual const char*TObject::GetTitle() const; virtual Int_tGetTreeCacheSize() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetUnzipTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreePerfStats&operator=(const TTreePerfStats&); vi",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:11482,Modifiability,Inherit,Inheritance,11482,"readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void Draw(Option_t* option = """"); Draw the TTree I/O perf graph.; by default the graph is drawn with option ""al""; Specify option =""ap"" to show only the read blocks and not the line; connecting the blocks. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void FileReadEvent(TFile* file, Int_t len, Double_t start); Record TTree file read event.; start is the TimeStamp before reading; len is the number of bytes read. void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); Record TTree u",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:369,Performance,perform,performance,369,". TTreePerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePerfStats. class TTreePerfStats: public TVirtualPerfStats. TTreePerfStats. TTree I/O performance measurement. see example of use below. The function FileReadEvent is called from TFile::ReadBuffer.; For each call the following information is stored in fGraphIO; - x[i] = Tree entry number; - y[i] = 1e-6*(file position); - ey[i] = 1e-9*number of bytes read; For each call the following information is stored in fGraphTime; - x[i] = Tree entry number; - y[i] = Time now; - ey[i] = readtime, eg timenow - start; The TTreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:1519,Performance,cache,cache,1519,"TreePerfStats object can be saved in a ROOT file in such a way that; its inspection can be done outside the job that generated it. Example of use; {; TFile *f = TFile::Open(""RelValMinBias-GEN-SIM-RECO.root"");; T = (TTree*)f->Get(""Events"");; Long64_t nentries = T->GetEntries();; T->SetCacheSize(10000000);; T->SetCacheEntryRange(0,nentries);; T->AddBranchToCache(""*"");. TTreePerfStats *ps= new TTreePerfStats(""ioperf"",T);. for (Int_t i=0;i<nentries;i++) {; T->GetEntry(i);; }; ps->SaveAs(""cmsperf.root"");; }. then, in a root interactive session, one can do:; root > TFile f(""cmsperf.root"");; root > ioperf->Draw();; root > ioperf->Print();. The Draw or Print functions print the following information:; TreeCache = TTree cache size in MBytes; N leaves = Number of leaves in the TTree; ReadTotal = Total number of zipped bytes read; ReadUnZip = Total number of unzipped bytes read; ReadCalls = Total number of disk reads; ReadSize = Average read size in KBytes; Readahead = Readahead size in KBytes; Readextra = Readahead overhead in percent; Real Time = Real Time in seconds; CPU Time = CPU Time in seconds; Disk Time = Real Time spent in pure raw disk IO; Disk IO = Raw disk IO speed in MBytes/second; ReadUZRT = Unzipped MBytes per RT second; ReadUZCP = Unipped MBytes per CP second; ReadRT = Zipped MBytes per RT second; ReadCP = Zipped MBytes per CP second. NOTE1 : The ReadTotal value indicates the effective number of zipped bytes; returned to the application. The physical number of bytes read; from the device (as measured for example with strace) is; ReadTotal +ReadTotal*Readextra/100. Same for ReadSize. NOTE2 : A consequence of NOTE1, the Disk I/O speed corresponds to the effective; number of bytes returned to the application per second.; The Physical disk speed is DiskIO + DiskIO*ReadExtra/100. Function Members (Methods); public:. virtual~TTreePerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrows",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:10501,Performance,cache,cache,10501,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:11125,Performance,cache,cache,11125,"verwrite; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kPacket; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kRate; static TObject::(anonymous)TObject::kSingleKey; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStart; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kStop; static TVirtualPerfStats::EEventTypeTVirtualPerfStats::kUnDefined; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Long64_tfBytesReadNumber of bytes read; Long64_tfBytesReadExtraNumber of bytes (overhead) of the readahead cache; Double_tfCompressTree compression factor; Double_tfCpuTimeCpu time; Double_tfDiskTimeTime spent in pure raw disk IO; TFile*fFile!pointer to the file containing the Tree; TGraphErrors*fGraphIOpointer to the graph with IO data; TGraphErrors*fGraphTimepointer to the graph with timestamp info; TStringfHostInfoname of the host system, ROOT version and date; TText*fHostInfoTextGraphics Text object with the fHostInfo data; TStringfNamename of this TTreePerfStats; Int_tfNleavesNumber of leaves in the tree; TPaveText*fPavepointer to annotation pavetext; Int_tfReadCallsNumber of read calls; Int_tfReadaheadSizeReadahead cache size; Double_tfRealNormReal time scale factor for fGraphTime; Double_tfRealTimeReal time; TGaxis*fRealTimeAxispointer to TGaxis object showing real-time; TTree*fTree!pointer to the Tree being monitored; Int_tfTreeCacheSizeTTreeCache buffer size; Double_tfUnzipTimeTime spent uncompressing the data.; TStopwatch*fWatchTStopwatch pointer. Class Charts. Inheritance Chart:. TObject. ←; TVirtualPerfStats. ←; TTreePerfStats. Function documentation; TTreePerfStats(); default constructor (used when reading an object only). TTreePerfStats(const char* name, TTree* T); Create a TTree I/O perf stats object. ~TTreePerfStats(); Destructor. void Browse(TBrowser* b); Browse. Int_t DistancetoPrimitive(Int_t px, Int_t py); Return distance to one of the objects in the TTreePerfStats. void D",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:5327,Security,Hash,Hash,5327,"rtual Long64_tGetBytesReadExtra() const; virtual Double_tGetCpuTime() const; virtual Double_tGetDiskTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGraphErrors*GetGraphIO(); TGraphErrors*GetGraphTime(); const char*GetHostInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual Int_tGetNleaves() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TPaveText*GetPave(); virtual Int_tGetReadaheadSize() const; virtual Int_tGetReadCalls() const; virtual Double_tGetRealTime() const; TStopwatch*GetStopwatch() const; virtual const char*TObject::GetTitle() const; virtual Int_tGetTreeCacheSize() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_tGetUnzipTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:8347,Testability,Test,TestBit,8347,"ject::ResetBit(UInt_t f); virtual voidSaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t nbytes); virtual voidSetBytesReadExtra(Long64_t nbytes); virtual voidSetCompress(Double_t cx); virtual voidSetCpuTime(Double_t cptime); virtual voidSetDiskTime(Double_t t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetGraphIO(TGraphErrors* gr); virtual voidSetGraphTime(TGraphErrors* gr); virtual voidSetHostInfo(const char* info); virtual voidSetName(const char* name); virtual voidSetNleaves(Int_t nleaves); virtual voidSetNumEvents(Long64_t); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadaheadSize(Int_t nbytes); virtual voidSetReadCalls(Int_t ncalls); virtual voidSetRealNorm(Double_t rnorm); virtual voidSetRealTime(Double_t rtime); virtual voidSetTreeCacheSize(Int_t nbytes); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUnzipTime(Double_t uztime); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSimpleEvent(TVirtualPerfStats::EEventType); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreePerfStats(); TTreePerfStats(const TTreePerfStats&); TTreePerfStats(const char* name, TTree* T); virtual voidUnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:8386,Testability,Test,TestBits,8386,"ject::ResetBit(UInt_t f); virtual voidSaveAs(const char* filename = """", Option_t* option = """") const; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBytesRead(Long64_t nbytes); virtual voidSetBytesReadExtra(Long64_t nbytes); virtual voidSetCompress(Double_t cx); virtual voidSetCpuTime(Double_t cptime); virtual voidSetDiskTime(Double_t t); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetGraphIO(TGraphErrors* gr); virtual voidSetGraphTime(TGraphErrors* gr); virtual voidSetHostInfo(const char* info); virtual voidSetName(const char* name); virtual voidSetNleaves(Int_t nleaves); virtual voidSetNumEvents(Long64_t); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetReadaheadSize(Int_t nbytes); virtual voidSetReadCalls(Int_t ncalls); virtual voidSetRealNorm(Double_t rnorm); virtual voidSetRealTime(Double_t rtime); virtual voidSetTreeCacheSize(Int_t nbytes); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetUnzipTime(Double_t uztime); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSimpleEvent(TVirtualPerfStats::EEventType); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreePerfStats(); TTreePerfStats(const TTreePerfStats&); TTreePerfStats(const char* name, TTree* T); virtual voidUnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:2906,Usability,Clear,Clear,2906,,MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePerfStats.html:14155,Usability,Simpl,SimpleEvent,14155,"n = """"); Save primitive as a C++ statement(s) on output stream out. TTreePerfStats(). Long64_t GetBytesRead() const; {return fBytesRead;}. Long64_t GetBytesReadExtra() const; {return fBytesReadExtra;}. Double_t GetCpuTime() const; {return fCpuTime;}. Double_t GetDiskTime() const; {return fDiskTime;}. TGraphErrors * GetGraphIO(); {return fGraphIO;}. TGraphErrors * GetGraphTime(); {return fGraphTime;}. const char * GetHostInfo() const; {return fHostInfo.Data();}. const char * GetName() const; {return fName.Data();}. Int_t GetNleaves() const; {return fNleaves;}. Long64_t GetNumEvents() const; {return 0;}. TPaveText * GetPave(); {return fPave;}. Int_t GetReadaheadSize() const; {return fReadaheadSize;}. Int_t GetReadCalls() const; {return fReadCalls;}. Double_t GetRealTime() const; {return fRealTime;}. TStopwatch * GetStopwatch() const; {return fWatch;}. Int_t GetTreeCacheSize() const; {return fTreeCacheSize;}. Double_t GetUnzipTime() const; {return fUnzipTime; }. void SimpleEvent(TVirtualPerfStats::EEventType ); {}. void PacketEvent(const char* , const char* , const char* , Long64_t , Double_t , Double_t , Double_t , Long64_t ); {}. void FileOpenEvent(TFile* , const char* , Double_t ); {}. void RateEvent(Double_t , Double_t , Long64_t , Long64_t ); {}. void SetBytesRead(Long64_t nbytes); {fBytesRead = nbytes;}. void SetBytesReadExtra(Long64_t nbytes); {fBytesReadExtra = nbytes;}. void SetCompress(Double_t cx); {fCompress = cx;}. void SetDiskTime(Double_t t); {fDiskTime = t;}. void SetNumEvents(Long64_t ); {}. void SetCpuTime(Double_t cptime); {fCpuTime = cptime;}. void SetGraphIO(TGraphErrors* gr); {fGraphIO = gr;}. void SetGraphTime(TGraphErrors* gr); {fGraphTime = gr;}. void SetHostInfo(const char* info); {fHostInfo = info;}. void SetName(const char* name); {fName = name;}. void SetNleaves(Int_t nleaves); {fNleaves = nleaves;}. void SetReadaheadSize(Int_t nbytes); {fReadaheadSize = nbytes;}. void SetReadCalls(Int_t ncalls); {fReadCalls = ncalls;}. void SetRealNorm(Dou",MatchSource.WIKI,root/html604/TTreePerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePerfStats.html
https://root.cern/root/html604/TTreePlayer.html:1781,Availability,Error,Error,1781,"nst char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:1910,Availability,error,error,1910,"me = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; vi",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:1994,Availability,error,error,1994,"dTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); static TVirtualTreePlayer*TVirtualTreePlayer::GetCurrentPlayer(); virtual Int_tGetDimension() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntries(const char* selection); virtual Long64_tGetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; virtual TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::G",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:12851,Availability,error,error,12851,"olean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the n",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:13180,Availability,error,error,13180," are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documentation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEn",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:13929,Availability,error,errors,13929,"ation of TTree::Draw for the complete details. Int_t Fit(const char* formula, const char* varexp, const char* selection, Option_t* option, Option_t* goption, Long64_t nentries, Long64_t firstentry); Fit a projected item(s) from a Tree.; Returns -1 in case of error or number of selected events in case of success. The formula is a TF1 expression. See TTree::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; tree.Fit(""pol4"",""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null if the fit is OK). Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesToProcess(Long64_t firstentry, Long64_t nentries) const; return the number of entries to be processed; this function checks that nentries is not bigger than the number; of entries in the Tree or in the associated TEventlist. const char * GetNameByIndex(TString& varexp, Int_t* index, Int_t colindex); -*-*-*Return name corresponding to colindex in varexp; *-* ===============================================. varexp is a string of names separated by :; index is an array with pointers to the start of name[i] in varexp. Int_t MakeClass(const char* classname, Option_t* option);",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18808,Availability,avail,available,18808,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19547,Availability,avail,available,19547,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22318,Availability,avail,available,22318,"ify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstent",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:23446,Availability,error,error,23446,"d in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically l",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:25842,Availability,error,error,25842,"ll this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Long64_t Process(TSelector* selector, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the code in the specified selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:29834,Availability,error,error,29834,"f format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better E",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30870,Availability,Error,Errors,30870,"r 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to ha",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32422,Availability,error,error,32422,"unc->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t Ge",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:9672,Deployability,update,updated,9672,"tatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:9687,Deployability,Update,UpdateFormulaLeaves,9687,"tatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18954,Deployability,update,updated,18954,"tong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32615,Deployability,Update,UpdateFormulaLeaves,32615,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32783,Deployability,update,update,32783,"effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See TSelectorDraw::GetVar. {return fSelector->GetVar(i);}. TTreeFormula * GetVar1() const; See TSelectorDraw::GetVar. {return",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19668,Energy Efficiency,efficient,efficient,19668,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19795,Energy Efficiency,efficient,efficient,19795,"). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fpri",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:1465,Integrability,wrap,wrapperPrefix,1465," virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11488,Integrability,wrap,wrapperPrefix,11488,"0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20420,Integrability,wrap,wrapper,20420,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22211,Integrability,interface,interface,22211,"void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for e",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22600,Integrability,Interface,Interface,22600,"exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27717,Integrability,synchroniz,synchronized,27717,"inters in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:28203,Integrability,synchroniz,synchronized,28203,"hange the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for all the column; If this options is not specified, the default column size is 9; precision=pp; Where 'pp' will be used as the default 'precision' for the; printing format.; col=xxx; Where 'xxx' is colon (:) delimited list of printing format for; each column. The format string should follow the printf format; specification. The value given will be prefixed by % and, if no; conversion specifier is given, will be suffixed by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:3915,Modifiability,Inherit,InheritsFrom,3915,"ar*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetScanFileName() const; virtual TTreeFormula*GetSelect() const; virtual Long64_tGetSelectedRows() const; TSelector*GetSelector() const; TSelector*GetSelectorFromFile() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_t*GetV1() const; virtual Double_t*GetV2() const; virtual Double_t*GetV3() const; virtual Double_t*GetV4() const; virtual Double_t*GetVal(Int_t i) const; virtual TTreeFormula*GetVar(Int_t i) const; virtual TTreeFormula*GetVar1() const; virtual TTreeFormula*GetVar2() const; virtual TTreeFormula*GetVar3() const; virtual TTreeFormula*GetVar4() const; virtual Double_t*GetW() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeClass(const char* classname, Option_t* option); virtual Int_tMakeCode(const char* filename); virtual Int_tMakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* v",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:3981,Modifiability,Inherit,InheritsFrom,3981,"TObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetScanFileName() const; virtual TTreeFormula*GetSelect() const; virtual Long64_tGetSelectedRows() const; TSelector*GetSelector() const; TSelector*GetSelectorFromFile() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_t*GetV1() const; virtual Double_t*GetV2() const; virtual Double_t*GetV3() const; virtual Double_t*GetV4() const; virtual Double_t*GetVal(Int_t i) const; virtual TTreeFormula*GetVar(Int_t i) const; virtual TTreeFormula*GetVar1() const; virtual TTreeFormula*GetVar2() const; virtual TTreeFormula*GetVar3() const; virtual TTreeFormula*GetVar4() const; virtual Double_t*GetW() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeClass(const char* classname, Option_t* option); virtual Int_tMakeCode(const char* filename); virtual Int_tMakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operat",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:9769,Modifiability,Inherit,Inheritance,9769,"t::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied tre",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:9782,Modifiability,Inherit,Inherited,9782,"t::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfDimensionDimension of the current expression; TList*fFormulaList! Pointer to a list of coordinated list TTreeFormula (used by Scan and Query); TH1*fHistogram! Pointer to histogram used for the projection; TList*fInput! input list to the selector; const char*fScanFileNameName of the file where Scan is redirected; Bool_tfScanRedirectSwitch to redirect TTree::Scan output to a file; Long64_tfSelectedRowsNumber of selected entries; TSelectorDraw*fSelector! Pointer to current selector; TClass*fSelectorClass! Pointer to the actual class of the TSelectorFromFile; TSelector*fSelectorFromFile! Pointer to a user defined selector created by this TTreePlayer object; TSelector*fSelectorUpdate! Set to the selector address when it's entry list needs to be updated by the UpdateFormulaLeaves function; TTree*fTree! Pointer to current Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreePlayer(); Default Tree constructor*-*-*-; *-* ========================. ~TTreePlayer(); Tree destructor*-*-*-*-; *-* =================. TVirtualIndex * BuildIndex(const TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied tre",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11962,Modifiability,variab,variables,11962,"d tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If the branch name can not be used a proper C++ symbol name,; it will be modified as follow:; - white spaces are removed; - if the leading character is not a letter, an underscore is inserted; - < and > are replace by underscores; - * is replaced by st; - & is replaced by rf. If a cutfilename is specified, for each entry, we execute; if (cutfilename()) htemp->Fill(macrofilename());; If no cutfilename is specified, for each entry we execute; htemp(macrofilename());. The default for the histogram are the same as for; TTreePlayer::DrawSelect. Long64_t DrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for specified entries that matches the selection.; Returns -1 in case of error or number of selected events in case of succss. See the documenta",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:16652,Modifiability,variab,variables,16652,"f(""myfile.root"");); - T->MakeClass(""MyClass"");; where T is the name of the Tree in file myfile.root; and MyClass.h, MyClass.C the name of the files created by this function.; In a ROOT session, you can do:; root> .L MyClass.C; root> MyClass t; root> t.GetEntry(12); // Fill t data members with entry number 12; root> t.Show(); // Show values of entry 12; root> t.Show(16); // Read and show values of entry 16; root> t.Loop(); // Loop on all entries. NOTE: Do not use the code generated for one Tree in case of a TChain.; Maximum dimensions calculated on the basis of one TTree only; might be too small when processing all the TTrees in one TChain.; Instead of myTree.MakeClass(.., use myChain.MakeClass(.. Int_t MakeCode(const char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class ge",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19566,Modifiability,variab,variables,19566,"vior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit cal",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19640,Modifiability,variab,variable,19640,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20382,Modifiability,variab,variable,20382,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20802,Modifiability,variab,variable,20802,">10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessibl",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21784,Modifiability,variab,variable,21784,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22714,Modifiability,variab,variables,22714,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:22802,Modifiability,variab,variables,22802,"loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a lo",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:29994,Modifiability,variab,variable,29994,"d by the letter g.; before being passed to fprintf. If no format is specified for a; column, the default is used (aka ${colsize}.${precision}g ); For example:; tree->Scan(""a:b:c"","""",""colsize=30 precision=3 col=::20.10:#x:5ld"");; Will print 3 columns, the first 2 columns will be 30 characters long,; the third columns will be 20 characters long. The printing format used; for the columns (assuming they are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitt",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30435,Modifiability,variab,variable,30435,"hey are numbers) will be respectively:; %30.3g %30.3g %20.10g %#x %5ld. TSQLResult * Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and return TSQLResult object containing entries passing; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30611,Modifiability,variab,variable,30611,"; selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns. Otherwise a columns selection can; be made using ""var1:var2:var3"". In case of error 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the fun",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:31857,Modifiability,variab,variable,31857,"Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TT",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11080,Performance,Load,Load,11080," for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeProxy (see MakeProxy); and including the files in the proper location. If th",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18618,Performance,load,loading,18618,"od; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19683,Performance,cache,cache,19683,"e the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20032,Performance,load,load,20032," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21732,Performance,load,loaded,21732,"dic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrinci",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21876,Performance,load,loaded,21876,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:23527,Performance,load,loaded,23527,"nterface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". See TTreePlayer::DrawSelect for explanation of the other parameters. Long64_t Process(const char* filename, Option_t* option, Long64_t nentries, Long64_t firstentry); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24360,Performance,load,loaded,24360,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24455,Performance,load,loaded,24455,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:24566,Performance,load,loaded,24566,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:30855,Performance,Perform,Perform,30855,"r 0 is returned otherwise; a TSQLResult object which must be deleted by the user. void SetEstimate(Long64_t n); -*-*-*-*-*Set number of entries to estimate variable limits; *-* ================================================. void StartViewer(Int_t ww, Int_t wh); Start the TTreeViewer on this TTree*-; *-* ===================================. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t UnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Unbinned fit of one or more variable(s) from a Tree; *-* ===================================================. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results; = ""D"" Draw the projected histogram with the fitted function; normalized to the number of selected rows; and multiplied by the bin width. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to ha",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32673,Performance,Load,LoadTree,32673,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:32701,Performance,load,loaded,32701,"ust be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UpdateFormulaLeaves(); this function is called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. TTreePlayer(const TTreePlayer& ). TTreePlayer& operator=(const TTreePlayer& ). void TakeAction(Int_t nfill, Int_t& npoints, Int_t& action, TObject* obj, Option_t* option). void TakeEstimate(Int_t nfill, Int_t& npoints, Int_t action, TObject* obj, Option_t* option). Int_t GetDimension() const; {return fDimension;}. TH1 * GetHistogram() const; {return fHistogram;}. Int_t GetNfill() const; {return fSelector->GetNfill();}. const char * GetScanFileName() const; {return fScanFileName;}. TTreeFormula * GetSelect() const; {return fSelector->GetSelect();}. Long64_t GetSelectedRows() const; {return fSelectedRows;}. TSelector * GetSelector() const; {return fSelector;}. TSelector * GetSelectorFromFile() const; See TSelectorDraw::GetVar. {return fSelectorFromFile;}. TTreeFormula * GetVar(Int_t i) const; See ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:389,Security,access,access,389,". TTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreePlayer. class TTreePlayer: public TVirtualTreePlayer. TTreePlayer. Implement some of the functionality of the class TTree requiring access to; extra libraries (Histogram, display, etc). Function Members (Methods); public:. virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:3805,Security,Hash,Hash,3805,"bject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetScanFileName() const; virtual TTreeFormula*GetSelect() const; virtual Long64_tGetSelectedRows() const; TSelector*GetSelector() const; TSelector*GetSelectorFromFile() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Double_t*GetV1() const; virtual Double_t*GetV2() const; virtual Double_t*GetV3() const; virtual Double_t*GetV4() const; virtual Double_t*GetVal(Int_t i) const; virtual TTreeFormula*GetVar(Int_t i) const; virtual TTreeFormula*GetVar1() const; virtual TTreeFormula*GetVar2() const; virtual TTreeFormula*GetVar3() const; virtual TTreeFormula*GetVar4() const; virtual Double_t*GetW() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual Int_tMakeClass(const char* classname, Option_t* option); virtual Int_tMakeCode(const char* filename); virtual Int_tMakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:17350,Security,access,access,17350," char* filename); Generate skeleton function for this Tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name; - Connection of the Tree file; - Declaration of Tree variables; - Setting of branches addresses; - A skeleton for the entry loop. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""anal.C"");; where T is the name of the Tree in file myfile.root; and anal.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy.; TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'm",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:18483,Security,access,access,18483," in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'.; If the fileprefix contains a period, the right side of the period; will be used as the extension (instead of 'h') and the left side; will be used as the classname. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source file which will be included in by the generated skeletong.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' class that are not split. 'unrolling' a class; will allow direct access to its data members a class (this; emulates the behavior of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). For example with Event.root, if; Double_t somepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19852,Security,Access,Access,19852,"omepx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somepx will be updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i])",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:19948,Security,access,access,19948," value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20253,Security,access,access,20253,"ame name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:20408,Security,access,access,20408,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21765,Security,access,accessible,21765,"lue or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal objec",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:21962,Security,access,access,21962,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. TPrincipal * Principal(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print r",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:7007,Testability,Test,TestBit,7007," Long64_t nentries, Long64_t firstentry); virtual TSQLResult*Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Long64_tScan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Bool_tScanRedirected(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEstimate(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualTreePlayer::SetPlayer(const char* player); voidSetScanFileName(const char* name); voidSetScanRedirect(Bool_t on = kFALSE); virtual voidSetTree(TTree* t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartViewer(Int_t ww, Int_t wh); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TVirtualTreePlayer*TVirtualTreePlayer::TreePlayer(TTree* obj); TTreePlayer(); virtual Int_tUnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:7046,Testability,Test,TestBits,7046," Long64_t nentries, Long64_t firstentry); virtual TSQLResult*Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Long64_tScan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Bool_tScanRedirected(); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEstimate(Long64_t n); static voidTObject::SetObjectStat(Bool_t stat); static voidTVirtualTreePlayer::SetPlayer(const char* player); voidSetScanFileName(const char* name); voidSetScanRedirect(Bool_t on = kFALSE); virtual voidSetTree(TTree* t); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStartViewer(Int_t ww, Int_t wh); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TVirtualTreePlayer*TVirtualTreePlayer::TreePlayer(TTree* obj); TTreePlayer(); virtual Int_tUnbinnedFit(const char* formula, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidUpdateFormulaLeaves(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:11059,Testability,test,test,11059,"nst TTree* T, const char* majorname, const char* minorname); Build the index for the tree (see TTree::BuildIndex). TTree * CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); copy a Tree with selection; make a clone of this Tree header.; then copy the selected entries. selection is a standard selection expression (see TTreePlayer::Draw); option is reserved for possible future use; nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). IMPORTANT: The copied tree stays connected with this tree until this tree; is deleted. In particular, any changes in branch addresses; in this tree are forwarded to the clone trees. Any changes; made to the branch addresses of the copied trees are over-ridden; anytime this tree changes its branch addresses.; Once this tree is deleted, all the addresses of the copied tree; are reset to their default values. The following example illustrates how to copy some events from the Tree; generated in $ROOTSYS/test/Event. gSystem->Load(""libEvent"");; TFile f(""Event.root"");; TTree *T = (TTree*)f.Get(""T"");; Event *event = new Event();; T->SetBranchAddress(""event"",&event);; TFile f2(""Event2.root"",""recreate"");; TTree *T2 = T->CopyTree(""fNtrack<595"");; T2->Write();. void DeleteSelectorFromFile(); Delete any selector created by this object.; The selector has been created using TSelector::GetSelector(file). Long64_t DrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw the result of a C++ script. The macrofilename and optionally cutfilename are assumed to contain; at least a method with the same name as the file. The method; should return a value that can be automatically cast to; respectively a double and a boolean. Both methods will be executed in a context such that the; branch names can be used as C++ variables. This is; accomplished by generating a TTreeP",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27539,Testability,log,log,27539,"st, starting at firstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the ",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:27568,Testability,log,log,27568,"irstentry, otherwise the loop is on the; specified Tree entries. void RecursiveRemove(TObject* obj); cleanup pointers in the player pointing to obj. Long64_t Scan(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Loop on Tree and print entries passing selection. If varexp is 0 (or """"); then print only first 8 columns. If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; The function returns the number of entries passing the selection. By default 50 rows are shown and you are asked for <CR>; to see the next 50 rows.; You can change the default number of rows to be shown before <CR>; via mytree->SetScanField(maxrows) where maxrows is 50 by default.; if maxrows is set to 0 all rows of the Tree are shown.; This option is interesting when dumping the contents of a Tree to; an ascii file, eg from the command line; tree->SetScanField(0);; tree->Scan(""*""); >tree.log; will create a file tree.log. Arrays (within an entry) are printed in their linear forms.; If several arrays with multiple dimensions are printed together,; they will NOT be synchronized. For example print; arr1[4][2] and arr2[2][3] will results in a printing similar to:. * Row * Instance * arr1 * arr2 *. * x * 0 * arr1[0][0]* arr2[0][0]*; * x * 1 * arr1[0][1]* arr2[0][1]*; * x * 2 * arr1[1][0]* arr2[0][2]*; * x * 3 * arr1[1][1]* arr2[1][0]*; * x * 4 * arr1[2][0]* arr2[1][1]*; * x * 5 * arr1[2][1]* arr2[1][2]*; * x * 6 * arr1[3][0]* *; * x * 7 * arr1[3][1]* *. However, if there is a selection criterion which is an array, then; all the formulas will be synchronized with the selection criterion; (see TTreePlayer::DrawSelect for more information). The options string can contains the following parameters:; lenmax=dd; Where 'dd' is the maximum number of elements per array that should; be printed. If 'dd' is 0, all elements are printed (this is the; default); colsize=ss; Where 'ss' will be used as the default size for",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreePlayer.html:842,Usability,Clear,Clear,842," virtual~TTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error =",MatchSource.WIKI,root/html604/TTreePlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreePlayer.html
https://root.cern/root/html604/TTreeReader.html:349,Availability,robust,robust,349,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1924,Availability,error,error,1924," #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single floa",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:2369,Availability,Error,Error,2369,"reeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:2606,Availability,error,errors,2606,"ose as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:;",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4094,Availability,Error,Error,4094,"triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4184,Availability,Error,Error,4184,"triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4351,Availability,Error,Error,4351,"  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4440,Availability,Error,Error,4440,"  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4567,Availability,Error,Error,4567,"  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtu",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4684,Availability,Error,Error,4684,"nd fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voi",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:6425,Availability,Error,Error,6425,,MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:6554,Availability,error,error,6554,"l~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:6638,Availability,error,error,6638,"TObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeReader::Iterator_tend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:13527,Availability,Error,Error,13527,"TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsChain); }. Bool_t Next(); { return SetEntry(GetCurrentEntry() + 1) == kEntryValid; }. EEntryStatus SetEntry(Long64_t entry); { return SetEntryBase(entry, kFALSE); }. EEntryStatus SetLocalEntry(Long64_t entry); { return SetEntryBase(entry, kTRUE); }. EEntryStatus GetEntryStatus() const; { return fEntryStatus; }. TTree* GetTree() const; { return fTree; }. Long64_t GetEntries(Bool_t force) const; { return fTree ? (force ? fTree->GetEntries() : fTree->GetEntriesFast() ) : -1; }. Iterator_t begin(); Return an iterator to the 0th TTree entry. Iterator_t end() const; { return Iterator_t(); }. ROOT::TNamedBranchProxy* FindProxy(const char* branchname) const. TCollection* GetProxies(); { return &fProxies; }. EEntryStatus SetEntryBase(Long64_t entry, Bool_t local). » Author: Axel Naumann, 2010-08-02 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last genera",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:13075,Deployability,update,update,13075,", owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ←; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsChain); }. Bool_t Next(); { return SetEntry(GetCurrentEntry() + 1) == kEntryValid; }. EEntryStatus SetEntry(Long64_t entry); { return SetEntryBase(entry, kFALSE); }. EEntryStatus SetLocalEntry(Long64_t entry); { return SetEntryBase(entry, kTRUE); }. EEntryStatus GetEntryStatus() const; { return fEntryStatus; }. TTree* GetTree() const; { return fTree; }. Long64_t GetEntries(Bool_t force) const; { return fTree ? (force ? fTree->GetEntries() : fTree->GetEntr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:711,Energy Efficiency,power,power,711,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:365,Integrability,interface,interface,365,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:117,Modifiability,inherit,inheritance,117,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:5100,Modifiability,variab,variable,5100,") {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Cop",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:7663,Modifiability,Inherit,InheritsFrom,7663,"::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsChain() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tNext(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz);",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:7729,Modifiability,Inherit,InheritsFrom,7729,"ct::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsChain() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tNext(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeReader&op",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:12441,Modifiability,Inherit,Inheritance,12441,"tsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. ROOT::TBranchProxyDirector*fDirectorproxying director, owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ←; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:3922,Performance,Load,Loaded,3922,"reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muo",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4121,Performance,load,loaded,4121,"triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:480,Security,access,access,480,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1473,Security,access,access,1473,"rValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value-",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1585,Security,access,access,1585,"Reader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:1745,Security,access,access,1745,"rams a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray obj",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:2736,Security,access,access,2736,"as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4466,Security,access,access,4466,"  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4784,Security,Access,Access,4784,"nd fill a histogram.;  ; TH1* hist = new TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);;  ; while (reader.Next()) {;  ; if (reader.GetEntryStatus() == kEntryValid) {; std::cout << ""Loaded entry "" << reader.GetCurrentEntry() << '\n';; } else {; switch (reader.GetEntryStatus()) {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voi",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:4953,Security,Access,Access,4953,") {; kEntryValid:; // Handled above.; break;; kEntryNotLoaded:; std::cerr << ""Error: TTreeReader has not loaded any data yet!\n"";; break;; kEntryNoTree:; std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Cop",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:5183,Security,Access,Access,5183,"std::cerr << ""Error: TTreeReader cannot find a tree names \""MyTree\""!\n"";; break;; kEntryNotFound:; // Can't really happen as TTreeReader::Next() knows when to stop.; std::cerr << ""Error: The entry number doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:5335,Security,Access,Access,5335,"r doe not exist\n"";; break;; kEntryChainSetupError:; std::cerr << ""Error: TTreeReader cannot access a chain element, e.g. file without the tree\n"";; break;; kEntryChainFileError:; std::cerr << ""Error: TTreeReader cannot open a chain element, e.g. missing file\n"";; break;; kEntryDictionaryError:; std::cerr << ""Error: TTreeReader cannot find the dictionary for some data\n"";; break;; }; return false;; };  ; // Access the TriggerInfo object as if it's a pointer.; if (!triggerInfo->hasMuonL1()); continue;;  ; // Ditto for the vector<Muon>.; if (!muons->size()); continue;;  ; // Access the jetPt as an array, whether the TTree stores this as; // a std::vector, std::list, TClonesArray or Jet* C-style array, with; // fixed or variable array size.; if (jetPt.GetSize() < 2 || jetPt[0] < 100); continue;;  ; // Access the array of taus.; if (!taus.IsEmpty()) {; float currentWeight = *weight;; for (int iTau = 0, nTau = taus.GetSize(); iTau < nTau; ++iTau) {; // Access a float value - need to dereference as TTreeReaderValue; // behaves like an iterator; hist->Fill(taus[iTau].eta(), currentWeight);; }; }; } // TTree entry / event loop; }. Function Members (Methods); public:. virtual~TTreeReader(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTreeReader::Iterator_tbegin(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTreeR",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:7553,Security,Hash,Hash,7553,"rror = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetCurrentEntry() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t force) const; TTreeReader::EEntryStatusGetEntryStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; TTree*GetTree() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsChain() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tNext(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:12536,Security,Access,Access,12536,"; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. ROOT::TBranchProxyDirector*fDirectorproxying director, owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ←; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:12619,Security,Access,Access,12619,"; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. ROOT::TBranchProxyDirector*fDirectorproxying director, owned; TDirectory*fDirectorydirectory (or current file for chains); TTreeReader::EEntryStatusfEntryStatusstatus of most recent read request; THashTablefProxiesattached ROOT::TNamedBranchProxies; owned; TTree*fTreetree that's read; deque<ROOT::TTreeReaderValueBase*>fValuesreaders that use our director; static TTreeReader::EPropertyBitskBitIsChain. Class Charts. Inheritance Chart:. TObject. ←; TTreeReader. Function documentation; TTreeReader(TTree* tree); Access data from tree. TTreeReader(const char* keyname, TDirectory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsCh",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:9927,Testability,Test,TestBit,9927,"r delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeReader&operator=(const TTreeReader&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetChain(const char*, TFileCollection*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TTreeReader::EEntryStatusSetEntry(Long64_t entry); TTreeReader::EEntryStatusSetLocalEntry(Long64_t entry); static voidTObject::SetObjectStat(Bool_t stat); voidSetTree(TTree* tree); voidSetTree(const char*, TDirectory*); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeReader(); TTreeReader(TTree* tree); TTreeReader(const TTreeReader&); TTreeReader(const char* keyname, TDirectory* dir = __null); TTreeReader(const char*, TFileCollection*); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:9966,Testability,Test,TestBits,9966,"r delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeReader&operator=(const TTreeReader&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetChain(const char*, TFileCollection*); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TTreeReader::EEntryStatusSetEntry(Long64_t entry); TTreeReader::EEntryStatusSetLocalEntry(Long64_t entry); static voidTObject::SetObjectStat(Bool_t stat); voidSetTree(TTree* tree); voidSetTree(const char*, TDirectory*); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeReader(); TTreeReader(TTree* tree); TTreeReader(const TTreeReader&); TTreeReader(const char* keyname, TDirectory* dir = __null); TTreeReader(const char*, TFileCollection*); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:13603,Testability,Test,TestBit,13603,"tory* dir = __null); Access data from the tree called keyname in the directory (e.g. TFile); dir, or the current directory if dir is NULL. If keyname cannot be; found, or if it is not a TTree, IsZombie() will return true. ~TTreeReader(); Tell all value readers that the tree reader does not exist anymore. void Initialize(); Initialization of the director. Long64_t GetCurrentEntry() const; Returns the index of the current entry being read. void SetTree(TTree* tree); Set (or update) the which tree to reader from. tree can be; a TTree or a TChain. void RegisterValueReader(ROOT::TTreeReaderValueBase* reader); Add a value reader for this tree. void DeregisterValueReader(ROOT::TTreeReaderValueBase* reader); Remove a value reader for this tree. TTreeReader(); {}. TTreeReader(TTree* tree). TTreeReader(const char* keyname, TDirectory* dir = __null). void SetTree(TTree* tree). void SetChain(const char* , TFileCollection* ); { Error(""SetChain()"", ""Not Implemented!"");}. Bool_t IsChain() const; { return TestBit(kBitIsChain); }. Bool_t Next(); { return SetEntry(GetCurrentEntry() + 1) == kEntryValid; }. EEntryStatus SetEntry(Long64_t entry); { return SetEntryBase(entry, kFALSE); }. EEntryStatus SetLocalEntry(Long64_t entry); { return SetEntryBase(entry, kTRUE); }. EEntryStatus GetEntryStatus() const; { return fEntryStatus; }. TTree* GetTree() const; { return fTree; }. Long64_t GetEntries(Bool_t force) const; { return fTree ? (force ? fTree->GetEntries() : fTree->GetEntriesFast() ) : -1; }. Iterator_t begin(); Return an iterator to the 0th TTree entry. Iterator_t end() const; { return Iterator_t(); }. ROOT::TNamedBranchProxy* FindProxy(const char* branchname) const. TCollection* GetProxies(); { return &fProxies; }. EEntryStatus SetEntryBase(Long64_t entry, Bool_t local). » Author: Axel Naumann, 2010-08-02 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comm",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:341,Usability,simpl,simple,341,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:721,Usability,simpl,simpler,721,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:859,Usability,simpl,simple,859,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeReader.html:5849,Usability,Clear,Clear,5849,,MatchSource.WIKI,root/html604/TTreeReader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeReader.html
https://root.cern/root/html604/TTreeResult.html:1423,Availability,Error,Error,1423," virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:1552,Availability,error,error,1552," virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:1636,Availability,error,error,1636,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) cons",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:349,Integrability,interface,interface,349,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:398,Integrability,interface,interface,398,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:7212,Integrability,interface,interface,7212,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ←; TSQLResult. ←; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}. » Author: Fons Rademakers 30/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:7378,Integrability,interface,interface,7378,"ic TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ←; TSQLResult. ←; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. TTreeResult(). TObjArray * GetRows() const; {return fResult;}. » Author: Fons Rademakers 30/11/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:117,Modifiability,inherit,inheritance,117,". TTreeResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeResult. class TTreeResult: public TSQLResult. TTreeResult. Class defining interface to a TTree query result with the same; interface as for SQL databases. A TTreeResult is returned by; TTree::Query() (actually TTreePlayer::Query()). Related classes are TTreeRow. Function Members (Methods); public:. virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:2665,Modifiability,Inherit,InheritsFrom,2665,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:2731,Modifiability,Inherit,InheritsFrom,2731,"Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeResult&operator=(const",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:6416,Modifiability,Inherit,Inheritance,6416,"t::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Int_tfColumnCountnumber of columns in result; TString*fFields[fColumnCount] array containing field strings; Int_tfNextRowrow iterator; TObjArray*fResultquery result (TTreeRow objects). Class Charts. Inheritance Chart:. TObject. ←; TSQLResult. ←; TTreeResult. Function documentation; TTreeResult(); Create a query result object. TTreeResult(Int_t nfields); Create a query result object. ~TTreeResult(); Cleanup result object. void Close(Option_t* option = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user and becomes invalid when the result set is; closed or deleted. void AddField(Int_t field, const char* fieldname); Add field name to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. void AddRow(TSQLRow* row); Adopt a row to result set. This is an internal method that is not; exported via the abstract interface and that should not be user called. T",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:2555,Security,Hash,Hash,2555," = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; TObjArray*GetRows() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:4699,Testability,Test,TestBit,4699,"voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeResult&operator=(const TTreeResult&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeResult(); TTreeResult(Int_t nfields); TTreeResult(const TTreeResult&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:4738,Testability,Test,TestBits,4738,"voidTObject::MayNotUse(const char* method) const; virtual TSQLRow*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeResult&operator=(const TTreeResult&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeResult(); TTreeResult(Int_t nfields); TTreeResult(const TTreeResult&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeResult.html:841,Usability,Clear,Clear,841," virtual~TTreeResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root/html604/TTreeResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeResult.html
https://root.cern/root/html604/TTreeRow.html:1352,Availability,Error,Error,1352," virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:1481,Availability,error,error,1481," virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:1565,Availability,error,error,1565,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:334,Integrability,interface,interface,334,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:114,Modifiability,inherit,inheritance,114,". TTreeRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeRow. class TTreeRow: public TSQLRow. TTreeRow. Class defining interface to a row of a TTree query result.; Objects of this class are created by TTreeResult methods. Related classes are TTreeResult. Function Members (Methods); public:. virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:2531,Modifiability,Inherit,InheritsFrom,2531,", TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:2597,Modifiability,Inherit,InheritsFrom,2597,"teEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); const char*TSQLRow::operator[](Int_t field); virtua",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:6308,Modifiability,Inherit,Inheritance,6308,"Row&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfColumnCountnumber of columns in row; Int_t*fFields[fColumnCount] index in fRow of the end of each field; TTreeRow*fOriginal! pointer to original row; char*fRowstring with all the fColumnCount fields. Class Charts. Inheritance Chart:. TObject. ←; TSQLRow. ←; TTreeRow. Function documentation; TTreeRow(); Single row of a query result. TTreeRow(Int_t nfields); Single row of a query result. TTreeRow(Int_t nfields, const Int_t* fields, const char* row); Single row of a query result. TTreeRow(TSQLRow* original); This is a shallow copy of a real row, i.e. it only contains; a pointer to the original. ~TTreeRow(); Destroy row object. void Close(Option_t* option = """"); Close row. Bool_t IsValid(Int_t field); Check if row is open and field index within range. ULong_t GetFieldLength(Int_t field); Get length in bytes of specified field. const char * GetField(Int_t field); Get specified field from row (0 <= field < GetFieldCount()). void SetRow(const Int_t* fields, const char* row); The field and row information. void Streamer(TBuffer& ); Stream an object of class TTreeRow. TTreeRow(TSQLRow* original). TTreeRow & operator=(const TTreeRow& ). » Author: Fons Rademakers 30/11/99 » Copyright (C) 1995-2000, Rene Brun and Fo",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:2421,Security,Hash,Hash,2421,"t::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:4593,Testability,Test,TestBit,4593,"rtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); const char*TSQLRow::operator[](Int_t field); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetRow(const Int_t* fields, const char* row); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeRow(); TTreeRow(Int_t nfields); TTreeRow(Int_t nfields, const Int_t* fields, const char* row); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:4632,Testability,Test,TestBits,4632,"rtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); const char*TSQLRow::operator[](Int_t field); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); voidSetRow(const Int_t* fields, const char* row); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeRow(); TTreeRow(Int_t nfields); TTreeRow(Int_t nfields, const Int_t* fields, const char* row); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeRow.html:770,Usability,Clear,Clear,770," virtual~TTreeRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(",MatchSource.WIKI,root/html604/TTreeRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeRow.html
https://root.cern/root/html604/TTreeSQL.html:4133,Availability,Error,Error,4133,"ual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoF",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:4262,Availability,error,error,4262,"e_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:4346,Availability,error,error,4346,"); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual Int_tTTree::DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tTTree::GetBranchStatus(const char* branch",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:15698,Deployability,update,updateExisting,15698,"t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:30708,Deployability,update,updated,30708," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:25135,Energy Efficiency,allocate,allocated,25135,lones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; TStringfInsertQuery; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTr,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:29693,Integrability,rout,routine,29693,"(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. TBranch * Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); Create a branch. void CheckBasket(TBranch* tb); Check if the basket is properly setup. Bool_t CheckBranch(TBranch* tb); Check if the table has a column corresponding the branch; and that the resultset are properly setup. Bool_t CheckTable(const TString& table) const; Check the table exist in the database. TString ConvertTypeName(const TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the T",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:114,Modifiability,inherit,inheritance,114,". TTreeSQL. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeSQL. class TTreeSQL: public TTree. TTreeSQL. Implement TTree for a SQL backend. Function Members (Methods); public:. virtual~TTreeSQL(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tBranch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tBranch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*Branch(const char* name, void* address, const char* leaflist, Int_t bufsize); virtual TBranch*Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); vir",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:9800,Modifiability,Inherit,InheritsFrom,9800,"st; TBuffer*TTree::GetTransientBuffer(Int_t size); virtual TTree*TTree::GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tTTree::GetTreeNumber() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::M",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:9866,Modifiability,Inherit,InheritsFrom,9866,"Tree::GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tTTree::GetTreeNumber() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(cons",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:27561,Modifiability,Inherit,Inheritance,27561,"ee::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree; static TTree::ELockStatusBitsTTree::kFindBranch; static TTree::ELockStatusBitsTTree::kFindLeaf; static TTree::ELockStatusBitsTTree::kGetAlias; static TTree::ELockStatusBitsTTree::kGetBranch; static TTree::ELockStatusBitsTTree::kGetEntry; static TTree::ELockStatusBitsTTree::kGetEntryWithIndex; static TTree::ELockStatusBitsTTree::kGetFriend; static TTree::ELockStatusBitsTTree::kGetFriendAlias; static TTree::ELockStatusBitsTTree::kGetLeaf; static TTree::ELockStatusBitsTTree::kLoadTree; static TTree::ELockStatusBitsTTree::kPrint; static TTree::ELockStatusBitsTTree::kRemoveFriend; static TTree::ELockStatusBitsTTree::kSetBranchStatus. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAttMarker. ←; TTree. ←; TTreeSQL. Function documentation; TTreeSQL(TSQLServer* server, TString DB, const TString& table); Constructor with an explicit TSQLServer. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Not implemented yet. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Not implemented yet. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Not implemented yet. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Not implemented yet. TBranch* BranchOld(const char* name, const ch",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:10281,Performance,Load,LoadBaskets,10281,"ormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* re",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:10392,Performance,Load,LoadTreeFriend,10392,":GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp);",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:11765,Performance,Optimiz,OptimizeBaskets,11765,"me) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_tTTree::MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); virtual Int_tTTree::MakeSelector(const char* selector = 0); voidTObject::MayNotUse(const char* method) const; Bool_tTTree::MemoryFull(Int_t nbytes); virtual Long64_tTTree::Merge(TCollection* list, Option_t* option = """"); virtual Long64_tTTree::Merge(TCollection* list, TFileMergeInfo* info); static TTree*TTree::MergeTrees(TList* list, Option_t* option = """"); virtual voidTAttLine::Modify(); virtual Bool_tTTree::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTreeSQL&operator=(const TTreeSQL&); TTreeSQL&operator=(TTreeSQL&&); virtual voidTTree::OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:15410,Performance,cache,cachesize,15410,"TTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = -30000000); virtual voidTTree::SetAutoSave(Long64_t autos = -300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual Int_tTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual Int_tTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 1000000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine:",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:21047,Performance,cache,cacheSize,21047," = 0) const. protected:. voidTTree::AddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*TTree::BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); voidCheckBasket(TBranch* tb); Bool_tCheckBranch(TBranch* tb); virtual Int_tTTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); Bool_tCheckTable(const TString& table) const; TStringConvertTypeName(const TString& typeName); virtual TBasket*CreateBasket(TBranch* br); virtual voidCreateBranch(const TString& branchName, const TString& typeName); TStringCreateBranches(TSQLResult* rs); Bool_tCreateTable(const TString& table); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTTree::GetCacheAutoSize(Bool_t withDefault = kFALSE) const; vector<Int_t>*GetColumnIndice(TBranch* branch); virtual TLeaf*TTree::GetLeafImpl(const char* branchname, const char* leafname); charTTree::GetNewlineValue(istream& inputStream); TTreeCache*TTree::GetReadCache(TFile* file, Bool_t create = kFALSE); voidTTree::ImportClusterRanges(TTree* fromtree); voidInit(); virtual voidTTree::KeepCircular(); voidTObject::MakeZombie(); voidTTree::MoveReadCache(TFile* src, TDirectory* dir); voidResetQuery(); Int_tTTree::SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tTTree::SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). Data Members; public:. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:23122,Performance,cache,cache,23122,ee::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; Bool_tfBranchChecked; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entri,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:23266,Performance,cache,cache,23266,ee::ESetBranchAddressStatusTTree::kNoCheck; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TTree::(anonymous)TTree::kSplitCollectionOfPointers; static TTree::ESetBranchAddressStatusTTree::kVoidPtr; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TList*TTree::fAliasesList of aliases for expressions based on the tree branches.; Long64_tTTree::fAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tTTree::fAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; Bool_tfBranchChecked; TBranchRef*TTree::fBranchRefBranch supporting the TRefTable (if any); TObjArrayTTree::fBranchesList of Branches; Bool_tTTree::fCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tTTree::fCacheSize! Maximum size of file buffers; Bool_tTTree::fCacheUserSet! true if the cache setting was explicitly given by user; Long64_tTTree::fChainOffset! Offset of 1st entry of this Tree in a TChain; TList*TTree::fClones! List of cloned trees which share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfCurrentEntry; TStringfDB; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entri,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:25620,Performance,load,loading,25620,Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; TStringfQuery; Long64_tTTree::fReadEntry! Number of the entry being processed; TSQLResult*fResult; TSQLRow*fRow; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TSQLServer*fServer; TStringfTable; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBr,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:30295,Performance,Load,Load,30295," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:30351,Performance,Load,LoadTree,30351," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:30399,Performance,load,load,30399," TString& typeName); Convert from ROOT typename to SQL typename. TBasket * CreateBasket(TBranch* br); Create a TBasketSQL. void CreateBranch(const TString& branchName, const TString& typeName); Create the column(s) in the database that correspond to the branch. TString CreateBranches(TSQLResult* rs); determine leaf description string. Bool_t CreateTable(const TString& table); Create the database table corresponding to this TTree. void Init(); Initializeation routine. Int_t Fill(); Copy the information from the user object to the TTree. std::vector<Int_t> * GetColumnIndice(TBranch* branch); Return a vector of columns index corresponding to the; current SQL table and the branch given as argument; Returns 0 if no columns indices is found; Otherwise returns a pointer to a vector to be deleted by the caller. Long64_t GetEntries() const; Get the number of rows in the database. Long64_t GetEntriesFast() const; Return the number of entries as of the last check.; Use GetEntries for a more accurate count. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Load the data for the entry from the database. Long64_t LoadTree(Long64_t entry); Setup the tree to the load the specified entry. Long64_t PrepEntry(Long64_t entry); Make sure the server and result set are setup for the requested entry. void Refresh(); Refresh contents of this Tree and its branches from the current; Tree status in the database; One can call this function in case the Tree on its file is being; updated by another process. void ResetQuery(); Reset the internal query. TTreeSQL(TSQLServer* server, TString DB, const TString& table). Long64_t GetEntries() const. TString GetTableName(); { return fTable; }. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:9634,Security,Hash,Hash,9634,"SelectedRows(); TStringGetTableName(); virtual Int_tTTree::GetTimerInterval() const; virtual const char*TNamed::GetTitle() const; virtual Long64_tTTree::GetTotBytes() const; TBuffer*TTree::GetTransientBuffer(Int_t size); virtual TTree*TTree::GetTree() const; virtual TVirtualIndex*TTree::GetTreeIndex() const; virtual Int_tTTree::GetTreeNumber() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tTTree::GetUpdate() const; virtual TList*TTree::GetUserInfo(); virtual Double_t*TTree::GetV1(); virtual Double_t*TTree::GetV2(); virtual Double_t*TTree::GetV3(); virtual Double_t*TTree::GetV4(); virtual Double_t*TTree::GetVal(Int_t i); TTreeFormula*TTree::GetVar(Int_t i); TTreeFormula*TTree::GetVar1(); TTreeFormula*TTree::GetVar2(); TTreeFormula*TTree::GetVar3(); TTreeFormula*TTree::GetVar4(); virtual Double_t*TTree::GetW(); virtual Double_tTTree::GetWeight() const; virtual Long64_tTTree::GetZipBytes() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTTree::IncrementTotalBuffers(Int_t nbytes); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTTree::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual Int_tTTree::LoadBaskets(Long64_t maxmemory = 2000000000); virtual Long64_tLoadTree(Long64_t entry); virtual Long64_tTTree::LoadTreeFriend(Long64_t entry, TTree* T); virtual voidTNamed::ls(Option_t* option = """") const; virtual Int_tTTree::MakeClass(const char* classname = 0, Option_t* option = """"); virtual Int_tTTree::MakeCode(const char* filename = 0); virtual Int_t",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:18445,Testability,Test,TestBit,18445,"ic voidTTree::SetMaxTreeSize(Long64_t maxsize = 1900000000); virtual voidTTree::SetMaxVirtualSize(Long64_t size = 0)MENU ; virtual voidTTree::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidTTree::SetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual Int_tTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeSQL(TTreeSQL&&); TTreeSQL(const TTreeSQL&); TTreeSQL(TSQLServer* server, TString DB, const TString& table); virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:18484,Testability,Test,TestBits,18484,"ic voidTTree::SetMaxTreeSize(Long64_t maxsize = 1900000000); virtual voidTTree::SetMaxVirtualSize(Long64_t size = 0)MENU ; virtual voidTTree::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTree::SetNotify(TObject* obj); virtual voidTTree::SetObject(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTTree::SetParallelUnzip(Bool_t opt = kTRUE, Float_t RelSize = -1); virtual voidTTree::SetPerfStats(TVirtualPerfStats* perf); virtual voidTTree::SetScanField(Int_t n = 50)MENU ; virtual voidTTree::SetTimerInterval(Int_t msec = 333); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTTree::SetTreeIndex(TVirtualIndex* index); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTTree::SetUpdate(Int_t freq = 0); virtual voidTTree::SetWeight(Double_t w = 1, Option_t* option = """"); virtual voidTTree::Show(Long64_t entry = -1, Int_t lenmax = 20); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidTTree::StartViewer()MENU ; virtual Int_tTTree::StopCacheLearningPhase(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTreeSQL(TTreeSQL&&); TTreeSQL(const TTreeSQL&); TTreeSQL(TSQLServer* server, TString DB, const TString& table); virtual Int_tTTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTTree::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTTree::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:2480,Usability,Clear,Clear,2480,"Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<const char>(const char* name, const char* classname, const char* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); TBranch*TTree::Branch<void>(const char* name, void* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """,MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeSQL.html:2804,Usability,undo,undo,2804,"000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") con",MatchSource.WIKI,root/html604/TTreeSQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeSQL.html
https://root.cern/root/html604/TTreeTableInterface.html:4183,Availability,avail,available,4183,"t nentries = 0, Long64_t firstentry = 0); TTreeTableInterface constructor. ~TTreeTableInterface(); TTreeTableInterface destructor. void SetVariablesExpression(const char* varexp); Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:772,Deployability,Update,Update,772,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:1027,Deployability,Update,Update,1027,"Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVir",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:4367,Deployability,Update,Update,4367,"Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:35:07 2015 » Last generated: 2015-06-02 16:35; This page has been automatically gener",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:4536,Deployability,Update,Update,4536,"xpression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:35:07 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:4675,Deployability,Update,Update,4675,"xpression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression at position,; TGTable->Update() is needed afterwards to apply the change to; the TGTable. void AddColumn(TTreeFormula* formula, UInt_t position); Add column with formula at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void RemoveColumn(UInt_t position); Remove column at position, TGTable->Update() is needed; afterwards to apply the change to the TGTable. void SetFormula(TTreeFormula* formula, UInt_t position); Set the TTreeFormula of position to formula. void SetEntryList(TEntryList* entrylist = 0); Set the currently active entrylist. TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). TEntryList * GetEntryList(); { return fEntries; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 16:35:07 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:415,Integrability,interface,interface,415,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:470,Integrability,interface,interface,470,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:907,Integrability,interface,interface,907,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:125,Modifiability,inherit,inheritance,125,". TTreeTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeTableInterface. class TTreeTableInterface: public TVirtualTableInterface. TTreeTableInterface. TTreeTableInterface is used to interface to data that is stored in a; TTree. When the interface is created, an expression can be; specified. This expression will define the columns to be shown. A selection criterium can also be specified. A TEntryList will be; created and applied to the TTree using this criterium.; a new TEntryList to use can be specified using SetEntryList.; TGTable->Update() will need to be called to show the effects. WARNING: Do not apply an entrylist to the tree in any other way than; through the interface, this will have undefined consequences. Columns can be manipulated using the appropriate methods. A; TGTable->Update is always needed afterwards to make the table aware; of the changes. Function Members (Methods); public:. virtual~TTreeTableInterface(); virtual voidAddColumn(const char* expression, UInt_t position); virtual voidAddColumn(TTreeFormula* formula, UInt_t position); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual TEntryList*GetEntryList(); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TTreeTableInterface&operator=(const TTreeTableInterface&); virtual voidRemoveColumn(UInt_t position); virtual voidSetEntryList(TEntryList* entrylist = 0); virtual voidSetFormula(TTreeFormula* formula, UInt_t position); virtual voidSetSelection(const char* selection); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuff",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:2953,Modifiability,Inherit,Inheritance,2953,"insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTreeTableInterface(const TTreeTableInterface&); TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0). private:. voidInitEntries(); voidSetVariablesExpression(const char* varexp); voidSyncFormulas(). Data Members; private:. TEntryList*fEntriesCurrently active entries; Long64_tfEntryPresent entry number in fTree.; Long64_tfFirstEntryFirst entry.; Bool_tfForceDimForce dimension.; TList*fFormulasArray of TTreeFormulas to display values; TList*fInputUsed for fSelector.; TTreeFormulaManager*fManagerCoordinator for the formulas.; UInt_tfNColumnsAmount of columns in the data; Long64_tfNEntriesNumber of entries in the tree.; UInt_tfNRowsAmount of rows in the data; TTreeFormula*fSelectSelection condition; TSelectorDraw*fSelectorSelector; TTree*fTreeData in a TTree. Class Charts. Inheritance Chart:. TVirtualTableInterface. ←; TTreeTableInterface. Function documentation; TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0); TTreeTableInterface constructor. ~TTreeTableInterface(); TTreeTableInterface destructor. void SetVariablesExpression(const char* varexp); Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t r",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeTableInterface.html:3354,Modifiability,variab,variables,3354,"arexp); voidSyncFormulas(). Data Members; private:. TEntryList*fEntriesCurrently active entries; Long64_tfEntryPresent entry number in fTree.; Long64_tfFirstEntryFirst entry.; Bool_tfForceDimForce dimension.; TList*fFormulasArray of TTreeFormulas to display values; TList*fInputUsed for fSelector.; TTreeFormulaManager*fManagerCoordinator for the formulas.; UInt_tfNColumnsAmount of columns in the data; Long64_tfNEntriesNumber of entries in the tree.; UInt_tfNRowsAmount of rows in the data; TTreeFormula*fSelectSelection condition; TSelectorDraw*fSelectorSelector; TTree*fTreeData in a TTree. Class Charts. Inheritance Chart:. TVirtualTableInterface. ←; TTreeTableInterface. Function documentation; TTreeTableInterface(TTree* tree = 0, const char* varexp = 0, const char* selection = 0, Option_t* option = 0, Long64_t nentries = 0, Long64_t firstentry = 0); TTreeTableInterface constructor. ~TTreeTableInterface(); TTreeTableInterface destructor. void SetVariablesExpression(const char* varexp); Compile the variables expression from the given varexp. void SetSelection(const char* selection); Set the selection expression. void SyncFormulas(); Sync the formulas using the TTreeFormulaManager. void InitEntries(); Initialise the TEntryList with the entries that match the; selection criterium. Double_t GetValue(UInt_t row, UInt_t column); Return the value of row,column. If the position does not exist; or does not contain a number, 0 is returned. const char * GetValueAsString(UInt_t row, UInt_t column); Return the content of row,column as string to use in a; TGTableCell label. const char * GetRowHeader(UInt_t row); Return a string to use as a label for rowheader at column. const char * GetColumnHeader(UInt_t column); Return a string to use as a label for columnheader at column. UInt_t GetNColumns(); Return the amount of column available. UInt_t GetNRows(); Return the amount of rows in the Tree. void AddColumn(const char* expression, UInt_t position); Add column according ot expression a",MatchSource.WIKI,root/html604/TTreeTableInterface.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeTableInterface.html
https://root.cern/root/html604/TTreeViewer.html:1361,Availability,echo,echoed,1361,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:11596,Availability,Error,Error,11596,":Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:11725,Availability,error,error,11725," char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWin",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:11809,Availability,error,error,11809,"; voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); voidEmptyAll()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); voidExecuteCommand(const char* command, Bool_t fast = kFALSE)MENU ; voidExecuteDraw(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteSpider(); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:28726,Availability,mask,mask,28726,,MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:38729,Availability,error,error,38729,"(); Remove the current record. Bool_t HandleTimer(TTimer* timer); This function is called by the fTimer object. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other commands generated. void CloseWindow(); Close the viewer. void ExecuteCommand(const char* command, Bool_t fast = kFALSE); Execute all user commands. void MapOptions(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:1940,Deployability,toggle,toggles,1940,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:5527,Deployability,toggle,toggle,5527,"editor usage is the following :; - you can write C expressions made of leaf names by hand or you can insert; any item from the right panel by clicking on it (recommandable);; - you can click on other expressions/leaves to paste them in the editor;; - you should write the item alias by hand since it not only make the expression; meaningfull, but it also highly improve the layout for big expressions; - you may redefine an old alias - the other expressions depending on it will; be modified accordingly. An alias must not be the leading string of other aliases.; When Draw commands are issued, the name of the corresponding histogram axes; will become the aliases of the expressions. User commands can be issued directly from the textbox labeled ""Command""; from the upper-left toolbar by typing and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the left tree-type list :; The items from the left that are provided with context menus are tree and; branch items. You can directly activate the *MENU* marked methods of TTree; from this menu.; Context menu for the right panel :; A general context menu is acivated if the user right-clicks the right panel.; Commands are :; - EmptyAll : clears the content of all expressions;; - ExecuteCommand : execute a ROOT command;; - MakeSelector : equivalent of TTree::MakeSelector();; - NewExpression : add an expression item in the right panel;; - Process : equivalent of TTree::Process();; - SaveSource : save the current session as a C++ macro;; - SetScanFileName : define a name for the file where TTree::Scan command; is redirected when the <Scan> button is ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:32479,Deployability,toggle,toggle,32479,,MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:39340,Deployability,Update,UpdateCombo,39340,"Options(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. void SetCutMode(Bool_t enabled = kTRUE); {fEnableCut = enabled;}. void SetScanMode(Bool_t mode = kTRUE); {fScanMode = mode;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:39355,Deployability,Update,Updates,39355,"Options(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. void SetCutMode(Bool_t enabled = kTRUE); {fEnableCut = enabled;}. void SetScanMode(Bool_t mode = kTRUE); {fScanMode = mode;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:39406,Deployability,Update,UpdateRecord,39406,"Options(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. void SetCutMode(Bool_t enabled = kTRUE); {fEnableCut = enabled;}. void SetScanMode(Bool_t mode = kTRUE); {fScanMode = mode;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:39451,Deployability,Update,Updates,39451,"Options(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Delete(Option_t* ); { }. TTree * GetTree(); {return fTree;}. Bool_t IsCutEnabled(); {return fEnableCut;}. void SetCutMode(Bool_t enabled = kTRUE); {fEnableCut = enabled;}. void SetScanMode(Bool_t mode = kTRUE); {fScanMode = mode;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:477,Energy Efficiency,adapt,adapted,477,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:357,Integrability,interface,interface,357,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:2327,Integrability,message,message,2327,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:4986,Integrability,depend,depending,4986,"ft (where expressions are; placed) by dragging them to the left at least 10 pixels. Editing expressions. Any editable expression from the right panel has two components : a; true name (that will be used when TTree::Draw() commands are issued) and an; alias. The visible name is the alias. Aliases of user defined expressions have; a leading ~ and may be used in new expressions. Expressions containing boolean; operators have a specific icon and may be dragged to the active cut (scissors; item) position.; The expression editor can be activated by double-clicking empty expression,; using <EditExpression> from the selected expression context menu or using; <Edit/Expression> menu.; The editor will pop-up in the left part, but it can be moved.; The editor usage is the following :; - you can write C expressions made of leaf names by hand or you can insert; any item from the right panel by clicking on it (recommandable);; - you can click on other expressions/leaves to paste them in the editor;; - you should write the item alias by hand since it not only make the expression; meaningfull, but it also highly improve the layout for big expressions; - you may redefine an old alias - the other expressions depending on it will; be modified accordingly. An alias must not be the leading string of other aliases.; When Draw commands are issued, the name of the corresponding histogram axes; will become the aliases of the expressions. User commands can be issued directly from the textbox labeled ""Command""; from the upper-left toolbar by typing and pressing Enter at the end.; Another way is from the right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:38583,Integrability,Message,Message,38583," if scan is redirected. void RemoveItem(); Remove the selected item from the list. void RemoveLastRecord(); Remove the current record. Bool_t HandleTimer(TTimer* timer); This function is called by the fTimer object. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other commands generated. void CloseWindow(); Close the viewer. void ExecuteCommand(const char* command, Bool_t fast = kFALSE); Execute all user commands. void MapOptions(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Del",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:38616,Integrability,message,message,38616," if scan is redirected. void RemoveItem(); Remove the selected item from the list. void RemoveLastRecord(); Remove the current record. Bool_t HandleTimer(TTimer* timer); This function is called by the fTimer object. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other commands generated. void CloseWindow(); Close the viewer. void ExecuteCommand(const char* command, Bool_t fast = kFALSE); Execute all user commands. void MapOptions(Long_t parm1); Scan the selected options from option menu. void MapTree(TTree* tree, TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current tree and expand its content (including friends) in the lists. void MapBranch(TBranch* branch, const char* prefix = """", TGListTreeItem* parent = 0, Bool_t listIt = kTRUE); Map current branch and expand its content in the list view. void NewExpression(); Create new expression. void SetParentTree(TGListTreeItem* item); Find parent tree of a clicked item. void Message(const char* msg); Send a message on the status bar. void DoError(int level, const char* location, const char* fmt, va_list va) const; Put error/warning into TMsgBox and also forward to console. void PrintEntries(); Print the number of selected entries on status-bar. void SaveSource(const char* filename = """", Option_t* option = """"); Save current session as a C++ macro file. Bool_t SwitchTree(Int_t index); Makes current the tree at a given index in the list. void SetRecordName(const char* name); Set record name. void SetCurrentRecord(Long64_t entry); Set current record. void SetHistogramTitle(const char* title); Set title of Histogram. void SetUserCode(const char* code, Bool_t autoexec = kTRUE); user defined command for current record. void UpdateCombo(); Updates combo box to current session entries. void UpdateRecord(const char* name = ""new name""); Updates current record to new X, Y, Z items. void DoRefresh(); This slot is called when button REFR is clicked. TTreeViewer(const char* treeName = 0). void Del",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:117,Modifiability,inherit,inheritance,117,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:477,Modifiability,adapt,adapted,477,". TTreeViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the;",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:795,Modifiability,variab,variables,795,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:17125,Modifiability,Inherit,InheritsFrom,17125,"ol_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tHandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tIsCutEnabled(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; Bool_tIsScanRedirected(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameE",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:17191,Modifiability,Inherit,InheritsFrom,17191,"Frame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tHandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tIsCutEnabled(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; Bool_tIsScanRedirected(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidT",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:35129,Modifiability,Inherit,Inheritance,35129,"utton //ia; TGTextButton*fResetclear expression's entries; TGPopupMenu*fRunMenu; TGTextButton*fSPIDERSPIDER button; TGPictureButton*fSTOPinterrupt current command (not yet); Bool_tfScanModeflag activated when Scan Box is double-clicked; TTVSession*fSessioncurrent tree-viewer session; TGDoubleVSlider*fSlidervertical slider to select processed tree entries;; const char*fSourceFilename of the C++ source file - default treeviewer.C; TGStatusBar*fStatusBarstatus bar; Bool_tfStopMappingtrue if branch don't need remapping; TTimer*fTimertree viewer timer; TGToolBar*fToolBar; TTree*fTreeselected tree; TGCompositeFrame*fTreeHdrheader for list tree; Int_tfTreeIndexindex of current tree in list; TList*fTreeListlist of mapped trees; TGCanvas*fTreeViewListTree canvas container; TGVerticalFrame*fV1list tree mother; TGVerticalFrame*fV2list view mother; Bool_tfVarDrawtrue if an item is double-clicked; Cursor_tfWatchCursorwatch cursor; TList*fWidgetslist of widgets to be deleted. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGMainFrame. ←; TTreeViewer. Function documentation; TTreeViewer(const char* treeName = 0); TTreeViewer default constructor. TTreeViewer(const TTree* tree); TTreeViewer constructor with a pointer to a Tree. void AppendTree(TTree* tree); Allow geting the tree from the context menu. void SetNexpressions(Int_t expr); Change the number of expression widgets. void SetScanFileName(const char* name = """"); Set the name of the file where to redirect <Scan> output. void SetScanRedirect(Bool_t mode); Set the state of Scan check button. void SetTree(TTree* tree); Assign the fTree member from existing tree, e.g. when calling; tree->StartViewer() from the browser, or even from the command line. void SetTreeName(const char* treeName); Allow geting the tree from the context menu. void SetFile(); Set file name containing the tree. void BuildInterface(); Create all viewer widgets. ~TTreeViewer(); TTreeViewer dest",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:7264,Performance,load,load,7264,"e file where TTree::Scan command; is redirected when the <Scan> button is checked;; - SetTreeName : open a new tree whith this name in the viewer;; A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1) From the TBrowser :; Select a tree in the TBrowser, then call the StartViewer() method from its; context menu (right-click on the tree).; 2) From the command line :; Start a ROOT session in the directory where you have your tree.; You will need first to load the library for TTreeViewer and optionally other; libraries for user defined classes (you can do this later in the session) :; root [0] gSystem->Load(\""TTreeViewer\"");; Supposing you have the tree MyTree in the file MyFile, you can do :; root [1] TFile file(\""Myfile\"");; root [2] new TTreeViewer(\""Mytree\"");; or :; root [2] TreeViewer *tv = new TTreeViewer();; root [3] tv->SetTreeName(\""Mytree\"");. /*. */. Function Members (Methods); public:. virtual~TTreeViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); voidAppendTree(TTree* tree); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackgrou",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:7414,Performance,Load,Load,7414,"e file where TTree::Scan command; is redirected when the <Scan> button is checked;; - SetTreeName : open a new tree whith this name in the viewer;; A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1) From the TBrowser :; Select a tree in the TBrowser, then call the StartViewer() method from its; context menu (right-click on the tree).; 2) From the command line :; Start a ROOT session in the directory where you have your tree.; You will need first to load the library for TTreeViewer and optionally other; libraries for user defined classes (you can do this later in the session) :; root [0] gSystem->Load(\""TTreeViewer\"");; Supposing you have the tree MyTree in the file MyFile, you can do :; root [1] TFile file(\""Myfile\"");; root [2] new TTreeViewer(\""Mytree\"");; or :; root [2] TreeViewer *tv = new TTreeViewer();; root [3] tv->SetTreeName(\""Mytree\"");. /*. */. Function Members (Methods); public:. virtual~TTreeViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); voidAppendTree(TTree* tree); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackgrou",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:16835,Security,Hash,Hash,16835,"t); virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tHandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tIsCutEnabled(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() con",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:24226,Testability,Test,TestBit,24226,"ual voidTGWindow::SetName(const char* name); voidSetNexpressions(Int_t expr); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name)MENU ; voidSetScanFileName(const char* name = """")MENU ; voidSetScanMode(Bool_t mode = kTRUE); voidSetScanRedirect(Bool_t mode); voidSetSession(TTVSession* session); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetTree(TTree* tree); voidSetTreeName(const char* treeName)MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tSwitchTree(Int_t index); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTreeViewer(const char* treeName = 0); TTreeViewer(const TTree* tree); TTreeViewer(const TTreeViewer&); virtual voidTGFrame::UnmapWindow(); voidUpdateCombo(); voidUpdateRecord(const char* name = ""new name"")MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:24265,Testability,Test,TestBits,24265,"ual voidTGWindow::SetName(const char* name); voidSetNexpressions(Int_t expr); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name)MENU ; voidSetScanFileName(const char* name = """")MENU ; voidSetScanMode(Bool_t mode = kTRUE); voidSetScanRedirect(Bool_t mode); voidSetSession(TTVSession* session); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetTree(TTree* tree); voidSetTreeName(const char* treeName)MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); Bool_tSwitchTree(Int_t index); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTreeViewer(const char* treeName = 0); TTreeViewer(const TTree* tree); TTreeViewer(const TTreeViewer&); virtual voidTGFrame::UnmapWindow(); voidUpdateCombo(); voidUpdateRecord(const char* name = ""new name"")MENU ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:1416,Usability,progress bar,progress bar,1416,"rce:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTreeViewer. class TTreeViewer: public TGMainFrame. TreeViewer is a graphic user interface designed to handle ROOT trees and to; take advantage of TTree class features. It uses ROOT native GUI widgets adapted for 'drag and drop' functionality.; in the same session.; The following capabilities are making the viewer a helpful tool for analysis:; - several trees may be opened in the same session;; - branches and leaves can be easily browsed or scanned;; - fast drawing of branch expressions by double-clicking;; - new variables/selections easy to compose with the built-in editor;; - histograms can be composed by dragging leaves or user-defined expressions; to X, Y and Z axis items;; - the tree entries to be processed can be selected with a double slider;; - selections can be defined and activated by dragging them to the 'Cut' item;; - all expressions can be aliased and aliases can be used in composing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCI",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:2377,Usability,clear,clear,2377,"mposing others;; - input/output event lists easy to handle;; - menu with histogram drawing options;; - user commands may be executed within the viewer and the current command; can be echoed;; - current 'Draw' event loop is reflected by a progress bar and may be; interrupted by the user;; - all widgets have self-explaining tool tips and/or context menus;; - expressions/leaves can be dragged to a 'scan box' and scanned by; double-clicking this item. The result can be redirected to an ASCII file;. The layout has the following items:. - a menu bar with entries : File, Edit, Run, Options and Help;; - a toolbar in the upper part where you can issue user commands, change; the drawing option and the histogram name, three check buttons Hist, Rec; and Scan.HIST toggles histogram drawing mode, REC enables recording of the; last command issued and SCAN enables redirecting of TTree::Scan command in; an ASCII file (see -Scanning expressions-);; - a button bar in the lower part with : buttons DRAW/STOP that issue histogram; drawing and stop the current command respectively, two text widgets where; input and output event lists can be specified, a message box and a RESET; button on the right that clear edited expression content (see Editing...); - a tree-type list on the main left panel where you can select among trees or; branches. The tree/branch will be detailed in the right panel.; Mapped trees are provided with context menus, activated by right-clicking;; - a view-type list on the right panel. The first column contain X, Y and; Z expression items, an optional cut and ten optional editable expressions.; Expressions and leaf-type items can be dragged or deleted. A right click on; the list-box or item activates context menus. Opening a new tree and saving a session :. To open a new tree in the viewer use <File/Open tree file> menu; The content of the file (keys) will be listed. Use <SetTreeName> function; from the context menu of the right panel, entering a tree name among those; l",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:6111,Usability,clear,clears,6111," right panel context menu : ExecuteCommand.; All commands can be interrupted at any time by pressing the STOP button; from the bottom-left; You can toggle recording of the current command in the history file by; checking the Rec button from the top-right. Context menus. You can activate context menus by right-clicking on items or inside the; right panel.; Context menus for mapped items from the left tree-type list :; The items from the left that are provided with context menus are tree and; branch items. You can directly activate the *MENU* marked methods of TTree; from this menu.; Context menu for the right panel :; A general context menu is acivated if the user right-clicks the right panel.; Commands are :; - EmptyAll : clears the content of all expressions;; - ExecuteCommand : execute a ROOT command;; - MakeSelector : equivalent of TTree::MakeSelector();; - NewExpression : add an expression item in the right panel;; - Process : equivalent of TTree::Process();; - SaveSource : save the current session as a C++ macro;; - SetScanFileName : define a name for the file where TTree::Scan command; is redirected when the <Scan> button is checked;; - SetTreeName : open a new tree whith this name in the viewer;; A specific context menu is activated if expressions/leaves are right-clicked.; Commands are :; - Draw : draw a histogram for this item;; - EditExpression : pops-up the expression editor;; - Empty : empty the name and alias of this item;; - RemoveItem : removes clicked item from the list;; - Scan : scan this expression;; - SetExpression : edit name and alias for this item by hand;. Starting the viewer. 1) From the TBrowser :; Select a tree in the TBrowser, then call the StartViewer() method from its; context menu (right-click on the tree).; 2) From the command line :; Start a ROOT session in the directory where you have your tree.; You will need first to load the library for TTreeViewer and optionally other; libraries for user defined classes (you can do this later in ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:8797,Usability,Clear,Clear,8797,"l voidTGFrame::Activate(Bool_t); voidActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); voidAppendTree(TTree* tree); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t*)MENU ; virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Disconnect(const char* signal ",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTreeViewer.html:36489,Usability,Clear,Clear,36489,"t menu. void SetNexpressions(Int_t expr); Change the number of expression widgets. void SetScanFileName(const char* name = """"); Set the name of the file where to redirect <Scan> output. void SetScanRedirect(Bool_t mode); Set the state of Scan check button. void SetTree(TTree* tree); Assign the fTree member from existing tree, e.g. when calling; tree->StartViewer() from the browser, or even from the command line. void SetTreeName(const char* treeName); Allow geting the tree from the context menu. void SetFile(); Set file name containing the tree. void BuildInterface(); Create all viewer widgets. ~TTreeViewer(); TTreeViewer destructor. void ActivateButtons(Bool_t first, Bool_t previous, Bool_t next, Bool_t last); Enable/disable session buttons. const char* Cut(); Apply Cut. const char* ScanList(); returns scanlist. void SetSession(TTVSession* session); Set current session. const char* EmptyBrackets(const char* name); Empty the bracket content of a string. void EmptyAll(); Clear the content of all items in the list view. void Empty(); Empty the content of the selected expression. TTVLVEntry * ExpressionItem(Int_t index); Get the item from a specific position. TList* ExpressionList(); Get the list of expression items. Int_t Dimension(); Compute dimension of the histogram. void ExecuteDraw(); Called when the DRAW button is executed. void ExecuteSpider(); Draw a spider plot for the selected entries. const char* Ex(); Get the expression to be drawn on X axis. const char* Ey(); Get the expression to be drawn on Y axis. const char* Ez(); Get the expression to be drawn on Z axis. const char* En(Int_t n); Get the n'th expression. void EditExpression(); Start the expression editor. Int_t MakeSelector(const char* selector = 0); Get use of TTree::MakeSelector() via the context menu. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Get use of TTree::Process() via the context menu. const char * GetGrOpt(); Get g",MatchSource.WIKI,root/html604/TTreeViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTreeViewer.html
https://root.cern/root/html604/TTUBE.html:1422,Availability,Error,Error,1422," virtual~TTUBE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; vi",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:1551,Availability,error,error,1551,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual In",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:1635,Availability,error,error,1635,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOf",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:111,Modifiability,inherit,inheritance,111,". TTUBE. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TTUBE. class TTUBE: public TShape. . TUBE is a tube. It has 6 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - rmin inside radius; - rmax outside radius; - dz half length in z. Function Members (Methods); public:. virtual~TTUBE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; vi",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:3177,Modifiability,Inherit,InheritsFrom,3177,"l Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRmax() const; virtual Float_tGetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); ",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:3243,Modifiability,Inherit,InheritsFrom,3243,"GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRmax() const; virtual Float_tGetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:9191,Modifiability,Inherit,Inheritance,9191,"anvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tfAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←. TCONE. TELTU. THYPE. TTUBS; ←. TCONS. TCTUB. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; C",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:3067,Security,Hash,Hash,3067,"Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tGetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetRmax() const; virtual Float_tGetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:6469,Testability,Test,TestBit,6469,"etBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t ndiv); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; TTUBE(); TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:6508,Testability,Test,TestBits,6508,"etBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNumberOfDivisions(Int_t ndiv); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; TTUBE(); TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:781,Usability,Clear,Clear,781," virtual~TTUBE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; vi",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBE.html:9654,Usability,simpl,simplified,9654,"ill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←. TCONE. TELTU. THYPE. TTUBS; ←. TCONS. TCTUB. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root/html604/TTUBE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBE.html
https://root.cern/root/html604/TTUBS.html:1611,Availability,Error,Error,1611," virtual~TTUBS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::Fil",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:1740,Availability,error,error,1740,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() con",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:1824,Availability,error,error,1824,"ion = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; vir",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:111,Modifiability,inherit,inheritance,111,". TTUBS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TTUBS. class TTUBS: public TTUBE. . TUBS is a segment of a tube. It has 8 parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - rmin inside radius; - rmax outside radius; - dz half length in z; - phi1 starting angle of the segment; - phi2 ending angle of the segment. NOTE: phi1 should be smaller than phi2. If this is not the case,; the system adds 360 degrees to phi2. Function Members (Methods); public:. virtual~TTUBS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::Fil",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:3472,Modifiability,Inherit,InheritsFrom,3472,"ual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi1() const; virtual Float_tGetPhi2() const; virtual Float_tTTUBE::GetRmax() const; virtual Float_tTTUBE::GetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); ",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:3538,Modifiability,Inherit,InheritsFrom,3538,"ne::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi1() const; virtual Float_tGetPhi2() const; virtual Float_tTTUBE::GetRmax() const; virtual Float_tTTUBE::GetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:9651,Modifiability,Inherit,Inheritance,9651,"c TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Float_tTTUBE::fAspectRatiodefines (the ellipse semi-axis in Y)/(the ellipse semi-axis in X); Double_t*TTUBE::fCoTab! Table of cos(fPhi1) .... cos(fPhil+fDphi1); Float_tTTUBE::fDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; G",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:3362,Security,Hash,Hash,3362,":GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() const; virtual Int_tTTUBE::GetNumberOfDivisions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPhi1() const; virtual Float_tGetPhi2() const; virtual Float_tTTUBE::GetRmax() const; virtual Float_tTTUBE::GetRmin() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tTShape::GetVisibility() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTAttFill::IsTransparent() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delet",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:6809,Testability,Test,TestBit,6809,"ual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTUBE::SetNumberOfDivisions(Int_t ndiv); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; TTUBS(); TTUBS(const TTUBS&); TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:6848,Testability,Test,TestBits,6848,"ual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTShape::SetName(const char* name); virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTTUBE::SetNumberOfDivisions(Int_t ndiv); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTShape::SetVisibility(Int_t vis)MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTShape::TransformPoints(Double_t* points, UInt_t NbPnts) const; TTUBS(); TTUBS(const TTUBS&); TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:970,Usability,Clear,Clear,970," virtual~TTUBS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::Fil",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTUBS.html:10129,Usability,simpl,simplified,10129,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root/html604/TTUBS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTUBS.html
https://root.cern/root/html604/TTVLVContainer.html:4844,Availability,Error,Error,4844,"ramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::Get",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:4990,Availability,error,error,4990,"nst char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:5074,Availability,error,error,5074,"am); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:12069,Availability,mask,mask,12069,") const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidTGLVContainer::LineDown(Bool_t select = kFALSE); virtual voidTGLVContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGLVContainer::LineRight(Bool_t select = kFALSE); virtual voidTGLVContainer::LineUp(Bool_t select = kFALSE); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virt",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:22395,Availability,mask,mask,22395,,MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:12726,Integrability,Message,Message,12726,"ol_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGContainer::KeyPressed(TGFrame*, UInt_t keysym, UInt_t mask)SIGNAL ; virtual voidTGContainer::Layout(); virtual voidTGLVContainer::LineDown(Bool_t select = kFALSE); virtual voidTGLVContainer::LineLeft(Bool_t select = kFALSE); virtual voidTGLVContainer::LineRight(Bool_t select = kFALSE); virtual voidTGLVContainer::LineUp(Bool_t select = kFALSE); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual Int_tTGContainer::NumItems() const; virtual Int_tTGContainer::NumSelected() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTGContainer::OnMouseOver(TGFrame*)SIGNAL ; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVLVContainer&operator=(const TTVLVContainer&);",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:23942,Integrability,message,messages,23942,ner::fLastActiveEllast active item; Bool_tTGContainer::fLastCasecase sensetivity of last search; Bool_tTGContainer::fLastDirdirection of last search; TStringTGContainer::fLastNamethe name of object of last search; Bool_tTGContainer::fLastSubstringsubstring search option of last search; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGListView*TGLVContainer::fListViewlistview which contains this container; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGContainer::fMsgWindowwindow handling container messages; Bool_tTGLVContainer::fMultiSelecttrue = multiple file selection; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; Bool_tTGContainer::fOnMouseOverkTRUE when mouse pointer is over entry; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; TTimer*TGContainer::fScrollTimerautoscroll timer; Bool_tTGContainer::fScrollingkTRUE - when scrolling is ON; Int_tTGContainer::fSelectednumber of selected items; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTGContainer::fTotaltotal items; EListViewModeTGLVContainer::fViewModelist view viewing mode; TGViewPort*TGContainer::fViewPortcontainer viewport; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGContainer::fX0corner of rubber band box; Int_tTGContainer::fXDND; Int_tTGContainer::fXfother corner of rubber band b,MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:120,Modifiability,inherit,inheritance,120,". TTVLVContainer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTVLVContainer. class TTVLVContainer: public TGLVContainer. TGItemContext - empty object used as context menu support for; TGLVTreeEntries. Function Members (Methods); public:. virtual~TTVLVContainer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_clas",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:10938,Modifiability,Inherit,InheritsFrom,10938,"(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGContainer::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGContainer::HandleKey(Event_t* event); virtual Bool_tHandleMotion(Event_t* event); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGContainer::Home(Bool_t select = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFra",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:11004,Modifiability,Inherit,InheritsFrom,11004,"rtual Bool_tTGContainer::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGContainer::HandleKey(Event_t* event); virtual Bool_tHandleMotion(Event_t* event); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGContainer::Home(Bool_t select = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual vo",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:26379,Modifiability,Inherit,Inheritance,26379,"me::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TGGC*TGContainer::fgLineGC; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. Cursor_tfCursorcurrent cursor; Cursor_tfDefaultCursordefault cursor; TList*fExpressionListlist of user defined expression widgets; TGListView*fListViewassociated list view; TTreeViewer*fViewerpointer to tree viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGContainer. ←; TGLVContainer. ←; TTVLVContainer. Function documentation; TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame); TGLVContainer constructor. ~TTVLVContainer(); TGLVContainer destructor. const char* Cut(); return the cut entry. TTVLVEntry * ExpressionItem(Int_t index); return the expression item at specific position. TList* ExpressionList(); return the list of user-defined expressions. const char* Ex(); return the expression on X. const char* Ey(); return the expression on Y. const char* Ez(); return the expression on Z. const char* ScanList(); return the cut entry. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. void EmptyAll(); Clear all names and aliases for expression type items. void RemoveNonStatic(); remove all non-static items from the list view, exce",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:10593,Security,Hash,Hash,10593,"m_t, Int_t, Int_t); virtual Bool_tTGContainer::HandleDoubleClick(Event_t* event); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGContainer::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGContainer::HandleKey(Event_t* event); virtual Bool_tHandleMotion(Event_t* event); virtual Bool_tTGCompositeFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGContainer::Home(Bool_t select = kFALSE); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual voidTGContainer::InvertSelection()SIGNAL ; virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual B",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:18605,Testability,Test,TestBit,18605,"virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGLVContainer::SetMultipleSelection(Bool_t multi = kTRUE); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGContainer::SetPageDimension(const TGDimension& dim); virtual voidTGContainer::SetPageDimension(UInt_t w, UInt_t h); virtual voidTGContainer::SetPagePosition(const TGPosition& pos); virtual voidTGContainer::SetPagePosition(Int_t x, Int_t y); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetViewer(TTreeViewer* viewer); virtual voidTGLVContainer::SetViewMode(EListViewMode viewMode); virtual voidTGContainer::SetVsbPosition(Int_t newPos); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTGContainer::SpacePressed(TGFrame*)SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTVLVContainer(const TTVLVContainer&); TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame); virtual voidTGFrame::UnmapWindow(); virtual voidTGContainer::UnSelectAll()SIGNAL ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:18644,Testability,Test,TestBits,18644,"virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGLVContainer::SetMultipleSelection(Bool_t multi = kTRUE); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGContainer::SetPageDimension(const TGDimension& dim); virtual voidTGContainer::SetPageDimension(UInt_t w, UInt_t h); virtual voidTGContainer::SetPagePosition(const TGPosition& pos); virtual voidTGContainer::SetPagePosition(Int_t x, Int_t y); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetViewer(TTreeViewer* viewer); virtual voidTGLVContainer::SetViewMode(EListViewMode viewMode); virtual voidTGContainer::SetVsbPosition(Int_t newPos); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTGContainer::SpacePressed(TGFrame*)SIGNAL ; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TTVLVContainer(const TTVLVContainer&); TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame); virtual voidTGFrame::UnmapWindow(); virtual voidTGContainer::UnSelectAll()SIGNAL ; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:1535,Usability,Clear,Clear,1535,"irtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContaine",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:1583,Usability,Clear,ClearViewPort,1583,"CompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGLVContainer::AddItem(TGLVEntry* item); virtual voidAddThisItem(TTVLVEntry* item); virtual voidTGContainer::AdjustPosition(); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGContainer::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual voidTGContainer::ClearViewPort(); virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn)SIGNAL ; virtual voidTGContainer::Clicked(TGFrame* f, Int_t btn, Int_t x, Int_t y)SIGNAL ; virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGContainer::CurrentChanged(TGFrame* f)SIGNAL ; virtual voidTGContainer::CurrentChanged(Int_t x, Int_t y)SIGNAL ; const ch",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVContainer.html:27257,Usability,Clear,Clear,27257,"ame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. private:. Cursor_tfCursorcurrent cursor; Cursor_tfDefaultCursordefault cursor; TList*fExpressionListlist of user defined expression widgets; TGListView*fListViewassociated list view; TTreeViewer*fViewerpointer to tree viewer. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGCompositeFrame. ←; TGContainer. ←; TGLVContainer. ←; TTVLVContainer. Function documentation; TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame); TGLVContainer constructor. ~TTVLVContainer(); TGLVContainer destructor. const char* Cut(); return the cut entry. TTVLVEntry * ExpressionItem(Int_t index); return the expression item at specific position. TList* ExpressionList(); return the list of user-defined expressions. const char* Ex(); return the expression on X. const char* Ey(); return the expression on Y. const char* Ez(); return the expression on Z. const char* ScanList(); return the cut entry. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. void EmptyAll(); Clear all names and aliases for expression type items. void RemoveNonStatic(); remove all non-static items from the list view, except expressions. void SelectItem(const char* name); select an item. TTVLVContainer(const TGWindow* p, UInt_t w, UInt_t h, UInt_t options = kSunkenFrame). void AddThisItem(TTVLVEntry* item); { AddFrame(item, fItemLayout); item->SetColumns(fCpos, fJmode); }. TTreeViewer * GetViewer(); {return fViewer;}. void SetListView(TGListView* lv); {fListView = lv;}. void SetViewer(TTreeViewer* viewer); {fViewer = viewer;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTVLVContainer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVContainer.html
https://root.cern/root/html604/TTVLVEntry.html:3887,Availability,Error,Error,3887,"ignal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlias(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TTVLVContainer*GetContainer(); TGItemContext*GetContext(); const char*GetConvName(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:4016,Availability,error,error,4016,"dTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlias(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TTVLVContainer*GetContainer(); TGItemContext*GetContext(); const char*GetConvName(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() ",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:4100,Availability,error,error,4100,"signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmpty(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAlias(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; TTVLVContainer*GetContainer(); TGItemContext*GetContext(); const char*GetConvName(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGLVEntry::GetDefaultSize() const; virtual UInt_tTGFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragTy",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:18265,Availability,mask,mask,18265,,MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:9810,Integrability,Message,Message,9810,"::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTGFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGWindow::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVLVEntry&operator=(const TTVLVEntry&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); voidPrependTilde(); virtual voidTGFrame::Print(Option_t* option = """") const; virtu",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:116,Modifiability,inherit,inheritance,116,". TTVLVEntry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTVLVEntry. class TTVLVEntry: public TGLVEntry. TGItemContext - empty object used as context menu support for; TGLVTreeEntries. Function Members (Methods); public:. virtual~TTVLVEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLVEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; const char*ConvertAliases(); virtual voidTObject::Copy(TObject& object) const; voidCopyItem(TTVLVEntry* dest); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindo",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:8661,Modifiability,Inherit,InheritsFrom,8661,"::HandleDragEnter(TGFrame*); virtual Bool_tTGFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tTGFrame::HandleMotion(Event_t*); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); Bool_tHasAlias(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTGFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); vi",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:8727,Modifiability,Inherit,InheritsFrom,8727,"e(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tTGFrame::HandleMotion(Event_t*); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); Bool_tHasAlias(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTGFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGFrame::MapSubwindows(); virtual voidTGFrame::MapWindow",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:20686,Modifiability,Inherit,Inheritance,20686,"Widthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGLVEntry::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGLVEntry::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGLVEntry. ←; TTVLVEntry. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empt",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:8424,Security,Hash,Hash,8424,"NDLeave(); virtual Atom_tTGFrame::HandleDNDPosition(Int_t, Int_t, Atom_t, Int_t, Int_t); virtual Bool_tTGFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGFrame::HandleDragDrop(TGFrame*, Int_t, Int_t, TGLayoutHints*); virtual Bool_tTGFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGFrame::HandleKey(Event_t*); virtual Bool_tTGFrame::HandleMotion(Event_t*); virtual Bool_tTGFrame::HandleSelection(Event_t*); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGFrame::HandleSelectionRequest(Event_t*); virtual Bool_tTGWindow::HandleTimer(TTimer*); Bool_tHasAlias(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGLVEntry::IsActive() const; virtual Bool_tTGFrame::IsComposite() const; Bool_tIsCut(); Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGWindow::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virt",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:14409,Testability,Test,TestBit,14409,"UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGLVEntry::SetPictures(const TGPicture* bigpic = 0, const TGPicture* smallpic = 0); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetSmallPic(const TGPicture* spic); virtual voidTGLVEntry::SetSubnames(const char* n1 = """", const char* n2 = """", const char* n3 = """", const char* n4 = """", const char* n5 = """", const char* n6 = """", const char* n7 = """", const char* n8 = """", const char* n9 = """", const char* n10 = """", const char* n11 = """", const char* n12 = """"); virtual voidTGLVEntry::SetTitle(const char* text); voidSetToolTipText(const char* text, Long_t delayms = 1000); voidSetTrueName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLVEntry::SetUserData(void* userData); virtual voidTGLVEntry::SetViewMode(EListViewMode viewMode); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVLVEntry(const TTVLVEntry&); TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:14448,Testability,Test,TestBits,14448,"UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGLVEntry::SetPictures(const TGPicture* bigpic = 0, const TGPicture* smallpic = 0); virtual voidTGFrame::SetSize(const TGDimension& s); voidSetSmallPic(const TGPicture* spic); virtual voidTGLVEntry::SetSubnames(const char* n1 = """", const char* n2 = """", const char* n3 = """", const char* n4 = """", const char* n5 = """", const char* n6 = """", const char* n7 = """", const char* n8 = """", const char* n9 = """", const char* n10 = """", const char* n11 = """", const char* n12 = """"); virtual voidTGLVEntry::SetTitle(const char* text); voidSetToolTipText(const char* text, Long_t delayms = 1000); voidSetTrueName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidTGLVEntry::SetUserData(void* userData); virtual voidTGLVEntry::SetViewMode(EListViewMode viewMode); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVLVEntry(const TTVLVEntry&); TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); virtual voidTGFrame::UnmapWindow(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:1130,Usability,Clear,Clear,1130," virtual~TTVLVEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGLVEntry::Activate(Bool_t a); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; const char*ConvertAliases(); virtual voidTObject::Copy(TObject& object) const; voidCopyItem(TTVLVEntry* dest); virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindo",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVLVEntry.html:21700,Usability,clear,clear,21700," TObject. ←; TGObject. ←; TGWindow. TQObject. ←; TGFrame. ←; TGLVEntry. ←; TTVLVEntry. Function documentation; TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode); TGTreeLVEntry constructor. ~TTVLVEntry(); TGTreeLVEntry destructor. const char * ConvertAliases(); Convert all aliases into true names. Bool_t FullConverted(); Return true if converted name is alias free. void CopyItem(TTVLVEntry* dest); Copy this item's name and alias to an other. Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Bool_t HasAlias(); Check if alias name is not empty. void PrependTilde(); Prepend a ~ to item alias. void SetItemName(const char* name); redraw this entry with new name. void SetCutType(Bool_t type = kFALSE); Set cut type. void SetExpression(const char* name, const char* alias, Bool_t cutType = kFALSE); Set the true name, alias and type of the expression, then refresh it. void Empty(); clear all names and alias. void SetToolTipText(const char* text, Long_t delayms = 1000); Set tool tip text associated with this item. The delay is in; milliseconds (minimum 250). To remove tool tip call method with text = 0. void SetSmallPic(const TGPicture* spic); Set small picture. TTVLVEntry(const TGWindow* p, const TGPicture* bigpic, const TGPicture* smallpic, TGString* name, TGString** subnames, EListViewMode ViewMode). const char * GetAlias(); {return fAlias.Data();}. TTVLVContainer * GetContainer(); {return fContainer;}. TGItemContext * GetContext(); {return fContext;}. const char * GetConvName(); {return fConvName;}. const char * GetTrueName(); {return fTrueName.Data();}. TGToolTip * GetTip(); {return fTip;}. Bool_t IsCut(); {return fIsCut;}. void SetAlias(const char* alias); {fAlias = alias;}. void SetTrueName(const char* name); {fTrueName = name;}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html604/TTVLVEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVLVEntry.html
https://root.cern/root/html604/TTVRecord.html:1159,Availability,Error,Error,1159," virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:1288,Availability,error,error,1288," virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:1372,Availability,error,error,1372," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* me",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:4053,Deployability,TOGGLE,TOGGLE,4053,", const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObje",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:115,Modifiability,inherit,inheritance,115,". TTVRecord. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTVRecord. class TTVRecord: public TObject. Function Members (Methods); public:. virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:2431,Modifiability,Inherit,InheritsFrom,2431,"px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:2497,Modifiability,Inherit,InheritsFrom,2497,"onst char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:6877,Modifiability,Inherit,Inheritance,6877,"xecuted when record is conected; TStringfXX expression and alias; TStringfXAliasX expression and alias; TStringfYY expression and alias; TStringfYAliasY expression and alias; TStringfZZ expression and alias; TStringfZAliasZ expression and alias; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TTVRecord. Function documentation; TTVRecord(); TTVRecord default constructor. void ExecuteUserCode(); Execute user-defined code. void FormFrom(TTreeViewer* tv); Populate members from treeviewer tv. void PlugIn(TTreeViewer* tv); Change treeviewer status to this record. void SaveSource(ofstream& out); Save the TTVRecord in a C++ macro file. TTVRecord(). ~TTVRecord(); {}. const char * GetX() const; {return fX;}. const char * GetY() const; {return fY;}. const char * GetZ() const; {return fZ;}. const char * GetName() const; {return fName;}. const char * GetUserCode() const; {return fUserCode;}. Bool_t HasUserCode() const; {return fUserCode.Length() != 0 ? kTRUE : kFALSE;}. Bool_t MustExecuteCode() const; {return fAutoexec;}. void SetAutoexec(Bool_t autoexec = kTRUE); {fAutoexec=autoexec;}. void SetName(const char* name = """"); {fName = name;}. void SetX(const char* x = """", const char* xal = ""-empty-""); {fX = x; fXAlias = xal;}. void SetY(const char* y = """", const char",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:7113,Modifiability,PlugIn,PlugIn,7113,"ject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. Class Charts. Inheritance Chart:. TObject. ←; TTVRecord. Function documentation; TTVRecord(); TTVRecord default constructor. void ExecuteUserCode(); Execute user-defined code. void FormFrom(TTreeViewer* tv); Populate members from treeviewer tv. void PlugIn(TTreeViewer* tv); Change treeviewer status to this record. void SaveSource(ofstream& out); Save the TTVRecord in a C++ macro file. TTVRecord(). ~TTVRecord(); {}. const char * GetX() const; {return fX;}. const char * GetY() const; {return fY;}. const char * GetZ() const; {return fZ;}. const char * GetName() const; {return fName;}. const char * GetUserCode() const; {return fUserCode;}. Bool_t HasUserCode() const; {return fUserCode.Length() != 0 ? kTRUE : kFALSE;}. Bool_t MustExecuteCode() const; {return fAutoexec;}. void SetAutoexec(Bool_t autoexec = kTRUE); {fAutoexec=autoexec;}. void SetName(const char* name = """"); {fName = name;}. void SetX(const char* x = """", const char* xal = ""-empty-""); {fX = x; fXAlias = xal;}. void SetY(const char* y = """", const char* yal = ""-empty-""); {fY = y; fYAlias = yal;}. void SetZ(const char* z = """", const char* zal = ""-empty-""); {fZ = z; fZAlias = zal;}. void SetCut(const char* cut = """", const char* cal = ""-empty-""); {fCut = cut; fCutAlias = cal;}. void SetOption(const char* op",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:2294,Security,Hash,Hash,2294,"0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUserCode() const; const char*GetX() const; const char*GetY() const; const char*GetZ() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasUserCode() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Bool_tMustExecuteCode() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:5022,Testability,Test,TestBit,5022,"_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVRecord(); TTVRecord(const TTVRecord&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:5061,Testability,Test,TestBits,5061,"_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVRecord&operator=(const TTVRecord&); virtual voidTObject::Paint(Option_t* option = """"); voidPlugIn(TTreeViewer* tv); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidSetAutoexec(Bool_t autoexec = kTRUE)TOGGLE GETTER ; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCut(const char* cut = """", const char* cal = ""-empty-""); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name = """"); static voidTObject::SetObjectStat(Bool_t stat); voidSetOption(const char* option = """"); voidSetRC(Bool_t redirect = kFALSE, Bool_t cut = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUserCode(const char* code, Bool_t autoexec = kTRUE)MENU ; voidSetX(const char* x = """", const char* xal = ""-empty-""); voidSetY(const char* y = """", const char* yal = ""-empty-""); voidSetZ(const char* z = """", const char* zal = ""-empty-""); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVRecord(); TTVRecord(const TTVRecord&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVRecord.html:619,Usability,Clear,Clear,619," virtual~TTVRecord(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteUserCode(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFormFrom(TTreeViewer* tv); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html604/TTVRecord.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVRecord.html
https://root.cern/root/html604/TTVSession.html:1210,Availability,Error,Error,1210," virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:1339,Availability,error,error,1339," virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:1423,Availability,error,error,1423,") const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) cons",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:6660,Deployability,Update,UpdateRecord,6660,"tic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance Chart:. TObject. ←; TTVSession. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent-1);}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:6696,Deployability,Update,Updates,6696,"tic TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance Chart:. TObject. ←; TTVSession. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(fCurrent-1);}. » Last changed: root/treeviewer:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:116,Modifiability,inherit,inheritance,116,". TTVSession. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TTVSession. class TTVSession: public TObject. Function Members (Methods); public:. virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:2386,Modifiability,Inherit,InheritsFrom,2386,"hod, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); ",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:2452,Modifiability,Inherit,InheritsFrom,2452,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVSession&oper",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:6160,Modifiability,Inherit,Inheritance,6160," voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Int_tfCurrentindex of current record; TClonesArray*fListlist of TV records; TStringfNamename of this session; Int_tfRecordsnumber of records; TTreeViewer*fViewerassociated tree viewer. Class Charts. Inheritance Chart:. TObject. ←; TTVSession. Function documentation; TTVSession(TTreeViewer* tv); constructor. ~TTVSession(); destructor. TTVRecord * AddRecord(Bool_t fromFile = kFALSE); add a record. TTVRecord * GetRecord(Int_t i); return record at index i. void SetRecordName(const char* name); Set record name. void RemoveLastRecord(); --- Remove current record from list. void Show(TTVRecord* rec); Display record rec. void SaveSource(ofstream& out); Save the TTVSession in a C++ macro file. void UpdateRecord(const char* name); --- Updates current record according to new X, Y, Z settings. const char * GetName() const; {return fName;}. void SetName(const char* name); {fName = name;}. TTVSession(TTreeViewer* tv). Int_t GetEntries(); {return fRecords;}. TTVRecord * GetCurrent(); {return GetRecord(fCurrent);}. TTVRecord * First(); {return GetRecord(0);}. TTVRecord * Last(); {return GetRecord(fRecords-1);}. TTVRecord * Next(); {return GetRecord(fCurrent+1);}. TTVRecord * Previous(); {return GetRecord(",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:2276,Security,Hash,Hash,2276,"ject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTVRecord*GetRecord(Int_t i); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; TTVRecord*Last(); virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; TTVRecord*Next(); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::o",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:4601,Testability,Test,TestBit,4601,"dFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVSession&operator=(const TTVSession&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); TTVRecord*Previous(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveLastRecord(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(TTVRecord* rec); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVSession(TTreeViewer* tv); TTVSession(const TTVSession&); voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:4640,Testability,Test,TestBits,4640,"dFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TTVSession&operator=(const TTVSession&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); TTVRecord*Previous(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidRemoveLastRecord(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSaveSource(ofstream& out); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); voidSetRecordName(const char* name); virtual voidTObject::SetUniqueID(UInt_t uid); voidShow(TTVRecord* rec); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTVSession(TTreeViewer* tv); TTVSession(const TTVSession&); voidUpdateRecord(const char* name); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TTVSession.html:670,Usability,Clear,Clear,670," virtual~TTVSession(); voidTObject::AbstractMethod(const char* method) const; TTVRecord*AddRecord(Bool_t fromFile = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTVRecord*First(); TTVRecord*GetCurrent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stat",MatchSource.WIKI,root/html604/TTVSession.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TTVSession.html
https://root.cern/root/html604/TUDPSocket.html:1400,Availability,Error,Error,1400," virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:1529,Availability,error,error,1529," virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:1613,Availability,error,error,1613,"method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:3752,Availability,error,error,3752,"Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendR",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13041,Availability,down,down,13041,"y of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Sen",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13350,Availability,error,error,13350,"cket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13484,Availability,error,error,13484,"on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" fiel",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13675,Availability,avail,available,13675,"a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an ackno",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13983,Availability,error,error,13983,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:14190,Availability,error,error,14190," dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:14576,Availability,error,error,14576,"d, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EP",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:14954,Availability,error,error,14954,"has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having re",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:15255,Availability,error,error,15255," been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:15816,Availability,error,error,15816,"NG); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on th",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16189,Availability,error,error,16189,"ge object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17049,Availability,error,error,17049,"ndRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17385,Availability,error,error,17385,"ss); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17675,Availability,error,error,17675,"sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containin",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17967,Availability,error,error,17967,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18376,Availability,error,error,18376," or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t al",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:19140,Availability,error,error,19140,"e mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:19183,Availability,error,error,19183,", Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::C",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:19249,Availability,error,error,19249,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:20631,Availability,error,error,20631,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:20645,Availability,error,error,20645,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:20671,Availability,error,error,20671,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:14036,Integrability,message,message,14036,"n(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:14420,Integrability,message,message,14420,". Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent and -1 in; case of error. In case the kind has been or'ed with kMESS_ACK, the call; will only return after having received an acknowledgement, making the; sending process synchronous. Int_t Send(const TMessage& mess); Send a TMessage object. Returns the number of bytes in the TMessage; that were sent and -1 in case of error. In case the TMessage::What; has been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, makin",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16463,Integrability,message,message,16463,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16500,Integrability,message,message,16500,"oBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; support for streaming TStreamerInfo added by Rene Brun May 2008; support for streaming TProcessID added by Rene Brun June 2008. Int_t SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is n",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16695,Integrability,message,message,16695,"ject(const TObject* obj, Int_t kind = kMESS_OBJECT); Send an object. Returns the number of bytes sent and -1 in case of error.; In case the ""kind"" has been or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16866,Integrability,message,message,16866,"en or'ed with kMESS_ACK, the call will only; return after having received an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:16911,Integrability,message,message,16911," an acknowledgement, making the sending; synchronous. Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. Using option kOob one can send; OOB data. Returns the number of bytes sent or -1 in case of error.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other sid",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17216,Integrability,message,message,17216,"r.; Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17268,Integrability,message,message,17268,"-5 if pipe broken or reset by peer (EPIPE || ECONNRESET). void SendStreamerInfos(const TMessage& mess); Check if TStreamerInfo must be sent. The list of TStreamerInfo of classes; in the object in the message is in the fInfos list of the message.; We send only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length byt",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17540,Integrability,message,message,17540,"end only the TStreamerInfos not yet sent on this socket. void SendProcessIDs(const TMessage& mess); Check if TProcessIDs must be sent. The list of TProcessIDs; in the object in the message is found by looking in the TMessage bits.; We send only the TProcessIDs not yet send on this socket. Int_t Recv(char* mess, Int_t max); Receive a character string message of maximum max length. The expected; message must be of type kMESS_STRING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:17883,Integrability,message,message,17883,"ING. Returns length of received string; (can be 0 if otherside of connection is closed) or -1 in case of error; or -4 in case a non-blocking socket would block (i.e. there is nothing; to be read). Int_t Recv(char* mess, Int_t max, Int_t& kind); Receive a character string message of maximum max length. Returns in; kind the message type. Returns length of received string+4 (can be 0 if; other side of connection is closed) or -1 in case of error or -4 in; case a non-blocking socket would block (i.e. there is nothing to be read). Int_t Recv(Int_t& status, Int_t& kind); Receives a status and a message type. Returns length of received; integers, 2*sizeof(Int_t) (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will b",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18626,Integrability,message,message,18626,"0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking; socket would block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and al",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18673,Integrability,message,message,18673,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18729,Integrability,message,message,18729,"ld block (i.e. there is nothing to be read). Int_t Recv(TMessage*& mess); Receive a TMessage object. The user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compres",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18833,Integrability,message,message,18833,"he user must delete the TMessage object.; Returns length of message in bytes (can be 0 if other side of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower a",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18877,Integrability,message,message,18877,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:18930,Integrability,message,message,18930,"of connection; is closed) or -1 in case of error or -4 in case a non-blocking socket; would block (i.e. there is nothing to be read) or -5 if pipe broken; or reset by peer (EPIPE || ECONNRESET). In those case mess == 0. Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If comp",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:19203,Integrability,depend,depends,19203,"); Receive a raw buffer of specified length bytes. Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build a",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:20658,Integrability,depend,depending,20658,"= 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressionLevel() const. Int_t GetCompressionSettings() const. TUDPSocket(); { }. void SetDescriptor(Int_t desc); { fSocket = desc; }. TUDPSocket& operator=(const TUDPSocket& ). Option_t * GetOption() const; { return TObject::GetOption(); }. virtual ~TUDPSocket(); { Close(); }. Int_t GetDescriptor() const; { return fSocket; }. TInetAddress GetInetAddress() const; { return fAddress; }. Int_t GetPort() const; { return fAddress.GetPort(); }. const char * GetService() const; { return fService; }. Int_t GetServType() const; { return (Int_t)fServType; }. UInt_t GetBytesSent() const; { return fBytesSent; }. UInt_t GetBytesRecv() const; { return fBytesRecv; }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TSecContext * GetS",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:116,Modifiability,inherit,inheritance,116,". TUDPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TUDPSocket. class TUDPSocket: public TNamed. TUDPSocket. This class implements UDP client sockets. A socket is an endpoint; for communication between two machines.; The actual work is done via the TSystem class (either TUnixSystem; or TWinNTSystem). Function Members (Methods); public:. virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:3157,Modifiability,Inherit,InheritsFrom,3157,"::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:3223,Modifiability,Inherit,InheritsFrom,3223,"tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operat",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:9720,Modifiability,Inherit,Inheritance,9720,"BitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUDPSocket. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(TInetAddress address, Int_t port); Create a socket. Connect to the specified port # at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been ac",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:5030,Safety,timeout,timeout,5030,"bject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13545,Safety,timeout,timeout,13545,"ocket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13795,Safety,timeout,timeout,13795,"ly. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13862,Safety,timeout,timeout,13862,"reated via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage """,MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13925,Safety,detect,detected,13925,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13942,Safety,timeout,timeout,13942,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:13964,Safety,timeout,timeout,13964,"ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(const char* mess, Int_t kind = kMESS_STRING); Send a character string buffer. Use kind to set the TMessage ""what"" field.; Returns the number of bytes in the string str that were sent",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:3047,Security,Hash,Hash,3047,"onLevel() const; Int_tGetCompressionSettings() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressGetInetAddress() const; TTimeStampGetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Int_tGetOption(ESockOptions opt, Int_t& val); Int_tGetPort() const; Int_tGetRemoteProtocol() const; TSecContext*GetSecContext() const; const char*GetService() const; Int_tGetServType() const; static ULong64_tGetSocketBytesRecv(); static ULong64_tGetSocketBytesSent(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidNetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:9250,Security,Authenticat,Authenticate,9250,"TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUDPSocket::EServiceTypekPROOFD; static TUDPSocket::EServiceTypekROOTD; static TUDPSocket::EInterestkRead; static TUDPSocket::EServiceTypekSOCKD; static TObject::(anonymous)TObject::kSingleKey; static TUDPSocket::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUDPSocket. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:9544,Security,authenticat,authentication,9544,"TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUDPSocket::EServiceTypekPROOFD; static TUDPSocket::EServiceTypekROOTD; static TUDPSocket::EInterestkRead; static TUDPSocket::EServiceTypekSOCKD; static TObject::(anonymous)TObject::kSingleKey; static TUDPSocket::EInterestkWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TInetAddressfAddressremote internet address and port #; TBitsfBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tfBytesRecvtotal bytes received over this socket; UInt_tfBytesSenttotal bytes sent using this socket; Int_tfCompressCompression level and algorithm; TTimeStampfLastUsageTime stamp of last usage; TVirtualMutex*fLastUsageMtxProtect last usage setting / reading; TInetAddressfLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tfRemoteProtocolprotocol of remote daemon; TSecContext*fSecContextafter a successful Authenticate call; TUDPSocket::EServiceTypefServTyperemote service type; TStringfServicename of service (matches remote port #); Int_tfSocketsocket descriptor; TStringTNamed::fTitleobject title; TList*fUUIDslist of TProcessIDs already sent through the socket; TStringfUrlneeds this for special authentication options; static ULong64_tfgBytesRecvtotal bytes received by all socket objects; static ULong64_tfgBytesSenttotal bytes sent by all socket objects. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUDPSocket. Function documentation; TUDPSocket(TInetAddress address, const char* service); Create a socket. Connect to the named service at address addr.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use ",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:11698,Security,authenticat,authentication,11698,"; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, const char* service); Create a socket. Connect to named service on the remote host.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* host, Int_t port); Create a socket; see CreateAuthSocket for the form of url.; Connect to the specified port # on the remote host.; If user is specified in url, try authentication as user.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns when connection has been accepted by remote side. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(const char* sockpath); Create a socket in the Unix domain on 'sockpath'.; Returns when connection has been accepted by the server. Use IsValid(); to check the validity of the socket. Every socket is added to the TROOT; sockets list which will make sure that any open sockets are properly; closed on program termination. TUDPSocket(Int_t descriptor); Create a socket. The socket will adopt previously opened TCP socket with; descriptor desc. TUDPSocket(Int_t descriptor, const char* sockpath); Create a s",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:6481,Testability,Test,TestBit,6481,"Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); TUDPSocket(const char* sockpath); TUDPSocket(Int_t descriptor); TUDPSocket(const TUDPSocket& s); TUDPSocket(TInetAddress address, const char* service); TUDPSocket(TInetAddress address, Int_t port); TUDPSocket(const char* host, const char* service); TUDPSocket(const char* host, Int_t port); TUDPSocket(Int_t descriptor, const char* sockpath); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:6520,Testability,Test,TestBits,6520,"Int_t kind = kMESS_STRING); virtual Int_tSendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidSetRemoteProtocol(Int_t rproto); voidSetSecContext(TSecContext* ctx); voidSetService(const char* service); voidSetServType(Int_t st); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); TUDPSocket(const char* sockpath); TUDPSocket(Int_t descriptor); TUDPSocket(const TUDPSocket& s); TUDPSocket(TInetAddress address, const char* service); TUDPSocket(TInetAddress address, Int_t port); TUDPSocket(const char* host, const char* service); TUDPSocket(const char* host, Int_t port); TUDPSocket(Int_t descriptor, const char* sockpath); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUDPSocket.html:818,Usability,Clear,Clear,818," virtual~TUDPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetBytesRecv() const; UInt_tGetBytesSent() const; Int_tGe",MatchSource.WIKI,root/html604/TUDPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUDPSocket.html
https://root.cern/root/html604/TUnfold.html:701,Availability,avail,available,701,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:853,Availability,error,errors,853,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:1757,Availability,error,errors,1757,"d updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in parti",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:1892,Availability,error,error,1892,"ng the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distr",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:3104,Availability,avail,available,3104,"put data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2);",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:3331,Availability,error,errors,3331,"nimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and comp",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:4937,Availability,avail,available,4937,"ctor of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias(",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:9381,Availability,Error,Error,9381,,MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:9510,Availability,error,error,9510,,MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:9594,Availability,error,error,9594,,MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:19202,Availability,error,error,19202,"ut: scale factor for the bias; TUnfold::EConstraintfConstraintInput: type of constraint to use; TArrayIfHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*fLInput: regularisation conditions; TUnfold::ERegModefRegModeInput: type of regularisation; TArrayDfSumOverYInput: sum of all columns; Double_tfTauSquaredInput: regularisation parameter; TMatrixDSparse*fVyyInput: covariance matrix for y; TMatrixD*fX0Input: x0; TArrayIfXToHistInput: matrix indices -> histogram bins; TMatrixD*fYInput: y. private:. TMatrixDSparse*fAxResult: Ax; Double_tfChi2AResult: chi**2 contribution from (y-Ax)V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfEpsMatrixmachine accuracy for eingenvalue analysis; Int_tfIgnoredBinsnumber of input bins which are dropped because they have error=0; Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixDSparse*fVyyInvResult: inverse of covariance matrix on y; TMatrixD*fXResult: x. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←. TUnfoldSys; ←. TUnfoldDensity. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Doub",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:20842,Availability,error,error,20842,"d). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:20868,Availability,error,error,20868,"d). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 from y-Ax; fChi2L: contribution to chi**2 from L*(x-x0); fDXDtauSquared: derivative of x wrt tau; fDXDAM[0,1]: matrix parts of derivative x wrt A; fDXDAZ[0,1]: vector parts of derivative x wrt A; fRhoMax: maximum global correlation coefficient; fRhoAvg: average global correlation coefficient; return code:; fRhoMax if(fRhoMax>=1.0) then the unfolding has failed!. TMatrixDSparse * MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; calculate the product of two sparse matrices; a,b: pointers to sparse matrices, where a->GetNcols()==b->GetNrows(); this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:24594,Availability,error,errors,24594,"n number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); add regularisation on the difference of two bins; left_bin: 1st bin; right_bin: 2nd bin; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documen",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:25048,Availability,error,errors,25048,"s data member fL. Int_t RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); add regularisation on the curvature through 3 bins (2nd derivative); left_bin: 1st bin; center_bin: 2nd bin; right_bin: 3rd bin; scale_left: scale factor on center-left difference; scale_right: scale factor on right-center difference; return value: number of conditions which have been skipped; modifies data member fL. Int_t RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfo",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:25302,Availability,error,errors,25302,"d::ERegMode regmode); set regulatisation on a 1-dimensional curve; start: first bin; step: distance between neighbouring bins; nbin: total number of bins; regmode: regularisation mode; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for th",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:25580,Availability,error,error,25580,"of errors (i.e. conditions which have been skipped); modifies data member fL. Int_t RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); set regularisation on a 2-dimensional grid of bins; start: first bin; step1: distance between bins in 1st direction; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given val",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:25908,Availability,error,errors,25908,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:25998,Availability,error,error,25998,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26027,Availability,error,error,26027,"n; nbin1: number of bins in 1st direction; step2: distance between bins in 2nd direction; nbin2: number of bins in 2nd direction; return value:; number of errors (i.e. conditions which have been skipped); modifies data member fL. Double_t DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); Do unfolding of an input histogram; tau_reg: regularisation parameter; input: input distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and th",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26135,Availability,error,errors,26135,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26282,Availability,error,error,26282,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26370,Availability,error,errors,26370,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:29275,Availability,error,error,29275,"_t* binMap = 0) const; get unfolding result, folded back trough the matrix; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; retreive matrix of probabilities; histmap: on which axis to arrange the input/output vector; A: histogram to store the probability matrix. void GetInput(TH1* inputData, const Int_t* binMap = 0) const; retreive input distribution; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetInputInverseEmatrix(TH2* ematrix); calculate the inverse of the contribution to the error matrix; corresponding to the input data. void GetLsquared(TH2* lsquared) const; retreive matrix of regularisation conditions squared; out: prebooked matrix. void GetL(TH2* l) const; retreive matrix of regularisation conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30347,Availability,Error,ErrorMatrixToHist,30347,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30458,Availability,error,error,30458,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30517,Availability,error,error,30517,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30547,Availability,error,error,30547,"on conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A valu",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30890,Availability,error,error,30890,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:30949,Availability,error,error,30949,"L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; get an error matrix, cumulated over several bins; ematrix: output error matrix histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; get output error matrix, cumulated over several bins; ematrix: output error matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:32340,Availability,error,error,32340,"t; get correlation coefficient matrix, cumulated over several bins; rhoij: correlation coefficient matrix histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. Double_t GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY;",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:32733,Availability,error,error,32733,"vEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatrixDSparse * GetVxx(void); { return fVxx; }. ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:689,Deployability,update,updates,689,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:2523,Energy Efficiency,reduce,reduce,2523,"surement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consisten",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:2067,Integrability,depend,depends,2067," transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus backgr",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:22787,Integrability,depend,depending,22787,"; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; a replacement for; (*dest) += f*(*src). TString GetOutputBinName(Int_t iBinX) const; given a bin number, return the name of the output bin; this method makes more sense for the class TUnfoldDnesity; where it gets overwritten. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fL: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t Reg",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:113,Modifiability,inherit,inheritance,113,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:3272,Modifiability,extend,extends,3272,"nimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and comp",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:3455,Modifiability,extend,extends,3455,"esult x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. epsilon_j = sum_i A_ij vector of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:7633,Modifiability,variab,variables,7633,"tive minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which often is found in; literature. The second derivative is often named curvature.; Sometimes the bias is not discussed, equivalent to a bias scale factor; of zero. The regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins; AddRegularisationCondition(); define an arbitrary regulatisation condition. Function Members (Methods); public:. virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b);",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:11481,Modifiability,Inherit,InheritsFrom,11481,"2* lsquared) const; virtual const char*TObject::GetName() const; Int_tGetNdf() const; voidGetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tGetNpar() const; Int_tGetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetOutput(TH1* output, const Int_t* binMap = 0) const; voidGetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tGetRhoAvg() const; Double_tGetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidGetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:11547,Modifiability,Inherit,InheritsFrom,11547,"nt_tGetNdf() const; voidGetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tGetNpar() const; Int_tGetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetOutput(TH1* output, const Int_t* binMap = 0) const; voidGetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tGetRhoAvg() const; Double_tGetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidGetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfold&operator=(const TUnfold&); virtual voidTObj",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:19654,Modifiability,Inherit,Inheritance,19654,"te:. TMatrixDSparse*fAxResult: Ax; Double_tfChi2AResult: chi**2 contribution from (y-Ax)V(y-Ax); TMatrixDSparse*fDXDAM[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDAZ[2]Result: part of derivative dx_k/dA_ij; TMatrixDSparse*fDXDYResult: derivative dx/dy; TMatrixDSparse*fDXDtauSquaredResult: derivative dx/dtau; TMatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfEpsMatrixmachine accuracy for eingenvalue analysis; Int_tfIgnoredBinsnumber of input bins which are dropped because they have error=0; Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixDSparse*fVyyInvResult: inverse of covariance matrix on y; TMatrixD*fXResult: x. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←. TUnfoldSys; ←. TUnfoldDensity. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of free",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:2363,Performance,perform,performed,2363,"ormalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:7233,Performance,tune,tuned,7233," If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; kRegModeSize minimize the size of (x-x0); kRegModeDerivative minimize the 1st derivative of (x-x0); kRegModeCurvature minimize the 2nd derivative of (x-x0). kRegModeSize is the regularisation scheme which often is found in; literature. The second derivative is often named curvature.; Sometimes the bias is not discussed, equivalent to a bias scale factor; of zero. The regularisation schemes kRegModeDerivative and; kRegModeCurvature have the nice feature that they create correlations; between x-bins, whereas the non-regularized unfolding tends to create; negative correlations between bins. For these regularisation schemes the; parameter tau could be tuned such that the correlations are smallest,; as an alternative to the L-curve method. If kRegModeSize is chosen or if x is a smooth function through all bins,; the regularisation condition can be set on all bins together by giving; the appropriate argument in the constructor (see examples above). If x is composed of independent groups of bins (for example,; signal and background binning in two variables), it may be necessary to; set regularisation conditions for the individual groups of bins.; In this case, give kRegModeNone in the constructor and specify; the bin grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regu",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:2779,Safety,detect,detector,2779,"he error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); depends on the structure of the input data; x0: bias distribution, from simulation. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. Determination of the unfolding result x:. (a) not constrained: minimisation is performed as a function of x; for fixed lambda=0; or; (b) constrained: stationary point is found as a function of x and lambda. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documentation is available here:; http://www.desy.de/~sschmitt. Note:; For most applications it is better to use the derived class; TUnfoldSys or even better TUnfoldDensity. TUnfoldSys extends the functionality of TUnfold; such that systematic errors are propagated to teh result; and that the unfolding can be done with proper background; subtraction. TUnfoldDensity extends further the functionality of TUnfoldSys; complex binning schemes are supported; The binning of input histograms is handeld consistently:; (1) the regularisation may be done by density,; i.e respecting the bin widths; (2) methods are provided which preserve the proper binning; of the result histograms. Implementation. The result of the unfolding is calculated as follows:. Lsquared = L#L regularisation conditions squared. eps",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:5577,Safety,avoid,avoid,5577," difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias; bias_default[j] = sum_i A[i][j]; x0[j] = scaleBias*bias[j]; The scale factor can be used to; (a) completely suppress the bias by setting it to zero; (b) compensate differences in the normalisation between data; and Monte Carlo. If the regularisation is strong, i.e. large parameter tau,; then the distribution x or its derivatives will look like the bias; distribution. If the parameter tau is small, the distribution x is; independent of the bias. Three basic types of regularisation are implemented in TUnfold. condition regularisation. kRegModeNone none; k",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:22887,Safety,Detect,Detector,22887,"; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. TMatrixDSparse * MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; multiply a Sparse matrix with a non-sparse matrix; a: pointer to sparse matrix; b: pointer to non-sparse matrix; this is a replacement for the call; new TMatrixDSparse(*a,TMatrixDSparse::kMult,*b);. void AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; a replacement for; (*dest) += f*(*src). TString GetOutputBinName(Int_t iBinX) const; given a bin number, return the name of the output bin; this method makes more sense for the class TUnfoldDnesity; where it gets overwritten. TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); set up unfolding matrix and initial regularisation scheme; hist_A: matrix that describes the migrations; histmap: mapping of the histogram axes to the unfolding output; regmode: global regularisation mode; constraint: type of constraint to use; data members initialized to something different from zero:; fA: filled from hist_A; fDA: filled from hist_A; fX0: filled from hist_A; fL: filled depending on the regularisation scheme; Treatment of overflow bins; Bins where the unfolding input (Detector level) is in overflow; are used for the efficiency correction. They have to be filled; properly!; Bins where the unfolding output (Generator level) is in overflow; are treated as a part of the generator level distribution.; I.e. the unfolding output could have non-zero overflow bins if the; input matrix does have such bins. ~TUnfold(void); delete all data members. void SetBias(const TH1* bias); initialize alternative bias from histogram; modifies data member fX0. Int_t RegularizeSize(int bin, Double_t scale = 1.); add regularisation on the size of bin i; bin: bin number; scale: size of the regularisation; return value: number of conditions which have been skipped; modifies data member fL. Int_t Reg",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:11371,Security,Hash,Hash,11371,"voidGetL(TH2* l) const; virtual Double_tGetLcurveX() const; virtual Double_tGetLcurveY() const; voidGetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tGetNdf() const; voidGetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tGetNpar() const; Int_tGetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetOutput(TH1* output, const Int_t* binMap = 0) const; voidGetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tGetRhoAvg() const; Double_tGetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidGetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; Double_tGetRhoMax() const; Double_tGetTau() const; virtual const char*TObject::GetTitle() const; static const char*GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:4952,Testability,test,tests,4952,"da/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias() to change the; bias distribution.; The 3rd argument to DoUnfold() is a scale factor applied to the bias",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:13507,Testability,log,logTauX,13507,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tRegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstrain",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:13530,Testability,log,logTauY,13530,"t::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tRegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tRegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tRegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tRegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tRegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstrain",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:14326,Testability,Test,TestBit,14326,"n = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tAddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tAddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidDeleteMatrix(TMatr",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:14365,Testability,Test,TestBits,14365,"n = """"); virtual Int_tScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidSetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfold(const TUnfold&); TUnfold(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tAddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tAddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidDeleteMatrix(TMatr",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:27020,Testability,log,logTauX,27020,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:27043,Testability,log,logTauY,27043,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:27227,Testability,log,logTauX,27227,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:27291,Testability,log,logTauY,27291,"non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L curve; logTauY: output spline of y-coordinates vs tau for the L curve; return value: the coordinate number (0..nPoint-1) with the ""best"" choice; of tau. void GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; get vector of normalisation factors; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetBias(TH1* bias, const Int_t* binMap = 0) const; get bias distribution, possibly with bin remapping; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underf",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:4895,Usability,simpl,simple,4895,"ctor of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias(",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:8725,Usability,Clear,Clear,8725,"grouping with calls to; RegularizeBins() specify a 1-dimensional group of bins; RegularizeBins2D() specify a 2-dimensional group of bins. Note, the class TUnfoldDensity provides an automatic setup of complex; regularisation schemes. For ultimate flexibility, the regularisation condition can be set on each; bin individually; -> give kRegModeNone in the constructor and use; RegularizeSize() regularize one bin; RegularizeDerivative() regularize the slope given by two bins; RegularizeCurvature() regularize the curvature given by three bins; AddRegularisationCondition(); define an arbitrary regulatisation condition. Function Members (Methods); public:. virtual~TUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDoUnfold(Double_t tau); Double_tDoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:19916,Usability,Clear,ClearResults,19916,"MatrixDSparse*fEResult: matrix E; TMatrixDSparse*fEinvResult: matrix E^(-1); Double_tfEpsMatrixmachine accuracy for eingenvalue analysis; Int_tfIgnoredBinsnumber of input bins which are dropped because they have error=0; Double_tfLXsquaredResult: chi**2 contribution from (x-s*x0)Lsquared(x-s*x0); Int_tfNdfResult: number of degrees of freedom; Double_tfRhoAvgResult: average global correlation; Double_tfRhoMaxResult: maximum global correlation; TMatrixDSparse*fVxxResult: covariance matrix on x; TMatrixDSparse*fVxxInvResult: inverse of covariance matrix on x; TMatrixDSparse*fVyyInvResult: inverse of covariance matrix on y; TMatrixD*fXResult: x. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←. TUnfoldSys; ←. TUnfoldDensity. Function documentation; const char * GetTUnfoldVersion(void). void InitTUnfold(void); reset all data members. void DeleteMatrix(TMatrixD** m). void DeleteMatrix(TMatrixDSparse** m). void ClearResults(void); delete old results (if any); this function is virtual, so derived classes may implement their own; method to flag results as non-valid. TUnfold(const TUnfold& ); set all matrix pointers to zero. Double_t DoUnfold(Double_t tau); main unfolding algorithm. Declared virtual, because other algorithms; could be implemented. Purpose: unfold y -> x; Data members required:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fVyy: covariance matrix for y; fL: regularisation conditions; fTauSquared: regularisation strength; fConstraint: whether the constraint is applied; Data members modified:; fVyyInv: inverse of input data covariance matrix; fNdf: number of dgerres of freedom; fEinv: inverse of the matrix needed for unfolding calculations; fE: the matrix needed for unfolding calculations; fX: unfolded data points; fDXDY: derivative of x wrt y (for error propagation); fVxx: error matrix (covariance matrix) on x; fAx: estimate of distribution y from unfolded data; fChi2A: contribution to chi**2 f",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26493,Usability,clear,cleared,26493,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:26523,Usability,Clear,ClearResults,26523,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:32657,Usability,Clear,ClearHistogram,32657,"(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatr",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfold.html:32704,Usability,clear,clear,32704,"vEmat = 0) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. Double_t GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; get global correlation coefficients with arbitrary min map; rhoi: global correlation histogram; emat: error matrix; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. return value: maximum global correlation. void ClearHistogram(TH1* h, Double_t x = 0.) const; clear histogram contents and error. void SetEpsMatrix(Double_t eps); set accuracy for matrix inversion. TUnfold(const TUnfold& ); Int_t IsNotSymmetric(TMatrixDSparse const &m) const;. TMatrixDSparse * MultiplyMSparseTranspMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const. TMatrixDSparse * InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const. TMatrixDSparse * CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const. Int_t GetNx(void). Int_t GetNy(void). const TMatrixDSparse * GetDXDY(void); { return fDXDY; }. const TMatrixDSparse * GetDXDAM(int i) const; { return fDXDAM[i]; }. const TMatrixDSparse * GetDXDAZ(int i) const; { return fDXDAZ[i]; }. const TMatrixDSparse * GetDXDtauSquared(void); { return fDXDtauSquared; }. const TMatrixDSparse * GetAx(void); { return fAx; }. const TMatrixDSparse * GetEinv(void); { return fEinv; }. const TMatrixDSparse * GetE(void); { return fE; }. const TMatrixDSparse * GetVxx(void); { return fVxx; }. ",MatchSource.WIKI,root/html604/TUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfold.html
https://root.cern/root/html604/TUnfoldBinning.html:813,Availability,avail,available,813,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:3462,Availability,Error,Error,3462,"(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; TH1*CreateHistogram(const char* histogramName, Bool_t originalAxisBinning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; static TH2D*CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); voidDecodeAxisSteering(const char* axisSteering, const char* options, Int_t* isOptionGiven) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TH1*ExtractHistogram(const char* histogramName, const TH1* globalBins, const TH2* globalBinsEmatrix = 0, Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); const TUnfoldBinning*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetBinFactor(Int_t iBin) const; const TUnfoldBinning*GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; TStringGetBinName(Int_t iBin) const; voidGetBinNeighbours(Int_t globalBin, Int_t",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:3591,Availability,error,error,3591,"ing = 0) const; TH1*CreateHistogram(const char* histogramName, Bool_t originalAxisBinning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; static TH2D*CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); voidDecodeAxisSteering(const char* axisSteering, const char* options, Int_t* isOptionGiven) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TH1*ExtractHistogram(const char* histogramName, const TH1* globalBins, const TH2* globalBinsEmatrix = 0, Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); const TUnfoldBinning*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetBinFactor(Int_t iBin) const; const TUnfoldBinning*GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; TStringGetBinName(Int_t iBin) const; voidGetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; Double_tGetBinSize(Int_t iBin) const; voidGetBinU",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:3675,Availability,error,error,3675,"nning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const; static TH2D*CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); voidDecodeAxisSteering(const char* axisSteering, const char* options, Int_t* isOptionGiven) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TH1*ExtractHistogram(const char* histogramName, const TH1* globalBins, const TH2* globalBinsEmatrix = 0, Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); const TUnfoldBinning*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetBinFactor(Int_t iBin) const; const TUnfoldBinning*GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; TStringGetBinName(Int_t iBin) const; voidGetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; Double_tGetBinSize(Int_t iBin) const; voidGetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const; const TUnf",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:801,Deployability,update,updates,801,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:12632,Deployability,Update,UpdateFirstLastBin,12632,"isListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-empty distributions; if there is none or if there are many, return zero. Int_t GetTHxxBinsRecursive(const char* axisSteering) const; input",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:12686,Deployability,update,update,12686,"isListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-empty distributions; if there is none or if there are many, return zero. Int_t GetTHxxBinsRecursive(const char* axisSteering) const; input",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:12793,Deployability,update,update,12793,"isListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-empty distributions; if there is none or if there are many, return zero. Int_t GetTHxxBinsRecursive(const char* axisSteering) const; input",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:120,Modifiability,inherit,inheritance,120,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:6393,Modifiability,Inherit,InheritsFrom,6393,"nst Double_t* x) const; Int_tGetGlobalBinNumber(Double_t x, Double_t y) const; Int_tGetGlobalBinNumber(Double_t x, Double_t y, Double_t z) const; Int_tGetGlobalBinNumber(Double_t x0, Double_t x1, Double_t x2, Double_t x3) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; const TUnfoldBinning*GetNextNode() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TUnfoldBinning*GetParentNode() const; const TUnfoldBinning*GetPrevNode() const; Int_tGetStartBin() const; Int_tGetTH1xNumberOfBins(Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:6459,Modifiability,Inherit,InheritsFrom,6459,"_t y) const; Int_tGetGlobalBinNumber(Double_t x, Double_t y, Double_t z) const; Int_tGetGlobalBinNumber(Double_t x0, Double_t x1, Double_t x2, Double_t x3) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; const TUnfoldBinning*GetNextNode() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TUnfoldBinning*GetParentNode() const; const TUnfoldBinning*GetPrevNode() const; Int_tGetStartBin() const; Int_tGetTH1xNumberOfBins(Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfoldBinning&operator=(const TUnfoldBinning&); virt",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:12491,Modifiability,Inherit,Inheritance,12491,"ic TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TUnfoldBinning*childNodefirst daughter node; TObjArray*fAxisLabelListfor each axis its name (TObjString); TObjArray*fAxisListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return ",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:12615,Modifiability,variab,variables,12615,"ie. protected:. TUnfoldBinning*childNodefirst daughter node; TObjArray*fAxisLabelListfor each axis its name (TObjString); TObjArray*fAxisListfor each axis the bin borders (TVectorD); Double_tfBinFactorConstantscale factor on user factor; TF1*fBinFactorFunctionfunction to calculate user factor from bin centres (default function is a constant); Int_tfDistributionSizenumber of bins in this node's distribution; Int_tfFirstBinglobal bin number of the first bin; Int_tfHasOverflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfHasUnderflowbit fields indicating whether there are underflow/overflow bins on the axes; Int_tfLastBinglobal bin number of the last(+1) bin; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TUnfoldBinning*nextNodenext sister; TUnfoldBinning*parentNodemother node; TUnfoldBinning*prevNodeprevious sister. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TUnfoldBinning. Function documentation; void Initialize(Int_t nBins); initialize variables. Int_t UpdateFirstLastBin(Bool_t startWithRootNode = kTRUE); update fFirstBin and fLastBin members of this node and its children; startWithRootNode: if true, start the update with the root node. ~TUnfoldBinning(void); delete all children. TUnfoldBinning * AddBinning(TUnfoldBinning* binning); add a binning as last daughter to this tree; binning: pointer to the new binning; return value: if succeeded, return ""binning""; otherwise return 0. void PrintStream(ostream& out, Int_t indent = 0) const; print some information about this binning tree; out: stream to write to; indent: initial indentation (sub-trees have indent+1). TUnfoldBinning const * FindNode(const char* name) const; parse the tree and return a node with the given name; name: the name of the node to find. TUnfoldBinning * GetRootNode(void); return root node. TUnfoldBinning const * GetRootNode(void); return root node. const TUnfoldBinning * GetNonemptyNode(void); get the node which has non-emp",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:888,Security,access,access,888,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:6283,Security,Hash,Hash,6283,"ject::GetDtorOnly(); Int_tGetEndBin() const; Int_tGetGlobalBinNumber(Double_t x) const; Int_tGetGlobalBinNumber(const Double_t* x) const; Int_tGetGlobalBinNumber(Double_t x, Double_t y) const; Int_tGetGlobalBinNumber(Double_t x, Double_t y, Double_t z) const; Int_tGetGlobalBinNumber(Double_t x0, Double_t x1, Double_t x2, Double_t x3) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; const TUnfoldBinning*GetNextNode() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TUnfoldBinning*GetParentNode() const; const TUnfoldBinning*GetPrevNode() const; Int_tGetStartBin() const; Int_tGetTH1xNumberOfBins(Bool_t originalAxisBinning = kTRUE, const char* axisSteering = 0) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:17148,Security,access,access,17148,"Create THxx histograms . TH1 * CreateHistogram(const char* histogramName, Bool_t originalAxisBinning = kFALSE, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, const Int_t* axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t ",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:17316,Security,access,access,17316,"har* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(const TUnfoldBinning* xAxis, const TUnfoldBinning* yAxis, const char* histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, const char* histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t[32] axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, const Int_t* axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. const TUnfoldBinning * GetBinLocationRecursive(Int_t& offset, const char* axisSteering, Int_t[3",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:8749,Testability,Test,TestBit,8749,"id* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfoldBinning&operator=(const TUnfoldBinning&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintStream(ostream& out, Int_t indent = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinFactorFunction(Double_t normalisation, TF1* userFunc = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldBinning(const TUnfoldBinning&); TUnfoldBinning(const char* name = 0, Int_t nBins = 0, const char* binNames = 0); TUnfoldBinning(const TAxis& axis, Int_t includeUnderflow, Int_t includeOverflow); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:8788,Testability,Test,TestBits,8788,"id* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfoldBinning&operator=(const TUnfoldBinning&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintStream(ostream& out, Int_t indent = 0) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetBinFactorFunction(Double_t normalisation, TF1* userFunc = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldBinning(const TUnfoldBinning&); TUnfoldBinning(const char* name = 0, Int_t nBins = 0, const char* binNames = 0); TUnfoldBinning(const TAxis& axis, Int_t includeUnderflow, Int_t includeOverflow); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldBinning.html:2237,Usability,Clear,Clear,2237," virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root/html604/TUnfoldBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldBinning.html
https://root.cern/root/html604/TUnfoldDensity.html:830,Availability,avail,available,830,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:1009,Availability,error,error,1009," Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly deter",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:5867,Availability,Error,Error,5867,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:5996,Availability,error,error,5996,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:6080,Availability,error,error,6080,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:16866,Availability,Error,ErrorMatrixToHist,16866,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:21676,Availability,error,error,21676,TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning sch,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:21731,Availability,error,error,21731,TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning sch,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:22225,Availability,error,errors,22225,s::ESysErrModeTUnfoldSys::kSysErrModeMatrix; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeRelative; static TUnfoldSys::ESysErrModeTUnfoldSys::kSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrix,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:22491,Availability,error,error,22491,ect::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*TUnfoldSys::fAoutsideInput: underflow/overflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins;,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:22558,Availability,error,error,22558,rflow bins; TMap*TUnfoldSys::fBgrErrScaleInInput: background sources correlated error; TMap*TUnfoldSys::fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*TUnfoldSys::fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; const TUnfoldBinning*fConstInputBinsbinning scheme for the input; const TUnfoldBinning*fConstOutputBinsbinning scheme for the output; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:22634,Availability,error,error,22634,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:23154,Availability,error,errors,23154,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:23325,Availability,error,error,23325,"trixD*TUnfoldSys::fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*TUnfoldSys::fDAinRelSqInput: normalized errors from input matrix; TMap*TUnfoldSys::fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*TUnfoldSys::fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*TUnfoldSys::fDeltaSysTauResult: systematic shift from tau; Double_tTUnfoldSys::fDtauInput: error on tau; TMatrixDSparse*TUnfoldSys::fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:818,Deployability,update,updates,818,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:3157,Integrability,depend,depend,3157,"lex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:120,Modifiability,inherit,inheritance,120,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:2999,Modifiability,variab,variable,2999,"with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determined with the help of auxillary; measurements. In TUnfoldDensity, such complex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area co",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:3134,Modifiability,variab,variable,3134,"lex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:3681,Modifiability,variab,variable,3681,"e ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation does not work well with; the tau-scan: the higher tau, the smaller rho, but there is no minimum.; In contrast, the tau-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative; correlations from migrations are approximately cancelled by the; positive correlations from the regularisation conditions. whichever algorithm is used, the output has to be checked:; (1) The L-curve should have approximate L-shape; and the final choice of tau should not be at the very edge of the; scanned region; (2) The scan result should have a well-defined",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:11668,Modifiability,Inherit,InheritsFrom,11668,"togramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetRhoIstatbgr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); TH1*GetRhoItotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); Double_tTUnfold::GetRhoMax() const; virtual Double_tGetScanVariable(Int_t mode, const char* distribution, const char* projectionMode); Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:11734,Modifiability,Inherit,InheritsFrom,11734,"jectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetRhoIstatbgr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); TH1*GetRhoItotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); Double_tTUnfold::GetRhoMax() const; virtual Double_tGetScanVariable(Int_t mode, const char* distribution, const char* projectionMode); Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfoldDensity&operator=(const TUnfoldDensity&); vi",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:23567,Modifiability,Inherit,Inheritance,23567," fAx; TMatrixDSparse*TUnfoldSys::fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfoldBinning*fOwnedInputBinsinput binning scheme if owner; TUnfoldBinning*fOwnedOutputBinsoutput binning scheme if owner; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TUnfoldBinning*fRegularisationConditionsbinning scheme for the regularisation conditions; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*TUnfoldSys::fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*TUnfoldSys::fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*TUnfoldSys::fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←; TUnfoldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:3329,Safety,predict,prediction,3329,"aves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" bins are mapped to the vector x. Choice of the regularisation. In TUnfoldDensity, two methods are implemented to determine tau**2; (1) ScanLcurve() locate the tau where the L-curve plot has a ""kink""; this function is implemented in the TUnfold class; (2) ScanTau() finds the solution such that some variable; (e.g. global correlation coefficient) is minimized; this function is implemented in the TUnfoldDensity class,; such that the variable could be made depend on the binning scheme. Each of the algorithms has its own advantages and disadvantages. The algorithm (1) does not work if the input data are too similar to the; MC prediction, that is unfolding with tau=0 gives a least-square sum; of zero. Typical no-go cases of the L-curve scan are:; (a) the number of measurements is too small (e.g. ny=nx); (b) the input data have no statistical fluctuations; [identical MC events are used to fill the matrix of migrations; and the vector y]. The algorithm (2) only works if the variable does have a real minimum; as a function of tau.; If global correlations are minimized, the situation is as follows:; The matrix of migration typically introduces negative correlations.; The area constraint introduces some positive correlation.; Regularisation on the ""size"" introduces no correlation.; Regularisation on 1st or 2nd derivatives adds positive correlations.; For this reason, ""size"" regularisation does not work well with; the tau-scan: the higher tau, the smaller rho, but there is no minimum.; In contrast, the tau-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:11558,Security,Hash,Hash,11558,":GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; TH2*GetRhoIJtotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetRhoIstatbgr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); TH1*GetRhoItotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, TH2** ematInv = 0); Double_tTUnfold::GetRhoMax() const; virtual Double_tGetScanVariable(Int_t mode, const char* distribution, const char* projectionMode); Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:1683,Testability,test,test,1683,", please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determined with the help of auxillary; measurements. In TUnfoldDensity, such complex binning schemes are handled with the help; of the class TUnfoldBinning. For each vector there is a tree; structure. The tree nodes hold multi-dimensiopnal distributions. For example, the ""measurement"" tree could have two leaves, one for; the primary distribution and one for auxillary measurements. Similarly, the ""truth"" tree could have two leaves, one for the; signal and one for the background. each of the leaves may then have a multi-dimensional distribution. The class TUnfoldBinning takes care to map all bins of the; ""measurement"" to the one-dimensional vector y.; Similarly, the ""truth"" b",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:13911,Testability,log,logTauX,13911,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:13934,Testability,log,logTauY,13934,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:14166,Testability,log,logTauXPlot,14166,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:14193,Testability,log,logTauYPlot,14193,"int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); voidRegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); virtual Int_tScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tTUnfoldSys::SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = ",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:15204,Testability,Test,TestBit,15204,":SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldDensity(const TUnfoldDensity&); TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidTUnfoldSys::ClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t*",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:15243,Testability,Test,TestBits,15243,":SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidTUnfoldSys::SetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTUnfoldSys::SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldDensity(const TUnfoldDensity&); TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidTUnfoldSys::ClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t*",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:24715,Testability,log,logTauXPlot,24715,"ldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0). TH1 * GetOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const. TH1 * GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetDeltaSysBackgroundScale(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE). TH2 * GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const c",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:24742,Testability,log,logTauYPlot,24742,"ldDensity. Function documentation; TUnfoldDensity(const TUnfoldDensity& ); empty constructor, for derived classes. ~TUnfoldDensity(void); clean up. TString GetOutputBinName(Int_t iBinX) const. TUnfoldDensity(const TUnfoldDensity& ). Double_t GetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const. TUnfoldDensity(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""). void RegularizeDistribution(TUnfold::ERegMode regmode, TUnfoldDensity::EDensityMode densityMode, const char* distribution, const char* axisSteering). Int_t ScanTau(Int_t nPoint, Double_t tauMin, Double_t tauMax, TSpline** scanResult, Int_t mode = kEScanTauRhoAvg, const char* distribution = 0, const char* projectionMode = 0, TGraph** lCurvePlot = 0, TSpline** logTauXPlot = 0, TSpline** logTauYPlot = 0). TH1 * GetOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const. TH1 * GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const. TH1 * GetDeltaSysBackgroundScale(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE). TH2 * GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const c",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:5193,Usability,Clear,Clear,5193,"u-scan is expected to work well with 1st or 2nd; derivative regularisation, because at some point the negative; correlations from migrations are approximately cancelled by the; positive correlations from the regularisation conditions. whichever algorithm is used, the output has to be checked:; (1) The L-curve should have approximate L-shape; and the final choice of tau should not be at the very edge of the; scanned region; (2) The scan result should have a well-defined minimum and the; final choice of tau should sit right in the minimum. Function Members (Methods); public:. virtual~TUnfoldDensity(); voidTObject::AbstractMethod(const char* method) const; voidTUnfoldSys::AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char*",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:6590,Usability,clear,clearHist,6590,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:7925,Usability,clear,clearEmat,7925,"t char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysSource(const char* source, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t u",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:8261,Usability,clear,clearEmat,8261,"e = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distribu",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:8360,Usability,clear,clearEmat,8360,"stogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distributionName = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); TH2*GetL(const char* histog",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:16360,Usability,Clear,ClearHistogram,16360,"nfold::ERegMode regmode = kRegModeCurvature, TUnfold::EConstraint constraint = kEConstraintArea, TUnfoldDensity::EDensityMode densityMode = kDensityModeBinWidthAndUser, const TUnfoldBinning* outputBins = 0, const TUnfoldBinning* inputBins = 0, const char* regularisationDistribution = 0, const char* regularisationAxisSteering = ""*[UOB]""); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidTUnfoldSys::ClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidTUnfoldSys::DoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; Double_tGetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSpar",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:16431,Usability,Clear,ClearResults,16431,,MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldDensity.html:17547,Usability,clear,clearEmat,17547,"uble_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidTUnfoldSys::DoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; Double_tGetDensityFactor(TUnfoldDensity::EDensityMode densityMode, Int_t iBin) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidTUnfoldSys::GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; virtual TStringGetOutputBinName(Int_t iBinX) const; Double_tTUnfold::GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; Int_tTUnfold::GetRowFromBin(int ix) const; TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixXX(); TMatrixDSparse*TUnfoldSys::GetSummedErrorMatrixYY(); const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixDSparse*TUnfold::GetVyyInv() const; const TMatrixD*TUnfold::GetX() const; TMatrixDSparse*TUnfold::InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatr",MatchSource.WIKI,root/html604/TUnfoldDensity.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldDensity.html
https://root.cern/root/html604/TUnfoldSys.html:495,Availability,error,error,495,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:527,Availability,error,errors,527,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:577,Availability,error,errors,577,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:864,Availability,avail,available,864,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:944,Availability,error,error,944,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:997,Availability,error,errors,997,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to t",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1045,Availability,error,errors,1045,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to t",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1114,Availability,error,errors,1114,"inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCL",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1273,Availability,error,error,1273,". ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas er",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1300,Availability,error,error,1300,"Unfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; pro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1347,Availability,error,error,1347," to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error mat",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1407,Availability,error,errors,1407,"nties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These s",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1450,Availability,error,errors,1450,"nties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These s",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1509,Availability,error,errors,1509,"stematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource()",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1837,Availability,error,errors,1837,"dates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. M",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1918,Availability,error,errors,1918,"rror are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatr",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:1997,Availability,error,errors,1997,"histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d)",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2038,Availability,error,errors,2038,"histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d)",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2082,Availability,error,errors,2082,"ples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2138,Availability,error,error,2138,"ples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2242,Availability,error,errors,2242," several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argu",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2350,Availability,error,error,2350," on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogra",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2371,Availability,error,error,2371,"elated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2629,Availability,error,error,2629,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2688,Availability,error,errors,2688,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2823,Availability,error,error,2823,"ror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2843,Availability,avail,available,2843,"ror(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TOb",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2868,Availability,error,error,2868,"tractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2896,Availability,error,error,2896,"tractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3154,Availability,Error,Error,3154,"by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3253,Availability,error,error,3253,"ereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfo",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3379,Availability,error,error,3379,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:4525,Availability,Error,Error,4525,,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:4654,Availability,error,error,4654,,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:4738,Availability,error,error,4738,,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:12440,Availability,Error,ErrorMatrixToHist,12440,,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16138,Availability,error,error,16138,tsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSpars,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16181,Availability,error,error,16181,tsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TUnfold::ERegModeTUnfold::kRegModeCurvature; static TUnfold::ERegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSpars,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16505,Availability,error,errors,16505,RegModeTUnfold::kRegModeDerivative; static TUnfold::ERegModeTUnfold::kRegModeMixed; static TUnfold::ERegModeTUnfold::kRegModeNone; static TUnfold::ERegModeTUnfold::kRegModeSize; static TObject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction.,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16723,Availability,error,error,16723,bject::(anonymous)TObject::kSingleKey; static TUnfoldSys::ESysErrModekSysErrModeMatrix; static TUnfoldSys::ESysErrModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgrou,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16778,Availability,error,error,16778,rModekSysErrModeRelative; static TUnfoldSys::ESysErrModekSysErrModeShift; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TMatrixDSparse*TUnfold::fAInput: matrix; TMatrixD*fAoutsideInput: underflow/overflow bins; TMap*fBgrErrScaleInInput: background sources correlated error; TMap*fBgrErrUncorrInSqInput: uncorr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + f,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:16842,Availability,error,error,16842,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:17136,Availability,error,errors,17136,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:17295,Availability,error,error,17295,"corr error squared from bgr sources; TMap*fBgrInInput: size of background sources; Double_tTUnfold::fBiasScaleInput: scale factor for the bias; TUnfold::EConstraintTUnfold::fConstraintInput: type of constraint to use; TMatrixD*fDAinColRelSqInput: normalized column err.sq. (inp.matr.); TMatrixDSparse*fDAinRelSqInput: normalized errors from input matrix; TMap*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18101,Availability,error,errors,18101," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18191,Availability,error,error,18191," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18220,Availability,error,error,18220," sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set un",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18266,Availability,error,error,18266,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18354,Availability,error,errors,18354,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18957,Availability,error,error,18957," 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:19278,Availability,error,error,19278,"nes 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:19553,Availability,error,error,19553,"s modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDS",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:19581,Availability,error,error,19581,"s modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDS",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:19803,Availability,error,errors,19803,"nfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMo",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:19968,Availability,error,errors,19968,"X, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:20125,Availability,error,error,20125,"X, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:852,Deployability,update,updates,852,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18865,Integrability,depend,depend,18865,"-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* b",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:116,Modifiability,inherit,inheritance,116,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:7981,Modifiability,Inherit,InheritsFrom,7981,"old::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tTUnfold::GetRhoAvg() const; Double_tTUnfold::GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidTUnfold::GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; voidGetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); Double_tTUnfold::GetRhoMax() const; Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:8047,Modifiability,Inherit,InheritsFrom,8047,"bject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tTUnfold::GetRhoAvg() const; Double_tTUnfold::GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidTUnfold::GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; voidGetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); Double_tTUnfold::GetRhoMax() const; Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnfoldSys&operator=(const TUnfoldSys&); virtual vo",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:17525,Modifiability,Inherit,Inheritance,17525,"p*fDeltaCorrAxResult: syst.shift from fSysIn on fAx; TMap*fDeltaCorrXResult: syst.shift from fSysIn on fX; TMatrixDSparse*fDeltaSysTauResult: systematic shift from tau; Double_tfDtauInput: error on tau; TMatrixDSparse*fEmatUncorrAxResult: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:17718,Performance,perform,performs,17718,"lt: syst.error from fDA2 on fAx; TMatrixDSparse*fEmatUncorrXResult: syst.error from fDA2 on fX; TArrayITUnfold::fHistToXInput: histogram bins -> matrix indices; TMatrixDSparse*TUnfold::fLInput: regularisation conditions; TUnfold::ERegModeTUnfold::fRegModeInput: type of regularisation; TArrayDTUnfold::fSumOverYInput: sum of all columns; TMap*fSysInInput: correlated errors; Double_tTUnfold::fTauSquaredInput: regularisation parameter; TMatrixDSparse*TUnfold::fVyyInput: covariance matrix for y; TMatrixDSparse*fVyyDataInput: error on fY prior to bgr subtraction; TMatrixD*TUnfold::fX0Input: x0; TArrayITUnfold::fXToHistInput: matrix indices -> histogram bins; TMatrixD*TUnfold::fYInput: y; TMatrixD*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~T",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18511,Performance,perform,performs,18511,"D*fYDataInput: fY prior to bgr subtraction. Class Charts. Inheritance Chart:. TObject. ←; TUnfold. ←; TUnfoldSys. ←. TUnfoldDensity. Function documentation; TUnfoldSys(const TUnfoldSys& ); set all pointers to zero. void DoBackgroundSubtraction(void); performs background subtraction; fY = fYData - fBgrIn; fVyy = fVyyData + fBgrErrUncorr^2 + fBgrErrCorr * fBgrErrCorr#; fVyyinv = fVyy^(-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2340,Security,Access,Accessing,2340," on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogra",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:2457,Security,access,accessed,2457,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:7871,Security,Hash,Hash,7871,"nt_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; Double_tTUnfold::GetRhoAvg() const; Double_tTUnfold::GetRhoI(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0) const; voidTUnfold::GetRhoIJ(TH2* rhoij, const Int_t* binMap = 0) const; voidGetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); Double_tTUnfold::GetRhoMax() const; Double_tTUnfold::GetTau() const; virtual const char*TObject::GetTitle() const; static const char*TUnfold::GetTUnfoldVersion(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:10067,Testability,log,logTauX,10067,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:10090,Testability,log,logTauY,10090,"rtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Int_tTUnfold::RegularizeBins(int start, int step, int nbin, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeBins2D(int start_bin, int step1, int nbin1, int step2, int nbin2, TUnfold::ERegMode regmode); Int_tTUnfold::RegularizeCurvature(int left_bin, int center_bin, int right_bin, Double_t scale_left = 1., Double_t scale_right = 1.); Int_tTUnfold::RegularizeDerivative(int left_bin, int right_bin, Double_t scale = 1.); Int_tTUnfold::RegularizeSize(int bin, Double_t scale = 1.); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTUnfold::ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); voidTUnfold::SetBias(const TH1* bias); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTUnfold::SetConstraint(TUnfold::EConstraint constraint); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:11061,Testability,Test,TestBit,11061,"voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtracti",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:11100,Testability,Test,TestBits,11100,"voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTUnfold::SetEpsMatrix(Double_t eps); virtual Int_tSetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); static voidTObject::SetObjectStat(Bool_t stat); voidSetTauError(Double_t delta_tau); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidSubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtracti",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3362,Usability,clear,cleared,3362,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3395,Usability,simpl,simply,3395,"rror matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); vir",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:3851,Usability,Clear,Clear,3851,"responds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tTUnfold::DoUnfold(Double_t tau); Double_tTUnfold::DoUnfold(Double_t tau, const TH1* hist_y, Double_t scaleBias = 0.); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:5127,Usability,clear,clearHist,5127,,MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:5768,Usability,clear,clearEmat,5768,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:5887,Usability,clear,clearEmat,5887,"virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:6007,Usability,clear,clearEmat,6007,"st; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:6117,Usability,clear,clearEmat,6117,"ol_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:6204,Usability,clear,clearEmat,6204," const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(T",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:6294,Usability,clear,clearEmat,6294,"hi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnf",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:11958,Usability,Clear,ClearHistogram,11958,"virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTUnfold::AddMSparse(TMatrixDSparse* dest, Double_t f, const TMatrixDSparse* src) const; Bool_tTUnfold::AddRegularisationCondition(Int_t nEle, const Int_t* indices, const Double_t* rowData); Bool_tTUnfold::AddRegularisationCondition(Int_t i0, Double_t f0, Int_t i1 = -1, Double_t f1 = 0., Int_t i2 = -1, Double_t f2 = 0.); voidTUnfold::ClearHistogram(TH1* h, Double_t x = 0.) const; virtual voidClearResults(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidGetEmatrixFromVyy(const TMatrixDS",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:13023,Usability,clear,clearEmat,13023,"s(); TMatrixDSparse*TUnfold::CreateSparseMatrix(Int_t nrow, Int_t ncol, Int_t nele, Int_t* row, Int_t* col, Double_t* data) const; static voidTUnfold::DeleteMatrix(TMatrixD** m); static voidTUnfold::DeleteMatrix(TMatrixDSparse** m); voidDoBackgroundSubtraction(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tTUnfold::DoUnfold(); voidTUnfold::ErrorMatrixToHist(TH2* ematrix, const TMatrixDSparse* emat, const Int_t* binMap, Bool_t doClear) const; const TMatrixDSparse*TUnfold::GetAx() const; Int_tTUnfold::GetBinFromRow(int ix) const; const TMatrixDSparse*TUnfold::GetDXDAM(int i) const; const TMatrixDSparse*TUnfold::GetDXDAZ(int i) const; const TMatrixDSparse*TUnfold::GetDXDtauSquared() const; const TMatrixDSparse*TUnfold::GetDXDY() const; const TMatrixDSparse*TUnfold::GetE() const; const TMatrixDSparse*TUnfold::GetEinv() const; voidGetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); Int_tTUnfold::GetNx() const; Int_tTUnfold::GetNy() const; virtual TStringTUnfold::GetOutputBinName(Int_t iBinX) const; Double_tTUnfold::GetRhoIFromMatrix(TH1* rhoi, const TMatrixDSparse* eOrig, const Int_t* binMap, TH2* invEmat) const; Int_tTUnfold::GetRowFromBin(int ix) const; TMatrixDSparse*GetSummedErrorMatrixXX(); TMatrixDSparse*GetSummedErrorMatrixYY(); const TMatrixDSparse*TUnfold::GetVxx() const; const TMatrixDSparse*TUnfold::GetVxxInv() const; const TMatrixDSparse*TUnfold::GetVyyInv() const; const TMatrixD*TUnfold::GetX() const; TMatrixDSparse*TUnfold::InvertMSparseSymmPos(const TMatrixDSparse* A, Int_t* rank) const; voidTObject::MakeZombie(); TMatrixDSparse*TUnfold::MultiplyMSparseM(const TMatrixDSparse* a, const TMatrixD* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparse(const TMatrixDSparse* a, const TMatrixDSparse* b) const; TMatrixDSparse*TUnfold::MultiplyMSparseMSparseTranspVector(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixTBase<Double_",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18816,Usability,Clear,ClearResults,18816,"-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* b",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:18836,Usability,clear,clear,18836,"-1). Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Calls the SetInput method of the base class, then renames the input; vectors fY and fVyy, then performs the background subtraction; Data members modified:; fYData,fY,fVyyData,fVyy,fVyyinvData,fVyyinv; and those modified by TUnfold::SetInput(); and those modified by DoBackgroundSubtraction(). void InitTUnfoldSys(void); initialize pointers and TMaps. ~TUnfoldSys(void); delete all data members. void ClearResults(void); clear all data members which depend on the unfolding results. void PrepareSysError(void); calculations required for syst.error; data members modified; fEmatUncorrX, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* b",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:20687,Usability,clear,clearEmat,20687,"Sparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:21240,Usability,clear,clearEmat,21240,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:21351,Usability,clear,clearEmat,21351,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:21471,Usability,clear,clearEmat,21471,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnfoldSys.html:21558,Usability,clear,clearEmat,21558,". void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1* hist_bgr, const char* name, Double_t scale = 1., Double_t scale_error = 0.). Bool_t GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0). void GetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: Tue Jun 2 16:35:15 2015 » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnfoldSys.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnfoldSys.html
https://root.cern/root/html604/TUnixSystem.html:3279,Availability,Error,Error,3279,", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidT",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:3449,Availability,error,error,3449,"har* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtu",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:3533,Availability,error,error,3533,"opyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSystem::GetBuildCompiler() const; virtual const char*TSystem::GetBuildCompilerVersion() const; virtual const char*TSystem::",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:11984,Availability,mask,mask,11984,"nst char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:13687,Availability,mask,mask,13687,"etNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnixSystem(); TUnixSystem(const TUnixSystem&); virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:19367,Availability,mask,mask,19367,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:19414,Availability,mask,mask,19414,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:19495,Availability,mask,masks,19495,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:20944,Availability,error,error,20944,"; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignal",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:22666,Availability,mask,mask,22666,"er was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Return",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23113,Availability,error,error,23113,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23566,Availability,error,error,23566,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25248,Availability,error,error,25248," system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const c",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25823,Availability,failure,failure,25823,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25910,Availability,error,error,25910,". FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file sy",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:26031,Availability,failure,failure,26031,"; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Sym",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:26998,Availability,failure,failure,26998,"e a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27134,Availability,failure,failure,27134,"ts to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the proces",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27257,Availability,failure,failure,27257,"char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27609,Availability,error,error,27609,"ee, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for c",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27959,Availability,error,error,27959," from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:28060,Availability,error,error,28060,"te a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effect",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:28096,Availability,mask,mask,28096,"essful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:28138,Availability,mask,mask,28138,"essful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the fi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:28332,Availability,error,error,28332,"pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:29284,Availability,error,error,29284,"ime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:29516,Availability,error,error,29516,"ed list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process i",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:29783,Availability,error,error,29783," the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30106,Availability,error,error,30106,"ile being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, c",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:31811,Availability,error,error,31811," of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32123,Availability,error,error,32123,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32520,Availability,error,error,32520,"ucture.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int p",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:34996,Availability,error,error,34996," scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:35073,Availability,avail,available,35073,"nounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:35357,Availability,error,error,35357,"to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoB",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:35511,Availability,error,error,35511,"indowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service on path ""kServerPath/<port>"". int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket optio",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:35873,Availability,error,error,35873,"omain service on path 'sockpath'. int AcceptConnection(int sock); Accept a connection. In case of an error return -1. In case; non-blocking I/O is enabled and no connections are available; return -2. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket. int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. Length is the size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When t",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:36296,Availability,error,error,36296," size of; the buffer. Returns the number of bytes received in buf or -1 in; case of error. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. Returns length of sent buffer; or -1 in case of error. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). Buffer; must be able to store at least length bytes. Returns the number of; bytes received (can be 0 if other side of connection was closed) or -1; in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls()",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37826,Availability,mask,masks,37826,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37964,Availability,error,error,37964,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:39622,Availability,error,error,39622,"t_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen(",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:39775,Availability,error,error,39775,"_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reu",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:39940,Availability,error,error,39940,"()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:41451,Availability,error,error,41451,"window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl a",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:41791,Availability,error,error,41791,"s; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. Returns socket fd or -1. int UnixRecv(int sock, void* buf, int len, int flag); Receive exactly length bytes into buffer. Returns number of bytes; received. Returns -1 in case of error, -2 in case of MSG_OOB; and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; and -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Retu",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:42710,Availability,error,error,42710,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:42887,Availability,error,error,42887,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:43138,Availability,error,error,43138,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:43297,Availability,error,error,43297,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:350,Integrability,interface,interface,350,". TUnixSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » UNIX; » TUnixSystem. class TUnixSystem: public TSystem. TUnixSystem. Class providing an interface to the UNIX Operating System. Function Members (Methods); public:. virtual~TUnixSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* lib); virtual voidAddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:2457,Integrability,protocol,protocol,2457,", Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock, Bool_t force = kFALSE); virtual voidCloselog(); virtual intClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); v",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:9187,Integrability,protocol,protocol,9187,"TObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intTSystem::mkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tTSystem::NextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidTSystem::NotifyApplicationCreated(); virtual TTimeNow(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intOpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidOpenlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*OpenPipe(const char* shellcmd, const char* mode); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUnixSystem&operator=(const TUnixSystem&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tTSystem::ProcessEvents(); const char*TSystem::pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(in",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:20545,Integrability,interface,interface,20545,"sion of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signa",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:26629,Integrability,depend,dependend,26629,"ists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Un",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30973,Integrability,message,message,30973,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32980,Integrability,Protocol,Protocol,32980,"t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:33170,Integrability,Protocol,Protocol,33170,"load a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a s",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:33261,Integrability,Protocol,Protocol,33261,"in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true re",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:33530,Integrability,protocol,protocol,33530,". TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms s",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:33687,Integrability,protocol,protocol,33687," dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int ConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); Connect to service servicename on server servername. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to a service on a server. Returns -1 in case; connection cannot be opened.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service.; Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int AnnounceUdpService(int port",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:38910,Integrability,depend,dependend,38910,"EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindows",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:117,Modifiability,inherit,inheritance,117,". TUnixSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » UNIX; » TUnixSystem. class TUnixSystem: public TSystem. TUnixSystem. Class providing an interface to the UNIX Operating System. Function Members (Methods); public:. virtual~TUnixSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* lib); virtual voidAddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:7711,Modifiability,Inherit,InheritsFrom,7711,"tual intGetServiceByName(const char* service); virtual char*GetServiceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* nam",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:7777,Modifiability,Inherit,InheritsFrom,7777,"viceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intT",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:17742,Modifiability,config,configure,17742,t; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TSystem::EAclicModeTSystem::kOpt; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EA,MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:20354,Modifiability,Inherit,Inheritance,20354,"ead mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handl",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:20860,Modifiability,variab,variable,20860,"lerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TUnixSystem. Function documentation; TUnixSystem(); { }. ~TUnixSystem(); Reset to original state. Bool_t Init(); Initialize Unix system interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. Copy the application pathname in gProgPath.; If name is 0 let the system set the actual executable name and path; (works on MacOS X and Linux). void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. const char * GetError(); Return system error string. const char * HostName(); Return the system's host name. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFileHandler(TFileHandler* fh); Remove a file handler from the list of file handlers. Returns; the handler or 0 if the handler was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified sig",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:24785,Modifiability,config,configured,24785,"ol_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when succes",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27460,Modifiability,variab,variables,27460,"; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Fi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:27810,Modifiability,variab,variables,27810,"stem; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Re",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30193,Modifiability,variab,variable,30193,"d); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redir",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30258,Modifiability,variab,variable,30258,"structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the fil",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30319,Modifiability,variab,variable,30319,"turned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:18359,Performance,optimiz,optimized,18359,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:19045,Performance,cache,cache,19045,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:19162,Performance,Cache,Cache,19162,"r optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:31910,Performance,Load,Load,31910,"vel and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:31984,Performance,Load,Load,31984,"vel and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32031,Performance,load,loading,32031,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32067,Performance,load,loaded,32067,"n. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname l",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32335,Performance,load,loaded,32335,"ifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetSer",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:32424,Performance,load,loaded,32424,"ed before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded and -1 in case lib does not exist; or in case of error. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. Bool_t DispatchTimers(Bool_t mode); Handle and dispatch timers. If mode = kTRUE dispatch synchronous; timers else a-synchronous timers. void AddTimer(TTimer* ti); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* ti); Remove timer from list of system timers. void ResetTimer(TTimer* ti); Reset a-sync timer. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. Returns an TInetAddress; object. To see if the hostname lookup was successfull call; TInetAddress::IsValid(). TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(in",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:42807,Performance,load,load,42807,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:42824,Performance,load,load,42824,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:42962,Performance,load,load,42962,"IPE || ECONNRESET). int UnixSend(int sock, const void* buf, int len, int flag); Send exactly length bytes from buffer. Returns -1 in case of error,; otherwise number of sent bytes. Returns -4 in case of kNoBlock and; errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; (EPIPE || ECONNRESET). void AddDynamicPath(const char* lib); Add a new directory to the dynamic path. const char * GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* lib); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Returns the path of a shared library (searches for library in the; shared library search path). If no file name extension is provided; it first tries .so, .sl, .dl and then .a (for AIX). int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. TUnixSystem(). » Author: Fons Rademakers 15/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/unix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:11161,Safety,timeout,timeout,11161,"obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(con",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:11216,Safety,timeout,timeout,11216,"ngth); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidTSystem::RemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*TSystem::RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* ti); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidTSystem::ResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer* ti); virtual voidTSystem::Run(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(c",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:15709,Safety,timeout,timeout,15709,"ptr = 0); virtual voidTSystem::DoBeep(Int_t = -1, Int_t = -1) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual const char*TSystem::ExpandFileName(const char* fname); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); TSystem*TSystem::FindHelper(const char* path, void* dirptr = 0); TString&TSystem::GetLastErrorString(); const TString&TSystem::GetLastErrorString() const; virtual const char*GetLinkedLibraries(); voidTObject::MakeZombie(); static const char*TSystem::StripOffProto(const char* path, const char* proto); static intUnixFilestat(const char* path, FileStat_t& buf); static intUnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); static const char*UnixGetdirentry(void* dir); static const char*UnixHomedirectory(const char* user = 0); static voidUnixIgnoreSignal(ESignals sig, Bool_t ignore); static intUnixMakedir(const char* name); static Long64_tUnixNow(); static void*UnixOpendir(const char* name); static intUnixRecv(int sock, void* buf, int len, int flag); static voidUnixResetSignal(ESignals sig); static voidUnixResetSignals(); static intUnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); static intUnixSend(int sock, const void* buf, int len, int flag); static intUnixSetitimer(Long_t ms); static voidUnixSigAlarmInterruptsSyscalls(Bool_t set); static voidUnixSignal(ESignals sig, SigHandler_t h); static const char*UnixSigname(ESignals sig); static intUnixTcpConnect(const char* hostname, int port, int tcpwindowsize); static intUnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); static intUnixUdpConnect(const char* hostname, int port); static intUnixUdpService(int port, int backlog); static intUnixUnixConnect(int port); static intUnixUnixConnect(const char* path); static intUnixUnixService(int port, int backlog); static intUnixUnixService(const char* sockpath, int backlog); static intUnixWaitchild().",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:22342,Safety,timeout,timeout,22342,"was not in the list of file handlers. void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void ResetSignal(ESignals sig, Bool_t reset = kTRUE); If reset is true reset the signal handler for the specified signal; to the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descri",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:22955,Safety,timeout,timeout,22955,"ers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:22997,Safety,timeout,timeout,22997,"s sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and ca",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23082,Safety,timeout,timeout,23082,"e restore previous; behaviour. void SigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23379,Safety,timeout,timeout,23379,"ed syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(voi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23451,Safety,timeout,timeout,23451,"controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:23536,Safety,timeout,timeout,23536,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25157,Safety,safe,safely,25157,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25191,Safety,avoid,avoids,25191,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:26162,Safety,avoid,avoid,26162,"ile; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int Link(const char* from, const char* to); Create a link from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Symlink(const char* from, const char* to); Create a symlink from file1 to file2. Returns 0 when successful,; -1 in case of failure. int Unlink(const char* name); Unlink,",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30592,Safety,Abort,Abort,30592,"Group_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30613,Safety,Abort,Abort,30613,"Group_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37067,Safety,timeout,timeout,37067,"eset by peer; (EPIPE || ECONNRESET). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). Returns the number of bytes sent or -1 in case of; error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). int SetSockOpt(int sock, int option, int val); Set socket option. int GetSockOpt(int sock, int option, int* val); Get socket option. void DispatchSignals(ESignals sig); Handle and dispatch signals. void UnixSignal(ESignals sig, SigHandler_t h); Set a signal handler for a signal. void UnixIgnoreSignal(ESignals sig, Bool_t ignore); If ignore is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37733,Safety,timeout,timeout,37733,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37839,Safety,timeout,timeout,37839,"re is true ignore the specified signal, else restore previous; behaviour. void UnixSigAlarmInterruptsSyscalls(Bool_t set); When the argument is true the SIGALRM signal handler is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:37933,Safety,timeout,timeout,37933,"er is set so that; interrupted syscalls will not be restarted by the kernel. This is; typically used in case one wants to put a timeout on an I/O operation.; By default interrupted syscalls will always be restarted (for all; signals). This can be controlled for each a-synchronous TTimer via; the method TTimer::SetInterruptSyscalls(). const char * UnixSigname(ESignals sig); Return the signal name associated with a signal. void UnixResetSignal(ESignals sig); Restore old signal handler for specified signal. void UnixResetSignals(); Restore old signal handlers. Long64_t UnixNow(); Get current time in milliseconds since 0:00 Jan 1 1995. int UnixSetitimer(Long_t ms); Set interval timer to time-out in ms milliseconds. int UnixSelect(Int_t nfds, TFdSet* readready, TFdSet* writeready, Long_t timeout); Wait for events on the file descriptors specified in the readready and; writeready masks or for timeout (in milliseconds) to occur. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. const char * UnixHomedirectory(const char* user = 0); Returns the user's home directory. int UnixMakedir(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * UnixOpendir(const char* name); Open a directory. const char * UnixGetdirentry(void* dir); Returns the next directory entry. int UnixFilestat(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int UnixFSstat(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsi",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:7352,Security,Hash,Hash,7352,"al char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSystem::GetObjExt() const; virtual Option_t*TObject::GetOption() const; virtual intGetPathInfo(const char* path, FileStat_t& buf); virtual TInetAddressGetPeerName(int sock); virtual intGetPid(); virtual intGetProcInfo(ProcInfo_t* info) const; virtual intGetServiceByName(const char* service); virtual char*GetServiceByPort(int port); virtual TInetAddressGetSockName(int sock); virtual intGetSockOpt(int sock, int option, int* val); virtual const char*TSystem::GetSoExt() const; virtual intGetSysInfo(SysInfo_t* info) const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetUid(const char* user = 0); virtual UInt_tTObject::GetUniqueID() const; virtual UserGroup_t*GetUserInfo(Int_t uid); virtual UserGroup_t*GetUserInfo(const char* user = 0); virtual TList*TSystem::GetVolumes(Option_t*) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual const char*HomeDirectory(const char* userName = 0); virtual const char*HostName(); virtual voidTSystem::IgnoreInterrupt(Bool_t ignore = kTRUE); virtual voidIgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); Bool_tTSystem::InControl() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tInit(); virtual voidTSystem::InnerLoop(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSystem::IsAbsoluteFileName(const char* dir); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTSystem::IsFileInIncludePath(const char* name, char** fullpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::Is",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:18468,Security,access,access,18468,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:24917,Security,secur,secure,24917,"hed. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error du",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25206,Security,secur,security,25206,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25365,Security,Access,AccessPathName,25365,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25456,Security,access,access,25456,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25490,Security,access,access,25490,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:25537,Security,access,access,25537,"ctory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:28233,Security,access,access,28233,"a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in th",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:13551,Testability,Test,TestBit,13551,"etNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnixSystem(); TUnixSystem(const TUnixSystem&); virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:13590,Testability,Test,TestBits,13590,"etNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUnixSystem(); TUnixSystem(const TUnixSystem&); virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30772,Testability,log,log,30772,"ed structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included S",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:30945,Testability,log,logging,30945,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:31009,Testability,log,log,31009,"ll are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:31058,Testability,log,log,31058," The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. const char * Getenv(const char* name); Get environment variable. void Unsetenv(const char* name); Unset environment variable. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* shellcmd, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; This function saves internally the current state into a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. Func_t DynFindSymbol(const char* module, const char* entry); dynamic linking of module. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnixSystem.html:1881,Usability,Clear,Clear,1881,"SignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* ti); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TSystem::BaseName(const char* pathname); voidTSystem::Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tTSystem::cd(const char* path); virtual Bool_tChangeDirectory(const char* path); voidCheckChilds(); Bool_tCheckDescriptors(); Bool_tCheckSignals(Bool_t sync); virtual intChmod(const char* file, UInt_t mode); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTSystem::CleanCompiledMacros(); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidCloseConnection(int sock, Bool_t force = kFALSE); virtual voidCloselog(); virtual intClosePipe(FILE* pipe); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual intTSystem::CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoP",MatchSource.WIKI,root/html604/TUnixSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnixSystem.html
https://root.cern/root/html604/TUnuran.html:4788,Availability,error,error,4788,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }. » Author: L. Moneta Tue Sep 26 16:25:09 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:3505,Deployability,continuous,continuous,3505,"opied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranEmpDist& distr, const string& method = ""empk""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN ",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:1587,Integrability,wrap,wrapper,1587,"igned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distrib",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:1886,Modifiability,Inherit,Inheritance,1886,"oubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with ",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:1899,Modifiability,Inherit,Inherited,1899,"oubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with ",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:1129,Testability,log,log,1129,". TUnuran. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuran. class TUnuran. Function Members (Methods); public:. ~TUnuran(); TRandom*GetRandom(); boolInit(const string& distr, const string& method); boolInit(const TUnuranContDist& distr, const string& method = ""auto""); boolInit(const TUnuranMultiContDist& distr, const string& method = ""hitro""); boolInit(const TUnuranDiscrDist& distr, const string& method = ""auto""); boolInit(const TUnuranEmpDist& distr, const string& method = ""empk""); boolInitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); boolInitPoisson(double mu, const string& method = ""dstd""); const string&MethodName() const; boolReInitDiscrDist(unsigned int npar, double* params); doubleSample(); intSampleDiscr(); boolSampleMulti(double* x); boolSetLogLevel(unsigned int iflag = 1); boolSetLogStream(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int l",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:2000,Testability,log,log,2000,"am(); voidSetRandom(TRandom* r); voidSetSeed(unsigned int seed); TUnuran(TRandom* r = 0, unsigned int log = 0). protected:. boolSetContDistribution(const TUnuranContDist& dist); boolSetDiscreteDistribution(const TUnuranDiscrDist& dist); boolSetEmpiricalDistribution(const TUnuranEmpDist& dist); boolSetMethodAndInit(); boolSetMultiDistribution(const TUnuranMultiContDist& dist); boolSetRandomGenerator(). private:. TUnuran&operator=(const TUnuran& rhs); TUnuran(const TUnuran&). Data Members; protected:. auto_ptr<TUnuranBaseDist>fDistpointer for distribution wrapper; UNUR_GEN*fGenpointer to the UnuRan C generator struct; stringfMethodstring representing the method; TRandom*fRngpointer to ROOT random number generator; UNUR_DISTR*fUdistrpointer to the UnuRan C distribution struct; UNUR_URNG*fUrngpointer to Unuran C random generator struct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuran(TRandom* r = 0, unsigned int log = 0); constructor implementation with a ROOT random generator; if no generator is given the ROOT default is used. ~TUnuran(); Destructor implementation. TUnuran(const TUnuran& ); Implementation of copy constructor. bool Init(const std::string & dist, const std::string & method); initialize with a string. bool Init(const TUnuranContDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranMultiContDist& distr, const string& method = ""hitro""); initialization with a distribution and method; the distribution object is copied in and managed by this class; use auto_ptr to manage previously existing distribution objects. bool Init(const TUnuranDiscrDist& distr, const string& method = ""auto""); initialization with a distribution and and generator; the distribution object is copied in and managed by this class; use auto_ptr to ma",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuran.html:4780,Testability,log,log,4780,"managed by this class; use auto_ptr to manage previously existing distribution objects. bool SetRandomGenerator(); set an external random generator. bool SetContDistribution(const TUnuranContDist& dist); internal method to set in unuran the function pointer for a continuous univariate distribution. bool SetMultiDistribution(const TUnuranMultiContDist& dist); internal method to set in unuran the function pointer for a multivariate distribution. bool SetEmpiricalDistribution(const TUnuranEmpDist& dist). bool SetDiscreteDistribution(const TUnuranDiscrDist& dist); internal method to set in unuran the function pointer for a discrete univariate distribution. bool SetMethodAndInit(). int SampleDiscr(); sample one-dimensional distribution. double Sample(); sample one-dimensional distribution. bool SampleMulti(double* x); sample multidimensional distribution. void SetSeed(unsigned int seed). bool SetLogLevel(unsigned int iflag = 1). bool InitPoisson(double mu, const string& method = ""dstd""); initializaton for a Poisson. bool InitBinomial(unsigned int ntot, double prob, const string& method = ""dstd""); initializaton for a Binomial. bool ReInitDiscrDist(unsigned int npar, double* params); re-initialization of UNURAN without freeing and creating a new fGen object; works only for pre-defined distribution by changing their parameters. void SetRandom(TRandom* r). set the random engine.; Must be called before init to have effect. TRandom * GetRandom(). return instance of the random engine used. bool SetLogStream(). set stream for log and error (not yet implemented). { return false;}. const std::string & MethodName() const. used Unuran method. { return fMethod; }. » Author: L. Moneta Tue Sep 26 16:25:09 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuran.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuran.html
https://root.cern/root/html604/TUnuranBaseDist.html:551,Availability,avail,available,551,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranBaseDist.html
https://root.cern/root/html604/TUnuranBaseDist.html:974,Modifiability,Inherit,Inheritance,974,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranBaseDist.html
https://root.cern/root/html604/TUnuranBaseDist.html:987,Modifiability,Inherit,Inherited,987,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranBaseDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranBaseDist.html
https://root.cern/root/html604/TUnuranContDist.html:2401,Integrability,interface,interfaces,2401,"LogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ←; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set t",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranContDist.html:2838,Integrability,interface,interface,2838,"on has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ←; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranContDist.html:121,Modifiability,inherit,inheritance,121,". TUnuranContDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranContDist. class TUnuranContDist: public TUnuranBaseDist. Function Members (Methods); public:. virtual~TUnuranContDist(); doubleCdf(double x) const; static TClass*Class(); virtual TUnuranContDist*Clone() const; doubleDPdf(double x) const; boolGetDomain(double& xmin, double& xmax) const; boolHasCdf() const; boolHasMode() const; boolHasPdfArea() const; virtual TClass*IsA() const; boolIsLogPdf() const; doubleMode() const; TUnuranContDist&operator=(const TUnuranContDist& rhs); doublePdf(double x) const; doublePdfArea() const; voidSetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranContDist(const TUnuranContDist&); TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; co",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranContDist.html:2144,Modifiability,Inherit,Inheritance,2144,"ContDist&); TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ←; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate th",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranContDist.html:1881,Testability,log,log,1881,"SetCdf(TF1* cdf); voidSetCdf(const ROOT::Math::IGenFunction& cdf); voidSetDomain(double xmin, double xmax); voidSetMode(double mode); voidSetPdfArea(double area); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranContDist(const TUnuranContDist&); TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false). Data Members; private:. doublefAreaarea below pdf; const ROOT::Math::IGenFunction*fCdfpointer to the cdf (cumulative dist.); const ROOT::Math::IGenFunction*fDPdfpointer to the derivative of the pdf; boolfHasAreaflag to control if distribution has a pre-computed area below the pdf; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [-inf,+inf]; boolfHasModeflag to control if distribution has a pre-computed mode; boolfIsLogPdfflag to control if function pointer represent log of pdf; doublefModemode of the distribution; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IGenFunction*fPdfpointer to the pdf; doublefXmaxupper value of the domain; doublefXminlower value of the domain. Class Charts. Inheritance Chart:. TUnuranBaseDist. ←; TUnuranContDist. Function documentation; TUnuranContDist(const ROOT::Math::IGenFunction& pdf, const ROOT::Math::IGenFunction* dpdf = 0, bool isLogPdf = false, bool copyFunc = false); Constructor from generic function interfaces; manage the functions and clone them if flag copyFunc is true. TUnuranContDist(TF1* pdf = 0, TF1* deriv = 0, bool isLogPdf = false); Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution u",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranContDist.html:4282,Testability,log,log,4282,"; Constructor from a TF1 objects; function pointers are managed by class. TUnuranContDist(const TUnuranContDist& ); Implementation of copy constructor. ~TUnuranContDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pdf(double x) const; evaluate the pdf of the distribution. double DPdf(double x) const; evaluate the derivative of the pdf; if derivative function is not given is evaluated numerically. double Cdf(double x) const; evaluate the integral (cdf) on the domain. TUnuranContDist * Clone() const. Clone (required by base class). { return new TUnuranContDist(*this); }. void SetDomain(double xmin, double xmax). Set the distribution domain. If min < max a domain is defined otherwise is undefined. void SetMode(double mode). set the distribution mode (x position of its maximum). { fMode = mode; fHasMode=true;}. void SetPdfArea(double area). set the area below the pdf. { fArea = area; fHasArea=true;}. bool GetDomain(double& xmin, double& xmax) const. check if distribution has a defined domain and return in case its domain. bool HasCdf() const. check if a cdf function is provided for the distribution. { return fCdf != 0; }. bool HasMode() const. check if distribution has a pre-computed mode. { return fHasMode; }. bool HasPdfArea() const. check if distribution has a pre-computed area below the Pdf. { return fHasArea; }. double Mode() const. return the mode (x location of maximum of the pdf). { return fMode; }. double PdfArea() const. return area below the pdf. { return fArea; }. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. » Last changed: root/unuran:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranContDist.html
https://root.cern/root/html604/TUnuranDiscrDist.html:2534,Integrability,interface,interface,2534,"e; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities; vector<double>fPVecSumVector of the sum of the probabilities; const ROOT::Math::IGenFunction*fPmfpointer to a function calculating the probability; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false); Constructor from a generic function object. TUnuranDiscrDist(TF1* func); Constructor from a TF1 objects. TUnuranDiscrDist(const TUnuranDiscrDist& ); Implementation of copy ctor using aassignment operator. ~TUnuranDiscrDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pmf(int x) const; evaluate the distribution. double Cdf(int x) const; evaluate the cumulative distribution; otherwise evaluate from the sum of the probabilities. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xmax a domain is removed. void SetMode(int mode). set the mode of the distribution (location of maximum probability). { fMode = mode; fHasMode=true;}. void SetProbSum(double sum). set the value of the sum of the probabilities in the given domain. { fSum = sum; fHasSum=true; }. bool GetDomain(int& xmin, int& xmax) const. check if distribution has domain and return in case its domain. int Mode() const. get the mode (x location of function maximum). { return fMode; }. double ProbSum",MatchSource.WIKI,root/html604/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranDiscrDist.html
https://root.cern/root/html604/TUnuranDiscrDist.html:2029,Modifiability,Inherit,Inheritance,2029,"merNVirtual_b); TUnuranDiscrDist(TF1* func); TUnuranDiscrDist(const TUnuranDiscrDist&); TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Data Members; private:. const ROOT::Math::IGenFunction*fCdfpointer to the cumulative distribution function; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [0,INT_MAX]); boolfHasModeflag to control if distribution has a pre-computed mode; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities; vector<double>fPVecSumVector of the sum of the probabilities; const ROOT::Math::IGenFunction*fPmfpointer to a function calculating the probability; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false); Constructor from a generic function object. TUnuranDiscrDist(TF1* func); Constructor from a TF1 objects. TUnuranDiscrDist(const TUnuranDiscrDist& ); Implementation of copy ctor using aassignment operator. ~TUnuranDiscrDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pmf(int x) const; evaluate the distribution. double Cdf(int x) const; evaluate the cumulative distribution; otherwise evaluate from the sum of the probabilities. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xmax a domain is removed. void SetMode(int mode)",MatchSource.WIKI,root/html604/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranDiscrDist.html
https://root.cern/root/html604/TUnuranDiscrDist.html:2042,Modifiability,Inherit,Inherited,2042,"merNVirtual_b); TUnuranDiscrDist(TF1* func); TUnuranDiscrDist(const TUnuranDiscrDist&); TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false). Data Members; private:. const ROOT::Math::IGenFunction*fCdfpointer to the cumulative distribution function; boolfHasDomainflag to control if distribution has a defined domain (otherwise is [0,INT_MAX]); boolfHasModeflag to control if distribution has a pre-computed mode; boolfHasSumflag to control if distribution has a pre-computed sum of the probabilities; intfModemode of the distribution; boolfOwnFuncflag to control if distribution owns the funcitno pointers; vector<double>fPVecVector of the probabilities; vector<double>fPVecSumVector of the sum of the probabilities; const ROOT::Math::IGenFunction*fPmfpointer to a function calculating the probability; doublefSumtotal sum of the probabilities in the given domain; intfXmaxupper value of the domain; intfXminlower value of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranDiscrDist(const ROOT::Math::IGenFunction& func, bool copyFunc = false); Constructor from a generic function object. TUnuranDiscrDist(TF1* func); Constructor from a TF1 objects. TUnuranDiscrDist(const TUnuranDiscrDist& ); Implementation of copy ctor using aassignment operator. ~TUnuranDiscrDist(); destructor implementation. void SetCdf(const ROOT::Math::IGenFunction& cdf); set cdf distribution using a generic function interface. void SetCdf(TF1* cdf); set cumulative distribution function from a TF1. double Pmf(int x) const; evaluate the distribution. double Cdf(int x) const; evaluate the cumulative distribution; otherwise evaluate from the sum of the probabilities. TUnuranDiscrDist * Clone() const. Clone (required by base class). { return new TUnuranDiscrDist(*this); }. void SetDomain(int xmin, int xmax). Set the distribution domain, by default the domain is [0,INT_MAX]; If xmin >= xmax a domain is removed. void SetMode(int mode)",MatchSource.WIKI,root/html604/TUnuranDiscrDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranDiscrDist.html
https://root.cern/root/html604/TUnuranEmpDist.html:1553,Availability,avail,available,1553,"pDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranEmpDist(const TUnuranEmpDist&); TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); Constructor from a TH1 objects.; The buffer of the histo, if available, can be used for; the estimation of the parent distribution using smoothing. TUnuranEmpDist(unsigned int n, double* x); constructor for 1D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y); constructor for 2D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); constructor for 3D unbinned data. TUnuranEmpDist(const TUnuranEmpDist& ); Implementation of copy ctor using aassignment operator. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. Return reference to data vector (unbinned or binned data). { return fData; }. bool IsBinned() const. Flag to control if data are binned. { return fBinned; }. double LowerBin() const. Min value of binned data; (return 0 for unbinned data). { return fMin; }. double UpperBin() const. upper value of binned data; (return 0 for unbinned data). { return fMax; }. unsigned int NDim()",MatchSource.WIKI,root/html604/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranEmpDist.html
https://root.cern/root/html604/TUnuranEmpDist.html:1357,Modifiability,Inherit,Inheritance,1357," TClass*Class(); virtual TUnuranEmpDist*Clone() const; const vector<double>&Data() const; virtual TClass*IsA() const; boolIsBinned() const; doubleLowerBin() const; unsigned intNDim() const; TUnuranEmpDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranEmpDist(const TUnuranEmpDist&); TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); Constructor from a TH1 objects.; The buffer of the histo, if available, can be used for; the estimation of the parent distribution using smoothing. TUnuranEmpDist(unsigned int n, double* x); constructor for 1D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y); constructor for 2D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); constructor for 3D unbinned data. TUnuranEmpDist(const TUnuranEmpDist& ); Implementation of copy ctor using aassignment operator. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. Return reference to data vector (unbinned or binned data). { return fData; }. bool IsBinned() const. Flag to control if data are binned. { return fBinned; }. double LowerBin() con",MatchSource.WIKI,root/html604/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranEmpDist.html
https://root.cern/root/html604/TUnuranEmpDist.html:1370,Modifiability,Inherit,Inherited,1370," TClass*Class(); virtual TUnuranEmpDist*Clone() const; const vector<double>&Data() const; virtual TClass*IsA() const; boolIsBinned() const; doubleLowerBin() const; unsigned intNDim() const; TUnuranEmpDist&operator=(const TUnuranEmpDist& rhs); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranEmpDist(const TUnuranEmpDist&); TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); TUnuranEmpDist(unsigned int n, double* x); TUnuranEmpDist(unsigned int n, double* x, double* y); TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); doubleUpperBin() const. Data Members; private:. boolfBinnedflag for binned/unbinned data; vector<double>fDatapointer to the data vector (used for generation from un-binned data); unsigned intfDimdata dimensionality; doublefMaxmax values (used in the binned case); doublefMinmin values (used in the binned case). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranEmpDist(const TH1* h1 = 0, bool useBuffer = true); Constructor from a TH1 objects.; The buffer of the histo, if available, can be used for; the estimation of the parent distribution using smoothing. TUnuranEmpDist(unsigned int n, double* x); constructor for 1D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y); constructor for 2D unbinned data. TUnuranEmpDist(unsigned int n, double* x, double* y, double* z); constructor for 3D unbinned data. TUnuranEmpDist(const TUnuranEmpDist& ); Implementation of copy ctor using aassignment operator. virtual ~TUnuranEmpDist(). Destructor (no operations). {}. TUnuranEmpDist * Clone() const. Clone (required by base class). { return new TUnuranEmpDist(*this); }. const std::vector<double> & Data() const. Return reference to data vector (unbinned or binned data). { return fData; }. bool IsBinned() const. Flag to control if data are binned. { return fBinned; }. double LowerBin() con",MatchSource.WIKI,root/html604/TUnuranEmpDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranEmpDist.html
https://root.cern/root/html604/TUnuranMultiContDist.html:1944,Integrability,interface,interfaces,1944,"* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array o",MatchSource.WIKI,root/html604/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html
https://root.cern/root/html604/TUnuranMultiContDist.html:1746,Modifiability,Inherit,Inheritance,1746,"&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. voi",MatchSource.WIKI,root/html604/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html
https://root.cern/root/html604/TUnuranMultiContDist.html:1759,Modifiability,Inherit,Inherited,1759,"&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. voi",MatchSource.WIKI,root/html604/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html
https://root.cern/root/html604/TUnuranMultiContDist.html:1385,Testability,log,log,1385,"uble*GetLowerDomain() const; const double*GetMode() const; const double*GetUpperDomain() const; voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; boolIsLogPdf() const; unsigned intNDim() const; TUnuranMultiContDist&operator=(const TUnuranMultiContDist& rhs); doublePdf(const double* x) const; voidSetDomain(const double* xmin, const double* xmax); voidSetMode(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranMultiContDist(const TUnuranMultiContDist&); TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false). Data Members; private:. boolfIsLogPdfflag to control if function pointer represent log of pdf; vector<double>fModevector representing the x coordinates of the maximum of the pdf; boolfOwnFuncflag to indicate if class manages the function pointers; const ROOT::Math::IMultiGenFunction*fPdfpointer to the pdf; vector<double>fXmaxvector with upper x values of the domain; vector<double>fXminvector with lower x values of the domain. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUnuranMultiContDist(const ROOT::Math::IMultiGenFunction& pdf, bool isLogPdf = false); Constructor from generic function interfaces. TUnuranMultiContDist(TF1* func = 0, unsigned int dim = 0, bool isLogPdf = false); Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivat",MatchSource.WIKI,root/html604/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html
https://root.cern/root/html604/TUnuranMultiContDist.html:3776,Testability,log,log,3776," Constructor from a TF1 objects. TUnuranMultiContDist(const TUnuranMultiContDist& ); Implementation of copy ctor using assignment operator. ~TUnuranMultiContDist(); destructor implementation. double Pdf(const double* x) const; evaluate the distribution. void Gradient(const double* x, double* grad) const; do numerical derivation and return gradient in vector grad; grad must point to a vector of at least ndim size. double Derivative(const double* x, int icoord) const; do numerical derivation of gradient using 5 point rule; use 5 point rule. TUnuranMultiContDist * Clone() const. Clone (required by base class). { return new TUnuranMultiContDist(*this); }. unsigned int NDim() const. get number of dimension of the distribution. void SetDomain(const double* xmin, const double* xmax). set the domain of the distribution giving an array of minimum and maximum values; By default otherwise the domain is undefined, i.e. is [-inf,+inf]; To remove the domain do a SetDomain(0,0).; There is no possibility to have a domain defined in only one coordinate. Use instead inf or DOUBLE_MAX to; specify un infinite domain in that coordinate. void SetMode(const double* x). set the mode of the distribution (coordinates of the distribution maximum values). const double * GetLowerDomain() const. get the distribution lower domain values. Return a null pointer if domain is not defined. const double * GetUpperDomain() const. get the distribution upper domain values. Return a null pointer if domain is not defined. const double * GetMode() const. get the mode (vector of coordinate positions of the maxima of the distribution); If a mode has not defined return a NULL pointer. bool IsLogPdf() const. flag to control if given function represent the log of a pdf. { return fIsLogPdf; }. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranMultiContDist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranMultiContDist.html
https://root.cern/root/html604/TUnuranSampler.html:1355,Availability,error,error,1355,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:1475,Availability,error,errors,1475,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:4012,Availability,error,error,4012,"ag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ←; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). {fLevel = level;}. void SetMode(double mode). set the mode. void SetArea(double area). set the area. » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:3330,Integrability,interface,interface,3330,"::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IGenFunction*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ←; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). ",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:120,Modifiability,inherit,inheritance,120,". TUnuranSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranSampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* ",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:772,Modifiability,extend,extend,772,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:913,Modifiability,extend,extend,913,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUnuranSampler.html:2942,Modifiability,Inherit,Inheritance,2942,"mpler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(const char* algo); virtual voidROOT::Math::DistSampler::DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolROOT::Math::DistSampler::IsInitialized(); const ROOT::Fit::DataRange&ROOT::Math::DistSampler::PdfRange() const. Data Members; private:. doublefAreaarea of dist; boolfDiscreteflag to indicate if the function is discrete; const ROOT::Math::IGenFunction*fFunc1D1D function pointer; boolfHasAreaflag to indicate if a area is set; boolfHasModeflag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ←; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distr",MatchSource.WIKI,root/html604/TUnuranSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html
https://root.cern/root/html604/TUploadDataSetDlg.html:440,Availability,avail,available,440,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const ",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:4450,Availability,Error,Error,4450,"const char* signal); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::G",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:4579,Availability,error,error,4579," params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:4663,Availability,error,error,4663,"(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:20350,Availability,mask,mask,20350,,MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:11238,Integrability,Message,Message,11238,"TGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidOnAppendFiles(Bool_t on); voidOnOverwriteDataset(Bool_t on); voidOnOverwriteFiles(Bool_t on); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUploadDataSetDlg&operator=(const TUploadDataSetDlg&); virtual voidTObject::Paint(Option_t* opti",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:24493,Integrability,message,messages,24493,"tonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void RemoveFile(); Remove the selected entry from the list view. void UploadDataSet(); Upload the dataset to the server. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sess",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:9821,Modifiability,Inherit,InheritsFrom,9821,"TGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() co",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:9887,Modifiability,Inherit,InheritsFrom,9887,"e::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; virtual voidTGCompositeFrame::Layout(); virtual voidTGWindow:",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:24122,Modifiability,Inherit,Inheritance,24122,"_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void Rem",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:24135,Modifiability,Inherit,Inherited,24135,"_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fAddButtonAdd >> button; TGCheckButton*fAppendFilesappend files; TGTextButton*fBrowseButtonBrowse... button; TGTextButton*fClearButtonClear button; TGTextButton*fCloseDlgButtonClose Dialog button; TGTextEntry*fDSetNamedataset name text entry; TGTextEntry*fDestinationURLdestination URL text entry; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void Rem",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:9531,Security,Hash,Hash,9531,"virtual Bool_tTGCompositeFrame::HandleDoubleClick(Event_t*); virtual Bool_tTGCompositeFrame::HandleDragDrop(TGFrame* frame, Int_t x, Int_t y, TGLayoutHints* lo); virtual Bool_tTGCompositeFrame::HandleDragEnter(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragLeave(TGFrame*); virtual Bool_tTGCompositeFrame::HandleDragMotion(TGFrame*); virtual Bool_tTGFrame::HandleEvent(Event_t* event); virtual Bool_tTGWindow::HandleExpose(Event_t* event); virtual Bool_tTGCompositeFrame::HandleFocusChange(Event_t*); virtual Bool_tTGWindow::HandleIdleEvent(TGIdleHandler*); virtual Bool_tTGMainFrame::HandleKey(Event_t* event); virtual Bool_tTGMainFrame::HandleMotion(Event_t* event); virtual Bool_tTGMainFrame::HandleSelection(Event_t* event); virtual Bool_tTGFrame::HandleSelectionClear(Event_t*); virtual Bool_tTGMainFrame::HandleSelectionRequest(Event_t* event); virtual Bool_tTGWindow::HandleTimer(TTimer*); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTGObject::Hash() const; virtual voidTGCompositeFrame::HideFrame(TGFrame* f); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTGWindow::IconifyWindow(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTGFrame::Inspect() const; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTGFrame::IsActive() const; Bool_tTGCompositeFrame::IsArranged(TGFrame* f) const; Bool_tTGCompositeFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWi",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:16232,Testability,Test,TestBit,16232,"ay); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TUploadDataSetDlg(const TUploadDataSetDlg&); TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual voidTGFrame::UnmapWindow(); voidUploadDataSet(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:16271,Testability,Test,TestBits,16271,"ay); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); voidTGMainFrame::SetMWMHints(UInt_t value, UInt_t funcs, UInt_t input); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGMainFrame::SetWindowName(const char* name = 0); voidTGMainFrame::SetWMPosition(Int_t x, Int_t y); voidTGMainFrame::SetWMSize(UInt_t w, UInt_t h); voidTGMainFrame::SetWMSizeHints(UInt_t wmin, UInt_t hmin, UInt_t wmax, UInt_t hmax, UInt_t winc, UInt_t hinc); voidTGMainFrame::SetWMState(EInitialState state); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateCoordinates(TGFrame* child, Int_t x, Int_t y, Int_t& fx, Int_t& fy); TUploadDataSetDlg(const TUploadDataSetDlg&); TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual voidTGFrame::UnmapWindow(); voidUploadDataSet(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:1697,Usability,Clear,Clear,1697,"leList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); Bool_tTGFrame::Contains(Int_t x, Int_t y) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTGFrame::Delete(Option_t* = """"); virtual voidTGFrame::DeleteWindow(); virtual voidTQObject::Destroyed()SIGNAL ; virtual voidTGWindow::DestroySubwindows(); virtual voidTGWindow::DestroyWindow(); Bool_tTQObject::Dis",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:24856,Usability,Clear,ClearFiles,24856,"y; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void RemoveFile(); Remove the selected entry from the list view. void UploadDataSet(); Upload the dataset to the server. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUploadDataSetDlg.html:24870,Usability,Clear,Clear,24870,"y; TGLVContainer*fLVContainerand its container; TGListView*fListViewdataset files list view; TGTextEntry*fLocationURLlocation URL text entry; TGCheckButton*fOverwriteDSetoverwrite DataSet; TGCheckButton*fOverwriteFilesoverwrite All Files; TGTextButton*fRemoveButtonRemove button; TList*fSkippedFilesList of skipped files; TGTextButton*fUploadButtonUpload button; Bool_tfUploading; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); Create a Upload DataSet dialog box. Used to create and upload a dataset. ~TUploadDataSetDlg(); Delete chain dialog. void CloseWindow(); Close upload dataset dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for upload dataset dialog. void AddFiles(const char* fileName); Add File name(s) from the file location URL to the list view. void AddFiles(TList* fileList); Add File name(s) from the file location URL to the list view. void BrowseFiles(); Opens the TGFileDialog to allow user to select local file(s) to be added; in the list view of dataset files. void ClearFiles(); Clear content of the list view. void OnOverwriteDataset(Bool_t on); Notification of Overwrite Dataset check button. void OnOverwriteFiles(Bool_t on); Notification of Overwrite Files check button. void OnAppendFiles(Bool_t on); Notification of Append Files check button. void RemoveFile(); Remove the selected entry from the list view. void UploadDataSet(); Upload the dataset to the server. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h). » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUploadDataSetDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html
https://root.cern/root/html604/TUri.html:1367,Availability,Error,Error,1367," virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:1496,Availability,error,error,1496," virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:1580,Availability,error,error,1580," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringG",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:13796,Availability,error,error,13796,"hority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. const TString PctEncode(const TString& source); Percent-encode and return the given string according to RFC 3986; in principle, this function cannot fail or produce an error. Bool_t IsHost(const TString& ); Returns kTRUE if string qualifies as valid host component:; host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t IsPath(const TString& ); Retruns kTRUE if string qualifies as valid path component:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t IsPathAbempty(const TString& ); Returns kTRUE if string qualifies as valid path-abempty component:; path-abempty = *( ""/"" segment ); segment = *pchar. Bool_t IsPathAbsolute(const TString& ); Returns kTRUE if string qualifies as valid path-absolute component; path-absolute = ""/"" [ segment-nz *( ""/"" segment ) ]; segment-nz = 1*pchar; segment = *pchar. Bool_t IsPathNoscheme(const TString& ); Returns kTRUE if s",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:9228,Integrability,rout,routine,9228,"_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ←; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix A. Bool_t IsRelative() const; Returns kTRUE if instance qualifies as relative-ref; relative-ref = relative-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsUri() const; Returns kTRUE if instance qualifies as URI; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; cf. Appendix A. Bool_t IsReference() const; Returns kTRUE if instance qualifies as URI-reference; URI-reference = URI / relative-ref; cf. Appendix A. Bool_t SetScheme(const TString& scheme); Set scheme component of URI:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / ""-"" / ""."" ). Bool_t IsScheme(const TString& ); Returns kTRUE if string qualifies as URI scheme:; scheme = ALPHA *( ALPHA / DIGIT / ""+"" / """,MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:110,Modifiability,inherit,inheritance,110,". TUri. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUri. class TUri: public TObject. TUri. This class represents a RFC 3986 compatible URI.; See http://rfc.net/rfc3986.html.; It provides member functions to set and return the different; the different parts of an URI. The functionality is that of; a validating parser. Function Members (Methods); public:. virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:3075,Modifiability,Inherit,InheritsFrom,3075,"ual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&); static Bool_tIsPathEmpty(const TString&); static Bool_tIsPathNoscheme(const TString&); static Bool_tIsPathRootless(const TString&); static Bool_tIsPort(const TString&); static Bool_tIsQuery(const TString&); Bool_tIsReference() const; static Bool_tIsRegName(const TString&); Bool_tIsRelative() const; static Bool_tIsR",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:3141,Modifiability,Inherit,InheritsFrom,3141,"bject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&); static Bool_tIsPathEmpty(const TString&); static Bool_tIsPathNoscheme(const TString&); static Bool_tIsPathRootless(const TString&); static Bool_tIsPort(const TString&); static Bool_tIsQuery(const TString&); Bool_tIsReference() const; static Bool_tIsRegName(const TString&); Bool_tIsRelative() const; static Bool_tIsRelativePart(const TString&); static Bool_tIsScheme(const TString&)",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:8495,Modifiability,Inherit,Inheritance,8495,"sBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ←; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' and '..' complete path segments from a; referenced path"". Bool_t IsAbsolute() const; Returns kTRUE if instance qualifies as absolute-URI; absolute-URI = scheme "":"" hier-part [ ""?"" query ]; cf. Appendix ",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:12432,Modifiability,variab,variables,12432,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:512,Security,validat,validating,512,". TUri. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUri. class TUri: public TObject. TUri. This class represents a RFC 3986 compatible URI.; See http://rfc.net/rfc3986.html.; It provides member functions to set and return the different; the different parts of an URI. The functionality is that of; a validating parser. Function Members (Methods); public:. virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:2762,Security,Hash,Hash,2762,"bject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragment() const; const TStringGetHierPart() const; const TStringGetHost() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TStringGetPath() const; const TStringGetPort() const; const TStringGetQuery() const; const TStringGetRelativePart() const; const TStringGetScheme() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const TStringGetUri() const; const TStringGetUserInfo() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasAuthority() const; Bool_tHasFragment() const; virtual ULong_tTObject::Hash() const; Bool_tHasHierPart() const; Bool_tHasHost() const; Bool_tHasPath() const; Bool_tHasPort() const; Bool_tHasQuery() const; Bool_tHasRelativePart() const; Bool_tHasScheme() const; Bool_tHasUserInfo() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsAbsolute() const; static Bool_tIsAuthority(const TString&); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; static Bool_tIsFragment(const TString&); static Bool_tIsHierPart(const TString&); static Bool_tIsHost(const TString&); static Bool_tIsIpv4(const TString&); Bool_tTObject::IsOnHeap() const; static Bool_tIsPath(const TString&); static Bool_tIsPathAbempty(const TString&); static Bool_tIsPathAbsolute(const TString&);",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:8467,Security,password,password,8467,"onst char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfFragment; Bool_tfHasFragment; Bool_tfHasHost; Bool_tfHasPath; Bool_tfHasPort; Bool_tfHasQuery; Bool_tfHasScheme; Bool_tfHasUserinfo; TStringfHostauthority/host: hostname or ip-address; TStringfPath; TStringfPortauthority/port: port number, normally 1-65535; TStringfQuery; TStringfScheme; TStringfUserinfoauthority/userinfo: user@password, ... Class Charts. Inheritance Chart:. TObject. ←; TUri. Function documentation; TUri(const TString& uri); Constructor that calls SetUri with a complete URI. TUri(const char* uri); Constructor that calls SetUri with a complete URI. TUri(const TUri& uri); TUri copy ctor. TUri & operator=(const TUri& rhs); TUri assignment operator. const TString GetUri() const; Returns the whole URI -; an implementation of chapter 5.3 component recomposition.; The result URI is composed out of the five basic parts. URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString RemoveDotSegments(const TString& ); This functions implements the ""remove_dot_segments"" routine; of chapter 5.2.4 ""for interpreting and removing the; special '.' a",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:12477,Security,validat,validates,12477,"Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsRelativePart(const TString& ); Returns kTRUE is string qualifies as relative-part:; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetRelativePart(const TString& ); Returns kTRUE is string qualifi",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:17711,Security,HasH,HasHierPart,17711,"base); Transform a URI reference into its target URI using; given a base URI.; This is an implementation of the pseudocode in chapter 5.2.2. const TString MergePaths(const TUri& reference, const TUri& base); RFC 3986, 5.3.2.; If the base URI has a defined authority component and an empty; path, then return a string consisting of ""/"" concatenated with the; reference's path; otherwise,; return a string consisting of the reference's path component; appended to all but the last segment of the base URI's path (i.e.,; excluding any characters after the right-most ""/"" in the base URI; path, or excluding the entire base URI path if it does not contain; any ""/"" characters). TUri(const TUri& uri). virtual ~TUri(); { }. const TString GetScheme() const; { return fScheme; }. const TString GetUserInfo() const; { return fUserinfo; }. const TString GetHost() const; { return fHost; }. const TString GetPort() const; { return fPort; }. const TString GetPath() const; { return fPath; }. const TString GetQuery() const; { return fQuery; }. const TString GetFragment() const; { return fFragment; }. Bool_t HasScheme() const; { return fHasScheme; }. Bool_t HasHierPart() const; { return IsHierPart(GetHierPart()); }. Bool_t HasAuthority() const; { return fHasHost; }. Bool_t HasUserInfo() const; { return fHasUserinfo; }. Bool_t HasHost() const; { return fHasHost; }. Bool_t HasPort() const; { return fHasPort; }. Bool_t HasPath() const; { return fHasPath; }. Bool_t HasQuery() const; { return fHasQuery; }. Bool_t HasFragment() const; { return fHasFragment; }. Bool_t HasRelativePart() const; { return IsRelativePart(GetRelativePart()); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Gerhard E. Bruckner 15/07/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:17883,Security,HasH,HasHost,17883,"base); Transform a URI reference into its target URI using; given a base URI.; This is an implementation of the pseudocode in chapter 5.2.2. const TString MergePaths(const TUri& reference, const TUri& base); RFC 3986, 5.3.2.; If the base URI has a defined authority component and an empty; path, then return a string consisting of ""/"" concatenated with the; reference's path; otherwise,; return a string consisting of the reference's path component; appended to all but the last segment of the base URI's path (i.e.,; excluding any characters after the right-most ""/"" in the base URI; path, or excluding the entire base URI path if it does not contain; any ""/"" characters). TUri(const TUri& uri). virtual ~TUri(); { }. const TString GetScheme() const; { return fScheme; }. const TString GetUserInfo() const; { return fUserinfo; }. const TString GetHost() const; { return fHost; }. const TString GetPort() const; { return fPort; }. const TString GetPath() const; { return fPath; }. const TString GetQuery() const; { return fQuery; }. const TString GetFragment() const; { return fFragment; }. Bool_t HasScheme() const; { return fHasScheme; }. Bool_t HasHierPart() const; { return IsHierPart(GetHierPart()); }. Bool_t HasAuthority() const; { return fHasHost; }. Bool_t HasUserInfo() const; { return fHasUserinfo; }. Bool_t HasHost() const; { return fHasHost; }. Bool_t HasPort() const; { return fHasPort; }. Bool_t HasPath() const; { return fHasPath; }. Bool_t HasQuery() const; { return fHasQuery; }. Bool_t HasFragment() const; { return fHasFragment; }. Bool_t HasRelativePart() const; { return IsRelativePart(GetRelativePart()); }. Bool_t IsSortable() const; { return kTRUE; }. » Author: Gerhard E. Bruckner 15/07/07 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:6722,Testability,Test,TestBit,6722,"static const TStringPctEncode(const TString& source); static const TStringPctNormalise(const TString& source); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static const TStringRemoveDotSegments(const TString&); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSetAuthority(const TString& authority); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tSetFragment(const TString& fragment); Bool_tSetHierPart(const TString& hier); Bool_tSetHost(const TString& host); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetPath(const TString& path); Bool_tSetPort(const TString& port); Bool_tSetQuery(const TString& path); Bool_tSetRelativePart(const TString&); Bool_tSetScheme(const TString& scheme); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetUri(const TString& uri); Bool_tSetUserInfo(const TString& userinfo); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TUriTransform(const TUri& reference, const TUri& base); TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:6761,Testability,Test,TestBits,6761,"static const TStringPctEncode(const TString& source); static const TStringPctNormalise(const TString& source); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); static const TStringRemoveDotSegments(const TString&); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSetAuthority(const TString& authority); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); Bool_tSetFragment(const TString& fragment); Bool_tSetHierPart(const TString& hier); Bool_tSetHost(const TString& host); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetPath(const TString& path); Bool_tSetPort(const TString& port); Bool_tSetQuery(const TString& path); Bool_tSetRelativePart(const TString&); Bool_tSetScheme(const TString& scheme); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetUri(const TString& uri); Bool_tSetUserInfo(const TString& userinfo); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; static TUriTransform(const TUri& reference, const TUri& base); TUri(); TUri(const TUri& uri); TUri(const TString& uri); TUri(const char* uri); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:827,Usability,Clear,Clear,827," virtual~TUri(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TStringGetAuthority() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TStringGetFragme",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUri.html:12231,Usability,simpl,simply,12231," userinfo = *( unreserved / pct-encoded / sub-delims / "":"" ); this equals to pchar without the '@' character. Bool_t SetHost(const TString& host); Set host component of URI:; RFC 3986: host = IP-literal / IPv4address / reg-name; implemented: host = IPv4address / reg-name. Bool_t SetPort(const TString& port); Set port component of URI:; port = *DIGIT. Bool_t SetPath(const TString& path); Set path component of URI:; path = path-abempty ; begins with ""/"" or is empty; / path-absolute ; begins with ""/"" but not ""//""; / path-noscheme ; begins with a non-colon segment; / path-rootless ; begins with a segment; / path-empty ; zero characters. Bool_t SetFragment(const TString& fragment); Set fragment component of URI:; fragment = *( pchar / ""/"" / ""?"" ). Bool_t IsFragment(const TString& ); Returns kTRUE if string qualifies as valid fragment component; fragment = *( pchar / ""/"" / ""?"" ). void Print(Option_t* option = """") const; Display function,; option ""d"" .. debug output; anything else .. simply print URI. void Reset(); Initialize this URI object.; Set all TString members to empty string,; set all Bool_t members to kFALSE. Bool_t SetUri(const TString& uri); Parse URI and set the member variables accordingly,; returns kTRUE if URI validates, and kFALSE otherwise:; URI = scheme "":"" hier-part [ ""?"" query ] [ ""#"" fragment ]; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetHierPart() const; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. const TString GetRelativePart() const; relative-part = ""//"" authority path-abempty; / path-absolute; / path-noscheme; / path-empty. Bool_t SetHierPart(const TString& hier); returns hier-part component of URI; hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless; / path-empty. Bool_t IsHierPart(const TString& ); Returns kTRUE if string qualifies as hier-part:. hier-part = ""//"" authority path-abempty; / path-absolute; / path-rootless",MatchSource.WIKI,root/html604/TUri.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUri.html
https://root.cern/root/html604/TUrl.html:1368,Availability,Error,Error,1368," virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:1497,Availability,error,error,1497," virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:1581,Availability,error,error,1581,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitl",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:7360,Integrability,protocol,protocols,7360,"eap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ←; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t ",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:7778,Integrability,protocol,protocols,7778,"(after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ←; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:7834,Integrability,protocol,protocols,7834,"(after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ←; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:7897,Integrability,protocol,protocol,7897,"!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ←; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been a",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:8546,Integrability,protocol,protocols,8546," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:8602,Integrability,protocol,protocols,8602," Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally speci",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:8665,Integrability,protocol,protocol,8665,"o://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Conve",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:9416,Integrability,protocol,protocol,9416,"acter string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:9896,Integrability,protocol,protocol,9896,"94, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing a",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:10143,Integrability,protocol,protocols,10143," anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { r",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:10183,Integrability,protocol,protocols,10183,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { ",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:10213,Integrability,protocol,protocol,10213,"assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) const; Returns true if the given key appears in the URL options list. void CleanRelativePath(); Recompute the path removing all relative directory jumps via '..'. TUrl(); { }. const char * GetProtocol() const; { return fProtocol; }. const char * GetUser() const; { return fUser; }. const char * GetPasswd() const; { return fPasswd; }. const char * GetHost() const; { return fHost; }. const char * GetFile() const; { return fFile; }. const char * GetAnchor() const; { ",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:110,Modifiability,inherit,inheritance,110,". TUrl. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUrl. class TUrl: public TObject. TUrl. This class represents a WWW compatible URL.; It provides member functions to return the different parts of; an URL. The supported url format is:; [proto://][user[:passwd]@]host[:port]/file.ext[#anchor][?options]. Function Members (Methods); public:. virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:2999,Modifiability,Inherit,InheritsFrom,2999,"nst char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasOption(const char* key) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:3065,Modifiability,Inherit,InheritsFrom,3065,"nst char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasOption(const char* key) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&operator=(const TUrl& rhs); virt",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:7474,Modifiability,Inherit,Inheritance,7474,"tMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfAnchoranchor in object (after #); TStringfFileremote object; TStringfFileOA!file with option and anchor; TStringfHostremote host; TStringfHostFQ!fully qualified host name; TStringfOptionsoptions/search (after ?); TMap*fOptionsMap!map containing options key/value pairs; TStringfPasswdpassword; Int_tfPortport through which to contact remote server; TStringfProtocolprotocol: http, ftp, news, root, proof, ...; TStringfUrlfull URL; TStringfUseruser name; static THashList*fgHostFQDNslist of resolved host FQDNs; static TObjArray*fgSpecialProtocolslist of special protocols; static TUrl::EStatusBitskUrlHasDefaultPort; static TUrl::EStatusBitskUrlWithDefaultPort. Class Charts. Inheritance Chart:. TObject. ←; TUrl. Function documentation; TUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://][user[:passwd]@]host[:port]/file.ext[?options][#anchor]. Known protocols: http, root, proof, ftp, news and any special protocols; defined in the rootrc Url.Special key.; The default protocol is ""http"", unless defaultIsFile is true in which; case the url is assumed to be of type ""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. ~TUrl(); Cleanup. void SetUrl(const char* url, Bool_t defaultIsFile = kFALSE); Parse url character string and split in its different subcomponents.; Use IsValid() to check if URL is legal. url: [proto://]",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:2849,Security,Hash,Hash,2849," const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const; const char*GetFileAndOptions() const; const char*GetHost() const; const char*GetHostFQDN() const; virtual const char*TObject::GetIconName() const; Int_tGetIntValueFromOptions(const char* key) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptions() const; const char*GetPasswd() const; Int_tGetPort() const; const char*GetProtocol() const; static TObjArray*GetSpecialProtocols(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl(Bool_t withDeflt = kFALSE) const; const char*GetUser() const; const char*GetValueFromOptions(const char* key) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Bool_tHasOption(const char* key) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:9780,Security,access,access,9780,"""file"".; If a passwd contains a @ it must be escaped by a \\, e.g.; ""pip@"" becomes ""pip\\@"". Default ports: http=80, root=1094, proof=1093, ftp=20, news=119.; Port #1093 has been assigned by IANA (www.iana.org) to proofd.; Port #1094 has been assigned by IANA (www.iana.org) to rootd. void FindFile(char* u, Bool_t stripDoubleSlash = kTRUE); Find file and optionally anchor and options. TUrl(const TUrl& url); TUrl copy ctor. TUrl & operator=(const TUrl& rhs); TUrl assignment operator. const char * GetUrl(Bool_t withDeflt = kFALSE) const; Return full URL. If withDflt is kTRUE, explicitly add the port even; if it matches the default value for the URL protocol. const char * GetHostFQDN() const; Return fully qualified domain name of url host. If host cannot be; resolved or not valid return the host name as originally specified. const char * GetFileAndOptions() const; Return the file and its options (the string specified behind the ?).; Convenience function useful when the option is used to pass; authetication/access information for the specified file. void SetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); Set protocol and, optionally, change the port accordingly. Int_t Compare(const TObject* obj) const; Compare two urls as strings. void Print(Option_t* option = """") const; Print URL on stdout. TObjArray * GetSpecialProtocols(); Read the list of special protocols from the rootrc files.; These protocols will be parsed in a protocol and a file part,; no host or other info will be determined. This is typically; used for legacy file descriptions like: rfio:host:/path/file.root. void ParseOptions() const; Parse URL options into a key/value map. const char * GetValueFromOptions(const char* key) const; Return a value for a given key from the URL options.; Returns 0 in case key is not found. Int_t GetIntValueFromOptions(const char* key) const; Return a value for a given key from the URL options as an Int_t,; a missing key returns -1. Bool_t HasOption(const char* key) co",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:5375,Testability,Test,TestBit,5375,"or delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&operator=(const TUrl& rhs); virtual voidTObject::Paint(Option_t* option = """"); voidParseOptions() const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAnchor(const char* anchor); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFile(const char* file); voidSetHost(const char* host); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptions(const char* opt); voidSetPasswd(const char* pw); voidSetPort(Int_t port); voidSetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url, Bool_t defaultIsFile = kFALSE); voidSetUser(const char* user); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUrl(); TUrl(const TUrl& url); TUrl(const char* url, Bool_t defaultIsFile = kFALSE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:5414,Testability,Test,TestBits,5414,"or delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TUrl&operator=(const TUrl& rhs); virtual voidTObject::Paint(Option_t* option = """"); voidParseOptions() const; virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSetAnchor(const char* anchor); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetFile(const char* file); voidSetHost(const char* host); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptions(const char* opt); voidSetPasswd(const char* pw); voidSetPort(Int_t port); voidSetProtocol(const char* proto, Bool_t setDefaultPort = kFALSE); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUrl(const char* url, Bool_t defaultIsFile = kFALSE); voidSetUser(const char* user); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TUrl(); TUrl(const TUrl& url); TUrl(const char* url, Bool_t defaultIsFile = kFALSE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUrl.html:837,Usability,Clear,Clear,837," virtual~TUrl(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanRelativePath(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetAnchor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFile() const",MatchSource.WIKI,root/html604/TUrl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUrl.html
https://root.cern/root/html604/TUUID.html:804,Integrability,Depend,Depending,804,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:6146,Integrability,interface,interface,6146,"_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:111,Modifiability,inherit,inheritance,111,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:4923,Modifiability,Inherit,Inheritance,4923,"DNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStreamerV1(TBuffer& b); TUUID(); TUUID(const char* uuid_str); TUUID(const TUUID&). protected:. Int_tCmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); voidFormat(UShort_t clockseq, TUUID::uuid_time_t ts); voidGetCurrentTime(TUUID::uuid_time_t* timestamp); voidGetNodeIdentifier(); voidGetRandomInfo(UChar_t[16] seed); voidGetSystemTime(TUUID::uuid_time_t* timestamp); voidSetFromString(const char* uuid_str). Data Members; protected:. UChar_tfClockSeqHiAndReservedhigh 6 clock bits + 2 bits reserved; UChar_tfClockSeqLowlow 8 clock bits; UChar_tfNode[6]6 node id bytes; UShort_tfTimeHiAndVersionhigh 12 time bits + 4 UUID version bits; UInt_tfTimeLow60 bit time, lower 32 bits; UShort_tfTimeMidmiddle 16 time bits; UInt_tfUUIDIndex!index in the list of UUIDs in TProcessUUID. Class Charts. Inheritance Chart:. TUUID. Function documentation; TUUID(); Create a UUID. ~TUUID(); delete this TUUID. Int_t CmpTime(TUUID::uuid_time_t* t1, TUUID::uuid_time_t* t2); Compare two time values. void SetFromString(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(const char* uuid_str); Initialize a TUUID with uuid (which must be in TUUID::AsString() format). void FillBuffer(char*& buffer); Stream UUID into output buffer. void ReadBuffer(char*& buffer); Stream UUID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns.",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:3254,Performance,perform,performance,3254," create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetUUIDNumber(UInt_t index); virtual voidShowMembers(TMemberInspector& insp) const; Int_tSizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStreamerV1(TBuffer& b); TUUID(); TUUID(const char* uuid_str); TUUID(const T",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:2014,Safety,detect,detects,2014,"id 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, a",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:2430,Safety,avoid,avoiding,2430," fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:1840,Security,Secur,Security,1840,"multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added t",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:6438,Security,Hash,Hash,6438," from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:6467,Security,hash,hash,6467," from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t[16] seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t[16] uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:2891,Testability,Log,Logically,2891,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:365,Usability,GUID,GUIDs,365,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:532,Usability,GUID,GUIDs,532,". TUUID. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TUUID. class TUUID. TUUID. This class defines a UUID (Universally Unique IDentifier), also; known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits; long, and if generated according to this algorithm, is either; guaranteed to be different from all other UUIDs/GUIDs generated; until 3400 A.D. or extremely likely to be different. UUIDs were; originally used in the Network Computing System (NCS) and; later in the Open Software Foundation's (OSF) Distributed Computing; Environment (DCE). Structure of universal unique IDs (UUIDs). Depending on the network data representation, the multi-; octet unsigned integer fields are subject to byte swapping; when communicated between dissimilar endian machines. | low 32 bits of time | 0-3 .fTimeLow; +-------------------------------+----; | mid 16 bits of time | 4-5 .fTimeMid; +; | vers. | hi 12 bits of time | 6-7 .fTimeHiAndVersion. |Res | clkSeqHi | 8 .fClockSeqHiAndReserved. | clkSeqLow | 9 .fClockSeqLow; +; | node ID | 10-15 .fNode. The adjusted time stamp is split into three fields, and the; clockSeq is split into two fields. The timestamp is a 60-bit value. For UUID version 1, this; is represented by Coordinated Universal Time (UTC/GMT) as; a count of 100-nanosecond intervals since 00:00:00.00,; 15 October 1582 (the date of Gregorian reform to the; Christian calendar). The version number is multiplexed in the 4 most significant; bits of the 'fTimeHiAndVersion' field. There are two defined; versions:; MSB <---; Version 4-Bit Code Description. | 1 0 0 0 1 DCE version, as specified herein.; | 2 0 0 1 0 DCE Security version, with; | embedded POSIX UIDs.; | 3 0 0 1 1 node id is a random value. Clock Sequence. The clock sequence value must be changed whenever:. The UU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TUUID.html:2961,Usability,clear,cleared,2961,"ock Sequence. The clock sequence value must be changed whenever:. The UUID generator detects that the local value of UTC; has gone backward; this may be due to re-syncing of the system; clock. While a node is operational, the UUID service always saves; the last UTC used to create a UUID. Each time a new UUID; is created, the current UTC is compared to the saved value; and if either the current value is less or the saved value; was lost, then the clock sequence is incremented modulo; 16,384, thus avoiding production of duplicted UUIDs. The clock sequence must be initialized to a random number; to minimize the correlation across system. This provides; maximum protection against node identifiers that may move; or switch from system to system rapidly. Clock Adjustment. UUIDs may be created at a rate greater than the system clock; resolution. Therefore, the system must also maintain an; adjustment value to be added to the lower-order bits of the; time. Logically, each time the system clock ticks, the; adjustment value is cleared. Every time a UUID is generated,; the current adjustment value is read and incremented, and; then added to the UTC time field of the UUID. Clock Overrun. The 100-nanosecond granularity of time should prove sufficient; even for bursts of UUID production in the next generation of; high-performance multiprocessors. If a system overruns the; clock adjustment by requesting too many UUIDs within a single; system clock tick, the UUID generator will stall until the; system clock catches up. Function Members (Methods); public:. virtual~TUUID(); const char*AsString() const; static TClass*Class(); Int_tCompare(const TUUID& u) const; voidFillBuffer(char*& buffer); TInetAddressGetHostAddress() const; TDatimeGetTime() const; voidGetUUID(UChar_t[16] uuid) const; UInt_tGetUUIDNumber() const; UShort_tHash() const; virtual TClass*IsA() const; TUUID&operator=(const TUUID&); voidPrint() const; voidReadBuffer(char*& buffer); voidSetUUID(const char* uuid_str); voidSetU",MatchSource.WIKI,root/html604/TUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TUUID.html
https://root.cern/root/html604/TVector2.html:1195,Availability,Error,Error,1195," virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:1324,Availability,error,error,1324," virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:1408,Availability,error,error,1408,"thod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:114,Modifiability,inherit,inheritance,114,". TVector2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector2. class TVector2: public TObject. Function Members (Methods); public:. virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:2288,Modifiability,Inherit,InheritsFrom,2288,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* ",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:2354,Modifiability,Inherit,InheritsFrom,2354,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operat",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:6453,Modifiability,Inherit,Inheritance,6453,"const; Double_tY() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Double_tfXcomponents of the vector; Double_tfY. Class Charts. Inheritance Chart:. TObject. ←; TVector2. Function documentation; TVector2(); constructor. TVector2(Double_t* s); constructor. TVector2(Double_t x0, Double_t y0); constructor. ~TVector2(). Double_t Mod() const; return modulo of this vector. TVector2 Unit() const; return module normalized to 1. Double_t Phi() const; return vector phi. Double_t Phi_0_2pi(Double_t x); (static function) returns phi angle in the interval [0,2*PI). Double_t Phi_mpi_pi(Double_t x); (static function) returns phi angle in the interval [-PI,PI). TVector2 Rotate(Double_t phi) const; rotation by phi. void SetMagPhi(Double_t mag, Double_t phi); set vector using mag and phi. void Streamer(TBuffer& ); Stream an object of class TVector2. void Print(Option_t* option = """") const; print vector parameters. Double_t DeltaPhi(const TVector2& v) const; { return Phi_mpi_pi(Phi()-v.Phi()); }. TVector2 Ort() const; { return Unit(); }. TVector2 Proj(const TVector2& v) const; { return v*(((*this)*v)/v.Mod2()); }. TVector2 Norm(const TVect",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:2178,Security,Hash,Hash,2178,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; Double_tMod() const; Double_tMod2() const; TVector2Norm(const TVector2& v) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator ",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:4967,Testability,Test,TestBit,4967,"nst TVector2& v); TVector2&operator-=(const TVector2& v); TVector2&operator/=(Double_t s); TVector2&operator=(const TVector2& v); TVector2Ort() const; virtual voidTObject::Paint(Option_t* option = """"); Double_tPhi() const; static Double_tPhi_0_2pi(Double_t x); static Double_tPhi_mpi_pi(Double_t x); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; TVector2Proj(const TVector2& v) const; Double_tPx() const; Double_tPy() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVector2Rotate(Double_t phi) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TVector2& v); voidSet(Double_t x0, Double_t y0); voidSet(float x0, float y0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMagPhi(Double_t mag, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t x0); voidSetY(Double_t y0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2(); TVector2(Double_t* s); TVector2(const TVector2&); TVector2(Double_t x0, Double_t y0); TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const.",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:5006,Testability,Test,TestBits,5006,"nst TVector2& v); TVector2&operator-=(const TVector2& v); TVector2&operator/=(Double_t s); TVector2&operator=(const TVector2& v); TVector2Ort() const; virtual voidTObject::Paint(Option_t* option = """"); Double_tPhi() const; static Double_tPhi_0_2pi(Double_t x); static Double_tPhi_mpi_pi(Double_t x); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; TVector2Proj(const TVector2& v) const; Double_tPx() const; Double_tPy() const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); TVector2Rotate(Double_t phi) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidSet(const TVector2& v); voidSet(Double_t x0, Double_t y0); voidSet(float x0, float y0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMagPhi(Double_t mag, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t x0); voidSetY(Double_t y0); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVector2(); TVector2(Double_t* s); TVector2(const TVector2&); TVector2(Double_t x0, Double_t y0); TVector2Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const.",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector2.html:612,Usability,Clear,Clear,612," virtual~TVector2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector2& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOpti",MatchSource.WIKI,root/html604/TVector2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector2.html
https://root.cern/root/html604/TVector3.html:5386,Availability,Error,Error,5386,"d) const; Double_tAngle(const TVector3&) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetX",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:5566,Availability,error,error,5566,"t char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:5650,Availability,error,error,5650,"al TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual B",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:114,Modifiability,inherit,inheritance,114,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;   TVector3 v1;        //; v1 = (0,0,0);   TVector3 v3(1,2,3); // v3 = (1,2,3);   TVector3 v4(v2);    // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;   xx = v1.X();    or    xx =; v1(0);;   yy = v1.Y();         ; yy = v1(1);;   zz = v1.Z();         ; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;   v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;   v1.SetXYZ(1.,2.,3.);;  . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;   Double_t m  = v.Ma",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:979,Modifiability,variab,variables,979,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;   TVector3 v1;        //; v1 = (0,0,0);   TVector3 v3(1,2,3); // v3 = (1,2,3);   TVector3 v4(v2);    // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;   xx = v1.X();    or    xx =; v1(0);;   yy = v1.Y();         ; yy = v1(1);;   zz = v1.Z();         ; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;   v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;   v1.SetXYZ(1.,2.,3.);;  . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;   Double_t m  = v.Ma",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:6601,Modifiability,Inherit,InheritsFrom,6601,"TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:6667,Modifiability,Inherit,InheritsFrom,6667,"dTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_top",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:11521,Modifiability,Inherit,Inheritance,11521,"; Double_tz() const; Double_tZ() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_tfX; Double_tfY; Double_tfZ. Class Charts. Inheritance Chart:. TObject. ←; TVector3. Function documentation; TVector3(); {}. TVector3(const TVector3& ); {}. TVector3(Double_t x, Double_t y, Double_t z); {}. TVector3(const Double_t* ); {}. TVector3(const Float_t* ); {}. ~TVector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vecto",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:892,Security,Access,Access,892,". TVector3. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TVector3. class TVector3: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; *. . TVector3; TVector3 is a general three vector class, which can be used for; the description of different vectors in 3D. Declaration / Access to the components; TVector3 has been implemented as a vector of three Double_t; variables, representing the cartesian coordinates. By default all components; are initialized to zero:;   TVector3 v1;        //; v1 = (0,0,0);   TVector3 v3(1,2,3); // v3 = (1,2,3);   TVector3 v4(v2);    // v4 = v2; It is also possible (but not recommended) to initialize a TVector3; with a Double_t or Float_t C array.; You can get the basic components either by name or by index using operator():;   xx = v1.X();    or    xx =; v1(0);;   yy = v1.Y();         ; yy = v1(1);;   zz = v1.Z();         ; zz = v1(2);; The memberfunctions SetX(), SetY(), SetZ(); and SetXYZ() allow to set the components:;   v1.SetX(1.); v1.SetY(2.); v1.SetZ(3.);;   v1.SetXYZ(1.,2.,3.);;  . Noncartesian coordinates; To get information on the TVector3 in spherical (rho,phi,theta); or cylindrical (z,r,theta) coordinates, the; the member functions Mag() (=magnitude=rho in spherical coordinates),; Mag2(), Theta(), CosTheta(), Phi(),; Perp() (the transverse component=r in cylindrical coordinates),; Perp2() can be used:;   Double_t m  = v.Ma",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:6491,Security,Hash,Hash,6491,"tual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; Double_tMag() const; Double_tMag2() const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TOb",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:9846,Testability,Test,TestBit,9846," voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidRotate(Double_t, const TVector3&); voidRotateUz(const TVector3&); voidRotateX(Double_t); voidRotateY(Double_t); voidRotateZ(Double_t); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMag(Double_t); voidSetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t); voidSetPhi(Double_t); voidSetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); voidSetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); voidSetTheta(Double_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t); voidSetXYZ(Double_t x, Double_t y, Double_t z); voidSetY(Double_t); voidSetZ(Double_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TVector3&Transform(const TRotation&); TVector3(); TVector3(const Double_t*); TVector3(const Float_t*); TVector3(const TVector3&); TVector3(Double_t x, Double_t y, Double_t z); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const.",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:9885,Testability,Test,TestBits,9885," voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); voidRotate(Double_t, const TVector3&); voidRotateUz(const TVector3&); voidRotateX(Double_t); voidRotateY(Double_t); voidRotateZ(Double_t); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMag(Double_t); voidSetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); static voidTObject::SetObjectStat(Bool_t stat); voidSetPerp(Double_t); voidSetPhi(Double_t); voidSetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); voidSetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); voidSetTheta(Double_t); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetX(Double_t); voidSetXYZ(Double_t x, Double_t y, Double_t z); voidSetY(Double_t); voidSetZ(Double_t); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Double_tTheta() const; TVector3&Transform(const TRotation&); TVector3(); TVector3(const Double_t*); TVector3(const Float_t*); TVector3(const TVector3&); TVector3(Double_t x, Double_t y, Double_t z); TVector3Unit() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tx() const; Double_tX() const; TVector2XYvector() const; Double_ty() const; Double_tY() const; Double_tz() const; Double_tZ() const.",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:12731,Testability,log,log,12731,"ector3(); {}. TVector3 & Transform(const TRotation& ); transform this vector with a TRotation. Double_t Angle(const TVector3& ) const; return the angle w.r.t. another 3-vector. Double_t Mag() const; return the magnitude (rho in spherical coordinate system). Double_t Perp() const; return the transverse component (R in cylindrical coordinate system). Double_t Perp(const TVector3& ) const; return the transverse component (R in cylindrical coordinate system). Double_t Phi() const; return the azimuth angle. returns phi from -pi to pi. Double_t Theta() const; return the polar angle. TVector3 Unit() const; return unit vector parallel to this. void RotateX(Double_t ); rotate vector around X. void RotateY(Double_t ); rotate vector around Y. void RotateZ(Double_t ); rotate vector around Z. void Rotate(Double_t , const TVector3& ); rotate vector. void RotateUz(const TVector3& ); NewUzVector must be normalized !. Double_t PseudoRapidity() const; Double_t m = Mag();; return 0.5*log( (m+fZ)/(m-fZ) );; guard against Pt=0. void SetPtEtaPhi(Double_t pt, Double_t eta, Double_t phi); set Pt, Eta and Phi. void SetPtThetaPhi(Double_t pt, Double_t theta, Double_t phi); set Pt, Theta and Phi. void SetTheta(Double_t ); Set theta keeping mag and phi constant (BaBar). void SetPhi(Double_t ); Set phi keeping mag and theta constant (BaBar). Double_t DeltaR(const TVector3& ) const; return deltaR with respect to v. void SetMagThetaPhi(Double_t mag, Double_t theta, Double_t phi); setter with mag, theta, phi. void Streamer(TBuffer& ); Stream an object of class TVector3. void Print(Option_t* option = """") const; print vector parameters. Double_t & operator[](int ); { return operator()(i); }. Double_t operator[](int ) const; { return operator()(i); }. Double_t x() const; { return fX; }. Double_t y() const; { return fY; }. Double_t z() const; { return fZ; }. Double_t X() const; { return fX; }. Double_t Y() const; { return fY; }. Double_t Z() const; { return fZ; }. Double_t Px() const; { return fX; }. ",MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVector3.html:4625,Usability,Clear,Clear,4625,,MatchSource.WIKI,root/html604/TVector3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVector3.html
https://root.cern/root/html604/TVectorT_double_.html:573,Availability,avail,available,573,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:2207,Availability,Error,Error,2207," TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:2336,Availability,error,error,2336,"ctorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:2420,Availability,error,error,2420,"orT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:11275,Energy Efficiency,Allocate,Allocate,11275,"er bound of the row index; static TVectorT<double>::(anonymous)kSizeMax; static TVectorT<double>::EVectorStatusBitskStatus; static TVectorT<double>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<double>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:11333,Energy Efficiency,Allocate,Allocate,11333,"er bound of the row index; static TVectorT<double>::(anonymous)kSizeMax; static TVectorT<double>::EVectorStatusBitskStatus; static TVectorT<double>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<double>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:11995,Integrability,depend,depends,11995,"ector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, double* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<double>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<double>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Elemen",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:122,Modifiability,inherit,inheritance,122,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:3650,Modifiability,Inherit,InheritsFrom,3650,"ct::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::o",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:3716,Modifiability,Inherit,InheritsFrom,3716,"::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:10486,Modifiability,Inherit,Inheritance,10486,"tusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. doublefDataStack[5]! data container; double*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; static TVectorT<double>::(anonymous)kSizeMax; static TVectorT<double>::EVectorStatusBitskStatus; static TVectorT<double>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<double>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, double*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<double>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<double>& v1, const TVectorT<double>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(double* newp, const double* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:602,Safety,avoid,avoiding,602,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:3540,Security,Hash,Hash,3540,"hod, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; double*GetMatrixArray(); const double*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<double>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<double>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<double>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<double>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<double>& select); doubleMax() const; voidTObject::MayNotUse(const char* method) const; doubleMin() const; Int_tNonZeros() const; doubleNorm1() const; doubleNorm2Sqr() const; doubleNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method,",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:18068,Security,Access,Access,18068,"urrent element is known. void TVectorT<Element> Draw(Option_t* option = """"); Draw this vector; The histogram is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& ); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:18176,Security,Access,Access,18176,"amed ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& ); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Op",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:1030,Testability,test,test,1030,"ick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:7743,Testability,Test,TestBit,7743,"SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<double>&SelectNonZeros(const TVectorT<double>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const double* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<double>&SetSub(Int_t row_lwb, const TVectorT<double>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<double>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp) const; Bool_tSomePositive(const TVectorT<double>& select); TVectorT<double>&Sqr(); TVectorT<double>&Sqrt(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, double iv1); TVectorT<double>&Use(TVectorT<double>& v); const TVectorT<double>&Use(const TVectorT<double>& v) const; TVectorT<double>&Use(Int_t n, double* data); const TVectorT<double>&Use(Int_t n, const double* data) const; TVectorT<double>&Use(Int_t lwb, Int_t upb, double* data); const TVectorT<double>&Use(Int_t lwb, Int_t upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:7782,Testability,Test,TestBits,7782,"n_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<double>&SelectNonZeros(const TVectorT<double>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const double* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<double>&SetSub(Int_t row_lwb, const TVectorT<double>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<double>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp) const; Bool_tSomePositive(const TVectorT<double>& select); TVectorT<double>&Sqr(); TVectorT<double>&Sqrt(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, double iv1); TVectorT<double>&Use(TVectorT<double>& v); const TVectorT<double>&Use(const TVectorT<double>& v) const; TVectorT<double>&Use(Int_t n, double* data); const TVectorT<double>&Use(Int_t n, const double* data) const; TVectorT<double>&Use(Int_t lwb, Int_t upb, double* data); const TVectorT<double>&Use(Int_t lwb, Int_t upb, const double* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:18620,Testability,Test,TestBit,18620,"ent> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_double_.html:19138,Usability,Clear,Clear,19138,"ent> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, double* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const double* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<double>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<double>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t ind) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const double* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, double* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TVectorT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_double_.html
https://root.cern/root/html604/TVectorT_float_.html:570,Availability,avail,available,570,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:2193,Availability,Error,Error,2193,"Add(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, O",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:2322,Availability,error,error,2322,"t TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:2406,Availability,error,error,2406,"VectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUn",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:11030,Energy Efficiency,Allocate,Allocate,11030,"fRowLwblower bound of the row index; static TVectorT<float>::(anonymous)kSizeMax; static TVectorT<float>::EVectorStatusBitskStatus; static TVectorT<float>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<float>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nr",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:11088,Energy Efficiency,Allocate,Allocate,11088,"fRowLwblower bound of the row index; static TVectorT<float>::(anonymous)kSizeMax; static TVectorT<float>::EVectorStatusBitskStatus; static TVectorT<float>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<float>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nr",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:11748,Integrability,depend,depends,11748,"is vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector to [lwb:upb] .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TVectorT<Element> &TVectorT<Element> Use(Int_t lwb, Int_t upb, float* data); Use the array data to fill the vector lwb..upb]. TVectorT<Element> &TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; Get subvector [row_lwb..row_upb]; The indexing range of the; returned vector depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb]. TVectorT<Element> &TVectorT<Element> SetSub(Int_t row_lwb, const TVectorT<float>& source); Insert vector source starting at [row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source];. TVectorT<Element> &TVectorT<Element> Zero(); Set vector elements to zero. TVectorT<Element> &TVectorT<Element> Abs(); Take an absolute value of a vector, i.e. apply Abs() to each element. TVectorT<Element> &TVectorT<Element> Sqr(); Square each element of the vector. TVectorT<Element> &TVectorT<Element> Sqrt(); Take square root of all elements. TVectorT<Element> &TVectorT<Element> Invert(); v[i] = 1/v[i]. TVectorT<Element> &TVectorT<Element> SelectNonZeros(const TVectorT<float>& select); Keep only element as selected through array select non-zero. Element TVectorT<Element> Norm1() const; Compute the 1-norm of the vector SUM{ |v[i]| }. Element TVectorT<Element>",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:121,Modifiability,inherit,inheritance,121,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:3631,Modifiability,Inherit,InheritsFrom,3631,"TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:3697,Modifiability,Inherit,InheritsFrom,3697,"bject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void*",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:10248,Modifiability,Inherit,Inheritance,10248,":EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. floatfDataStack[5]! data container; float*fElements[fNrows] elements themselves; Bool_tfIsOwner!default kTRUE, when Use array kFALSE; Int_tfNrowsnumber of rows; Int_tfRowLwblower bound of the row index; static TVectorT<float>::(anonymous)kSizeMax; static TVectorT<float>::EVectorStatusBitskStatus; static TVectorT<float>::(anonymous)kWorkMax. Class Charts. Inheritance Chart:. TObject. ←; TVectorT<float>. Function documentation; void TVectorT<Element> Delete_m(Int_t size, float*& ); Delete data pointer m, if it was assigned on the heap. Element* TVectorT<Element> New_m(Int_t size); Return data pointer . if requested size <= kSizeMax, assign pointer; to the stack space. void TVectorT<Element> Add(const TVectorT<float>& v); Add vector v to this vector. void TVectorT<Element> Add(const TVectorT<float>& v1, const TVectorT<float>& v2); Set this vector to v1+v2. Int_t TVectorT<Element> Memcpy_m(float* newp, const float* oldp, Int_t copySize, Int_t newSize, Int_t oldSize); Copy copySize doubles from *oldp to *newp . However take care of the; situation where both pointers are assigned to the same stack space. void TVectorT<Element> Allocate(Int_t nrows, Int_t row_lwb = 0, Int_t init = 0); Allocate new vector. Arguments are number of rows and row; lowerbound (0 default). TVectorT<Element> &TVectorT<Element> ResizeTo(Int_t lwb, Int_t upb); Resize the vector",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:599,Safety,avoid,avoiding,599,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:3521,Security,Hash,Hash,3521,"* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLwb() const; float*GetMatrixArray(); const float*GetMatrixArray() const; virtual const char*TObject::GetName() const; Int_tGetNoElements() const; Int_tGetNrows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TVectorT<float>GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const; TVectorT<float>&GetSub(Int_t row_lwb, Int_t row_upb, TVectorT<float>& target, Option_t* option = ""S"") const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpb() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInvalidate(); TVectorT<float>&Invert(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tIsOwner() const; virtual Bool_tTObject::IsSortable() const; Bool_tIsValid() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidMakeValid(); Bool_tMatchesNonZeroPattern(const TVectorT<float>& select); floatMax() const; voidTObject::MayNotUse(const char* method) const; floatMin() const; Int_tNonZeros() const; floatNorm1() const; floatNorm2Sqr() const; floatNormInf() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const ",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:17805,Security,Access,Access,17805,"e current element is known. void TVectorT<Element> Draw(Option_t* option = """"); Draw this vector; The histogram is named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& ); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index)",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:17913,Security,Access,Access,17913," named ""TVectorT"" by default and no title. void TVectorT<Element> Print(Option_t* option = """") const; Print the vector as a list of elements. void TVectorT<Element> Streamer(TBuffer& ); Stream an object of class TVectorT. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Opti",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:1027,Testability,test,test,1027,"Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; vir",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:7595,Testability,Test,TestBit,7595,"dTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<float>&SelectNonZeros(const TVectorT<float>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const float* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<float>&SetSub(Int_t row_lwb, const TVectorT<float>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<float>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp) const; Bool_tSomePositive(const TVectorT<float>& select); TVectorT<float>&Sqr(); TVectorT<float>&Sqrt(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, float iv1); TVectorT<float>&Use(TVectorT<float>& v); const TVectorT<float>&Use(const TVectorT<float>& v) const; TVectorT<float>&Use(Int_t n, float* data); const TVectorT<float>&Use(Int_t n, const float* data) const; TVectorT<float>&Use(Int_t lwb, Int_t upb, float* data); const TVectorT<float>&Use(Int_t lwb, Int_t upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(cons",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:7634,Testability,Test,TestBits,7634," """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TVectorT<float>&SelectNonZeros(const TVectorT<float>& select); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetElements(const float* elements); static voidTObject::SetObjectStat(Bool_t stat); TVectorT<float>&SetSub(Int_t row_lwb, const TVectorT<float>& source); virtual voidTObject::SetUniqueID(UInt_t uid); TVectorT<float>&Shift(Int_t row_shift); virtual voidShowMembers(TMemberInspector& insp) const; Bool_tSomePositive(const TVectorT<float>& select); TVectorT<float>&Sqr(); TVectorT<float>&Sqrt(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); floatSum() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, float iv1); TVectorT<float>&Use(TVectorT<float>& v); const TVectorT<float>&Use(const TVectorT<float>& v) const; TVectorT<float>&Use(Int_t n, float* data); const TVectorT<float>&Use(Int_t n, const float* data) const; TVectorT<float>&Use(Int_t lwb, Int_t upb, float* data); const TVectorT<float>&Use(Int_t lwb, Int_t upb, const float* data) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:18357,Testability,Test,TestBit,18357,"Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TVectorT_float_.html:18873,Usability,Clear,Clear,18873,"Element> inline TVectorT<Element> &TVectorT<Element> Use(Int_t n, float* data); { return Use(0,n-1,data); }. template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(Int_t n, const float* data) const; { return Use(0,n-1,data); }. template<class Element> inline TVectorT<Element> &TVectorT<Element> Use(TVectorT<float>& v). template<class Element> inline const TVectorT<Element> &TVectorT<Element> Use(const TVectorT<float>& v) const. template<class Element> inline TVectorT<Element> TVectorT<Element> GetSub(Int_t row_lwb, Int_t row_upb, Option_t* option = ""S"") const. template<class Element> inline const Element &TVectorT<Element> operator()(Int_t index) const; Access a vector element. template<class Element> inline Element &TVectorT<Element> operator()(Int_t index); Access a vector element. Int_t GetLwb() const; { return fRowLwb; }. Int_t GetUpb() const; { return fNrows+fRowLwb-1; }. Int_t GetNrows() const; { return fNrows; }. Int_t GetNoElements() const; { return fNrows; }. Element * GetMatrixArray(); { return fElements; }. const Element * GetMatrixArray() const; { return fElements; }. void Invalidate(); { SetBit(kStatus); }. void MakeValid(); { ResetBit(kStatus); }. Bool_t IsValid() const; { return !TestBit(kStatus); }. Bool_t IsOwner() const; { return fIsOwner; }. void SetElements(const float* elements). TVectorT<Element> & Shift(Int_t row_shift); { fRowLwb += row_shift; return *this; }. TVectorT<Element> & ResizeTo(Int_t lwb, Int_t upb). TVectorT<Element> & ResizeTo(Int_t n); { return ResizeTo(0,n-1); }. TVectorT<Element> & Use(Int_t lwb, Int_t upb, float* data). const Element & operator[](Int_t index) const; { return (*this)(index); }. Element & operator[](Int_t index); { return (*this)(index); }. void Clear(Option_t* = """"). » Last changed: root/matrix:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TVectorT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TVectorT_float_.html
https://root.cern/root/html604/TView.html:468,Availability,avail,available,468,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:2073,Availability,Error,Error,2073,"newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual In",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:2202,Availability,error,error,2202,"tatic TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:2286,Availability,error,error,2286,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront(); virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDvi",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:14445,Deployability,Toggle,ToggleRulers,14445," x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2). void SetDefaultWindow(). void SetDview(Double_t dview). void SetDproj(Double_t dproj). void SetLatitude(Double_t latitude). void SetLongitude(Double_t longitude). void SetPsi(Double_t psi). void SetOutlineToCube(). void SetParallel(). void SetPerspective(). void SetRange(const Double_t* min, const Double_t* max). void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0). void SetSystem(Int_t system). void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep). void SetViewChanged(Bool_t flag = kTRUE). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv). void WCtoNDC(const Float_t* pw, Float_t* pn). void WCtoNDC(const Double_t* pw, Double_t* pn). void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); --. void MoveWindow(Char_t option). void AdjustScales(TVirtualPad* pad = 0). void Centered3DImages(TVirtualPad* pad = 0). void Centered(). void FrontView(TVirtualPad* pad = 0). void Front(). void ZoomIn(). void ZoomOut(). void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25). void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0). void SideView(TVirtualPad* pad = 0). void Side(). void TopView(TVirtualPad* pad = 0). void Top(). void ToggleRulers(TVirtualPad* pad = 0). void ShowAxis(). void ToggleZoom(TVirtualPad* pad = 0). void ZoomMove(). void Zoom(). void UnZoom(). » Author: Rene Brun, Nenad Buncic, Evgueni Tcherniaev, Olivier Couet 18/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:14503,Deployability,Toggle,ToggleZoom,14503," x2, const Double_t* y1, const Double_t* y2, const Double_t* z1, const Double_t* z2). void SetDefaultWindow(). void SetDview(Double_t dview). void SetDproj(Double_t dproj). void SetLatitude(Double_t latitude). void SetLongitude(Double_t longitude). void SetPsi(Double_t psi). void SetOutlineToCube(). void SetParallel(). void SetPerspective(). void SetRange(const Double_t* min, const Double_t* max). void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0). void SetSystem(Int_t system). void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep). void SetViewChanged(Bool_t flag = kTRUE). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv). void WCtoNDC(const Float_t* pw, Float_t* pn). void WCtoNDC(const Double_t* pw, Double_t* pn). void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); --. void MoveWindow(Char_t option). void AdjustScales(TVirtualPad* pad = 0). void Centered3DImages(TVirtualPad* pad = 0). void Centered(). void FrontView(TVirtualPad* pad = 0). void Front(). void ZoomIn(). void ZoomOut(). void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25). void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25). void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0). void SideView(TVirtualPad* pad = 0). void Side(). void TopView(TVirtualPad* pad = 0). void Top(). void ToggleRulers(TVirtualPad* pad = 0). void ShowAxis(). void ToggleZoom(TVirtualPad* pad = 0). void ZoomMove(). void Zoom(). void UnZoom(). » Author: Rene Brun, Nenad Buncic, Evgueni Tcherniaev, Olivier Couet 18/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:111,Modifiability,inherit,inheritance,111,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:4553,Modifiability,Inherit,InheritsFrom,4553,"rtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(con",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:4619,Modifiability,Inherit,InheritsFrom,4619,") const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(const Double_t* pn, Double_t* pw); virtual voidNormalWCtoNDC(const Fl",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:10772,Modifiability,Inherit,Inheritance,10772,"t level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance Chart:. TObject. TAttLine. ←; TView. ←. TView3D. Function documentation; TView(const TView& ); Copy constructor. TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. TView(); {}. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). ",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:11030,Modifiability,plug-in,plug-in,11030,"TObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width. Class Charts. Inheritance Chart:. TObject. TAttLine. ←; TView. ←. TView3D. Function documentation; TView(const TView& ); Copy constructor. TView * CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); Create a concrete default 3-d view via the plug-in manager. TView(); {}. virtual ~TView(); {}. void DefinePerspectiveView(). void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2). void DefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback). void ExecuteEvent(Int_t event, Int_t px, Int_t py). void ExecuteRotateView(Int_t event, Int_t px, Int_t py). void FindScope(Double_t* scale, Double_t* center, Int_t& irep). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio). Double_t GetDview() const. Double_t GetDproj() const. Double_t GetExtent() const. Bool_t GetAutoRange(). Double_t GetLatitude(). Double_t GetLongitude(). Double_t GetPsi(). void GetRange(Float_t* min, Float_t* max). void GetRange(Double_t* min, Double_t* max). Double_t * GetRmax(). Double_t * G",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:4443,Security,Hash,Hash,4443,"ineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); v",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:8822,Testability,Test,TestBit,8822,"t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel(); virtual voidSetPerspective(); virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSide(); virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop(); virtual voidTopView(TVirtualPad* pad = 0); TView(); TView(const TView&); virtual voidUnZoom(); virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:8861,Testability,Test,TestBits,8861,"t* z1, const Double_t* z2); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel(); virtual voidSetPerspective(); virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSide(); virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop(); virtual voidTopView(TVirtualPad* pad = 0); TView(); TView(const TView&); virtual voidUnZoom(); virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView.html:1010,Usability,Clear,Clear,1010," virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root/html604/TView.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView.html
https://root.cern/root/html604/TView3D.html:2138,Availability,avail,available,2138," PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSize(2);; pm3d1->SetMarkerColor(4);; pm3d1->SetMarkerStyle(2);. // Draw; pl3d1->Draw();; pm3d1->Draw();; }. Several coordinate systems are available:. Cartesian; Polar; Cylindrical; Spherical; PseudoRapidity/Phi. . Function Members (Methods); public:. virtual~TView3D(); voidTObject::AbstractMethod(const char* method) const; static voidAdjustPad(TVirtualPad* pad = 0); virtual voidAdjustScales(TVirtualPad* pad = 0)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered()MENU ; virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefin",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:3885,Availability,Error,Error,3885," = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtu",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:4014,Availability,error,error,4014,"View*TView::CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TO",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:4098,Availability,error,error,4098,"max = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteRotateView(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); virtual voidFindScope(Double_t* scale, Double_t* center, Int_t& irep); virtual voidFindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); virtual voidFront()MENU ; virtual voidFrontView(TVirtualPad* pad = 0); virtual Bool_tGetAutoRange(); virtual Int_tGetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); virtual Double_tGetDproj() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tG",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:17290,Availability,down,down,17290,"costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); Define view direction (in spherical coordinates). Compute transformation matrix from world coordinates; to normalised coordinates (-1 to +1). Input: S(3) - scale factors; C(3) - centre of scope; COSPHI - longitude COS; SINPHI - longitude SIN; COSTHE - latitude COS (angle between +Z and view direc.); SINTHE - latitude SIN; COSPSI - screen plane rotation angle COS; SINPSI - screen plane rotation angle SIN. void DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); Draw the outline of a cube while rotating a 3-d object in the pad. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. void ExecuteRotateView(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a object is clicked with the locator. If Left button clicked in the object area, while the button is kept down; the cube representing the surrounding frame for the corresponding; new latitude and longitude position is drawn. void FindNormal(Double_t x, Double_t y, Double_t z, Double_t& zn); Find Z component of NORMAL in normalized coordinates. Input: X - X-component of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separato",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:18581,Availability,error,error,18581," of NORMAL; Y - Y-component of NORMAL; Z - Z-component of NORMAL. Output: ZN - Z-component of NORMAL in normalized coordinates. void FindPhiSectors(Int_t iopt, Int_t& kphi, Double_t* aphi, Int_t& iphi1, Int_t& iphi2); Find critical PHI sectors. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; KPHI - number of phi sectors; APHI(*) - PHI separators (modified internally). Output: IPHI1 - initial sector; IPHI2 - final sector. void FindThetaSectors(Int_t iopt, Double_t phi, Int_t& kth, Double_t* ath, Int_t& ith1, Int_t& ith2); Find critical THETA sectors for given PHI sector. Input: IOPT - options: 1 - from BACK to FRONT 'BF'; 2 - from FRONT to BACK 'FB'; PHI - PHI sector; KTH - number of THETA sectors; ATH(*) - THETA separators (modified internally). Output: ITH1 - initial sector; ITH2 - final sector. void FindScope(Double_t* scale, Double_t* center, Int_t& irep); Find centre of a MIN-MAX scope and scale factors. Output: SCALE(3) - scale factors; CENTER(3) - centre; IREP - reply (-1 if error in min-max). Int_t GetDistancetoAxis(Int_t axis, Int_t px, Int_t py, Double_t& ratio); Return distance to axis from point px,py. Algorithm:. A(x1,y1) P B(x2,y2); ------------------------------------------------; I; I; I; I; M(x,y). Let us call a = distance AM A=a**2; b = distance BM B=b**2; c = distance AB C=c**2; d = distance PM D=d**2; u = distance AP U=u**2; v = distance BP V=v**2 c = u + v. D = A - U; D = B - V = B -(c-u)**2; ==> u = (A -B +C)/2c. Double_t GetExtent() const; Get maximum view extent. void GetRange(Float_t* min, Float_t* max); Get Range function. void GetRange(Double_t* min, Double_t* max); Get Range function. void GetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; Get current window extent. Bool_t IsClippedNDC(Double_t* p) const; Check if point is clipped in perspective view. void NDCtoWC(const Float_t* pn, Float_t* pw); Transfer point from normalized to world coordinates. Input: PN(3) - point in world coordina",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22003,Availability,error,error,22003,"-------+; (x,y,z) (X,y,z). void SetParallel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22022,Availability,Error,Errors,22022,"lel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void Adj",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22030,Availability,error,error,22030,"lel(); Set the parallel option (default). void SetPerspective(); Set perspective option. void SetRange(const Double_t* min, const Double_t* max); Set Range function. void SetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); Set 3-D View range. Input: x0, y0, z0 are minimum coordinates; x1, y1, z1 are maximum coordinates. flag values are: 0 (set always) <- default; 1 (shrink view); 2 (expand view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void Adj",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:23874,Availability,down,down,23874,"(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {ret",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22512,Deployability,update,updated,22512,"view). void SetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); Set viewing window. void SetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view parameters. void ResizePad(); Recompute window for perspective view. void ResetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); Set view direction (in spherical coordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlon",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22827,Deployability,Toggle,ToggleRulers,22827,"ordinates). Input PHI - longitude; THETA - latitude (angle between +Z and view direction); PSI - rotation in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:22890,Deployability,Toggle,ToggleZoom,22890,"n in screen plane. Output: IREP - reply (-1 if error in min-max). Errors: error in min-max scope. void WCtoNDC(const Float_t* pw, Float_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void WCtoNDC(const Double_t* pw, Double_t* pn); Transfer point from world to normalized coordinates. Input: PW(3) - point in world coordinate system; PN(3) - point in normalized coordinate system. void AdjustPad(TVirtualPad* pad = 0); Force the current pad to be updated. void RotateView(Double_t phi, Double_t theta, TVirtualPad* pad = 0); API to rotate view and adjust the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TB",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:24089,Deployability,Toggle,ToggleRulers,24089,"f view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:24180,Deployability,Toggle,ToggleZoom,24180,"ew into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dvie",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:442,Energy Efficiency,adapt,adapted,442,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:14157,Integrability,depend,depending,14157,"_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance Chart:. TObject. TAttLine. ←; TView. ←; TView3D. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st point of X-axis; IX2 - 2nd point of X-axis; IY1 - 1st point of Y-axis; IY2 - 2nd point of Y-axis; IZ1 - 1st point of Z-axis; IZ2 - 2nd point of Z-axis. 8 6; / \ /|\; 5 / \ 7 5 / | \ 7; |\ /| | | |; THETA < 90 | \6/ | THETA > 90 | /2\ |; (Top view) | | | (Bottom vie",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:113,Modifiability,inherit,inheritance,113,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:442,Modifiability,adapt,adapted,442,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:6370,Modifiability,Inherit,InheritsFrom,6370,"rtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(con",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:6436,Modifiability,Inherit,InheritsFrom,6436,") const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); virtual voidMoveWindow(Char_t option); virtual voidNDCtoWC(const Float_t* pn, Float_t* pw); virtual voidNDCtoWC(const Double_t* pn, Double_t* pw); virtual voidNormalWCtoNDC(const Fl",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:13867,Modifiability,Inherit,Inheritance,13867,"cube; Double_tfDprojDistance from COP to projection plane; Double_tfDviewDistance from COP to COV; Double_tfLatitudeView angle latitude; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Double_tfLongitudeView angle longitude; TSeqCollection*fOutlineCollection of outline's objects; Double_tfPsiView angle psi; Double_tfRmax[3]Upper limits of object; Double_tfRmin[3]Lower limits of object; Int_tfSystemCoordinate system; Double_tfTB[16]; Double_tfTN[16]; Double_tfTback[16]Back transformation matrix; Double_tfTnorm[16]Transformation matrix; Double_tfUVcoord[4]Viewing window limits; Double_tfUpixpad X size in pixels; Double_tfVpixpad Y size in pixels; Double_tfX1[3]First coordinate of X axis; Double_tfX2[3]Second coordinate of X axis; Double_tfY1[3]First coordinate of Y axis; Double_tfY2[3]Second coordinate of Y axis; Double_tfZ1[3]First coordinate of Z axis; Double_tfZ2[3]Second coordinate of Z axis. Class Charts. Inheritance Chart:. TObject. TAttLine. ←; TView. ←; TView3D. Function documentation; TView3D(); Default constructor. TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); TView3D constructor. Creates a 3-D view in the current pad; rmin[3], rmax[3] are the limits of the object depending on; the selected coordinate system. Before drawing a 3-D object in a pad, a 3-D view must be created.; Note that a view is automatically created when drawing legos or surfaces. The coordinate system is selected via system:; system = 1 Cartesian; system = 2 Polar; system = 3 Cylindrical; system = 4 Spherical; system = 5 PseudoRapidity/Phi. TView3D(const TView3D& ); Copy constructor. TView3D& operator=(const TView3D& ); Assignment operator. ~TView3D(); TView3D default destructor. void AxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); Define axis vertices. Input ANG - angle between X and Y axis. Output: AV(3,8) - axis vertices; IX1 - 1st poin",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:23590,Performance,Perform,Perform,23590,"just the pad provided it the current one. void SideView(TVirtualPad* pad = 0); Set to side view. void FrontView(TVirtualPad* pad = 0); Set to front view. void TopView(TVirtualPad* pad = 0); Set to top view. void ToggleRulers(TVirtualPad* pad = 0); Turn on /off 3D axis. void ToggleZoom(TVirtualPad* pad = 0); Turn on /off the interactive option to; Zoom / Move / Change attributes of 3D axis correspond this view. void AdjustScales(TVirtualPad* pad = 0); Adjust all sides of view in respect of the biggest one. void Centered3DImages(TVirtualPad* pad = 0); Move view into the center of the scene. void UnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.25); unZOOM this view. void ZoomView(TVirtualPad* pad = 0, Double_t zoomFactor = 1.25); ZOOM this view. void MoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); Move focus to a different box position and extent in nsteps. Perform; rotation with dlat,dlong,dpsi at each step. void MoveViewCommand(Char_t chCode, Int_t count = 1); 'a' increase scale factor (clip cube borders); 's' decrease scale factor (clip cube borders). void MoveWindow(Char_t option); Move view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * Get",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:6260,Security,Hash,Hash,6260,"ineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetLongitude(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TSeqCollection*GetOutline(); virtual Double_tGetPsi(); virtual voidGetRange(Float_t* min, Float_t* max); virtual voidGetRange(Double_t* min, Double_t* max); virtual Double_t*GetRmax(); virtual Double_t*GetRmin(); virtual Int_tGetSystem(); virtual Double_t*GetTback(); virtual const char*TObject::GetTitle() const; virtual Double_t*GetTN(); virtual Double_t*GetTnorm(); virtual UInt_tTObject::GetUniqueID() const; virtual voidGetWindow(Double_t& u0, Double_t& v0, Double_t& du, Double_t& dv) const; virtual Double_tGetWindowHeight() const; virtual Double_tGetWindowWidth() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tIsClippedNDC(Double_t* p) const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPerspective() const; virtual Bool_tTObject::IsSortable() const; virtual Bool_tIsViewChanged() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual voidTAttLine::Modify(); virtual voidMoveFocus(Double_t* center, Double_t dx, Double_t dy, Double_t dz, Int_t nsteps = 10, Double_t dlong = 0, Double_t dlat = 0, Double_t dpsi = 0); virtual voidMoveViewCommand(Char_t chCode, Int_t count = 1); v",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:10628,Testability,Test,TestBit,10628,"(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel()MENU ; virtual voidSetPerspective()MENU ; virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis()MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSide()MENU ; virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop()MENU ; virtual voidTopView(TVirtualPad* pad = 0); TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual voidUnZoom()MENU ; virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:10667,Testability,Test,TestBits,10667,"(UInt_t f, Bool_t set); virtual voidSetDefaultWindow(); virtual voidSetDproj(Double_t dproj); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDview(Double_t dview); virtual voidSetLatitude(Double_t latitude); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetLongitude(Double_t longitude); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOutlineToCube(); virtual voidSetParallel()MENU ; virtual voidSetPerspective()MENU ; virtual voidSetPsi(Double_t psi); virtual voidSetRange(const Double_t* min, const Double_t* max); virtual voidSetRange(Double_t x0, Double_t y0, Double_t z0, Double_t x1, Double_t y1, Double_t z1, Int_t flag = 0); virtual voidSetSystem(Int_t system); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetView(Double_t longitude, Double_t latitude, Double_t psi, Int_t& irep); virtual voidSetViewChanged(Bool_t flag = kTRUE); virtual voidSetWindow(Double_t u0, Double_t v0, Double_t du, Double_t dv); virtual voidShowAxis()MENU ; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidSide()MENU ; virtual voidSideView(TVirtualPad* pad = 0); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidToggleRulers(TVirtualPad* pad = 0); virtual voidToggleZoom(TVirtualPad* pad = 0); virtual voidTop()MENU ; virtual voidTopView(TVirtualPad* pad = 0); TView3D(); TView3D(Int_t system, const Double_t* rmin, const Double_t* rmax); virtual voidUnZoom()MENU ; virtual voidUnzoomView(TVirtualPad* pad = 0, Double_t unZoomFactor = 1.",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:24990,Testability,Test,TestBit,24990," view window :; l,L - left; h,H - right; u,U - down; i,I - up. void ZoomIn(); Zoom in. void ZoomOut(); Zoom out. void Streamer(TBuffer& ); Stream an object of class TView3D. void Centered(); {Centered3DImages();}. void Front(); {FrontView();}. void ShowAxis(); {ToggleRulers(); }. void Side(); {SideView();}. void Top(); {TopView();}. void ZoomMove(); {ToggleZoom();}. void Zoom(); {ZoomView();}. void UnZoom(); {UnzoomView();}. Double_t GetDview() const; {return fDview;}. Double_t GetDproj() const; {return fDproj;}. Bool_t GetAutoRange(); {return fAutoRange;}. Double_t GetLatitude(); {return fLatitude;}. Double_t GetLongitude(); {return fLongitude;}. Double_t GetPsi(); {return fPsi;}. Double_t * GetRmax(); {return fRmax;}. Double_t * GetRmin(); {return fRmin;}. TSeqCollection * GetOutline(); {return fOutline; }. Double_t * GetTback(); {return fTback;}. Double_t * GetTN(); {return fTN;}. Double_t * GetTnorm(); {return fTnorm;}. Int_t GetSystem(); {return fSystem;}. Double_t GetWindowWidth() const; {return 0.5*(fUVcoord[1]-fUVcoord[0]);}. Double_t GetWindowHeight() const; {return 0.5*(fUVcoord[3]-fUVcoord[2]);}. Bool_t IsPerspective() const; {return TestBit(kPerspective);}. Bool_t IsViewChanged() const; {return fChanged;}. void SetAutoRange(Bool_t autorange = kTRUE); {fAutoRange=autorange;}. void SetDview(Double_t dview); {fDview=dview;}. void SetDproj(Double_t dproj); {fDproj=dproj;}. void SetLatitude(Double_t latitude); {fLatitude = latitude;}. void SetLongitude(Double_t longitude); {fLongitude = longitude;}. void SetPsi(Double_t psi); {fPsi = psi;}. void SetSystem(Int_t system); {fSystem = system;}. void SetViewChanged(Bool_t flag = kTRUE); {fChanged = flag;}. » Author: Rene Brun 19/02/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:955,Usability,simpl,simple,955,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:981,Usability,simpl,simple,981,". TView3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TView3D. class TView3D: public TView. The 3D view class; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet and; Evgueni Tcherniaev. This View class is a subset of the original system. It has been converted to a; C++ class by Rene Brun. TView3D creates a 3-D view in the current pad. In this 3D view Lego and Surface; plots can be drawn and also 3D polyline and markers. Most of the time a TView3D; is created automatically when a 3D object needs to be painted in a pad (for; instance a Lego or a Surface plot). In some case a TView3D should be explicitly. For instance to paint a 3D simple; scene composed of simple objects like polylines and polymarkers.; The following macro gives an example:. Picture; Source. {; cV3D = new TCanvas(""cV3D"",""PolyLine3D & PolyMarker3D Window"",200,10,500,500);. // Creating a view; TView3D *view = (TView3D*) TView::CreateView(1);; view->SetRange(5,5,5,25,25,25);. // Create a first PolyLine3D; TPolyLine3D *pl3d1 = new TPolyLine3D(5);; pl3d1->SetPoint(0, 10, 10, 10);; pl3d1->SetPoint(1, 15, 15, 10);; pl3d1->SetPoint(2, 20, 15, 15);; pl3d1->SetPoint(3, 20, 20, 20);; pl3d1->SetPoint(4, 10, 10, 20);. // Create a first PolyMarker3D; TPolyMarker3D *pm3d1 = new TPolyMarker3D(12);; pm3d1->SetPoint(0, 10, 10, 10);; pm3d1->SetPoint(1, 11, 15, 11);; pm3d1->SetPoint(2, 12, 15, 9);; pm3d1->SetPoint(3, 13, 17, 20);; pm3d1->SetPoint(4, 14, 16, 15);; pm3d1->SetPoint(5, 15, 20, 15);; pm3d1->SetPoint(6, 16, 18, 10);; pm3d1->SetPoint(7, 17, 15, 10);; pm3d1->SetPoint(8, 18, 22, 15);; pm3d1->SetPoint(9, 19, 28, 25);; pm3d1->SetPoint(10, 20, 12, 15);; pm3d1->SetPoint(11, 21, 12, 15);; pm3d1->SetMarkerSi",MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TView3D.html:2815,Usability,Clear,Clear,2815,,MatchSource.WIKI,root/html604/TView3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TView3D.html
https://root.cern/root/html604/TViewer3DPad.html:1724,Availability,Error,Error,1724,"t TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtua",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:1853,Availability,error,error,1853,"irtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:1937,Availability,error,error,1937,"l Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:351,Integrability,interface,interface,351,". TViewer3DPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TViewer3DPad. class TViewer3DPad: public TVirtualViewer3D. Provides 3D viewer interface (TVirtualViewer3D) support on a pad.; Will be merged with TView / TView3D eventually. Function Members (Methods); public:. virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:118,Modifiability,inherit,inheritance,118,". TViewer3DPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TViewer3DPad. class TViewer3DPad: public TVirtualViewer3D. Provides 3D viewer interface (TVirtualViewer3D) support on a pad.; Will be merged with TView / TView3D eventually. Function Members (Methods); public:. virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:2817,Modifiability,Inherit,InheritsFrom,2817,"d, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::ope",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:2883,Modifiability,Inherit,InheritsFrom,2883,"cute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* ",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:6813,Modifiability,Inherit,Inheritance,6813,"va_list va) const; voidTObject::MakeZombie(). private:. TViewer3DPad&operator=(const TViewer3DPad&); TViewer3DPad(const TViewer3DPad&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfBuildingis scene being built?; TVirtualPad&fPadthe pad we paint into. Class Charts. Inheritance Chart:. TObject. ←; TVirtualViewer3D. ←; TViewer3DPad. Function documentation; Bool_t PreferLocalFrame() const; Indicates if we prefer positions in local frame. Always false - pad; drawing is always done in master frame. void BeginScene(); Open a scene on the viewer. void EndScene(); Close the scene on the viewer. Int_t AddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); Add an 3D object described by the buffer to the viewer. Returns flags; to indicate:; i) if extra sections of the buffer need completing.; ii) if child objects of the buffer object should be added (always true). Int_t AddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); We don't support placed ID shapes - ID is discarded. Bool_t OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); Composite shapes not supported on this viewer currently - ignore.; Will result in a set of individual component shapes. void CloseComposite(); {}. void AddCompositeOp(UInt_t operation); {}. TVie",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:2707,Security,Hash,Hash,2707,"l voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTObject::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); virtual voidTVirtualViewer3D::ObjectPaint(TObject*, Option_t* = """"); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Bool_tOpenComposite(const TBuffer3D& buffer, Bool_t* addChildren = 0); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp);",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:5241,Testability,Test,TestBit,5241,"tor delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TViewer3DPad(TVirtualPad& pad); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:5280,Testability,Test,TestBits,5280,"tor delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTVirtualViewer3D::PadPaint(TVirtualPad*); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual Bool_tPreferLocalFrame() const; virtual voidTObject::Print(Option_t* option = """") const; virtual voidTVirtualViewer3D::PrintObjects(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTVirtualViewer3D::ResetCameras(); virtual voidTVirtualViewer3D::ResetCamerasAfterNextUpdate(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual TObject*TVirtualViewer3D::SelectObject(Int_t, Int_t); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TViewer3DPad(TVirtualPad& pad); virtual voidTObject::UseCurrentStyle(); static TVirtualViewer3D*TVirtualViewer3D::Viewer3D(TVirtualPad* pad = 0, Option_t* type = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewer3DPad.html:1086,Usability,Clear,Clear,1086," virtual~TViewer3DPad(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual Int_tAddObject(UInt_t placedID, const TBuffer3D& buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t",MatchSource.WIKI,root/html604/TViewer3DPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewer3DPad.html
https://root.cern/root/html604/TViewerX3D.html:1648,Availability,Error,Error,1648,"buffer, Bool_t* addChildren = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginScene(); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tBuildingScene() const; virtual Bool_tTVirtualViewer3D::CanLoopOnPrimitives() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(); virtual voidCloseComposite(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTVirtualViewer3D::DrawViewer(); virtual voidTObject::Dump() constMENU ; virtual voidEndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExecCommand(Int_t px, Int_t py, char command); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidGetPosition(Float_t& longitude, Float_t& latitude, Float_t& psi); virtual const char*TObject::GetTitle() const; virtual UInt_tTOb",MatchSource.WIKI,root/html604/TViewerX3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html604/TViewerX3D.html
